
ALLJOYN_LSF_LAMP.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000220ec  00000000  00000000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000002fc  20000000  000220ec  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000029c0  20000300  000223f0  00030300  2**3
                  ALLOC
  3 .stack        00002000  20002cc0  00024db0  00030300  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000302fc  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00030324  2**0
                  CONTENTS, READONLY
  6 .debug_info   0006ad56  00000000  00000000  0003037f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000b416  00000000  00000000  0009b0d5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0002f8e0  00000000  00000000  000a64eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001ca0  00000000  00000000  000d5dcb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000027a0  00000000  00000000  000d7a6b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00027e5d  00000000  00000000  000da20b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000275f6  00000000  00000000  00102068  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a0ddc  00000000  00000000  0012965e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000626c  00000000  00000000  001ca43c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20004cc0 	.word	0x20004cc0
       4:	00013a89 	.word	0x00013a89
       8:	00013a85 	.word	0x00013a85
       c:	00013a85 	.word	0x00013a85
	...
      2c:	00013a85 	.word	0x00013a85
	...
      38:	00013a85 	.word	0x00013a85
      3c:	00014211 	.word	0x00014211
      40:	00013a85 	.word	0x00013a85
      44:	00013a85 	.word	0x00013a85
      48:	00013a85 	.word	0x00013a85
      4c:	00013a85 	.word	0x00013a85
      50:	000104f1 	.word	0x000104f1
      54:	00013a85 	.word	0x00013a85
      58:	00013a85 	.word	0x00013a85
      5c:	00013a85 	.word	0x00013a85
      60:	00013a85 	.word	0x00013a85
      64:	00010425 	.word	0x00010425
      68:	00010435 	.word	0x00010435
      6c:	00010445 	.word	0x00010445
      70:	00010455 	.word	0x00010455
      74:	00010465 	.word	0x00010465
      78:	00010475 	.word	0x00010475
      7c:	00013a85 	.word	0x00013a85
      80:	00013a85 	.word	0x00013a85
      84:	00013a85 	.word	0x00013a85
      88:	00013a85 	.word	0x00013a85
      8c:	00013a85 	.word	0x00013a85
      90:	00013a85 	.word	0x00013a85
      94:	00013a85 	.word	0x00013a85
      98:	00013a85 	.word	0x00013a85
      9c:	00013a85 	.word	0x00013a85
      a0:	00013a85 	.word	0x00013a85
      a4:	00013a85 	.word	0x00013a85
      a8:	00013a85 	.word	0x00013a85
      ac:	00013a85 	.word	0x00013a85

000000b0 <__do_global_dtors_aux>:
      b0:	b510      	push	{r4, lr}
      b2:	4c06      	ldr	r4, [pc, #24]	; (cc <__do_global_dtors_aux+0x1c>)
      b4:	7823      	ldrb	r3, [r4, #0]
      b6:	2b00      	cmp	r3, #0
      b8:	d107      	bne.n	ca <__do_global_dtors_aux+0x1a>
      ba:	4b05      	ldr	r3, [pc, #20]	; (d0 <__do_global_dtors_aux+0x20>)
      bc:	2b00      	cmp	r3, #0
      be:	d002      	beq.n	c6 <__do_global_dtors_aux+0x16>
      c0:	4804      	ldr	r0, [pc, #16]	; (d4 <__do_global_dtors_aux+0x24>)
      c2:	e000      	b.n	c6 <__do_global_dtors_aux+0x16>
      c4:	bf00      	nop
      c6:	2301      	movs	r3, #1
      c8:	7023      	strb	r3, [r4, #0]
      ca:	bd10      	pop	{r4, pc}
      cc:	20000300 	.word	0x20000300
      d0:	00000000 	.word	0x00000000
      d4:	000220ec 	.word	0x000220ec

000000d8 <frame_dummy>:
      d8:	b508      	push	{r3, lr}
      da:	4b08      	ldr	r3, [pc, #32]	; (fc <frame_dummy+0x24>)
      dc:	2b00      	cmp	r3, #0
      de:	d003      	beq.n	e8 <frame_dummy+0x10>
      e0:	4807      	ldr	r0, [pc, #28]	; (100 <frame_dummy+0x28>)
      e2:	4908      	ldr	r1, [pc, #32]	; (104 <frame_dummy+0x2c>)
      e4:	e000      	b.n	e8 <frame_dummy+0x10>
      e6:	bf00      	nop
      e8:	4807      	ldr	r0, [pc, #28]	; (108 <frame_dummy+0x30>)
      ea:	6803      	ldr	r3, [r0, #0]
      ec:	2b00      	cmp	r3, #0
      ee:	d100      	bne.n	f2 <frame_dummy+0x1a>
      f0:	bd08      	pop	{r3, pc}
      f2:	4b06      	ldr	r3, [pc, #24]	; (10c <frame_dummy+0x34>)
      f4:	2b00      	cmp	r3, #0
      f6:	d0fb      	beq.n	f0 <frame_dummy+0x18>
      f8:	4798      	blx	r3
      fa:	e7f9      	b.n	f0 <frame_dummy+0x18>
      fc:	00000000 	.word	0x00000000
     100:	000220ec 	.word	0x000220ec
     104:	20000304 	.word	0x20000304
     108:	000220ec 	.word	0x000220ec
     10c:	00000000 	.word	0x00000000

00000110 <IsValueValid>:

static uint8_t IsValueValid(const char* key, const char* value)
{
   // AJ_InfoPrintf(("\n%s\n", __func__));
    return TRUE;
}
     110:	2001      	movs	r0, #1
     112:	4770      	bx	lr

00000114 <SetPasscode>:
    OEM_LS_Restart();
    return AJ_ERR_RESTART_APP;
}

static AJ_Status SetPasscode(const char* routerRealm, const uint8_t* newPasscode, uint8_t newPasscodeLen)
{
     114:	b530      	push	{r4, r5, lr}
     116:	b08d      	sub	sp, #52	; 0x34
     118:	1c05      	adds	r5, r0, #0
    char newStringPasscode[PASSWORD_VALUE_LENGTH + 1];
    AJ_Status status;

 //   AJ_InfoPrintf(("\n%s\n", __func__));

    status = AJ_RawToHex(newPasscode, newPasscodeLen, newStringPasscode, sizeof(newStringPasscode), FALSE);
     11a:	2300      	movs	r3, #0
     11c:	9300      	str	r3, [sp, #0]
     11e:	1c08      	adds	r0, r1, #0
     120:	1c11      	adds	r1, r2, #0
     122:	aa03      	add	r2, sp, #12
     124:	3321      	adds	r3, #33	; 0x21
     126:	4c0e      	ldr	r4, [pc, #56]	; (160 <SetPasscode+0x4c>)
     128:	47a0      	blx	r4
     12a:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) {
     12c:	d115      	bne.n	15a <SetPasscode+0x46>
        return status;
    }

    if (AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_REALM_NAME, routerRealm) &&
     12e:	2005      	movs	r0, #5
     130:	1c29      	adds	r1, r5, #0
     132:	4b0c      	ldr	r3, [pc, #48]	; (164 <SetPasscode+0x50>)
     134:	4798      	blx	r3
     136:	2800      	cmp	r0, #0
     138:	d00d      	beq.n	156 <SetPasscode+0x42>
        AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_PASSCODE, newStringPasscode)) 
     13a:	2004      	movs	r0, #4
     13c:	a903      	add	r1, sp, #12
     13e:	4b09      	ldr	r3, [pc, #36]	; (164 <SetPasscode+0x50>)
     140:	4798      	blx	r3
    status = AJ_RawToHex(newPasscode, newPasscodeLen, newStringPasscode, sizeof(newStringPasscode), FALSE);
    if (status != AJ_OK) {
        return status;
    }

    if (AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_REALM_NAME, routerRealm) &&
     142:	2800      	cmp	r0, #0
     144:	d007      	beq.n	156 <SetPasscode+0x42>
        AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_PASSCODE, newStringPasscode)) 
	{

        status = AJSVC_PropertyStore_SaveAll();
     146:	4b08      	ldr	r3, [pc, #32]	; (168 <SetPasscode+0x54>)
     148:	4798      	blx	r3
     14a:	1e03      	subs	r3, r0, #0
        if (status != AJ_OK)
     14c:	d105      	bne.n	15a <SetPasscode+0x46>
	   {
            return status;
        }

        AJ_ClearCredentials();
     14e:	4b07      	ldr	r3, [pc, #28]	; (16c <SetPasscode+0x58>)
     150:	4798      	blx	r3
        //Force disconnect of AJ and services to refresh current sessions
        status = AJ_ERR_READ;
     152:	2005      	movs	r0, #5
     154:	e001      	b.n	15a <SetPasscode+0x46>
    }
	else 
	{
        status = AJSVC_PropertyStore_LoadAll();
     156:	4b06      	ldr	r3, [pc, #24]	; (170 <SetPasscode+0x5c>)
     158:	4798      	blx	r3
            return status;
        }
    }

    return status;
}
     15a:	b00d      	add	sp, #52	; 0x34
     15c:	bd30      	pop	{r4, r5, pc}
     15e:	46c0      	nop			; (mov r8, r8)
     160:	0000d86d 	.word	0x0000d86d
     164:	00000f59 	.word	0x00000f59
     168:	00000fe9 	.word	0x00000fe9
     16c:	00004409 	.word	0x00004409
     170:	00000fbd 	.word	0x00000fbd

00000174 <Restart>:
    // Force disconnect of AJ and services and reconnection of WiFi on restart of app
    return AJ_ERR_RESTART_APP;
}

static AJ_Status Restart(void)
{
     174:	b508      	push	{r3, lr}
    printf("%s\n", __func__);
     176:	4803      	ldr	r0, [pc, #12]	; (184 <Restart+0x10>)
     178:	4b03      	ldr	r3, [pc, #12]	; (188 <Restart+0x14>)
     17a:	4798      	blx	r3
    OEM_LS_Restart();
     17c:	4b03      	ldr	r3, [pc, #12]	; (18c <Restart+0x18>)
     17e:	4798      	blx	r3
    return AJ_ERR_RESTART_APP;
}
     180:	201e      	movs	r0, #30
     182:	bd08      	pop	{r3, pc}
     184:	0001841c 	.word	0x0001841c
     188:	00016f5d 	.word	0x00016f5d
     18c:	00000a9d 	.word	0x00000a9d

00000190 <FactoryReset>:
    AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_DEVICE_NAME, name);
    AJSVC_PropertyStore_SaveAll();
}

static AJ_Status FactoryReset(void)
{
     190:	b508      	push	{r3, lr}
    printf("%s\n", __func__);
     192:	4806      	ldr	r0, [pc, #24]	; (1ac <FactoryReset+0x1c>)
     194:	4b06      	ldr	r3, [pc, #24]	; (1b0 <FactoryReset+0x20>)
     196:	4798      	blx	r3
    AJSVC_PropertyStore_ResetAll();
     198:	4b06      	ldr	r3, [pc, #24]	; (1b4 <FactoryReset+0x24>)
     19a:	4798      	blx	r3

    // this will clear onboarding data, state, and credentials
   // AJ_NVRAM_Clear();

    // we must persist the device id!
    SavePersistentDeviceId();
     19c:	4b06      	ldr	r3, [pc, #24]	; (1b8 <FactoryReset+0x28>)
     19e:	4798      	blx	r3

    // reinitialize!
    PropertyStore_Init();
     1a0:	4b06      	ldr	r3, [pc, #24]	; (1bc <FactoryReset+0x2c>)
     1a2:	4798      	blx	r3

    OEM_LS_DoFactoryReset();
     1a4:	4b06      	ldr	r3, [pc, #24]	; (1c0 <FactoryReset+0x30>)
     1a6:	4798      	blx	r3

    // Force disconnect of AJ and services and reconnection of WiFi on restart of app
    return AJ_ERR_RESTART_APP;
}
     1a8:	201e      	movs	r0, #30
     1aa:	bd08      	pop	{r3, pc}
     1ac:	00018424 	.word	0x00018424
     1b0:	00016f5d 	.word	0x00016f5d
     1b4:	00001435 	.word	0x00001435
     1b8:	00000fb9 	.word	0x00000fb9
     1bc:	00000fc1 	.word	0x00000fc1
     1c0:	00000ab1 	.word	0x00000ab1

000001c4 <LAMP_GetID>:
#ifndef NDEBUG
uint8_t dbgLAMP_ABOUT_DATA = 1;
#endif

const char* LAMP_GetID(void)
{
     1c4:	b508      	push	{r3, lr}
   // AJ_InfoPrintf(("\n%s\n", __func__));
    return AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID);
     1c6:	2000      	movs	r0, #0
     1c8:	4b01      	ldr	r3, [pc, #4]	; (1d0 <LAMP_GetID+0xc>)
     1ca:	4798      	blx	r3
}
     1cc:	bd08      	pop	{r3, pc}
     1ce:	46c0      	nop			; (mov r8, r8)
     1d0:	00000e39 	.word	0x00000e39

000001d4 <LAMP_PasswordCallback>:
}

#define INITIAL_PASSCODE "000000"

uint32_t LAMP_PasswordCallback(uint8_t* buffer, uint32_t bufLen)
{
     1d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     1d6:	1c07      	adds	r7, r0, #0
     1d8:	1c0e      	adds	r6, r1, #0
    AJ_Status status = AJ_OK;
    const char* hexPassword = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_PASSCODE);
     1da:	2004      	movs	r0, #4
     1dc:	4b10      	ldr	r3, [pc, #64]	; (220 <LAMP_PasswordCallback+0x4c>)
     1de:	4798      	blx	r3
     1e0:	1e05      	subs	r5, r0, #0
    size_t hexPasswordLen;
    uint32_t len = 0;

    if (hexPassword == NULL)
     1e2:	d10d      	bne.n	200 <LAMP_PasswordCallback+0x2c>
	{
        AJ_ErrPrintf(("Password is NULL!\n"));
     1e4:	2001      	movs	r0, #1
     1e6:	490f      	ldr	r1, [pc, #60]	; (224 <LAMP_PasswordCallback+0x50>)
     1e8:	229a      	movs	r2, #154	; 0x9a
     1ea:	4b0f      	ldr	r3, [pc, #60]	; (228 <LAMP_PasswordCallback+0x54>)
     1ec:	4798      	blx	r3
     1ee:	1c03      	adds	r3, r0, #0
        return len;
     1f0:	2000      	movs	r0, #0
    size_t hexPasswordLen;
    uint32_t len = 0;

    if (hexPassword == NULL)
	{
        AJ_ErrPrintf(("Password is NULL!\n"));
     1f2:	2b00      	cmp	r3, #0
     1f4:	d012      	beq.n	21c <LAMP_PasswordCallback+0x48>
     1f6:	480d      	ldr	r0, [pc, #52]	; (22c <LAMP_PasswordCallback+0x58>)
     1f8:	4b0d      	ldr	r3, [pc, #52]	; (230 <LAMP_PasswordCallback+0x5c>)
     1fa:	4798      	blx	r3
        return len;
     1fc:	2000      	movs	r0, #0
     1fe:	e00d      	b.n	21c <LAMP_PasswordCallback+0x48>
    }

  //  AJ_InfoPrintf(("Configured password=%s\n", hexPassword));
    hexPasswordLen = strlen(hexPassword);
     200:	4b0c      	ldr	r3, [pc, #48]	; (234 <LAMP_PasswordCallback+0x60>)
     202:	4798      	blx	r3
     204:	1c04      	adds	r4, r0, #0
    len = hexPasswordLen / 2;
    status = AJ_HexToRaw(hexPassword, hexPasswordLen, buffer, bufLen);
     206:	1c28      	adds	r0, r5, #0
     208:	1c21      	adds	r1, r4, #0
     20a:	1c3a      	adds	r2, r7, #0
     20c:	1c33      	adds	r3, r6, #0
     20e:	4d0a      	ldr	r5, [pc, #40]	; (238 <LAMP_PasswordCallback+0x64>)
     210:	47a8      	blx	r5
    if (status == AJ_ERR_RESOURCES) 
     212:	280b      	cmp	r0, #11
     214:	d001      	beq.n	21a <LAMP_PasswordCallback+0x46>
        return len;
    }

  //  AJ_InfoPrintf(("Configured password=%s\n", hexPassword));
    hexPasswordLen = strlen(hexPassword);
    len = hexPasswordLen / 2;
     216:	0860      	lsrs	r0, r4, #1
     218:	e000      	b.n	21c <LAMP_PasswordCallback+0x48>
    status = AJ_HexToRaw(hexPassword, hexPasswordLen, buffer, bufLen);
    if (status == AJ_ERR_RESOURCES) 
	{
        len = 0;
     21a:	2000      	movs	r0, #0
    }

    return len;
}
     21c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     21e:	46c0      	nop			; (mov r8, r8)
     220:	00000e39 	.word	0x00000e39
     224:	00018434 	.word	0x00018434
     228:	0000636d 	.word	0x0000636d
     22c:	00018464 	.word	0x00018464
     230:	00016f5d 	.word	0x00016f5d
     234:	0001715b 	.word	0x0001715b
     238:	0000d8c1 	.word	0x0000d8c1

0000023c <LAMP_SetupAboutConfigData>:

void LAMP_SetupAboutConfigData(void)
{
     23c:	b510      	push	{r4, lr}
	AJ_Status status = AJ_OK;
	
  //  AJ_InfoPrintf(("\n%s\n", __func__));
    AJCFG_Start(&FactoryReset, &Restart, &SetPasscode, &IsValueValid);
     23e:	4809      	ldr	r0, [pc, #36]	; (264 <LAMP_SetupAboutConfigData+0x28>)
     240:	4909      	ldr	r1, [pc, #36]	; (268 <LAMP_SetupAboutConfigData+0x2c>)
     242:	4a0a      	ldr	r2, [pc, #40]	; (26c <LAMP_SetupAboutConfigData+0x30>)
     244:	4b0a      	ldr	r3, [pc, #40]	; (270 <LAMP_SetupAboutConfigData+0x34>)
     246:	4c0b      	ldr	r4, [pc, #44]	; (274 <LAMP_SetupAboutConfigData+0x38>)
     248:	47a0      	blx	r4
    AJ_AboutSetIcon(aboutIconContent, aboutIconSize, aboutIconMimetype, aboutIconUrl);
     24a:	4b0b      	ldr	r3, [pc, #44]	; (278 <LAMP_SetupAboutConfigData+0x3c>)
     24c:	8819      	ldrh	r1, [r3, #0]
     24e:	4b0b      	ldr	r3, [pc, #44]	; (27c <LAMP_SetupAboutConfigData+0x40>)
     250:	681a      	ldr	r2, [r3, #0]
     252:	4b0b      	ldr	r3, [pc, #44]	; (280 <LAMP_SetupAboutConfigData+0x44>)
     254:	681b      	ldr	r3, [r3, #0]
     256:	480b      	ldr	r0, [pc, #44]	; (284 <LAMP_SetupAboutConfigData+0x48>)
     258:	4c0b      	ldr	r4, [pc, #44]	; (288 <LAMP_SetupAboutConfigData+0x4c>)
     25a:	47a0      	blx	r4

    // first read in the data from the propertystore
    status = PropertyStore_Init();
     25c:	4b0b      	ldr	r3, [pc, #44]	; (28c <LAMP_SetupAboutConfigData+0x50>)
     25e:	4798      	blx	r3
//	printf("PropertyStore_Init() status=%s\n",AJ_StatusText(status));
	
}
     260:	bd10      	pop	{r4, pc}
     262:	46c0      	nop			; (mov r8, r8)
     264:	00000191 	.word	0x00000191
     268:	00000175 	.word	0x00000175
     26c:	00000115 	.word	0x00000115
     270:	00000111 	.word	0x00000111
     274:	0000d9d1 	.word	0x0000d9d1
     278:	00018544 	.word	0x00018544
     27c:	20000004 	.word	0x20000004
     280:	20000008 	.word	0x20000008
     284:	0001857c 	.word	0x0001857c
     288:	0000169d 	.word	0x0000169d
     28c:	00000fc1 	.word	0x00000fc1

00000290 <LAMP_MarshalState>:
    memcpy(dest, src, minSize);
    return minSize;
}

LampResponseCode LAMP_MarshalState(LampState* state, AJ_Message* msg)
{
     290:	b570      	push	{r4, r5, r6, lr}
     292:	b082      	sub	sp, #8
     294:	1c05      	adds	r5, r0, #0
     296:	1c0c      	adds	r4, r1, #0
 //   AJ_InfoPrintf(("%s\n", __func__));
    AJ_Status status = AJ_MarshalArgs(msg, "{sv}", "Hue", "u", state->hue);
     298:	6803      	ldr	r3, [r0, #0]
     29a:	9300      	str	r3, [sp, #0]
     29c:	1c08      	adds	r0, r1, #0
     29e:	491e      	ldr	r1, [pc, #120]	; (318 <LAMP_MarshalState+0x88>)
     2a0:	4a1e      	ldr	r2, [pc, #120]	; (31c <LAMP_MarshalState+0x8c>)
     2a2:	4b1f      	ldr	r3, [pc, #124]	; (320 <LAMP_MarshalState+0x90>)
     2a4:	4e1f      	ldr	r6, [pc, #124]	; (324 <LAMP_MarshalState+0x94>)
     2a6:	47b0      	blx	r6
    if (status != AJ_OK) 
	{
        return LAMP_ERR_MESSAGE;
     2a8:	230b      	movs	r3, #11

LampResponseCode LAMP_MarshalState(LampState* state, AJ_Message* msg)
{
 //   AJ_InfoPrintf(("%s\n", __func__));
    AJ_Status status = AJ_MarshalArgs(msg, "{sv}", "Hue", "u", state->hue);
    if (status != AJ_OK) 
     2aa:	2800      	cmp	r0, #0
     2ac:	d130      	bne.n	310 <LAMP_MarshalState+0x80>
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "Saturation", "u", state->saturation);
     2ae:	686b      	ldr	r3, [r5, #4]
     2b0:	9300      	str	r3, [sp, #0]
     2b2:	1c20      	adds	r0, r4, #0
     2b4:	4918      	ldr	r1, [pc, #96]	; (318 <LAMP_MarshalState+0x88>)
     2b6:	4a1c      	ldr	r2, [pc, #112]	; (328 <LAMP_MarshalState+0x98>)
     2b8:	4b19      	ldr	r3, [pc, #100]	; (320 <LAMP_MarshalState+0x90>)
     2ba:	4e1a      	ldr	r6, [pc, #104]	; (324 <LAMP_MarshalState+0x94>)
     2bc:	47b0      	blx	r6
    if (status != AJ_OK) 
	{
        return LAMP_ERR_MESSAGE;
     2be:	230b      	movs	r3, #11
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "Saturation", "u", state->saturation);
    if (status != AJ_OK) 
     2c0:	2800      	cmp	r0, #0
     2c2:	d125      	bne.n	310 <LAMP_MarshalState+0x80>
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "ColorTemp", "u", state->colorTemp);
     2c4:	68ab      	ldr	r3, [r5, #8]
     2c6:	9300      	str	r3, [sp, #0]
     2c8:	1c20      	adds	r0, r4, #0
     2ca:	4913      	ldr	r1, [pc, #76]	; (318 <LAMP_MarshalState+0x88>)
     2cc:	4a17      	ldr	r2, [pc, #92]	; (32c <LAMP_MarshalState+0x9c>)
     2ce:	4b14      	ldr	r3, [pc, #80]	; (320 <LAMP_MarshalState+0x90>)
     2d0:	4e14      	ldr	r6, [pc, #80]	; (324 <LAMP_MarshalState+0x94>)
     2d2:	47b0      	blx	r6
    if (status != AJ_OK) 
	{
        return LAMP_ERR_MESSAGE;
     2d4:	230b      	movs	r3, #11
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "ColorTemp", "u", state->colorTemp);
    if (status != AJ_OK) 
     2d6:	2800      	cmp	r0, #0
     2d8:	d11a      	bne.n	310 <LAMP_MarshalState+0x80>
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "Brightness", "u", state->brightness);
     2da:	68eb      	ldr	r3, [r5, #12]
     2dc:	9300      	str	r3, [sp, #0]
     2de:	1c20      	adds	r0, r4, #0
     2e0:	490d      	ldr	r1, [pc, #52]	; (318 <LAMP_MarshalState+0x88>)
     2e2:	4a13      	ldr	r2, [pc, #76]	; (330 <LAMP_MarshalState+0xa0>)
     2e4:	4b0e      	ldr	r3, [pc, #56]	; (320 <LAMP_MarshalState+0x90>)
     2e6:	4e0f      	ldr	r6, [pc, #60]	; (324 <LAMP_MarshalState+0x94>)
     2e8:	47b0      	blx	r6
    if (status != AJ_OK) 
	{
        return LAMP_ERR_MESSAGE;
     2ea:	230b      	movs	r3, #11
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "Brightness", "u", state->brightness);
    if (status != AJ_OK) 
     2ec:	2800      	cmp	r0, #0
     2ee:	d10f      	bne.n	310 <LAMP_MarshalState+0x80>
	{
        return LAMP_ERR_MESSAGE;
    }

    status = AJ_MarshalArgs(msg, "{sv}", "OnOff", "b", (state->onOff ? TRUE : FALSE));
     2f0:	7c2b      	ldrb	r3, [r5, #16]
     2f2:	1e5a      	subs	r2, r3, #1
     2f4:	4193      	sbcs	r3, r2
     2f6:	9300      	str	r3, [sp, #0]
     2f8:	1c20      	adds	r0, r4, #0
     2fa:	4907      	ldr	r1, [pc, #28]	; (318 <LAMP_MarshalState+0x88>)
     2fc:	4a0d      	ldr	r2, [pc, #52]	; (334 <LAMP_MarshalState+0xa4>)
     2fe:	4b0e      	ldr	r3, [pc, #56]	; (338 <LAMP_MarshalState+0xa8>)
     300:	4c08      	ldr	r4, [pc, #32]	; (324 <LAMP_MarshalState+0x94>)
     302:	47a0      	blx	r4
    if (status != AJ_OK) 
	{
        return LAMP_ERR_MESSAGE;
     304:	230b      	movs	r3, #11
    }

    return LAMP_OK;
     306:	1c02      	adds	r2, r0, #0
     308:	1e50      	subs	r0, r2, #1
     30a:	4182      	sbcs	r2, r0
     30c:	4252      	negs	r2, r2
     30e:	4013      	ands	r3, r2
}
     310:	1c18      	adds	r0, r3, #0
     312:	b002      	add	sp, #8
     314:	bd70      	pop	{r4, r5, r6, pc}
     316:	46c0      	nop			; (mov r8, r8)
     318:	0001f938 	.word	0x0001f938
     31c:	00018478 	.word	0x00018478
     320:	0002192c 	.word	0x0002192c
     324:	0000bc85 	.word	0x0000bc85
     328:	0001847c 	.word	0x0001847c
     32c:	000199d8 	.word	0x000199d8
     330:	00018488 	.word	0x00018488
     334:	00018494 	.word	0x00018494
     338:	0001ed84 	.word	0x0001ed84

0000033c <LAMP_UnmarshalState>:

LampResponseCode LAMP_UnmarshalState(LampStateContainer* state, AJ_Message* msg)
{
     33c:	b5f0      	push	{r4, r5, r6, r7, lr}
     33e:	4647      	mov	r7, r8
     340:	b480      	push	{r7}
     342:	b08c      	sub	sp, #48	; 0x30
     344:	1c06      	adds	r6, r0, #0
     346:	1c0c      	adds	r4, r1, #0
    AJ_Arg array1, struct1;
    AJ_Status status = AJ_UnmarshalContainer(msg, &array1, AJ_ARG_ARRAY);
     348:	1c08      	adds	r0, r1, #0
     34a:	a908      	add	r1, sp, #32
     34c:	2261      	movs	r2, #97	; 0x61
     34e:	4b5a      	ldr	r3, [pc, #360]	; (4b8 <LAMP_UnmarshalState+0x17c>)
     350:	4798      	blx	r3
    LampResponseCode responseCode = LAMP_OK;

    AJ_DumpMsg("LAMP_UnmarshalState", msg, TRUE);

    // initialize
    memset(state, 0, sizeof(LampStateContainer));
     352:	1c30      	adds	r0, r6, #0
     354:	2100      	movs	r1, #0
     356:	2218      	movs	r2, #24
     358:	4b58      	ldr	r3, [pc, #352]	; (4bc <LAMP_UnmarshalState+0x180>)
     35a:	4798      	blx	r3

    do {
        char* field;
        char* sig;

        status = AJ_UnmarshalContainer(msg, &struct1, AJ_ARG_DICT_ENTRY);
     35c:	4f56      	ldr	r7, [pc, #344]	; (4b8 <LAMP_UnmarshalState+0x17c>)
        if (status != AJ_OK) 
		{
            break;
        }

        status = AJ_UnmarshalArgs(msg, "s", &field);
     35e:	4b58      	ldr	r3, [pc, #352]	; (4c0 <LAMP_UnmarshalState+0x184>)
     360:	4698      	mov	r8, r3

    do {
        char* field;
        char* sig;

        status = AJ_UnmarshalContainer(msg, &struct1, AJ_ARG_DICT_ENTRY);
     362:	1c20      	adds	r0, r4, #0
     364:	a904      	add	r1, sp, #16
     366:	227b      	movs	r2, #123	; 0x7b
     368:	47b8      	blx	r7
        if (status != AJ_OK) 
     36a:	2800      	cmp	r0, #0
     36c:	d000      	beq.n	370 <LAMP_UnmarshalState+0x34>
     36e:	e095      	b.n	49c <LAMP_UnmarshalState+0x160>
		{
            break;
        }

        status = AJ_UnmarshalArgs(msg, "s", &field);
     370:	1c20      	adds	r0, r4, #0
     372:	4954      	ldr	r1, [pc, #336]	; (4c4 <LAMP_UnmarshalState+0x188>)
     374:	aa01      	add	r2, sp, #4
     376:	47c0      	blx	r8
        if (status != AJ_OK) 
     378:	2800      	cmp	r0, #0
     37a:	d006      	beq.n	38a <LAMP_UnmarshalState+0x4e>
		{
            printf("AJ_UnmarshalArgs: %s\n", AJ_StatusText(status));
     37c:	4b52      	ldr	r3, [pc, #328]	; (4c8 <LAMP_UnmarshalState+0x18c>)
     37e:	4798      	blx	r3
     380:	1c01      	adds	r1, r0, #0
     382:	4852      	ldr	r0, [pc, #328]	; (4cc <LAMP_UnmarshalState+0x190>)
     384:	4b52      	ldr	r3, [pc, #328]	; (4d0 <LAMP_UnmarshalState+0x194>)
     386:	4798      	blx	r3
            return LAMP_ERR_MESSAGE;
     388:	e08a      	b.n	4a0 <LAMP_UnmarshalState+0x164>
        }

        // Process the field!
        status = AJ_UnmarshalVariant(msg, (const char**) &sig);
     38a:	1c20      	adds	r0, r4, #0
     38c:	a902      	add	r1, sp, #8
     38e:	4b51      	ldr	r3, [pc, #324]	; (4d4 <LAMP_UnmarshalState+0x198>)
     390:	4798      	blx	r3
     392:	1e05      	subs	r5, r0, #0
        if (status != AJ_OK) 
     394:	d00e      	beq.n	3b4 <LAMP_UnmarshalState+0x78>
		{
            AJ_ErrPrintf(("AJ_UnmarshalVariant: %s\n", AJ_StatusText(status)));
     396:	2001      	movs	r0, #1
     398:	494f      	ldr	r1, [pc, #316]	; (4d8 <LAMP_UnmarshalState+0x19c>)
     39a:	2278      	movs	r2, #120	; 0x78
     39c:	4b4f      	ldr	r3, [pc, #316]	; (4dc <LAMP_UnmarshalState+0x1a0>)
     39e:	4798      	blx	r3
     3a0:	2800      	cmp	r0, #0
     3a2:	d07d      	beq.n	4a0 <LAMP_UnmarshalState+0x164>
     3a4:	1c28      	adds	r0, r5, #0
     3a6:	4b48      	ldr	r3, [pc, #288]	; (4c8 <LAMP_UnmarshalState+0x18c>)
     3a8:	4798      	blx	r3
     3aa:	1c01      	adds	r1, r0, #0
     3ac:	484c      	ldr	r0, [pc, #304]	; (4e0 <LAMP_UnmarshalState+0x1a4>)
     3ae:	4b48      	ldr	r3, [pc, #288]	; (4d0 <LAMP_UnmarshalState+0x194>)
     3b0:	4798      	blx	r3
     3b2:	e075      	b.n	4a0 <LAMP_UnmarshalState+0x164>
            return LAMP_ERR_MESSAGE;
        }

        if (0 == strcmp(field, "OnOff")) 
     3b4:	9d01      	ldr	r5, [sp, #4]
     3b6:	1c28      	adds	r0, r5, #0
     3b8:	494a      	ldr	r1, [pc, #296]	; (4e4 <LAMP_UnmarshalState+0x1a8>)
     3ba:	4b4b      	ldr	r3, [pc, #300]	; (4e8 <LAMP_UnmarshalState+0x1ac>)
     3bc:	4798      	blx	r3
     3be:	2800      	cmp	r0, #0
     3c0:	d10d      	bne.n	3de <LAMP_UnmarshalState+0xa2>
		{
            uint32_t onoff;
            status = AJ_UnmarshalArgs(msg, "b", &onoff);
     3c2:	1c20      	adds	r0, r4, #0
     3c4:	4949      	ldr	r1, [pc, #292]	; (4ec <LAMP_UnmarshalState+0x1b0>)
     3c6:	aa03      	add	r2, sp, #12
     3c8:	4b3d      	ldr	r3, [pc, #244]	; (4c0 <LAMP_UnmarshalState+0x184>)
     3ca:	4798      	blx	r3
            state->state.onOff = onoff ? TRUE : FALSE;
     3cc:	9b03      	ldr	r3, [sp, #12]
     3ce:	1e5a      	subs	r2, r3, #1
     3d0:	4193      	sbcs	r3, r2
     3d2:	7433      	strb	r3, [r6, #16]
            state->stateFieldIndicators |= LAMP_STATE_ON_OFF_FIELD_INDICATOR;
     3d4:	7d32      	ldrb	r2, [r6, #20]
     3d6:	2301      	movs	r3, #1
     3d8:	4313      	orrs	r3, r2
     3da:	7533      	strb	r3, [r6, #20]
     3dc:	e055      	b.n	48a <LAMP_UnmarshalState+0x14e>
        } 
		else if (0 == strcmp(field, "Hue")) 
     3de:	1c28      	adds	r0, r5, #0
     3e0:	4943      	ldr	r1, [pc, #268]	; (4f0 <LAMP_UnmarshalState+0x1b4>)
     3e2:	4b41      	ldr	r3, [pc, #260]	; (4e8 <LAMP_UnmarshalState+0x1ac>)
     3e4:	4798      	blx	r3
     3e6:	2800      	cmp	r0, #0
     3e8:	d109      	bne.n	3fe <LAMP_UnmarshalState+0xc2>
		{
            status = AJ_UnmarshalArgs(msg, "u", &state->state.hue);
     3ea:	1c20      	adds	r0, r4, #0
     3ec:	4941      	ldr	r1, [pc, #260]	; (4f4 <LAMP_UnmarshalState+0x1b8>)
     3ee:	1c32      	adds	r2, r6, #0
     3f0:	4b33      	ldr	r3, [pc, #204]	; (4c0 <LAMP_UnmarshalState+0x184>)
     3f2:	4798      	blx	r3
            state->stateFieldIndicators |= LAMP_STATE_HUE_FIELD_INDICATOR;
     3f4:	7d32      	ldrb	r2, [r6, #20]
     3f6:	2302      	movs	r3, #2
     3f8:	4313      	orrs	r3, r2
     3fa:	7533      	strb	r3, [r6, #20]
     3fc:	e045      	b.n	48a <LAMP_UnmarshalState+0x14e>
        }
		else if (0 == strcmp(field, "Saturation"))
     3fe:	1c28      	adds	r0, r5, #0
     400:	493d      	ldr	r1, [pc, #244]	; (4f8 <LAMP_UnmarshalState+0x1bc>)
     402:	4b39      	ldr	r3, [pc, #228]	; (4e8 <LAMP_UnmarshalState+0x1ac>)
     404:	4798      	blx	r3
     406:	2800      	cmp	r0, #0
     408:	d109      	bne.n	41e <LAMP_UnmarshalState+0xe2>
		{
            status = AJ_UnmarshalArgs(msg, "u", &state->state.saturation);
     40a:	1d32      	adds	r2, r6, #4
     40c:	1c20      	adds	r0, r4, #0
     40e:	4939      	ldr	r1, [pc, #228]	; (4f4 <LAMP_UnmarshalState+0x1b8>)
     410:	4b2b      	ldr	r3, [pc, #172]	; (4c0 <LAMP_UnmarshalState+0x184>)
     412:	4798      	blx	r3
            state->stateFieldIndicators |= LAMP_STATE_SATURATION_FIELD_INDICATOR;
     414:	7d32      	ldrb	r2, [r6, #20]
     416:	2304      	movs	r3, #4
     418:	4313      	orrs	r3, r2
     41a:	7533      	strb	r3, [r6, #20]
     41c:	e035      	b.n	48a <LAMP_UnmarshalState+0x14e>
        } 
		else if (0 == strcmp(field, "ColorTemp")) 
     41e:	1c28      	adds	r0, r5, #0
     420:	4936      	ldr	r1, [pc, #216]	; (4fc <LAMP_UnmarshalState+0x1c0>)
     422:	4b31      	ldr	r3, [pc, #196]	; (4e8 <LAMP_UnmarshalState+0x1ac>)
     424:	4798      	blx	r3
     426:	2800      	cmp	r0, #0
     428:	d10a      	bne.n	440 <LAMP_UnmarshalState+0x104>
		{
            status = AJ_UnmarshalArgs(msg, "u", &state->state.colorTemp);
     42a:	1c32      	adds	r2, r6, #0
     42c:	3208      	adds	r2, #8
     42e:	1c20      	adds	r0, r4, #0
     430:	4930      	ldr	r1, [pc, #192]	; (4f4 <LAMP_UnmarshalState+0x1b8>)
     432:	4b23      	ldr	r3, [pc, #140]	; (4c0 <LAMP_UnmarshalState+0x184>)
     434:	4798      	blx	r3
            state->stateFieldIndicators |= LAMP_STATE_COLOR_TEMP_FIELD_INDICATOR;
     436:	7d32      	ldrb	r2, [r6, #20]
     438:	2308      	movs	r3, #8
     43a:	4313      	orrs	r3, r2
     43c:	7533      	strb	r3, [r6, #20]
     43e:	e024      	b.n	48a <LAMP_UnmarshalState+0x14e>
        } 
		else if (0 == strcmp(field, "Brightness")) 
     440:	1c28      	adds	r0, r5, #0
     442:	492f      	ldr	r1, [pc, #188]	; (500 <LAMP_UnmarshalState+0x1c4>)
     444:	4b28      	ldr	r3, [pc, #160]	; (4e8 <LAMP_UnmarshalState+0x1ac>)
     446:	4798      	blx	r3
     448:	2800      	cmp	r0, #0
     44a:	d10a      	bne.n	462 <LAMP_UnmarshalState+0x126>
		{
            status = AJ_UnmarshalArgs(msg, "u", &state->state.brightness);
     44c:	1c32      	adds	r2, r6, #0
     44e:	320c      	adds	r2, #12
     450:	1c20      	adds	r0, r4, #0
     452:	4928      	ldr	r1, [pc, #160]	; (4f4 <LAMP_UnmarshalState+0x1b8>)
     454:	4b1a      	ldr	r3, [pc, #104]	; (4c0 <LAMP_UnmarshalState+0x184>)
     456:	4798      	blx	r3
            state->stateFieldIndicators |= LAMP_STATE_BRIGHTNESS_FIELD_INDICATOR;
     458:	7d32      	ldrb	r2, [r6, #20]
     45a:	2310      	movs	r3, #16
     45c:	4313      	orrs	r3, r2
     45e:	7533      	strb	r3, [r6, #20]
     460:	e013      	b.n	48a <LAMP_UnmarshalState+0x14e>
        } 
		else 
		{
            AJ_ErrPrintf(("Unknown field: %s\n", field));
     462:	2001      	movs	r0, #1
     464:	491c      	ldr	r1, [pc, #112]	; (4d8 <LAMP_UnmarshalState+0x19c>)
     466:	2299      	movs	r2, #153	; 0x99
     468:	4b1c      	ldr	r3, [pc, #112]	; (4dc <LAMP_UnmarshalState+0x1a0>)
     46a:	4798      	blx	r3
     46c:	2800      	cmp	r0, #0
     46e:	d003      	beq.n	478 <LAMP_UnmarshalState+0x13c>
     470:	4824      	ldr	r0, [pc, #144]	; (504 <LAMP_UnmarshalState+0x1c8>)
     472:	9901      	ldr	r1, [sp, #4]
     474:	4b16      	ldr	r3, [pc, #88]	; (4d0 <LAMP_UnmarshalState+0x194>)
     476:	4798      	blx	r3
            responseCode = LAMP_ERR_MESSAGE;
            AJ_SkipArg(msg);
     478:	1c20      	adds	r0, r4, #0
     47a:	4b23      	ldr	r3, [pc, #140]	; (508 <LAMP_UnmarshalState+0x1cc>)
     47c:	4798      	blx	r3
        }

        status = AJ_UnmarshalCloseContainer(msg, &struct1);
     47e:	1c20      	adds	r0, r4, #0
     480:	a904      	add	r1, sp, #16
     482:	4b22      	ldr	r3, [pc, #136]	; (50c <LAMP_UnmarshalState+0x1d0>)
     484:	4798      	blx	r3
            state->stateFieldIndicators |= LAMP_STATE_BRIGHTNESS_FIELD_INDICATOR;
        } 
		else 
		{
            AJ_ErrPrintf(("Unknown field: %s\n", field));
            responseCode = LAMP_ERR_MESSAGE;
     486:	250b      	movs	r5, #11
     488:	e00c      	b.n	4a4 <LAMP_UnmarshalState+0x168>
            AJ_SkipArg(msg);
        }

        status = AJ_UnmarshalCloseContainer(msg, &struct1);
     48a:	1c20      	adds	r0, r4, #0
     48c:	a904      	add	r1, sp, #16
     48e:	4b1f      	ldr	r3, [pc, #124]	; (50c <LAMP_UnmarshalState+0x1d0>)
     490:	4798      	blx	r3
        // if field invalid, throw the whole thing out and return the error
    } while (status == AJ_OK && responseCode == LAMP_OK);
     492:	2800      	cmp	r0, #0
     494:	d100      	bne.n	498 <LAMP_UnmarshalState+0x15c>
     496:	e764      	b.n	362 <LAMP_UnmarshalState+0x26>
     498:	2500      	movs	r5, #0
     49a:	e003      	b.n	4a4 <LAMP_UnmarshalState+0x168>
     49c:	2500      	movs	r5, #0
     49e:	e001      	b.n	4a4 <LAMP_UnmarshalState+0x168>

        status = AJ_UnmarshalArgs(msg, "s", &field);
        if (status != AJ_OK) 
		{
            printf("AJ_UnmarshalArgs: %s\n", AJ_StatusText(status));
            return LAMP_ERR_MESSAGE;
     4a0:	200b      	movs	r0, #11
     4a2:	e004      	b.n	4ae <LAMP_UnmarshalState+0x172>
        }

        status = AJ_UnmarshalCloseContainer(msg, &struct1);
        // if field invalid, throw the whole thing out and return the error
    } while (status == AJ_OK && responseCode == LAMP_OK);
    AJ_UnmarshalCloseContainer(msg, &array1);
     4a4:	1c20      	adds	r0, r4, #0
     4a6:	a908      	add	r1, sp, #32
     4a8:	4b18      	ldr	r3, [pc, #96]	; (50c <LAMP_UnmarshalState+0x1d0>)
     4aa:	4798      	blx	r3

    return responseCode;
     4ac:	1c28      	adds	r0, r5, #0
}
     4ae:	b00c      	add	sp, #48	; 0x30
     4b0:	bc04      	pop	{r2}
     4b2:	4690      	mov	r8, r2
     4b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4b6:	46c0      	nop			; (mov r8, r8)
     4b8:	0000a951 	.word	0x0000a951
     4bc:	00016773 	.word	0x00016773
     4c0:	0000b5f5 	.word	0x0000b5f5
     4c4:	0001f054 	.word	0x0001f054
     4c8:	000063c5 	.word	0x000063c5
     4cc:	0001849c 	.word	0x0001849c
     4d0:	00016e3d 	.word	0x00016e3d
     4d4:	0000b319 	.word	0x0000b319
     4d8:	000184b4 	.word	0x000184b4
     4dc:	0000636d 	.word	0x0000636d
     4e0:	000184e0 	.word	0x000184e0
     4e4:	00018494 	.word	0x00018494
     4e8:	00017137 	.word	0x00017137
     4ec:	0001ed84 	.word	0x0001ed84
     4f0:	00018478 	.word	0x00018478
     4f4:	0002192c 	.word	0x0002192c
     4f8:	0001847c 	.word	0x0001847c
     4fc:	000199d8 	.word	0x000199d8
     500:	00018488 	.word	0x00018488
     504:	000184fc 	.word	0x000184fc
     508:	0000aae5 	.word	0x0000aae5
     50c:	0000a9d9 	.word	0x0000a9d9

00000510 <LAMP_InitializeState>:

#define LAMP_STATE_FD AJ_NVRAM_ID_FOR_APPS + 1

void LAMP_InitializeState(void)
{
     510:	b508      	push	{r3, lr}
        AJ_NVRAM_Close(id);
    } 
	else 
	{
        AJ_NV_DATASET* id = AJ_NVRAM_Open(LAMP_STATE_FD, "w", sizeof(LampState));
     */   OEM_LS_SetFactoryState(&TheLampState);
     512:	4802      	ldr	r0, [pc, #8]	; (51c <LAMP_InitializeState+0xc>)
     514:	4b02      	ldr	r3, [pc, #8]	; (520 <LAMP_InitializeState+0x10>)
     516:	4798      	blx	r3
		{
            AJ_NVRAM_Write(&TheLampState, sizeof(LampState), id);
            AJ_NVRAM_Close(id);
        }
    }*/
}
     518:	bd08      	pop	{r3, pc}
     51a:	46c0      	nop			; (mov r8, r8)
     51c:	2000031c 	.word	0x2000031c
     520:	00000a8d 	.word	0x00000a8d

00000524 <LAMP_GetState>:

void LAMP_GetState(LampState* state)
{
     524:	b508      	push	{r3, lr}
static LampState TheLampState;

static size_t memscpy(void*dest, size_t dstSize, const void*src, size_t copySize)
{
    size_t minSize = dstSize < copySize ? dstSize : copySize;
    memcpy(dest, src, minSize);
     526:	4902      	ldr	r1, [pc, #8]	; (530 <LAMP_GetState+0xc>)
     528:	2214      	movs	r2, #20
     52a:	4b02      	ldr	r3, [pc, #8]	; (534 <LAMP_GetState+0x10>)
     52c:	4798      	blx	r3
}

void LAMP_GetState(LampState* state)
{
    memscpy((void*)(state), sizeof(LampState), (const void*)(&TheLampState), sizeof(LampState));
}
     52e:	bd08      	pop	{r3, pc}
     530:	2000031c 	.word	0x2000031c
     534:	00016739 	.word	0x00016739

00000538 <LAMP_SetState>:

void LAMP_SetState(const LampState* state)
{
     538:	b510      	push	{r4, lr}
     53a:	1c04      	adds	r4, r0, #0
  //  AJ_InfoPrintf(("\n%s\n", __func__));
    int32_t diff = memcmp(state, &TheLampState, sizeof(LampState));
     53c:	4906      	ldr	r1, [pc, #24]	; (558 <LAMP_SetState+0x20>)
     53e:	2214      	movs	r2, #20
     540:	4b06      	ldr	r3, [pc, #24]	; (55c <LAMP_SetState+0x24>)
     542:	4798      	blx	r3

    if (diff) 
     544:	2800      	cmp	r0, #0
     546:	d004      	beq.n	552 <LAMP_SetState+0x1a>
static LampState TheLampState;

static size_t memscpy(void*dest, size_t dstSize, const void*src, size_t copySize)
{
    size_t minSize = dstSize < copySize ? dstSize : copySize;
    memcpy(dest, src, minSize);
     548:	4803      	ldr	r0, [pc, #12]	; (558 <LAMP_SetState+0x20>)
     54a:	1c21      	adds	r1, r4, #0
     54c:	2214      	movs	r2, #20
     54e:	4b04      	ldr	r3, [pc, #16]	; (560 <LAMP_SetState+0x28>)
     550:	4798      	blx	r3
        }*/
    }

    // this will cause the signal org.allseen.LSF.LampService.LampStateChanged
    // to be sent if there is a current session.
    LAMP_SendStateChangedSignal();
     552:	4b04      	ldr	r3, [pc, #16]	; (564 <LAMP_SetState+0x2c>)
     554:	4798      	blx	r3
}
     556:	bd10      	pop	{r4, pc}
     558:	2000031c 	.word	0x2000031c
     55c:	0001671b 	.word	0x0001671b
     560:	00016739 	.word	0x00016739
     564:	00014285 	.word	0x00014285

00000568 <OEM_LS_SetOnOff>:
{
    return min + ((double)value / (double)UINT32_MAX) * (max - min);
}

LampResponseCode OEM_LS_SetOnOff(uint8_t onoff)
{
     568:	b530      	push	{r4, r5, lr}
     56a:	b087      	sub	sp, #28
     56c:	1c05      	adds	r5, r0, #0
    LampState state;
    printf("%s: %u\n", __func__, onoff);
     56e:	4808      	ldr	r0, [pc, #32]	; (590 <OEM_LS_SetOnOff+0x28>)
     570:	4908      	ldr	r1, [pc, #32]	; (594 <OEM_LS_SetOnOff+0x2c>)
     572:	1c2a      	adds	r2, r5, #0
     574:	4b08      	ldr	r3, [pc, #32]	; (598 <OEM_LS_SetOnOff+0x30>)
     576:	4798      	blx	r3
    LAMP_GetState(&state);
     578:	ac01      	add	r4, sp, #4
     57a:	1c20      	adds	r0, r4, #0
     57c:	4b07      	ldr	r3, [pc, #28]	; (59c <OEM_LS_SetOnOff+0x34>)
     57e:	4798      	blx	r3
	
    state.onOff = onoff;
     580:	7425      	strb	r5, [r4, #16]
	
    LAMP_SetState(&state);
     582:	1c20      	adds	r0, r4, #0
     584:	4b06      	ldr	r3, [pc, #24]	; (5a0 <OEM_LS_SetOnOff+0x38>)
     586:	4798      	blx	r3
    return LAMP_OK;
}
     588:	2000      	movs	r0, #0
     58a:	b007      	add	sp, #28
     58c:	bd30      	pop	{r4, r5, pc}
     58e:	46c0      	nop			; (mov r8, r8)
     590:	00019494 	.word	0x00019494
     594:	00019b70 	.word	0x00019b70
     598:	00016e3d 	.word	0x00016e3d
     59c:	00000525 	.word	0x00000525
     5a0:	00000539 	.word	0x00000539

000005a4 <OEM_LS_SetHue>:

LampResponseCode OEM_LS_SetHue(uint32_t hue)
{
     5a4:	b530      	push	{r4, r5, lr}
     5a6:	b089      	sub	sp, #36	; 0x24
     5a8:	1c04      	adds	r4, r0, #0
const char FirmwareVersion[] = "1.0";
const char HardwareVersion[] = "1.0";

static float OEM_LS_Range(uint32_t value, float min, float max) 
{
    return min + ((double)value / (double)UINT32_MAX) * (max - min);
     5aa:	4b11      	ldr	r3, [pc, #68]	; (5f0 <OEM_LS_SetHue+0x4c>)
     5ac:	4798      	blx	r3
     5ae:	4a11      	ldr	r2, [pc, #68]	; (5f4 <OEM_LS_SetHue+0x50>)
     5b0:	4b11      	ldr	r3, [pc, #68]	; (5f8 <OEM_LS_SetHue+0x54>)
     5b2:	4d12      	ldr	r5, [pc, #72]	; (5fc <OEM_LS_SetHue+0x58>)
     5b4:	47a8      	blx	r5
     5b6:	2200      	movs	r2, #0
     5b8:	4b11      	ldr	r3, [pc, #68]	; (600 <OEM_LS_SetHue+0x5c>)
     5ba:	4d12      	ldr	r5, [pc, #72]	; (604 <OEM_LS_SetHue+0x60>)
     5bc:	47a8      	blx	r5
     5be:	2200      	movs	r2, #0
     5c0:	2300      	movs	r3, #0
     5c2:	4d11      	ldr	r5, [pc, #68]	; (608 <OEM_LS_SetHue+0x64>)
     5c4:	47a8      	blx	r5
     5c6:	4b11      	ldr	r3, [pc, #68]	; (60c <OEM_LS_SetHue+0x68>)
     5c8:	4798      	blx	r3
}

LampResponseCode OEM_LS_SetHue(uint32_t hue)
{
    LampState state;
    printf("%s: %u %f\n", __func__, hue, OEM_LS_Range(hue, OEM_LS_HUE_MIN, OEM_LS_HUE_MAX));
     5ca:	4b11      	ldr	r3, [pc, #68]	; (610 <OEM_LS_SetHue+0x6c>)
     5cc:	4798      	blx	r3
     5ce:	9000      	str	r0, [sp, #0]
     5d0:	9101      	str	r1, [sp, #4]
     5d2:	4810      	ldr	r0, [pc, #64]	; (614 <OEM_LS_SetHue+0x70>)
     5d4:	4910      	ldr	r1, [pc, #64]	; (618 <OEM_LS_SetHue+0x74>)
     5d6:	1c22      	adds	r2, r4, #0
     5d8:	4b10      	ldr	r3, [pc, #64]	; (61c <OEM_LS_SetHue+0x78>)
     5da:	4798      	blx	r3
    LAMP_GetState(&state);
     5dc:	a803      	add	r0, sp, #12
     5de:	4b10      	ldr	r3, [pc, #64]	; (620 <OEM_LS_SetHue+0x7c>)
     5e0:	4798      	blx	r3
    state.hue = hue;
     5e2:	9403      	str	r4, [sp, #12]
    LAMP_SetState(&state);
     5e4:	a803      	add	r0, sp, #12
     5e6:	4b0f      	ldr	r3, [pc, #60]	; (624 <OEM_LS_SetHue+0x80>)
     5e8:	4798      	blx	r3
    return LAMP_OK;
}
     5ea:	2000      	movs	r0, #0
     5ec:	b009      	add	sp, #36	; 0x24
     5ee:	bd30      	pop	{r4, r5, pc}
     5f0:	000163c1 	.word	0x000163c1
     5f4:	ffe00000 	.word	0xffe00000
     5f8:	41efffff 	.word	0x41efffff
     5fc:	00015845 	.word	0x00015845
     600:	40768000 	.word	0x40768000
     604:	00015e8d 	.word	0x00015e8d
     608:	000151f5 	.word	0x000151f5
     60c:	000164cd 	.word	0x000164cd
     610:	00016425 	.word	0x00016425
     614:	0001949c 	.word	0x0001949c
     618:	00019b98 	.word	0x00019b98
     61c:	00016e3d 	.word	0x00016e3d
     620:	00000525 	.word	0x00000525
     624:	00000539 	.word	0x00000539

00000628 <OEM_LS_SetBrightness>:

LampResponseCode OEM_LS_SetBrightness(uint32_t brightness)
{
     628:	b530      	push	{r4, r5, lr}
     62a:	b089      	sub	sp, #36	; 0x24
     62c:	1c04      	adds	r4, r0, #0
const char FirmwareVersion[] = "1.0";
const char HardwareVersion[] = "1.0";

static float OEM_LS_Range(uint32_t value, float min, float max) 
{
    return min + ((double)value / (double)UINT32_MAX) * (max - min);
     62e:	4b0f      	ldr	r3, [pc, #60]	; (66c <OEM_LS_SetBrightness+0x44>)
     630:	4798      	blx	r3
     632:	4a0f      	ldr	r2, [pc, #60]	; (670 <OEM_LS_SetBrightness+0x48>)
     634:	4b0f      	ldr	r3, [pc, #60]	; (674 <OEM_LS_SetBrightness+0x4c>)
     636:	4d10      	ldr	r5, [pc, #64]	; (678 <OEM_LS_SetBrightness+0x50>)
     638:	47a8      	blx	r5
     63a:	2200      	movs	r2, #0
     63c:	2300      	movs	r3, #0
     63e:	4d0f      	ldr	r5, [pc, #60]	; (67c <OEM_LS_SetBrightness+0x54>)
     640:	47a8      	blx	r5
     642:	4b0f      	ldr	r3, [pc, #60]	; (680 <OEM_LS_SetBrightness+0x58>)
     644:	4798      	blx	r3
}

LampResponseCode OEM_LS_SetBrightness(uint32_t brightness)
{
    LampState state;
    printf("%s: %u %f\n", __func__, brightness, OEM_LS_Range(brightness, OEM_LS_BRIGHTNESS_MIN, OEM_LS_BRIGHTNESS_MAX));
     646:	4b0f      	ldr	r3, [pc, #60]	; (684 <OEM_LS_SetBrightness+0x5c>)
     648:	4798      	blx	r3
     64a:	9000      	str	r0, [sp, #0]
     64c:	9101      	str	r1, [sp, #4]
     64e:	480e      	ldr	r0, [pc, #56]	; (688 <OEM_LS_SetBrightness+0x60>)
     650:	490e      	ldr	r1, [pc, #56]	; (68c <OEM_LS_SetBrightness+0x64>)
     652:	1c22      	adds	r2, r4, #0
     654:	4b0e      	ldr	r3, [pc, #56]	; (690 <OEM_LS_SetBrightness+0x68>)
     656:	4798      	blx	r3
    LAMP_GetState(&state);
     658:	a803      	add	r0, sp, #12
     65a:	4b0e      	ldr	r3, [pc, #56]	; (694 <OEM_LS_SetBrightness+0x6c>)
     65c:	4798      	blx	r3
    state.brightness = brightness;
     65e:	9406      	str	r4, [sp, #24]
    LAMP_SetState(&state);
     660:	a803      	add	r0, sp, #12
     662:	4b0d      	ldr	r3, [pc, #52]	; (698 <OEM_LS_SetBrightness+0x70>)
     664:	4798      	blx	r3
    return LAMP_OK;
}
     666:	2000      	movs	r0, #0
     668:	b009      	add	sp, #36	; 0x24
     66a:	bd30      	pop	{r4, r5, pc}
     66c:	000163c1 	.word	0x000163c1
     670:	ffe00000 	.word	0xffe00000
     674:	41efffff 	.word	0x41efffff
     678:	00015845 	.word	0x00015845
     67c:	000151f5 	.word	0x000151f5
     680:	000164cd 	.word	0x000164cd
     684:	00016425 	.word	0x00016425
     688:	0001949c 	.word	0x0001949c
     68c:	00019ba8 	.word	0x00019ba8
     690:	00016e3d 	.word	0x00016e3d
     694:	00000525 	.word	0x00000525
     698:	00000539 	.word	0x00000539

0000069c <OEM_LS_SetSaturation>:

LampResponseCode OEM_LS_SetSaturation(uint32_t saturation)
{
     69c:	b530      	push	{r4, r5, lr}
     69e:	b089      	sub	sp, #36	; 0x24
     6a0:	1c04      	adds	r4, r0, #0
const char FirmwareVersion[] = "1.0";
const char HardwareVersion[] = "1.0";

static float OEM_LS_Range(uint32_t value, float min, float max) 
{
    return min + ((double)value / (double)UINT32_MAX) * (max - min);
     6a2:	4b0f      	ldr	r3, [pc, #60]	; (6e0 <OEM_LS_SetSaturation+0x44>)
     6a4:	4798      	blx	r3
     6a6:	4a0f      	ldr	r2, [pc, #60]	; (6e4 <OEM_LS_SetSaturation+0x48>)
     6a8:	4b0f      	ldr	r3, [pc, #60]	; (6e8 <OEM_LS_SetSaturation+0x4c>)
     6aa:	4d10      	ldr	r5, [pc, #64]	; (6ec <OEM_LS_SetSaturation+0x50>)
     6ac:	47a8      	blx	r5
     6ae:	2200      	movs	r2, #0
     6b0:	2300      	movs	r3, #0
     6b2:	4d0f      	ldr	r5, [pc, #60]	; (6f0 <OEM_LS_SetSaturation+0x54>)
     6b4:	47a8      	blx	r5
     6b6:	4b0f      	ldr	r3, [pc, #60]	; (6f4 <OEM_LS_SetSaturation+0x58>)
     6b8:	4798      	blx	r3
}

LampResponseCode OEM_LS_SetSaturation(uint32_t saturation)
{
    LampState state;
    printf("%s: %u %f\n", __func__, saturation, OEM_LS_Range(saturation, OEM_LS_SATURATION_MIN, OEM_LS_SATURATION_MAX));
     6ba:	4b0f      	ldr	r3, [pc, #60]	; (6f8 <OEM_LS_SetSaturation+0x5c>)
     6bc:	4798      	blx	r3
     6be:	9000      	str	r0, [sp, #0]
     6c0:	9101      	str	r1, [sp, #4]
     6c2:	480e      	ldr	r0, [pc, #56]	; (6fc <OEM_LS_SetSaturation+0x60>)
     6c4:	490e      	ldr	r1, [pc, #56]	; (700 <OEM_LS_SetSaturation+0x64>)
     6c6:	1c22      	adds	r2, r4, #0
     6c8:	4b0e      	ldr	r3, [pc, #56]	; (704 <OEM_LS_SetSaturation+0x68>)
     6ca:	4798      	blx	r3
    LAMP_GetState(&state);
     6cc:	a803      	add	r0, sp, #12
     6ce:	4b0e      	ldr	r3, [pc, #56]	; (708 <OEM_LS_SetSaturation+0x6c>)
     6d0:	4798      	blx	r3
    state.saturation = saturation;
     6d2:	9404      	str	r4, [sp, #16]
    LAMP_SetState(&state);
     6d4:	a803      	add	r0, sp, #12
     6d6:	4b0d      	ldr	r3, [pc, #52]	; (70c <OEM_LS_SetSaturation+0x70>)
     6d8:	4798      	blx	r3
    return LAMP_OK;
}
     6da:	2000      	movs	r0, #0
     6dc:	b009      	add	sp, #36	; 0x24
     6de:	bd30      	pop	{r4, r5, pc}
     6e0:	000163c1 	.word	0x000163c1
     6e4:	ffe00000 	.word	0xffe00000
     6e8:	41efffff 	.word	0x41efffff
     6ec:	00015845 	.word	0x00015845
     6f0:	000151f5 	.word	0x000151f5
     6f4:	000164cd 	.word	0x000164cd
     6f8:	00016425 	.word	0x00016425
     6fc:	0001949c 	.word	0x0001949c
     700:	00019be0 	.word	0x00019be0
     704:	00016e3d 	.word	0x00016e3d
     708:	00000525 	.word	0x00000525
     70c:	00000539 	.word	0x00000539

00000710 <OEM_LS_SetColorTemp>:

LampResponseCode OEM_LS_SetColorTemp(uint32_t colorTemp)
{
     710:	b530      	push	{r4, r5, lr}
     712:	b089      	sub	sp, #36	; 0x24
     714:	1c04      	adds	r4, r0, #0
const char FirmwareVersion[] = "1.0";
const char HardwareVersion[] = "1.0";

static float OEM_LS_Range(uint32_t value, float min, float max) 
{
    return min + ((double)value / (double)UINT32_MAX) * (max - min);
     716:	4b11      	ldr	r3, [pc, #68]	; (75c <OEM_LS_SetColorTemp+0x4c>)
     718:	4798      	blx	r3
     71a:	4a11      	ldr	r2, [pc, #68]	; (760 <OEM_LS_SetColorTemp+0x50>)
     71c:	4b11      	ldr	r3, [pc, #68]	; (764 <OEM_LS_SetColorTemp+0x54>)
     71e:	4d12      	ldr	r5, [pc, #72]	; (768 <OEM_LS_SetColorTemp+0x58>)
     720:	47a8      	blx	r5
     722:	2200      	movs	r2, #0
     724:	4b11      	ldr	r3, [pc, #68]	; (76c <OEM_LS_SetColorTemp+0x5c>)
     726:	4d12      	ldr	r5, [pc, #72]	; (770 <OEM_LS_SetColorTemp+0x60>)
     728:	47a8      	blx	r5
     72a:	2200      	movs	r2, #0
     72c:	4b11      	ldr	r3, [pc, #68]	; (774 <OEM_LS_SetColorTemp+0x64>)
     72e:	4d12      	ldr	r5, [pc, #72]	; (778 <OEM_LS_SetColorTemp+0x68>)
     730:	47a8      	blx	r5
     732:	4b12      	ldr	r3, [pc, #72]	; (77c <OEM_LS_SetColorTemp+0x6c>)
     734:	4798      	blx	r3
}

LampResponseCode OEM_LS_SetColorTemp(uint32_t colorTemp)
{
    LampState state;
    printf("%s: %u %f\n", __func__, colorTemp, OEM_LS_Range(colorTemp, OEM_LS_COLOR_TEMPERATURE_MIN, OEM_LS_COLOR_TEMPERATURE_MAX));
     736:	4b12      	ldr	r3, [pc, #72]	; (780 <OEM_LS_SetColorTemp+0x70>)
     738:	4798      	blx	r3
     73a:	9000      	str	r0, [sp, #0]
     73c:	9101      	str	r1, [sp, #4]
     73e:	4811      	ldr	r0, [pc, #68]	; (784 <OEM_LS_SetColorTemp+0x74>)
     740:	4911      	ldr	r1, [pc, #68]	; (788 <OEM_LS_SetColorTemp+0x78>)
     742:	1c22      	adds	r2, r4, #0
     744:	4b11      	ldr	r3, [pc, #68]	; (78c <OEM_LS_SetColorTemp+0x7c>)
     746:	4798      	blx	r3
    LAMP_GetState(&state);
     748:	a803      	add	r0, sp, #12
     74a:	4b11      	ldr	r3, [pc, #68]	; (790 <OEM_LS_SetColorTemp+0x80>)
     74c:	4798      	blx	r3
    state.colorTemp = colorTemp;
     74e:	9405      	str	r4, [sp, #20]
    LAMP_SetState(&state);
     750:	a803      	add	r0, sp, #12
     752:	4b10      	ldr	r3, [pc, #64]	; (794 <OEM_LS_SetColorTemp+0x84>)
     754:	4798      	blx	r3
    return LAMP_OK;
}
     756:	2000      	movs	r0, #0
     758:	b009      	add	sp, #36	; 0x24
     75a:	bd30      	pop	{r4, r5, pc}
     75c:	000163c1 	.word	0x000163c1
     760:	ffe00000 	.word	0xffe00000
     764:	41efffff 	.word	0x41efffff
     768:	00015845 	.word	0x00015845
     76c:	40b89c00 	.word	0x40b89c00
     770:	00015e8d 	.word	0x00015e8d
     774:	40a51800 	.word	0x40a51800
     778:	000151f5 	.word	0x000151f5
     77c:	000164cd 	.word	0x000164cd
     780:	00016425 	.word	0x00016425
     784:	0001949c 	.word	0x0001949c
     788:	00019bf8 	.word	0x00019bf8
     78c:	00016e3d 	.word	0x00016e3d
     790:	00000525 	.word	0x00000525
     794:	00000539 	.word	0x00000539

00000798 <OEM_LS_ApplyPulseEffect>:

LampResponseCode OEM_LS_ApplyPulseEffect(LampState* fromState, LampState* toState, uint32_t period, uint32_t duration, uint32_t numPulses, uint64_t timestamp)
{
     798:	b570      	push	{r4, r5, r6, lr}
     79a:	b08e      	sub	sp, #56	; 0x38
     79c:	1c15      	adds	r5, r2, #0
     79e:	1c1c      	adds	r4, r3, #0
   printf("%s: fromState(Hue=%u,Saturation=%u,colorTemp=%u,Brightness=%u,OnOff=%u), toState(Hue=%u,Saturation=%u,colorTemp=%u,Brightness=%u,OnOff=%u), period=%u, duration=%u, numPulses=%u, start=%u/%u\n", __func__,
     7a0:	6802      	ldr	r2, [r0, #0]
     7a2:	6843      	ldr	r3, [r0, #4]
     7a4:	6886      	ldr	r6, [r0, #8]
     7a6:	9600      	str	r6, [sp, #0]
     7a8:	68c6      	ldr	r6, [r0, #12]
     7aa:	9601      	str	r6, [sp, #4]
     7ac:	7c00      	ldrb	r0, [r0, #16]
     7ae:	9002      	str	r0, [sp, #8]
     7b0:	6808      	ldr	r0, [r1, #0]
     7b2:	9003      	str	r0, [sp, #12]
     7b4:	6848      	ldr	r0, [r1, #4]
     7b6:	9004      	str	r0, [sp, #16]
     7b8:	6888      	ldr	r0, [r1, #8]
     7ba:	9005      	str	r0, [sp, #20]
     7bc:	68c8      	ldr	r0, [r1, #12]
     7be:	9006      	str	r0, [sp, #24]
     7c0:	7c09      	ldrb	r1, [r1, #16]
     7c2:	9107      	str	r1, [sp, #28]
     7c4:	9508      	str	r5, [sp, #32]
     7c6:	9409      	str	r4, [sp, #36]	; 0x24
     7c8:	9912      	ldr	r1, [sp, #72]	; 0x48
     7ca:	910a      	str	r1, [sp, #40]	; 0x28
     7cc:	9914      	ldr	r1, [sp, #80]	; 0x50
     7ce:	910b      	str	r1, [sp, #44]	; 0x2c
     7d0:	9915      	ldr	r1, [sp, #84]	; 0x54
     7d2:	910c      	str	r1, [sp, #48]	; 0x30
     7d4:	4803      	ldr	r0, [pc, #12]	; (7e4 <OEM_LS_ApplyPulseEffect+0x4c>)
     7d6:	4904      	ldr	r1, [pc, #16]	; (7e8 <OEM_LS_ApplyPulseEffect+0x50>)
     7d8:	4c04      	ldr	r4, [pc, #16]	; (7ec <OEM_LS_ApplyPulseEffect+0x54>)
     7da:	47a0      	blx	r4
                   fromState->hue, fromState->saturation, fromState->colorTemp, fromState->brightness, fromState->onOff,
                   toState->hue, toState->saturation, toState->colorTemp, toState->brightness, toState->onOff,
                   period, duration, numPulses, (uint32_t) (timestamp), (uint32_t) (timestamp >> 32));
   return LAMP_OK;
}
     7dc:	2000      	movs	r0, #0
     7de:	b00e      	add	sp, #56	; 0x38
     7e0:	bd70      	pop	{r4, r5, r6, pc}
     7e2:	46c0      	nop			; (mov r8, r8)
     7e4:	000194a8 	.word	0x000194a8
     7e8:	00019b2c 	.word	0x00019b2c
     7ec:	00016e3d 	.word	0x00016e3d

000007f0 <OEM_LS_ApplyPulseEffectOnStateFields>:

LampResponseCode OEM_LS_ApplyPulseEffectOnStateFields(LampStateContainer* fromStateContainer, LampStateContainer* toStateContainer, uint32_t period, uint32_t duration, uint32_t numPulses, uint64_t timestamp)
{
     7f0:	b5f0      	push	{r4, r5, r6, r7, lr}
     7f2:	465f      	mov	r7, fp
     7f4:	4646      	mov	r6, r8
     7f6:	b4c0      	push	{r6, r7}
     7f8:	b093      	sub	sp, #76	; 0x4c
     7fa:	1c06      	adds	r6, r0, #0
     7fc:	1c0c      	adds	r4, r1, #0
     7fe:	1c11      	adds	r1, r2, #0
     800:	9206      	str	r2, [sp, #24]
     802:	1c18      	adds	r0, r3, #0
     804:	9307      	str	r3, [sp, #28]
     806:	9b1c      	ldr	r3, [sp, #112]	; 0x70
     808:	4698      	mov	r8, r3
     80a:	9f1d      	ldr	r7, [sp, #116]	; 0x74
    printf("%s: fromStateContainer->stateFieldIndicators = 0x%x, toStateContainer->stateFieldIndicators = 0x%x, period=%u, duration=%u, numPulses=%u, start=%u/%u\n", __func__,
     80c:	7d32      	ldrb	r2, [r6, #20]
     80e:	7d23      	ldrb	r3, [r4, #20]
     810:	9100      	str	r1, [sp, #0]
     812:	9001      	str	r0, [sp, #4]
     814:	991a      	ldr	r1, [sp, #104]	; 0x68
     816:	9102      	str	r1, [sp, #8]
     818:	4641      	mov	r1, r8
     81a:	9103      	str	r1, [sp, #12]
     81c:	9704      	str	r7, [sp, #16]
     81e:	483e      	ldr	r0, [pc, #248]	; (918 <OEM_LS_ApplyPulseEffectOnStateFields+0x128>)
     820:	493e      	ldr	r1, [pc, #248]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     822:	4d3f      	ldr	r5, [pc, #252]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     824:	47a8      	blx	r5
     * OEMs should do the following operations just before starting the pulse effect.
     */
    LampState fromState, toState;

    /* Retrieve the current state of the Lamp */
    LAMP_GetState(&fromState);
     826:	a80d      	add	r0, sp, #52	; 0x34
     828:	4b3e      	ldr	r3, [pc, #248]	; (924 <OEM_LS_ApplyPulseEffectOnStateFields+0x134>)
     82a:	469b      	mov	fp, r3
     82c:	4798      	blx	r3
    LAMP_GetState(&toState);
     82e:	a808      	add	r0, sp, #32
     830:	47d8      	blx	fp

    /* Update the requisite fields to new values */
    if (fromStateContainer->stateFieldIndicators & LAMP_STATE_ON_OFF_FIELD_INDICATOR) 
     832:	7d33      	ldrb	r3, [r6, #20]
     834:	07db      	lsls	r3, r3, #31
     836:	d506      	bpl.n	846 <OEM_LS_ApplyPulseEffectOnStateFields+0x56>
	{
        fromState.onOff = fromStateContainer->state.onOff;
     838:	7c32      	ldrb	r2, [r6, #16]
     83a:	ab0d      	add	r3, sp, #52	; 0x34
     83c:	741a      	strb	r2, [r3, #16]
		printf("%s: FromState: Updating OnOff to %u\n", __func__, fromState.onOff);
     83e:	483a      	ldr	r0, [pc, #232]	; (928 <OEM_LS_ApplyPulseEffectOnStateFields+0x138>)
     840:	4936      	ldr	r1, [pc, #216]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     842:	4b37      	ldr	r3, [pc, #220]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     844:	4798      	blx	r3
    }
    if (fromStateContainer->stateFieldIndicators & LAMP_STATE_HUE_FIELD_INDICATOR) 
     846:	7d33      	ldrb	r3, [r6, #20]
     848:	079b      	lsls	r3, r3, #30
     84a:	d506      	bpl.n	85a <OEM_LS_ApplyPulseEffectOnStateFields+0x6a>
	{
        fromState.hue = fromStateContainer->state.hue;
     84c:	6833      	ldr	r3, [r6, #0]
     84e:	930d      	str	r3, [sp, #52]	; 0x34
		printf("%s: FromState: Updating Hue to %u\n", __func__, fromState.hue);
     850:	4836      	ldr	r0, [pc, #216]	; (92c <OEM_LS_ApplyPulseEffectOnStateFields+0x13c>)
     852:	4932      	ldr	r1, [pc, #200]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     854:	1c1a      	adds	r2, r3, #0
     856:	4b32      	ldr	r3, [pc, #200]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     858:	4798      	blx	r3
    }
    if (fromStateContainer->stateFieldIndicators & LAMP_STATE_SATURATION_FIELD_INDICATOR)
     85a:	7d33      	ldrb	r3, [r6, #20]
     85c:	075b      	lsls	r3, r3, #29
     85e:	d506      	bpl.n	86e <OEM_LS_ApplyPulseEffectOnStateFields+0x7e>
	 {
        fromState.saturation = fromStateContainer->state.saturation;
     860:	6873      	ldr	r3, [r6, #4]
     862:	930e      	str	r3, [sp, #56]	; 0x38
		printf("%s: FromState: Updating Saturation to %u\n", __func__, fromState.saturation);
     864:	4832      	ldr	r0, [pc, #200]	; (930 <OEM_LS_ApplyPulseEffectOnStateFields+0x140>)
     866:	492d      	ldr	r1, [pc, #180]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     868:	1c1a      	adds	r2, r3, #0
     86a:	4b2d      	ldr	r3, [pc, #180]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     86c:	4798      	blx	r3
    }
    if (fromStateContainer->stateFieldIndicators & LAMP_STATE_COLOR_TEMP_FIELD_INDICATOR) 
     86e:	7d33      	ldrb	r3, [r6, #20]
     870:	071b      	lsls	r3, r3, #28
     872:	d506      	bpl.n	882 <OEM_LS_ApplyPulseEffectOnStateFields+0x92>
	{
        fromState.colorTemp = fromStateContainer->state.colorTemp;
     874:	68b3      	ldr	r3, [r6, #8]
     876:	930f      	str	r3, [sp, #60]	; 0x3c
		printf("%s: FromState: Updating Color Temp to %u\n", __func__, fromState.colorTemp);
     878:	482e      	ldr	r0, [pc, #184]	; (934 <OEM_LS_ApplyPulseEffectOnStateFields+0x144>)
     87a:	4928      	ldr	r1, [pc, #160]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     87c:	1c1a      	adds	r2, r3, #0
     87e:	4b28      	ldr	r3, [pc, #160]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     880:	4798      	blx	r3
    }
    if (fromStateContainer->stateFieldIndicators & LAMP_STATE_BRIGHTNESS_FIELD_INDICATOR) 
     882:	7d33      	ldrb	r3, [r6, #20]
     884:	06db      	lsls	r3, r3, #27
     886:	d505      	bpl.n	894 <OEM_LS_ApplyPulseEffectOnStateFields+0xa4>
	{
        fromState.brightness = fromStateContainer->state.brightness;
     888:	68f2      	ldr	r2, [r6, #12]
     88a:	9210      	str	r2, [sp, #64]	; 0x40
        printf("%s: FromState: Updating Brightness to %u\n", __func__, fromState.brightness);
     88c:	482a      	ldr	r0, [pc, #168]	; (938 <OEM_LS_ApplyPulseEffectOnStateFields+0x148>)
     88e:	4923      	ldr	r1, [pc, #140]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     890:	4b23      	ldr	r3, [pc, #140]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     892:	4798      	blx	r3
    }

    if (toStateContainer->stateFieldIndicators & LAMP_STATE_ON_OFF_FIELD_INDICATOR)
     894:	7d23      	ldrb	r3, [r4, #20]
     896:	07db      	lsls	r3, r3, #31
     898:	d506      	bpl.n	8a8 <OEM_LS_ApplyPulseEffectOnStateFields+0xb8>
	 {
        toState.onOff = toStateContainer->state.onOff;
     89a:	7c22      	ldrb	r2, [r4, #16]
     89c:	ab08      	add	r3, sp, #32
     89e:	741a      	strb	r2, [r3, #16]
        printf("%s: ToState: Updating OnOff to %u\n", __func__, toState.onOff);
     8a0:	4826      	ldr	r0, [pc, #152]	; (93c <OEM_LS_ApplyPulseEffectOnStateFields+0x14c>)
     8a2:	491e      	ldr	r1, [pc, #120]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     8a4:	4b1e      	ldr	r3, [pc, #120]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     8a6:	4798      	blx	r3
    }
    if (toStateContainer->stateFieldIndicators & LAMP_STATE_HUE_FIELD_INDICATOR)
     8a8:	7d23      	ldrb	r3, [r4, #20]
     8aa:	079b      	lsls	r3, r3, #30
     8ac:	d506      	bpl.n	8bc <OEM_LS_ApplyPulseEffectOnStateFields+0xcc>
	 {
        toState.hue = toStateContainer->state.hue;
     8ae:	6823      	ldr	r3, [r4, #0]
     8b0:	9308      	str	r3, [sp, #32]
        printf("%s: ToState: Updating Hue to %u\n", __func__, toState.hue);
     8b2:	4823      	ldr	r0, [pc, #140]	; (940 <OEM_LS_ApplyPulseEffectOnStateFields+0x150>)
     8b4:	4919      	ldr	r1, [pc, #100]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     8b6:	1c1a      	adds	r2, r3, #0
     8b8:	4b19      	ldr	r3, [pc, #100]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     8ba:	4798      	blx	r3
    }
    if (toStateContainer->stateFieldIndicators & LAMP_STATE_SATURATION_FIELD_INDICATOR) 
     8bc:	7d23      	ldrb	r3, [r4, #20]
     8be:	075b      	lsls	r3, r3, #29
     8c0:	d506      	bpl.n	8d0 <OEM_LS_ApplyPulseEffectOnStateFields+0xe0>
	{
        toState.saturation = toStateContainer->state.saturation;
     8c2:	6863      	ldr	r3, [r4, #4]
     8c4:	9309      	str	r3, [sp, #36]	; 0x24
        printf("%s: ToState: Updating Saturation to %u\n", __func__, toState.saturation);
     8c6:	481f      	ldr	r0, [pc, #124]	; (944 <OEM_LS_ApplyPulseEffectOnStateFields+0x154>)
     8c8:	4914      	ldr	r1, [pc, #80]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     8ca:	1c1a      	adds	r2, r3, #0
     8cc:	4b14      	ldr	r3, [pc, #80]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     8ce:	4798      	blx	r3
    }
    if (toStateContainer->stateFieldIndicators & LAMP_STATE_COLOR_TEMP_FIELD_INDICATOR) 
     8d0:	7d23      	ldrb	r3, [r4, #20]
     8d2:	071b      	lsls	r3, r3, #28
     8d4:	d506      	bpl.n	8e4 <OEM_LS_ApplyPulseEffectOnStateFields+0xf4>
	{
        toState.colorTemp = toStateContainer->state.colorTemp;
     8d6:	68a3      	ldr	r3, [r4, #8]
     8d8:	930a      	str	r3, [sp, #40]	; 0x28
        printf("%s: ToState: Updating Color Temp to %u\n", __func__, toState.colorTemp);
     8da:	481b      	ldr	r0, [pc, #108]	; (948 <OEM_LS_ApplyPulseEffectOnStateFields+0x158>)
     8dc:	490f      	ldr	r1, [pc, #60]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     8de:	1c1a      	adds	r2, r3, #0
     8e0:	4b0f      	ldr	r3, [pc, #60]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     8e2:	4798      	blx	r3
    }
    if (toStateContainer->stateFieldIndicators & LAMP_STATE_BRIGHTNESS_FIELD_INDICATOR) 
     8e4:	7d23      	ldrb	r3, [r4, #20]
     8e6:	06db      	lsls	r3, r3, #27
     8e8:	d505      	bpl.n	8f6 <OEM_LS_ApplyPulseEffectOnStateFields+0x106>
	{
        toState.brightness = toStateContainer->state.brightness;
     8ea:	68e2      	ldr	r2, [r4, #12]
     8ec:	920b      	str	r2, [sp, #44]	; 0x2c
		printf("%s: ToState: Updating Brightness to %u\n", __func__, toState.brightness);
     8ee:	4817      	ldr	r0, [pc, #92]	; (94c <OEM_LS_ApplyPulseEffectOnStateFields+0x15c>)
     8f0:	490a      	ldr	r1, [pc, #40]	; (91c <OEM_LS_ApplyPulseEffectOnStateFields+0x12c>)
     8f2:	4b0b      	ldr	r3, [pc, #44]	; (920 <OEM_LS_ApplyPulseEffectOnStateFields+0x130>)
     8f4:	4798      	blx	r3
    }

    return OEM_LS_ApplyPulseEffect(&fromState, &toState, period, duration, numPulses, timestamp);
     8f6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
     8f8:	9300      	str	r3, [sp, #0]
     8fa:	4643      	mov	r3, r8
     8fc:	9302      	str	r3, [sp, #8]
     8fe:	9703      	str	r7, [sp, #12]
     900:	a80d      	add	r0, sp, #52	; 0x34
     902:	a908      	add	r1, sp, #32
     904:	9a06      	ldr	r2, [sp, #24]
     906:	9b07      	ldr	r3, [sp, #28]
     908:	4c11      	ldr	r4, [pc, #68]	; (950 <OEM_LS_ApplyPulseEffectOnStateFields+0x160>)
     90a:	47a0      	blx	r4
}
     90c:	b013      	add	sp, #76	; 0x4c
     90e:	bc0c      	pop	{r2, r3}
     910:	4690      	mov	r8, r2
     912:	469b      	mov	fp, r3
     914:	bdf0      	pop	{r4, r5, r6, r7, pc}
     916:	46c0      	nop			; (mov r8, r8)
     918:	00019568 	.word	0x00019568
     91c:	00019b44 	.word	0x00019b44
     920:	00016e3d 	.word	0x00016e3d
     924:	00000525 	.word	0x00000525
     928:	00019600 	.word	0x00019600
     92c:	00019628 	.word	0x00019628
     930:	0001964c 	.word	0x0001964c
     934:	00019678 	.word	0x00019678
     938:	000196a4 	.word	0x000196a4
     93c:	000196d0 	.word	0x000196d0
     940:	000196f4 	.word	0x000196f4
     944:	00019718 	.word	0x00019718
     948:	00019740 	.word	0x00019740
     94c:	00019768 	.word	0x00019768
     950:	00000799 	.word	0x00000799

00000954 <OEM_LS_TransitionState>:

LampResponseCode OEM_LS_TransitionState(LampState* newState, uint64_t timestamp, uint32_t transitionPeriod)
{
     954:	b530      	push	{r4, r5, lr}
     956:	b087      	sub	sp, #28
     958:	1c04      	adds	r4, r0, #0
	printf("%s: (Hue=%u,Saturation=%u,colorTemp=%u,Brightness=%u,OnOff=%u), transitionPeriod=%u, start=%u/%u\n", __func__,
     95a:	6881      	ldr	r1, [r0, #8]
     95c:	9100      	str	r1, [sp, #0]
     95e:	68c1      	ldr	r1, [r0, #12]
     960:	9101      	str	r1, [sp, #4]
     962:	7c01      	ldrb	r1, [r0, #16]
     964:	9102      	str	r1, [sp, #8]
     966:	990a      	ldr	r1, [sp, #40]	; 0x28
     968:	9103      	str	r1, [sp, #12]
     96a:	9204      	str	r2, [sp, #16]
     96c:	9305      	str	r3, [sp, #20]
     96e:	4806      	ldr	r0, [pc, #24]	; (988 <OEM_LS_TransitionState+0x34>)
     970:	4906      	ldr	r1, [pc, #24]	; (98c <OEM_LS_TransitionState+0x38>)
     972:	6822      	ldr	r2, [r4, #0]
     974:	6863      	ldr	r3, [r4, #4]
     976:	4d06      	ldr	r5, [pc, #24]	; (990 <OEM_LS_TransitionState+0x3c>)
     978:	47a8      	blx	r5
                   (uint32_t) (timestamp), (uint32_t) (timestamp >> 32));

    /*
     * OEMs should call this function after the transition operation has completed successfully
     */
    LAMP_SetState(newState);
     97a:	1c20      	adds	r0, r4, #0
     97c:	4b05      	ldr	r3, [pc, #20]	; (994 <OEM_LS_TransitionState+0x40>)
     97e:	4798      	blx	r3
    return LAMP_OK;
}
     980:	2000      	movs	r0, #0
     982:	b007      	add	sp, #28
     984:	bd30      	pop	{r4, r5, pc}
     986:	46c0      	nop			; (mov r8, r8)
     988:	00019790 	.word	0x00019790
     98c:	00019b80 	.word	0x00019b80
     990:	00016e3d 	.word	0x00016e3d
     994:	00000539 	.word	0x00000539

00000998 <OEM_LS_TransitionStateFields>:

LampResponseCode OEM_LS_TransitionStateFields(LampStateContainer* newStateContainer, uint64_t timestamp, uint32_t transitionPeriod)
{
     998:	b5f0      	push	{r4, r5, r6, r7, lr}
     99a:	4647      	mov	r7, r8
     99c:	b480      	push	{r7}
     99e:	b088      	sub	sp, #32
     9a0:	1c04      	adds	r4, r0, #0
     9a2:	1c16      	adds	r6, r2, #0
     9a4:	1c1d      	adds	r5, r3, #0
  printf("%s: stateFieldIndicators=0x%x, transitionPeriod=%u, start=%u/%u\n", __func__,
     9a6:	7d02      	ldrb	r2, [r0, #20]
     9a8:	9600      	str	r6, [sp, #0]
     9aa:	9301      	str	r3, [sp, #4]
     9ac:	4829      	ldr	r0, [pc, #164]	; (a54 <OEM_LS_TransitionStateFields+0xbc>)
     9ae:	492a      	ldr	r1, [pc, #168]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     9b0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     9b2:	4f2a      	ldr	r7, [pc, #168]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     9b4:	47b8      	blx	r7
     * OEMs should do the following operations just before transitioning the state
     */
    LampState state;

    /* Retrieve the current state of the Lamp */
    LAMP_GetState(&state);
     9b6:	a803      	add	r0, sp, #12
     9b8:	4b29      	ldr	r3, [pc, #164]	; (a60 <OEM_LS_TransitionStateFields+0xc8>)
     9ba:	4798      	blx	r3

    /* Update the requisite fields to new values */
    if (newStateContainer->stateFieldIndicators & LAMP_STATE_ON_OFF_FIELD_INDICATOR) 
     9bc:	7d23      	ldrb	r3, [r4, #20]
     9be:	07db      	lsls	r3, r3, #31
     9c0:	d516      	bpl.n	9f0 <OEM_LS_TransitionStateFields+0x58>
	{
        state.onOff = newStateContainer->state.onOff;
     9c2:	7c22      	ldrb	r2, [r4, #16]
     9c4:	af03      	add	r7, sp, #12
     9c6:	743a      	strb	r2, [r7, #16]
        printf("%s: Updating OnOff to %u\n", __func__, state.onOff);
     9c8:	4826      	ldr	r0, [pc, #152]	; (a64 <OEM_LS_TransitionStateFields+0xcc>)
     9ca:	4923      	ldr	r1, [pc, #140]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     9cc:	4b23      	ldr	r3, [pc, #140]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     9ce:	4698      	mov	r8, r3
     9d0:	4798      	blx	r3
		printf("----------------state.onOff=%d-----------------------\n",state.onOff);
     9d2:	7c39      	ldrb	r1, [r7, #16]
     9d4:	4824      	ldr	r0, [pc, #144]	; (a68 <OEM_LS_TransitionStateFields+0xd0>)
     9d6:	47c0      	blx	r8
		if (state.onOff==1)
     9d8:	7c3b      	ldrb	r3, [r7, #16]
     9da:	2b01      	cmp	r3, #1
     9dc:	d104      	bne.n	9e8 <OEM_LS_TransitionStateFields+0x50>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
     9de:	2280      	movs	r2, #128	; 0x80
     9e0:	05d2      	lsls	r2, r2, #23
     9e2:	4b22      	ldr	r3, [pc, #136]	; (a6c <OEM_LS_TransitionStateFields+0xd4>)
     9e4:	615a      	str	r2, [r3, #20]
     9e6:	e003      	b.n	9f0 <OEM_LS_TransitionStateFields+0x58>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     9e8:	2280      	movs	r2, #128	; 0x80
     9ea:	05d2      	lsls	r2, r2, #23
     9ec:	4b1f      	ldr	r3, [pc, #124]	; (a6c <OEM_LS_TransitionStateFields+0xd4>)
     9ee:	619a      	str	r2, [r3, #24]
		{
			port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
		}
		
    }
    if (newStateContainer->stateFieldIndicators & LAMP_STATE_HUE_FIELD_INDICATOR)
     9f0:	7d23      	ldrb	r3, [r4, #20]
     9f2:	079b      	lsls	r3, r3, #30
     9f4:	d506      	bpl.n	a04 <OEM_LS_TransitionStateFields+0x6c>
	{
        state.hue = newStateContainer->state.hue;
     9f6:	6823      	ldr	r3, [r4, #0]
     9f8:	9303      	str	r3, [sp, #12]
        printf("%s: Updating Hue to %u\n", __func__, state.hue);
     9fa:	481d      	ldr	r0, [pc, #116]	; (a70 <OEM_LS_TransitionStateFields+0xd8>)
     9fc:	4916      	ldr	r1, [pc, #88]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     9fe:	1c1a      	adds	r2, r3, #0
     a00:	4b16      	ldr	r3, [pc, #88]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     a02:	4798      	blx	r3
    }
    if (newStateContainer->stateFieldIndicators & LAMP_STATE_SATURATION_FIELD_INDICATOR)
     a04:	7d23      	ldrb	r3, [r4, #20]
     a06:	075b      	lsls	r3, r3, #29
     a08:	d506      	bpl.n	a18 <OEM_LS_TransitionStateFields+0x80>
	{
        state.saturation = newStateContainer->state.saturation;
     a0a:	6863      	ldr	r3, [r4, #4]
     a0c:	9304      	str	r3, [sp, #16]
        printf("%s: Updating Saturation to %u\n", __func__, state.saturation);
     a0e:	4819      	ldr	r0, [pc, #100]	; (a74 <OEM_LS_TransitionStateFields+0xdc>)
     a10:	4911      	ldr	r1, [pc, #68]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     a12:	1c1a      	adds	r2, r3, #0
     a14:	4b11      	ldr	r3, [pc, #68]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     a16:	4798      	blx	r3
    }
    if (newStateContainer->stateFieldIndicators & LAMP_STATE_COLOR_TEMP_FIELD_INDICATOR)
     a18:	7d23      	ldrb	r3, [r4, #20]
     a1a:	071b      	lsls	r3, r3, #28
     a1c:	d506      	bpl.n	a2c <OEM_LS_TransitionStateFields+0x94>
	{
        state.colorTemp = newStateContainer->state.colorTemp;
     a1e:	68a3      	ldr	r3, [r4, #8]
     a20:	9305      	str	r3, [sp, #20]
        printf("%s: Updating Color Temp to %u\n", __func__, state.colorTemp);
     a22:	4815      	ldr	r0, [pc, #84]	; (a78 <OEM_LS_TransitionStateFields+0xe0>)
     a24:	490c      	ldr	r1, [pc, #48]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     a26:	1c1a      	adds	r2, r3, #0
     a28:	4b0c      	ldr	r3, [pc, #48]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     a2a:	4798      	blx	r3
    }
    if (newStateContainer->stateFieldIndicators & LAMP_STATE_BRIGHTNESS_FIELD_INDICATOR)
     a2c:	7d23      	ldrb	r3, [r4, #20]
     a2e:	06db      	lsls	r3, r3, #27
     a30:	d505      	bpl.n	a3e <OEM_LS_TransitionStateFields+0xa6>
	{
        state.brightness = newStateContainer->state.brightness;
     a32:	68e2      	ldr	r2, [r4, #12]
     a34:	9206      	str	r2, [sp, #24]
		printf("%s: Updating Brightness to %u\n", __func__, state.brightness);
     a36:	4811      	ldr	r0, [pc, #68]	; (a7c <OEM_LS_TransitionStateFields+0xe4>)
     a38:	4907      	ldr	r1, [pc, #28]	; (a58 <OEM_LS_TransitionStateFields+0xc0>)
     a3a:	4b08      	ldr	r3, [pc, #32]	; (a5c <OEM_LS_TransitionStateFields+0xc4>)
     a3c:	4798      	blx	r3
    }

    return OEM_LS_TransitionState(&state, timestamp, transitionPeriod);
     a3e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     a40:	9300      	str	r3, [sp, #0]
     a42:	a803      	add	r0, sp, #12
     a44:	1c32      	adds	r2, r6, #0
     a46:	1c2b      	adds	r3, r5, #0
     a48:	490d      	ldr	r1, [pc, #52]	; (a80 <OEM_LS_TransitionStateFields+0xe8>)
     a4a:	4788      	blx	r1
}
     a4c:	b008      	add	sp, #32
     a4e:	bc04      	pop	{r2}
     a50:	4690      	mov	r8, r2
     a52:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a54:	000197f4 	.word	0x000197f4
     a58:	00019bc0 	.word	0x00019bc0
     a5c:	00016e3d 	.word	0x00016e3d
     a60:	00000525 	.word	0x00000525
     a64:	00019838 	.word	0x00019838
     a68:	00019854 	.word	0x00019854
     a6c:	41004480 	.word	0x41004480
     a70:	0001988c 	.word	0x0001988c
     a74:	000198a4 	.word	0x000198a4
     a78:	000198c4 	.word	0x000198c4
     a7c:	000198e4 	.word	0x000198e4
     a80:	00000955 	.word	0x00000955

00000a84 <OEM_LS_GetFaultsText>:
}

const char* OEM_LS_GetFaultsText(void)
{
    return "Some notification";
}
     a84:	4800      	ldr	r0, [pc, #0]	; (a88 <OEM_LS_GetFaultsText+0x4>)
     a86:	4770      	bx	lr
     a88:	00019904 	.word	0x00019904

00000a8c <OEM_LS_SetFactoryState>:

void OEM_LS_SetFactoryState(LampState* state)
{
    state->onOff = TRUE;
     a8c:	2301      	movs	r3, #1
     a8e:	7403      	strb	r3, [r0, #16]
    state->colorTemp = 0;
     a90:	2300      	movs	r3, #0
     a92:	6083      	str	r3, [r0, #8]
    state->brightness = 0;
     a94:	60c3      	str	r3, [r0, #12]
    state->hue = 0;
     a96:	6003      	str	r3, [r0, #0]
    state->saturation = 0;
     a98:	6043      	str	r3, [r0, #4]
}
     a9a:	4770      	bx	lr

00000a9c <OEM_LS_Restart>:
};

#endif

void OEM_LS_Restart(void)
{
     a9c:	b508      	push	{r3, lr}
    printf("%s\n", __func__);
     a9e:	4802      	ldr	r0, [pc, #8]	; (aa8 <OEM_LS_Restart+0xc>)
     aa0:	4b02      	ldr	r3, [pc, #8]	; (aac <OEM_LS_Restart+0x10>)
     aa2:	4798      	blx	r3
    // TODO: anything that must be done before the device restarts.
    // do not restart the device here; we will do it in the main loop
}
     aa4:	bd08      	pop	{r3, pc}
     aa6:	46c0      	nop			; (mov r8, r8)
     aa8:	00019c0c 	.word	0x00019c0c
     aac:	00016f5d 	.word	0x00016f5d

00000ab0 <OEM_LS_DoFactoryReset>:

void OEM_LS_DoFactoryReset(void)
{
     ab0:	b508      	push	{r3, lr}
    printf("%s\n", __func__);
     ab2:	4802      	ldr	r0, [pc, #8]	; (abc <OEM_LS_DoFactoryReset+0xc>)
     ab4:	4b02      	ldr	r3, [pc, #8]	; (ac0 <OEM_LS_DoFactoryReset+0x10>)
     ab6:	4798      	blx	r3
    // TODO: anything that must be done before the device restarts.
    // do not restart the device here; we will do it in the main loop

    // The framework will take care of deleting items that it manages (e.g., State, Name, Language)
}
     ab8:	bd08      	pop	{r3, pc}
     aba:	46c0      	nop			; (mov r8, r8)
     abc:	00018518 	.word	0x00018518
     ac0:	00016f5d 	.word	0x00016f5d

00000ac4 <OEM_LS_GetEnergyUsageMilliwatts>:
uint32_t OEM_LS_GetEnergyUsageMilliwatts(void)
{
    uint32_t energyUsageMilliwatts = 15;
    //printf("%s: energy usage %u mW\n", __func__, energyUsageMilliwatts);
    return energyUsageMilliwatts;
}
     ac4:	200f      	movs	r0, #15
     ac6:	4770      	bx	lr

00000ac8 <OEM_LS_GetBrightnessLumens>:

uint32_t OEM_LS_GetBrightnessLumens(void)
{
     ac8:	b510      	push	{r4, lr}
     aca:	b086      	sub	sp, #24
	LampState state;
	LAMP_GetState(&state);
     acc:	ac01      	add	r4, sp, #4
     ace:	1c20      	adds	r0, r4, #0
     ad0:	4b06      	ldr	r3, [pc, #24]	; (aec <OEM_LS_GetBrightnessLumens+0x24>)
     ad2:	4798      	blx	r3
    uint32_t brightnessLumens = ((state.brightness&0xff)*100)>>8;//100;
     ad4:	7b24      	ldrb	r4, [r4, #12]
     ad6:	2364      	movs	r3, #100	; 0x64
     ad8:	435c      	muls	r4, r3
     ada:	0a24      	lsrs	r4, r4, #8
    printf("===%s: brightness %u lumens===\n", __func__, brightnessLumens);
     adc:	4804      	ldr	r0, [pc, #16]	; (af0 <OEM_LS_GetBrightnessLumens+0x28>)
     ade:	4905      	ldr	r1, [pc, #20]	; (af4 <OEM_LS_GetBrightnessLumens+0x2c>)
     ae0:	1c22      	adds	r2, r4, #0
     ae2:	4b05      	ldr	r3, [pc, #20]	; (af8 <OEM_LS_GetBrightnessLumens+0x30>)
     ae4:	4798      	blx	r3
    return brightnessLumens;
}
     ae6:	1c20      	adds	r0, r4, #0
     ae8:	b006      	add	sp, #24
     aea:	bd10      	pop	{r4, pc}
     aec:	00000525 	.word	0x00000525
     af0:	00019918 	.word	0x00019918
     af4:	00018548 	.word	0x00018548
     af8:	00016e3d 	.word	0x00016e3d

00000afc <OEM_LS_PopulateFaults>:

LampResponseCode OEM_LS_PopulateFaults(AJ_Message* msg)
{
     afc:	b5f0      	push	{r4, r5, r6, r7, lr}
     afe:	b083      	sub	sp, #12
     b00:	1c05      	adds	r5, r0, #0
    printf("%s\n", __func__);
     b02:	480a      	ldr	r0, [pc, #40]	; (b2c <OEM_LS_PopulateFaults+0x30>)
     b04:	4b0a      	ldr	r3, [pc, #40]	; (b30 <OEM_LS_PopulateFaults+0x34>)
     b06:	4798      	blx	r3
    // this is an example of what this function might look like!
    LampFaultCode faults[2] = { 1, 4 };
     b08:	4b0a      	ldr	r3, [pc, #40]	; (b34 <OEM_LS_PopulateFaults+0x38>)
     b0a:	466a      	mov	r2, sp
     b0c:	cb03      	ldmia	r3!, {r0, r1}
     b0e:	c203      	stmia	r2!, {r0, r1}
    size_t i = 0;

    for (i = 0; i < 2; ++i) 
	{
        AJ_MarshalArgs(msg, "u", (LampFaultCode) faults[i]);
     b10:	4f09      	ldr	r7, [pc, #36]	; (b38 <OEM_LS_PopulateFaults+0x3c>)
     b12:	1c28      	adds	r0, r5, #0
     b14:	1c39      	adds	r1, r7, #0
     b16:	9a00      	ldr	r2, [sp, #0]
     b18:	4e08      	ldr	r6, [pc, #32]	; (b3c <OEM_LS_PopulateFaults+0x40>)
     b1a:	47b0      	blx	r6
     b1c:	9a01      	ldr	r2, [sp, #4]
     b1e:	1c28      	adds	r0, r5, #0
     b20:	1c39      	adds	r1, r7, #0
     b22:	47b0      	blx	r6
    }

    return LAMP_OK;
}
     b24:	2000      	movs	r0, #0
     b26:	b003      	add	sp, #12
     b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b2a:	46c0      	nop			; (mov r8, r8)
     b2c:	00018564 	.word	0x00018564
     b30:	00016f5d 	.word	0x00016f5d
     b34:	00018510 	.word	0x00018510
     b38:	0002192c 	.word	0x0002192c
     b3c:	0000bc85 	.word	0x0000bc85

00000b40 <OEM_LS_ClearFault>:

LampResponseCode OEM_LS_ClearFault(LampFaultCode fault)
{
     b40:	b508      	push	{r3, lr}
     b42:	1c02      	adds	r2, r0, #0
    printf("%s: code=%d\n", __func__, fault);
     b44:	4802      	ldr	r0, [pc, #8]	; (b50 <OEM_LS_ClearFault+0x10>)
     b46:	4903      	ldr	r1, [pc, #12]	; (b54 <OEM_LS_ClearFault+0x14>)
     b48:	4b03      	ldr	r3, [pc, #12]	; (b58 <OEM_LS_ClearFault+0x18>)
     b4a:	4798      	blx	r3
    // TOOD: clear the fault code
    return LAMP_OK;
}
     b4c:	2000      	movs	r0, #0
     b4e:	bd08      	pop	{r3, pc}
     b50:	00019938 	.word	0x00019938
     b54:	00018530 	.word	0x00018530
     b58:	00016e3d 	.word	0x00016e3d

00000b5c <OEM_LS_PopulateParameters>:

AJ_Status OEM_LS_PopulateParameters(AJ_Message* msg)
{
     b5c:	b5f0      	push	{r4, r5, r6, r7, lr}
     b5e:	b083      	sub	sp, #12
     b60:	1c07      	adds	r7, r0, #0
    printf("%s\n", __func__);
     b62:	480c      	ldr	r0, [pc, #48]	; (b94 <OEM_LS_PopulateParameters+0x38>)
     b64:	4b0c      	ldr	r3, [pc, #48]	; (b98 <OEM_LS_PopulateParameters+0x3c>)
     b66:	4798      	blx	r3

  //  printf("Energy_Usage_Milliwatts: %u\n", OEM_LS_GetEnergyUsageMilliwatts());
    AJ_MarshalArgs(msg, "{sv}", "Energy_Usage_Milliwatts", "u", OEM_LS_GetEnergyUsageMilliwatts());
     b68:	4e0c      	ldr	r6, [pc, #48]	; (b9c <OEM_LS_PopulateParameters+0x40>)
     b6a:	4d0d      	ldr	r5, [pc, #52]	; (ba0 <OEM_LS_PopulateParameters+0x44>)
     b6c:	230f      	movs	r3, #15
     b6e:	9300      	str	r3, [sp, #0]
     b70:	1c38      	adds	r0, r7, #0
     b72:	1c31      	adds	r1, r6, #0
     b74:	4a0b      	ldr	r2, [pc, #44]	; (ba4 <OEM_LS_PopulateParameters+0x48>)
     b76:	1c2b      	adds	r3, r5, #0
     b78:	4c0b      	ldr	r4, [pc, #44]	; (ba8 <OEM_LS_PopulateParameters+0x4c>)
     b7a:	47a0      	blx	r4
   // printf("Brightness_Lumens: %u\n", OEM_LS_GetBrightnessLumens());
    AJ_MarshalArgs(msg, "{sv}", "Brightness_Lumens", "u", OEM_LS_GetBrightnessLumens());
     b7c:	4b0b      	ldr	r3, [pc, #44]	; (bac <OEM_LS_PopulateParameters+0x50>)
     b7e:	4798      	blx	r3
     b80:	9000      	str	r0, [sp, #0]
     b82:	1c38      	adds	r0, r7, #0
     b84:	1c31      	adds	r1, r6, #0
     b86:	4a0a      	ldr	r2, [pc, #40]	; (bb0 <OEM_LS_PopulateParameters+0x54>)
     b88:	1c2b      	adds	r3, r5, #0
     b8a:	47a0      	blx	r4
    return AJ_OK;
}
     b8c:	2000      	movs	r0, #0
     b8e:	b003      	add	sp, #12
     b90:	bdf0      	pop	{r4, r5, r6, r7, pc}
     b92:	46c0      	nop			; (mov r8, r8)
     b94:	00019474 	.word	0x00019474
     b98:	00016f5d 	.word	0x00016f5d
     b9c:	0001f938 	.word	0x0001f938
     ba0:	0002192c 	.word	0x0002192c
     ba4:	00019948 	.word	0x00019948
     ba8:	0000bc85 	.word	0x0000bc85
     bac:	00000ac9 	.word	0x00000ac9
     bb0:	00019960 	.word	0x00019960

00000bb4 <OEM_LS_PopulateDetails>:
    .deviceMaxTemperature = 5000,
    .deviceColorRenderingIndex = 0
};

LampResponseCode OEM_LS_PopulateDetails(AJ_Message* msg)
{
     bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
     bb6:	b085      	sub	sp, #20
     bb8:	1c05      	adds	r5, r0, #0
   // AJ_InfoPrintf(("%s", __func__));


  //  AJ_InfoPrintf(("LampVersion: %u\n", LAMP_GetServiceVersion()));
    AJ_MarshalArgs(msg, "{sv}", "LampVersion", "u", LAMP_GetServiceVersion());
     bba:	4b4a      	ldr	r3, [pc, #296]	; (ce4 <OEM_LS_PopulateDetails+0x130>)
     bbc:	4798      	blx	r3
     bbe:	4c4a      	ldr	r4, [pc, #296]	; (ce8 <OEM_LS_PopulateDetails+0x134>)
     bc0:	4e4a      	ldr	r6, [pc, #296]	; (cec <OEM_LS_PopulateDetails+0x138>)
     bc2:	9000      	str	r0, [sp, #0]
     bc4:	1c28      	adds	r0, r5, #0
     bc6:	1c21      	adds	r1, r4, #0
     bc8:	4a49      	ldr	r2, [pc, #292]	; (cf0 <OEM_LS_PopulateDetails+0x13c>)
     bca:	1c33      	adds	r3, r6, #0
     bcc:	4f49      	ldr	r7, [pc, #292]	; (cf4 <OEM_LS_PopulateDetails+0x140>)
     bce:	47b8      	blx	r7

  //  AJ_InfoPrintf(("Make: %u\n", LampDetails.lampMake));
    AJ_MarshalArgs(msg, "{sv}", "Make", "u", LampDetails.lampMake);
     bd0:	2302      	movs	r3, #2
     bd2:	9300      	str	r3, [sp, #0]
     bd4:	9503      	str	r5, [sp, #12]
     bd6:	1c28      	adds	r0, r5, #0
     bd8:	1c21      	adds	r1, r4, #0
     bda:	4a47      	ldr	r2, [pc, #284]	; (cf8 <OEM_LS_PopulateDetails+0x144>)
     bdc:	1c33      	adds	r3, r6, #0
     bde:	47b8      	blx	r7

  //  AJ_InfoPrintf(("Model: %u\n", LampDetails.lampModel));
    AJ_MarshalArgs(msg, "{sv}", "Model", "u", LampDetails.lampModel);
     be0:	2501      	movs	r5, #1
     be2:	9500      	str	r5, [sp, #0]
     be4:	9803      	ldr	r0, [sp, #12]
     be6:	1c21      	adds	r1, r4, #0
     be8:	4a44      	ldr	r2, [pc, #272]	; (cfc <OEM_LS_PopulateDetails+0x148>)
     bea:	1c33      	adds	r3, r6, #0
     bec:	47b8      	blx	r7

   // AJ_InfoPrintf(("Type: %u\n", LampDetails.deviceType));
    AJ_MarshalArgs(msg, "{sv}", "Type", "u", LampDetails.deviceType);
     bee:	9500      	str	r5, [sp, #0]
     bf0:	9803      	ldr	r0, [sp, #12]
     bf2:	1c21      	adds	r1, r4, #0
     bf4:	4a42      	ldr	r2, [pc, #264]	; (d00 <OEM_LS_PopulateDetails+0x14c>)
     bf6:	1c33      	adds	r3, r6, #0
     bf8:	47b8      	blx	r7

  //  AJ_InfoPrintf(("LampType: %u\n", LampDetails.lampType));
    AJ_MarshalArgs(msg, "{sv}", "LampType", "u", LampDetails.lampType);
     bfa:	2347      	movs	r3, #71	; 0x47
     bfc:	9300      	str	r3, [sp, #0]
     bfe:	9803      	ldr	r0, [sp, #12]
     c00:	1c21      	adds	r1, r4, #0
     c02:	4a40      	ldr	r2, [pc, #256]	; (d04 <OEM_LS_PopulateDetails+0x150>)
     c04:	1c33      	adds	r3, r6, #0
     c06:	47b8      	blx	r7

  //  AJ_InfoPrintf(("LampBaseType: %u\n", LampDetails.baseType));
    AJ_MarshalArgs(msg, "{sv}", "LampBaseType", "u", LampDetails.baseType);
     c08:	2306      	movs	r3, #6
     c0a:	9300      	str	r3, [sp, #0]
     c0c:	9803      	ldr	r0, [sp, #12]
     c0e:	1c21      	adds	r1, r4, #0
     c10:	4a3d      	ldr	r2, [pc, #244]	; (d08 <OEM_LS_PopulateDetails+0x154>)
     c12:	1c33      	adds	r3, r6, #0
     c14:	47b8      	blx	r7


   // AJ_InfoPrintf(("LampBeamAngle: %u\n", LampDetails.deviceLampBeamAngle));
    AJ_MarshalArgs(msg, "{sv}", "LampBeamAngle", "u", LampDetails.deviceLampBeamAngle);
     c16:	2364      	movs	r3, #100	; 0x64
     c18:	9300      	str	r3, [sp, #0]
     c1a:	9803      	ldr	r0, [sp, #12]
     c1c:	1c21      	adds	r1, r4, #0
     c1e:	4a3b      	ldr	r2, [pc, #236]	; (d0c <OEM_LS_PopulateDetails+0x158>)
     c20:	1c33      	adds	r3, r6, #0
     c22:	47b8      	blx	r7

  //  AJ_InfoPrintf(("Dimmable: %s\n", (LampDetails.deviceDimmable ? "TRUE" : "FALSE")));
    AJ_MarshalArgs(msg, "{sv}", "Dimmable", "b", (LampDetails.deviceDimmable ? TRUE : FALSE));
     c24:	9500      	str	r5, [sp, #0]
     c26:	9803      	ldr	r0, [sp, #12]
     c28:	1c21      	adds	r1, r4, #0
     c2a:	4a39      	ldr	r2, [pc, #228]	; (d10 <OEM_LS_PopulateDetails+0x15c>)
     c2c:	4b39      	ldr	r3, [pc, #228]	; (d14 <OEM_LS_PopulateDetails+0x160>)
     c2e:	47b8      	blx	r7
  //  AJ_InfoPrintf(("Color: %s\n", (LampDetails.deviceColor ? "TRUE" : "FALSE")));
    AJ_MarshalArgs(msg, "{sv}", "Color", "b", (LampDetails.deviceColor ? TRUE : FALSE));
     c30:	9500      	str	r5, [sp, #0]
     c32:	9803      	ldr	r0, [sp, #12]
     c34:	1c21      	adds	r1, r4, #0
     c36:	4a38      	ldr	r2, [pc, #224]	; (d18 <OEM_LS_PopulateDetails+0x164>)
     c38:	4b36      	ldr	r3, [pc, #216]	; (d14 <OEM_LS_PopulateDetails+0x160>)
     c3a:	47b8      	blx	r7
  //  AJ_InfoPrintf(("VariableColorTemp: %s\n", (LampDetails.variableColorTemp ? "TRUE" : "FALSE")));
    AJ_MarshalArgs(msg, "{sv}", "VariableColorTemp", "b", (LampDetails.variableColorTemp ? TRUE : FALSE));
     c3c:	9500      	str	r5, [sp, #0]
     c3e:	9803      	ldr	r0, [sp, #12]
     c40:	1c21      	adds	r1, r4, #0
     c42:	4a36      	ldr	r2, [pc, #216]	; (d1c <OEM_LS_PopulateDetails+0x168>)
     c44:	4b33      	ldr	r3, [pc, #204]	; (d14 <OEM_LS_PopulateDetails+0x160>)
     c46:	47b8      	blx	r7
  //  AJ_InfoPrintf(("HasEffects: %s\n", (LampDetails.deviceHasEffects ? "TRUE" : "FALSE")));
    AJ_MarshalArgs(msg, "{sv}", "HasEffects", "b", (LampDetails.deviceHasEffects ? TRUE : FALSE));
     c48:	9500      	str	r5, [sp, #0]
     c4a:	9d03      	ldr	r5, [sp, #12]
     c4c:	1c28      	adds	r0, r5, #0
     c4e:	1c21      	adds	r1, r4, #0
     c50:	4a33      	ldr	r2, [pc, #204]	; (d20 <OEM_LS_PopulateDetails+0x16c>)
     c52:	4b30      	ldr	r3, [pc, #192]	; (d14 <OEM_LS_PopulateDetails+0x160>)
     c54:	47b8      	blx	r7

 //   AJ_InfoPrintf(("MinVoltage: %u\n", LampDetails.deviceMinVoltage));
    AJ_MarshalArgs(msg, "{sv}", "MinVoltage", "u", LampDetails.deviceMinVoltage);
     c56:	23b4      	movs	r3, #180	; 0xb4
     c58:	9300      	str	r3, [sp, #0]
     c5a:	1c28      	adds	r0, r5, #0
     c5c:	1c21      	adds	r1, r4, #0
     c5e:	4a31      	ldr	r2, [pc, #196]	; (d24 <OEM_LS_PopulateDetails+0x170>)
     c60:	1c33      	adds	r3, r6, #0
     c62:	47b8      	blx	r7

 //   AJ_InfoPrintf(("MaxVoltage: %u\n", LampDetails.deviceMaxVoltage));
    AJ_MarshalArgs(msg, "{sv}", "MaxVoltage", "u", LampDetails.deviceMaxVoltage);
     c64:	2387      	movs	r3, #135	; 0x87
     c66:	005b      	lsls	r3, r3, #1
     c68:	9300      	str	r3, [sp, #0]
     c6a:	1c28      	adds	r0, r5, #0
     c6c:	1c21      	adds	r1, r4, #0
     c6e:	4a2e      	ldr	r2, [pc, #184]	; (d28 <OEM_LS_PopulateDetails+0x174>)
     c70:	1c33      	adds	r3, r6, #0
     c72:	47b8      	blx	r7

 //   AJ_InfoPrintf(("Wattage: %u\n", LampDetails.deviceWattage));
    AJ_MarshalArgs(msg, "{sv}", "Wattage", "u", LampDetails.deviceWattage);
     c74:	23f0      	movs	r3, #240	; 0xf0
     c76:	9300      	str	r3, [sp, #0]
     c78:	1c28      	adds	r0, r5, #0
     c7a:	1c21      	adds	r1, r4, #0
     c7c:	4a2b      	ldr	r2, [pc, #172]	; (d2c <OEM_LS_PopulateDetails+0x178>)
     c7e:	1c33      	adds	r3, r6, #0
     c80:	47b8      	blx	r7

 //   AJ_InfoPrintf(("IncandescentEquivalent: %u\n", LampDetails.deviceIncandescentEquivalent));
    AJ_MarshalArgs(msg, "{sv}", "IncandescentEquivalent", "u", LampDetails.deviceIncandescentEquivalent);
     c82:	234b      	movs	r3, #75	; 0x4b
     c84:	9300      	str	r3, [sp, #0]
     c86:	1c28      	adds	r0, r5, #0
     c88:	1c21      	adds	r1, r4, #0
     c8a:	4a29      	ldr	r2, [pc, #164]	; (d30 <OEM_LS_PopulateDetails+0x17c>)
     c8c:	1c33      	adds	r3, r6, #0
     c8e:	47b8      	blx	r7

 //   AJ_InfoPrintf(("MaxLumens: %u\n", LampDetails.deviceMaxLumens));
    AJ_MarshalArgs(msg, "{sv}", "MaxLumens", "u", LampDetails.deviceMaxLumens);
     c90:	23e1      	movs	r3, #225	; 0xe1
     c92:	009b      	lsls	r3, r3, #2
     c94:	9300      	str	r3, [sp, #0]
     c96:	1c28      	adds	r0, r5, #0
     c98:	1c21      	adds	r1, r4, #0
     c9a:	4a26      	ldr	r2, [pc, #152]	; (d34 <OEM_LS_PopulateDetails+0x180>)
     c9c:	1c33      	adds	r3, r6, #0
     c9e:	47b8      	blx	r7

  //  AJ_InfoPrintf(("MinTemperature: %u\n", LampDetails.deviceMinTemperature));
    AJ_MarshalArgs(msg, "{sv}", "MinTemperature", "u", LampDetails.deviceMinTemperature);
     ca0:	4b25      	ldr	r3, [pc, #148]	; (d38 <OEM_LS_PopulateDetails+0x184>)
     ca2:	9300      	str	r3, [sp, #0]
     ca4:	1c28      	adds	r0, r5, #0
     ca6:	1c21      	adds	r1, r4, #0
     ca8:	4a24      	ldr	r2, [pc, #144]	; (d3c <OEM_LS_PopulateDetails+0x188>)
     caa:	1c33      	adds	r3, r6, #0
     cac:	47b8      	blx	r7

  //  AJ_InfoPrintf(("MaxTemperature: %u\n", LampDetails.deviceMaxTemperature));
    AJ_MarshalArgs(msg, "{sv}", "MaxTemperature", "u", LampDetails.deviceMaxTemperature);
     cae:	4b24      	ldr	r3, [pc, #144]	; (d40 <OEM_LS_PopulateDetails+0x18c>)
     cb0:	9300      	str	r3, [sp, #0]
     cb2:	1c28      	adds	r0, r5, #0
     cb4:	1c21      	adds	r1, r4, #0
     cb6:	4a23      	ldr	r2, [pc, #140]	; (d44 <OEM_LS_PopulateDetails+0x190>)
     cb8:	1c33      	adds	r3, r6, #0
     cba:	47b8      	blx	r7

   // AJ_InfoPrintf(("ColorRenderingIndex: %u\n", LampDetails.deviceColorRenderingIndex));
    AJ_MarshalArgs(msg, "{sv}", "ColorRenderingIndex", "u", LampDetails.deviceColorRenderingIndex);
     cbc:	2300      	movs	r3, #0
     cbe:	9300      	str	r3, [sp, #0]
     cc0:	1c28      	adds	r0, r5, #0
     cc2:	1c21      	adds	r1, r4, #0
     cc4:	4a20      	ldr	r2, [pc, #128]	; (d48 <OEM_LS_PopulateDetails+0x194>)
     cc6:	1c33      	adds	r3, r6, #0
     cc8:	47b8      	blx	r7

  //  AJ_InfoPrintf(("LampID: %s\n", AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID)));
    AJ_MarshalArgs(msg, "{sv}", "LampID", "s", AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID));
     cca:	2000      	movs	r0, #0
     ccc:	4b1f      	ldr	r3, [pc, #124]	; (d4c <OEM_LS_PopulateDetails+0x198>)
     cce:	4798      	blx	r3
     cd0:	9000      	str	r0, [sp, #0]
     cd2:	1c28      	adds	r0, r5, #0
     cd4:	1c21      	adds	r1, r4, #0
     cd6:	4a1e      	ldr	r2, [pc, #120]	; (d50 <OEM_LS_PopulateDetails+0x19c>)
     cd8:	4b1e      	ldr	r3, [pc, #120]	; (d54 <OEM_LS_PopulateDetails+0x1a0>)
     cda:	47b8      	blx	r7
    return LAMP_OK;
}
     cdc:	2000      	movs	r0, #0
     cde:	b005      	add	sp, #20
     ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ce2:	46c0      	nop			; (mov r8, r8)
     ce4:	0001420d 	.word	0x0001420d
     ce8:	0001f938 	.word	0x0001f938
     cec:	0002192c 	.word	0x0002192c
     cf0:	00019974 	.word	0x00019974
     cf4:	0000bc85 	.word	0x0000bc85
     cf8:	00019980 	.word	0x00019980
     cfc:	00019988 	.word	0x00019988
     d00:	000199a4 	.word	0x000199a4
     d04:	00019990 	.word	0x00019990
     d08:	0001999c 	.word	0x0001999c
     d0c:	000199ac 	.word	0x000199ac
     d10:	000199bc 	.word	0x000199bc
     d14:	0001ed84 	.word	0x0001ed84
     d18:	000199c8 	.word	0x000199c8
     d1c:	000199d0 	.word	0x000199d0
     d20:	000199e4 	.word	0x000199e4
     d24:	000199f0 	.word	0x000199f0
     d28:	000199fc 	.word	0x000199fc
     d2c:	00019a08 	.word	0x00019a08
     d30:	00019a10 	.word	0x00019a10
     d34:	00019a28 	.word	0x00019a28
     d38:	00000a8c 	.word	0x00000a8c
     d3c:	00019a34 	.word	0x00019a34
     d40:	00001388 	.word	0x00001388
     d44:	00019a44 	.word	0x00019a44
     d48:	00019a54 	.word	0x00019a54
     d4c:	00000e39 	.word	0x00000e39
     d50:	00019a68 	.word	0x00019a68
     d54:	0001f054 	.word	0x0001f054

00000d58 <AJSVC_PropertyStore_GetMaxValueLength>:

static const char* defaultLanguagesKeyName = { "SupportedLanguages" };

uint8_t AJSVC_PropertyStore_GetMaxValueLength(int8_t fieldIndex)
{
    switch (fieldIndex) 
     d58:	2803      	cmp	r0, #3
     d5a:	d004      	beq.n	d66 <AJSVC_PropertyStore_GetMaxValueLength+0xe>
     d5c:	2804      	cmp	r0, #4
     d5e:	d004      	beq.n	d6a <AJSVC_PropertyStore_GetMaxValueLength+0x12>
     d60:	2802      	cmp	r0, #2
     d62:	d104      	bne.n	d6e <AJSVC_PropertyStore_GetMaxValueLength+0x16>
     d64:	e005      	b.n	d72 <AJSVC_PropertyStore_GetMaxValueLength+0x1a>
	{
    case AJSVC_PROPERTY_STORE_DEVICE_NAME:
        return DEVICE_NAME_VALUE_LENGTH;

    case AJSVC_PROPERTY_STORE_DEFAULT_LANGUAGE:
        return LANG_VALUE_LENGTH;
     d66:	2007      	movs	r0, #7
     d68:	e004      	b.n	d74 <AJSVC_PropertyStore_GetMaxValueLength+0x1c>

    case AJSVC_PROPERTY_STORE_PASSCODE:
        return PASSWORD_VALUE_LENGTH;
     d6a:	2020      	movs	r0, #32
     d6c:	e002      	b.n	d74 <AJSVC_PropertyStore_GetMaxValueLength+0x1c>

    default:
        return KEY_VALUE_LENGTH;
     d6e:	200a      	movs	r0, #10
     d70:	e000      	b.n	d74 <AJSVC_PropertyStore_GetMaxValueLength+0x1c>
uint8_t AJSVC_PropertyStore_GetMaxValueLength(int8_t fieldIndex)
{
    switch (fieldIndex) 
	{
    case AJSVC_PROPERTY_STORE_DEVICE_NAME:
        return DEVICE_NAME_VALUE_LENGTH;
     d72:	20fe      	movs	r0, #254	; 0xfe
        return PASSWORD_VALUE_LENGTH;

    default:
        return KEY_VALUE_LENGTH;
    }
}
     d74:	4770      	bx	lr
     d76:	46c0      	nop			; (mov r8, r8)

00000d78 <AJSVC_PropertyStore_GetFieldName>:

const char* AJSVC_PropertyStore_GetFieldName(int8_t fieldIndex)
{
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
     d78:	b2c3      	uxtb	r3, r0
     d7a:	2b0f      	cmp	r3, #15
     d7c:	d803      	bhi.n	d86 <AJSVC_PropertyStore_GetFieldName+0xe>
	{
        return "N/A";
    }
    return propertyStoreProperties[fieldIndex].keyName;
     d7e:	00c0      	lsls	r0, r0, #3
     d80:	4b02      	ldr	r3, [pc, #8]	; (d8c <AJSVC_PropertyStore_GetFieldName+0x14>)
     d82:	58c0      	ldr	r0, [r0, r3]
     d84:	e000      	b.n	d88 <AJSVC_PropertyStore_GetFieldName+0x10>

const char* AJSVC_PropertyStore_GetFieldName(int8_t fieldIndex)
{
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
	{
        return "N/A";
     d86:	4802      	ldr	r0, [pc, #8]	; (d90 <AJSVC_PropertyStore_GetFieldName+0x18>)
    }
    return propertyStoreProperties[fieldIndex].keyName;
}
     d88:	4770      	bx	lr
     d8a:	46c0      	nop			; (mov r8, r8)
     d8c:	00019e24 	.word	0x00019e24
     d90:	00019c74 	.word	0x00019c74

00000d94 <AJSVC_PropertyStore_GetFieldIndex>:

int8_t AJSVC_PropertyStore_GetFieldIndex(const char* fieldName)
{
     d94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d96:	1c06      	adds	r6, r0, #0
     d98:	4d07      	ldr	r5, [pc, #28]	; (db8 <AJSVC_PropertyStore_GetFieldIndex+0x24>)
    int8_t fieldIndex;
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS; fieldIndex++) 
     d9a:	2400      	movs	r4, #0
	{
        if (!strcmp(propertyStoreProperties[fieldIndex].keyName, fieldName)) 
     d9c:	4f07      	ldr	r7, [pc, #28]	; (dbc <AJSVC_PropertyStore_GetFieldIndex+0x28>)
     d9e:	6828      	ldr	r0, [r5, #0]
     da0:	1c31      	adds	r1, r6, #0
     da2:	47b8      	blx	r7
     da4:	2800      	cmp	r0, #0
     da6:	d005      	beq.n	db4 <AJSVC_PropertyStore_GetFieldIndex+0x20>
     da8:	3401      	adds	r4, #1
     daa:	b2e4      	uxtb	r4, r4
     dac:	3508      	adds	r5, #8
}

int8_t AJSVC_PropertyStore_GetFieldIndex(const char* fieldName)
{
    int8_t fieldIndex;
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS; fieldIndex++) 
     dae:	2c10      	cmp	r4, #16
     db0:	d1f5      	bne.n	d9e <AJSVC_PropertyStore_GetFieldIndex+0xa>
        if (!strcmp(propertyStoreProperties[fieldIndex].keyName, fieldName)) 
		{
            return fieldIndex;
        }
    }
    return AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX;
     db2:	34ef      	adds	r4, #239	; 0xef
     db4:	b260      	sxtb	r0, r4
}
     db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     db8:	00019e24 	.word	0x00019e24
     dbc:	00017137 	.word	0x00017137

00000dc0 <AJSVC_PropertyStore_GetValueForLang>:
    return AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
}

const char* AJSVC_PropertyStore_GetValueForLang(int8_t fieldIndex, int8_t langIndex)
{
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
     dc0:	b2c3      	uxtb	r3, r0
     dc2:	2b0f      	cmp	r3, #15
     dc4:	d82c      	bhi.n	e20 <AJSVC_PropertyStore_GetValueForLang+0x60>
    return AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX;
}

static int8_t GetLanguageIndexForProperty(int8_t langIndex, int8_t fieldIndex)
{
    if (propertyStoreProperties[fieldIndex].mode2MultiLng) 
     dc6:	00c3      	lsls	r3, r0, #3
     dc8:	4a18      	ldr	r2, [pc, #96]	; (e2c <AJSVC_PropertyStore_GetValueForLang+0x6c>)
     dca:	18d3      	adds	r3, r2, r3
     dcc:	791b      	ldrb	r3, [r3, #4]
     dce:	075b      	lsls	r3, r3, #29
     dd0:	d504      	bpl.n	ddc <AJSVC_PropertyStore_GetValueForLang+0x1c>
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
	{
        return NULL;
    }
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES)
     dd2:	b2ca      	uxtb	r2, r1
	{
        return NULL;
     dd4:	2300      	movs	r3, #0
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
	{
        return NULL;
    }
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES)
     dd6:	2a01      	cmp	r2, #1
     dd8:	d825      	bhi.n	e26 <AJSVC_PropertyStore_GetValueForLang+0x66>
     dda:	e000      	b.n	dde <AJSVC_PropertyStore_GetValueForLang+0x1e>
{
    if (propertyStoreProperties[fieldIndex].mode2MultiLng) 
	{
        return langIndex;
    }
    return AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
     ddc:	2100      	movs	r1, #0
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES)
	{
        return NULL;
    }
    if (fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS &&
     dde:	2805      	cmp	r0, #5
     de0:	dc16      	bgt.n	e10 <AJSVC_PropertyStore_GetValueForLang+0x50>
        (propertyStoreProperties[fieldIndex].mode0Write || propertyStoreProperties[fieldIndex].mode3Init) &&
     de2:	00c3      	lsls	r3, r0, #3
     de4:	4a11      	ldr	r2, [pc, #68]	; (e2c <AJSVC_PropertyStore_GetValueForLang+0x6c>)
     de6:	18d3      	adds	r3, r2, r3
     de8:	791b      	ldrb	r3, [r3, #4]
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES)
	{
        return NULL;
    }
    if (fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS &&
     dea:	07db      	lsls	r3, r3, #31
     dec:	d404      	bmi.n	df8 <AJSVC_PropertyStore_GetValueForLang+0x38>
        (propertyStoreProperties[fieldIndex].mode0Write || propertyStoreProperties[fieldIndex].mode3Init) &&
     dee:	00c3      	lsls	r3, r0, #3
     df0:	18d3      	adds	r3, r2, r3
     df2:	791b      	ldrb	r3, [r3, #4]
     df4:	071b      	lsls	r3, r3, #28
     df6:	d50b      	bpl.n	e10 <AJSVC_PropertyStore_GetValueForLang+0x50>
        propertyStoreRuntimeValues[fieldIndex].value != NULL &&
     df8:	00c3      	lsls	r3, r0, #3
     dfa:	4a0d      	ldr	r2, [pc, #52]	; (e30 <AJSVC_PropertyStore_GetValueForLang+0x70>)
     dfc:	589b      	ldr	r3, [r3, r2]
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES)
	{
        return NULL;
    }
    if (fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS &&
        (propertyStoreProperties[fieldIndex].mode0Write || propertyStoreProperties[fieldIndex].mode3Init) &&
     dfe:	2b00      	cmp	r3, #0
     e00:	d006      	beq.n	e10 <AJSVC_PropertyStore_GetValueForLang+0x50>
        propertyStoreRuntimeValues[fieldIndex].value != NULL &&
        (propertyStoreRuntimeValues[fieldIndex].value[langIndex]) != NULL &&
     e02:	008a      	lsls	r2, r1, #2
     e04:	58d3      	ldr	r3, [r2, r3]
	{
        return NULL;
    }
    if (fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS &&
        (propertyStoreProperties[fieldIndex].mode0Write || propertyStoreProperties[fieldIndex].mode3Init) &&
        propertyStoreRuntimeValues[fieldIndex].value != NULL &&
     e06:	2b00      	cmp	r3, #0
     e08:	d002      	beq.n	e10 <AJSVC_PropertyStore_GetValueForLang+0x50>
        (propertyStoreRuntimeValues[fieldIndex].value[langIndex]) != NULL &&
     e0a:	781a      	ldrb	r2, [r3, #0]
     e0c:	2a00      	cmp	r2, #0
     e0e:	d10a      	bne.n	e26 <AJSVC_PropertyStore_GetValueForLang+0x66>
        (propertyStoreRuntimeValues[fieldIndex].value[langIndex])[0] != '\0') 
	{
   //     AJ_InfoPrintf(("Has key [%s] runtime Value [%s]\n", propertyStoreProperties[fieldIndex].keyName, propertyStoreRuntimeValues[fieldIndex].value[langIndex]));
        return propertyStoreRuntimeValues[fieldIndex].value[langIndex];
    } 
	else if (propertyStoreDefaultValues[fieldIndex] != NULL &&
     e10:	0080      	lsls	r0, r0, #2
     e12:	4b08      	ldr	r3, [pc, #32]	; (e34 <AJSVC_PropertyStore_GetValueForLang+0x74>)
     e14:	58c3      	ldr	r3, [r0, r3]
     e16:	2b00      	cmp	r3, #0
     e18:	d004      	beq.n	e24 <AJSVC_PropertyStore_GetValueForLang+0x64>
               (propertyStoreDefaultValues[fieldIndex])[langIndex] != NULL)
     e1a:	0089      	lsls	r1, r1, #2
     e1c:	58cb      	ldr	r3, [r1, r3]
     e1e:	e002      	b.n	e26 <AJSVC_PropertyStore_GetValueForLang+0x66>

const char* AJSVC_PropertyStore_GetValueForLang(int8_t fieldIndex, int8_t langIndex)
{
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS) 
	{
        return NULL;
     e20:	2300      	movs	r3, #0
     e22:	e000      	b.n	e26 <AJSVC_PropertyStore_GetValueForLang+0x66>
	{
  //      AJ_InfoPrintf(("Has key [%s] default Value [%s]\n", propertyStoreProperties[fieldIndex].keyName, (propertyStoreDefaultValues[fieldIndex])[langIndex]));
        return (propertyStoreDefaultValues[fieldIndex])[langIndex];
    }

    return NULL;
     e24:	2300      	movs	r3, #0
}
     e26:	1c18      	adds	r0, r3, #0
     e28:	4770      	bx	lr
     e2a:	46c0      	nop			; (mov r8, r8)
     e2c:	00019e24 	.word	0x00019e24
     e30:	20000028 	.word	0x20000028
     e34:	2000007c 	.word	0x2000007c

00000e38 <AJSVC_PropertyStore_GetValue>:

const char* AJSVC_PropertyStore_GetValue(int8_t fieldIndex)
{
     e38:	b508      	push	{r3, lr}
    return AJSVC_PropertyStore_GetValueForLang(fieldIndex, AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX);
     e3a:	2100      	movs	r1, #0
     e3c:	4b01      	ldr	r3, [pc, #4]	; (e44 <AJSVC_PropertyStore_GetValue+0xc>)
     e3e:	4798      	blx	r3
}
     e40:	bd08      	pop	{r3, pc}
     e42:	46c0      	nop			; (mov r8, r8)
     e44:	00000dc1 	.word	0x00000dc1

00000e48 <AJSVC_PropertyStore_GetLanguageIndex>:
    }
    return propertyStoreDefaultLanguages[langIndex];
}

int8_t AJSVC_PropertyStore_GetLanguageIndex(const char* const language)
{
     e48:	b538      	push	{r3, r4, r5, lr}
    int8_t langIndex;
    const char* search = language;
    if (search != NULL)
     e4a:	2800      	cmp	r0, #0
     e4c:	d00c      	beq.n	e68 <AJSVC_PropertyStore_GetLanguageIndex+0x20>
	{
        if (search[0] == '\0') 
     e4e:	7803      	ldrb	r3, [r0, #0]
     e50:	2b00      	cmp	r3, #0
     e52:	d10d      	bne.n	e70 <AJSVC_PropertyStore_GetLanguageIndex+0x28>
		{ // Check for empty language, if yes then search for current default language index
            search = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEFAULT_LANGUAGE);
     e54:	2003      	movs	r0, #3
     e56:	4b0f      	ldr	r3, [pc, #60]	; (e94 <AJSVC_PropertyStore_GetLanguageIndex+0x4c>)
     e58:	4798      	blx	r3
     e5a:	1e04      	subs	r4, r0, #0
            if (search == NULL) 
     e5c:	d109      	bne.n	e72 <AJSVC_PropertyStore_GetLanguageIndex+0x2a>
     e5e:	e005      	b.n	e6c <AJSVC_PropertyStore_GetLanguageIndex+0x24>
            }
        }
        langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++)
		 {
            if (!strcmp(search, propertyStoreDefaultLanguages[langIndex]))
     e60:	2000      	movs	r0, #0
     e62:	e015      	b.n	e90 <AJSVC_PropertyStore_GetLanguageIndex+0x48>
			{
                return AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
            }
        }
        langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++)
     e64:	2001      	movs	r0, #1
     e66:	e013      	b.n	e90 <AJSVC_PropertyStore_GetLanguageIndex+0x48>
		    {
                return langIndex;
            }
        }
    }
    return AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
     e68:	20ff      	movs	r0, #255	; 0xff
     e6a:	e011      	b.n	e90 <AJSVC_PropertyStore_GetLanguageIndex+0x48>
        if (search[0] == '\0') 
		{ // Check for empty language, if yes then search for current default language index
            search = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEFAULT_LANGUAGE);
            if (search == NULL) 
			{
                return AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
     e6c:	20ff      	movs	r0, #255	; 0xff
     e6e:	e00f      	b.n	e90 <AJSVC_PropertyStore_GetLanguageIndex+0x48>
}

int8_t AJSVC_PropertyStore_GetLanguageIndex(const char* const language)
{
    int8_t langIndex;
    const char* search = language;
     e70:	1c04      	adds	r4, r0, #0
            }
        }
        langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++)
		 {
            if (!strcmp(search, propertyStoreDefaultLanguages[langIndex]))
     e72:	4b09      	ldr	r3, [pc, #36]	; (e98 <AJSVC_PropertyStore_GetLanguageIndex+0x50>)
     e74:	681d      	ldr	r5, [r3, #0]
     e76:	1c20      	adds	r0, r4, #0
     e78:	6829      	ldr	r1, [r5, #0]
     e7a:	4b08      	ldr	r3, [pc, #32]	; (e9c <AJSVC_PropertyStore_GetLanguageIndex+0x54>)
     e7c:	4798      	blx	r3
     e7e:	2800      	cmp	r0, #0
     e80:	d0ee      	beq.n	e60 <AJSVC_PropertyStore_GetLanguageIndex+0x18>
     e82:	6869      	ldr	r1, [r5, #4]
     e84:	1c20      	adds	r0, r4, #0
     e86:	4b05      	ldr	r3, [pc, #20]	; (e9c <AJSVC_PropertyStore_GetLanguageIndex+0x54>)
     e88:	4798      	blx	r3
     e8a:	2800      	cmp	r0, #0
     e8c:	d0ea      	beq.n	e64 <AJSVC_PropertyStore_GetLanguageIndex+0x1c>
		    {
                return langIndex;
            }
        }
    }
    return AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
     e8e:	20ff      	movs	r0, #255	; 0xff
     e90:	b240      	sxtb	r0, r0
}
     e92:	bd38      	pop	{r3, r4, r5, pc}
     e94:	00000e39 	.word	0x00000e39
     e98:	200000c0 	.word	0x200000c0
     e9c:	00017137 	.word	0x00017137

00000ea0 <AJSVC_PropertyStore_SetValueForLang>:

uint8_t AJSVC_PropertyStore_SetValueForLang(int8_t fieldIndex, int8_t langIndex, const char* value)
{
     ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t var_size;
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX ||
     ea2:	b2c4      	uxtb	r4, r0
        fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS) 
	{
        return FALSE;
     ea4:	2300      	movs	r3, #0
}

uint8_t AJSVC_PropertyStore_SetValueForLang(int8_t fieldIndex, int8_t langIndex, const char* value)
{
    size_t var_size;
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX ||
     ea6:	2c05      	cmp	r4, #5
     ea8:	d81c      	bhi.n	ee4 <AJSVC_PropertyStore_SetValueForLang+0x44>
    return AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX;
}

static int8_t GetLanguageIndexForProperty(int8_t langIndex, int8_t fieldIndex)
{
    if (propertyStoreProperties[fieldIndex].mode2MultiLng) 
     eaa:	00c3      	lsls	r3, r0, #3
     eac:	4c0e      	ldr	r4, [pc, #56]	; (ee8 <AJSVC_PropertyStore_SetValueForLang+0x48>)
     eae:	18e3      	adds	r3, r4, r3
     eb0:	791b      	ldrb	r3, [r3, #4]
     eb2:	075b      	lsls	r3, r3, #29
     eb4:	d504      	bpl.n	ec0 <AJSVC_PropertyStore_SetValueForLang+0x20>
        fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS) 
	{
        return FALSE;
    }
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES) 
     eb6:	b2cc      	uxtb	r4, r1
	{
        return FALSE;
     eb8:	2300      	movs	r3, #0
        fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS) 
	{
        return FALSE;
    }
    langIndex = GetLanguageIndexForProperty(langIndex, fieldIndex);
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES) 
     eba:	2c01      	cmp	r4, #1
     ebc:	d812      	bhi.n	ee4 <AJSVC_PropertyStore_SetValueForLang+0x44>
     ebe:	e000      	b.n	ec2 <AJSVC_PropertyStore_SetValueForLang+0x22>
{
    if (propertyStoreProperties[fieldIndex].mode2MultiLng) 
	{
        return langIndex;
    }
    return AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
     ec0:	2100      	movs	r1, #0
	{
        return FALSE;
    }
  //  AJ_InfoPrintf(("Set key [%s] defaultValue [%s]\n", propertyStoreProperties[fieldIndex].keyName, value));
    var_size = propertyStoreRuntimeValues[fieldIndex].size;
    strncpy(propertyStoreRuntimeValues[fieldIndex].value[langIndex], value, var_size - 1);
     ec2:	008c      	lsls	r4, r1, #2
    if (langIndex <= AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX || langIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES) 
	{
        return FALSE;
    }
  //  AJ_InfoPrintf(("Set key [%s] defaultValue [%s]\n", propertyStoreProperties[fieldIndex].keyName, value));
    var_size = propertyStoreRuntimeValues[fieldIndex].size;
     ec4:	4e09      	ldr	r6, [pc, #36]	; (eec <AJSVC_PropertyStore_SetValueForLang+0x4c>)
     ec6:	00c7      	lsls	r7, r0, #3
     ec8:	19f3      	adds	r3, r6, r7
     eca:	791d      	ldrb	r5, [r3, #4]
    strncpy(propertyStoreRuntimeValues[fieldIndex].value[langIndex], value, var_size - 1);
     ecc:	3d01      	subs	r5, #1
     ece:	59bb      	ldr	r3, [r7, r6]
     ed0:	5918      	ldr	r0, [r3, r4]
     ed2:	1c11      	adds	r1, r2, #0
     ed4:	1c2a      	adds	r2, r5, #0
     ed6:	4b06      	ldr	r3, [pc, #24]	; (ef0 <AJSVC_PropertyStore_SetValueForLang+0x50>)
     ed8:	4798      	blx	r3
    (propertyStoreRuntimeValues[fieldIndex].value[langIndex])[var_size - 1] = '\0';
     eda:	59bb      	ldr	r3, [r7, r6]
     edc:	591b      	ldr	r3, [r3, r4]
     ede:	2200      	movs	r2, #0
     ee0:	555a      	strb	r2, [r3, r5]

    return TRUE;
     ee2:	2301      	movs	r3, #1
}
     ee4:	1c18      	adds	r0, r3, #0
     ee6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ee8:	00019e24 	.word	0x00019e24
     eec:	20000028 	.word	0x20000028
     ef0:	00017191 	.word	0x00017191

00000ef4 <UpdateFieldInRAM>:
    AJ_AboutSetShouldAnnounce(); // Set flag for sending an updated Announcement
    return status;
}

static uint8_t UpdateFieldInRAM(int8_t fieldIndex, int8_t langIndex, const char* fieldValue)
{
     ef4:	b510      	push	{r4, lr}
     ef6:	1c04      	adds	r4, r0, #0
    uint8_t ret = FALSE;

    if (propertyStoreProperties[fieldIndex].mode0Write && propertyStoreProperties[fieldIndex].mode7Public) 
     ef8:	00c3      	lsls	r3, r0, #3
     efa:	4810      	ldr	r0, [pc, #64]	; (f3c <UpdateFieldInRAM+0x48>)
     efc:	18c3      	adds	r3, r0, r3
     efe:	791b      	ldrb	r3, [r3, #4]
     f00:	07db      	lsls	r3, r3, #31
     f02:	d509      	bpl.n	f18 <UpdateFieldInRAM+0x24>
     f04:	00e3      	lsls	r3, r4, #3
     f06:	18c3      	adds	r3, r0, r3
     f08:	791b      	ldrb	r3, [r3, #4]
     f0a:	09db      	lsrs	r3, r3, #7
     f0c:	d004      	beq.n	f18 <UpdateFieldInRAM+0x24>
	{
        ret = AJSVC_PropertyStore_SetValueForLang(fieldIndex, langIndex, fieldValue);
     f0e:	1c20      	adds	r0, r4, #0
     f10:	4b0b      	ldr	r3, [pc, #44]	; (f40 <UpdateFieldInRAM+0x4c>)
     f12:	4798      	blx	r3
     f14:	1c03      	adds	r3, r0, #0
     f16:	e00e      	b.n	f36 <UpdateFieldInRAM+0x42>
    } 
	else
	{
        AJ_ErrPrintf(("UpdateFieldInRAM ERROR - field %s has read only attribute or is private\n", propertyStoreProperties[fieldIndex].keyName));
     f18:	2001      	movs	r0, #1
     f1a:	490a      	ldr	r1, [pc, #40]	; (f44 <UpdateFieldInRAM+0x50>)
     f1c:	4a0a      	ldr	r2, [pc, #40]	; (f48 <UpdateFieldInRAM+0x54>)
     f1e:	4b0b      	ldr	r3, [pc, #44]	; (f4c <UpdateFieldInRAM+0x58>)
     f20:	4798      	blx	r3
    return status;
}

static uint8_t UpdateFieldInRAM(int8_t fieldIndex, int8_t langIndex, const char* fieldValue)
{
    uint8_t ret = FALSE;
     f22:	2300      	movs	r3, #0
	{
        ret = AJSVC_PropertyStore_SetValueForLang(fieldIndex, langIndex, fieldValue);
    } 
	else
	{
        AJ_ErrPrintf(("UpdateFieldInRAM ERROR - field %s has read only attribute or is private\n", propertyStoreProperties[fieldIndex].keyName));
     f24:	2800      	cmp	r0, #0
     f26:	d006      	beq.n	f36 <UpdateFieldInRAM+0x42>
     f28:	00e4      	lsls	r4, r4, #3
     f2a:	4b04      	ldr	r3, [pc, #16]	; (f3c <UpdateFieldInRAM+0x48>)
     f2c:	58e1      	ldr	r1, [r4, r3]
     f2e:	4808      	ldr	r0, [pc, #32]	; (f50 <UpdateFieldInRAM+0x5c>)
     f30:	4b08      	ldr	r3, [pc, #32]	; (f54 <UpdateFieldInRAM+0x60>)
     f32:	4798      	blx	r3
    return status;
}

static uint8_t UpdateFieldInRAM(int8_t fieldIndex, int8_t langIndex, const char* fieldValue)
{
    uint8_t ret = FALSE;
     f34:	2300      	movs	r3, #0
	{
        AJ_ErrPrintf(("UpdateFieldInRAM ERROR - field %s has read only attribute or is private\n", propertyStoreProperties[fieldIndex].keyName));
    }

    return ret;
}
     f36:	1c18      	adds	r0, r3, #0
     f38:	bd10      	pop	{r4, pc}
     f3a:	46c0      	nop			; (mov r8, r8)
     f3c:	00019e24 	.word	0x00019e24
     f40:	00000ea1 	.word	0x00000ea1
     f44:	00019c78 	.word	0x00019c78
     f48:	0000026a 	.word	0x0000026a
     f4c:	0000636d 	.word	0x0000636d
     f50:	00019cb0 	.word	0x00019cb0
     f54:	00016e3d 	.word	0x00016e3d

00000f58 <AJSVC_PropertyStore_SetValue>:

    return TRUE;
}

uint8_t AJSVC_PropertyStore_SetValue(int8_t fieldIndex, const char* value)
{
     f58:	b508      	push	{r3, lr}
     f5a:	1c0a      	adds	r2, r1, #0
    return AJSVC_PropertyStore_SetValueForLang(fieldIndex, AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX, value);
     f5c:	2100      	movs	r1, #0
     f5e:	4b01      	ldr	r3, [pc, #4]	; (f64 <AJSVC_PropertyStore_SetValue+0xc>)
     f60:	4798      	blx	r3
}
     f62:	bd08      	pop	{r3, pc}
     f64:	00000ea1 	.word	0x00000ea1

00000f68 <InitMandatoryPropertiesInRAM>:
    AJ_NVRAM_Write(DeviceId, sizeof(DeviceId), file);
    AJ_NVRAM_Close(file);*/
}

static void InitMandatoryPropertiesInRAM()
{
     f68:	b570      	push	{r4, r5, r6, lr}
    char* machineIdValue = propertyStoreRuntimeValues[AJSVC_PROPERTY_STORE_APP_ID].value[AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX];
     f6a:	4b0e      	ldr	r3, [pc, #56]	; (fa4 <InitMandatoryPropertiesInRAM+0x3c>)
     f6c:	689b      	ldr	r3, [r3, #8]
     f6e:	681e      	ldr	r6, [r3, #0]
    const char* currentAppIdValue = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_ID);
     f70:	2001      	movs	r0, #1
     f72:	4c0d      	ldr	r4, [pc, #52]	; (fa8 <InitMandatoryPropertiesInRAM+0x40>)
     f74:	47a0      	blx	r4
     f76:	1c05      	adds	r5, r0, #0
    const char* currentDeviceIdValue = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID);
     f78:	2000      	movs	r0, #0
     f7a:	47a0      	blx	r4
     f7c:	1c04      	adds	r4, r0, #0
    const char* real_id = GetPersistentDeviceId();

    if (currentAppIdValue == NULL || currentAppIdValue[0] == '\0') 
     f7e:	2d00      	cmp	r5, #0
     f80:	d002      	beq.n	f88 <InitMandatoryPropertiesInRAM+0x20>
     f82:	782b      	ldrb	r3, [r5, #0]
     f84:	2b00      	cmp	r3, #0
     f86:	d103      	bne.n	f90 <InitMandatoryPropertiesInRAM+0x28>
	{
        strcpy(machineIdValue, real_id);
     f88:	1c30      	adds	r0, r6, #0
     f8a:	4908      	ldr	r1, [pc, #32]	; (fac <InitMandatoryPropertiesInRAM+0x44>)
     f8c:	4b08      	ldr	r3, [pc, #32]	; (fb0 <InitMandatoryPropertiesInRAM+0x48>)
     f8e:	4798      	blx	r3
    }

    if (currentDeviceIdValue == NULL || currentDeviceIdValue[0] == '\0') 
     f90:	2c00      	cmp	r4, #0
     f92:	d002      	beq.n	f9a <InitMandatoryPropertiesInRAM+0x32>
     f94:	7823      	ldrb	r3, [r4, #0]
     f96:	2b00      	cmp	r3, #0
     f98:	d103      	bne.n	fa2 <InitMandatoryPropertiesInRAM+0x3a>
	{
        AJSVC_PropertyStore_SetValue(AJSVC_PROPERTY_STORE_DEVICE_ID, machineIdValue);
     f9a:	2000      	movs	r0, #0
     f9c:	1c31      	adds	r1, r6, #0
     f9e:	4b05      	ldr	r3, [pc, #20]	; (fb4 <InitMandatoryPropertiesInRAM+0x4c>)
     fa0:	4798      	blx	r3
    }
}
     fa2:	bd70      	pop	{r4, r5, r6, pc}
     fa4:	20000028 	.word	0x20000028
     fa8:	00000e39 	.word	0x00000e39
     fac:	200000d8 	.word	0x200000d8
     fb0:	0001714b 	.word	0x0001714b
     fb4:	00000f59 	.word	0x00000f59

00000fb8 <SavePersistentDeviceId>:
void SavePersistentDeviceId(void)
{
    /*AJ_NV_DATASET* file = AJ_NVRAM_Open(LAMP_STATE_FD, "w", sizeof(DeviceId));
    AJ_NVRAM_Write(DeviceId, sizeof(DeviceId), file);
    AJ_NVRAM_Close(file);*/
}
     fb8:	4770      	bx	lr
     fba:	46c0      	nop			; (mov r8, r8)

00000fbc <AJSVC_PropertyStore_LoadAll>:
            }
        }
    }

    return status;
}
     fbc:	2000      	movs	r0, #0
     fbe:	4770      	bx	lr

00000fc0 <PropertyStore_Init>:
	
    return status;
}

AJ_Status PropertyStore_Init()
{
     fc0:	b510      	push	{r4, lr}
    AJ_Status status = AJ_OK;
    status = AJSVC_PropertyStore_LoadAll();
     fc2:	4b05      	ldr	r3, [pc, #20]	; (fd8 <PropertyStore_Init+0x18>)
     fc4:	4798      	blx	r3
     fc6:	1c04      	adds	r4, r0, #0
    InitMandatoryPropertiesInRAM();
     fc8:	4b04      	ldr	r3, [pc, #16]	; (fdc <PropertyStore_Init+0x1c>)
     fca:	4798      	blx	r3
    // About needs to get values from the property store
    AJ_AboutRegisterPropStoreGetter(AboutPropGetter);
     fcc:	4804      	ldr	r0, [pc, #16]	; (fe0 <PropertyStore_Init+0x20>)
     fce:	4b05      	ldr	r3, [pc, #20]	; (fe4 <PropertyStore_Init+0x24>)
     fd0:	4798      	blx	r3
    return status;
}
     fd2:	1c20      	adds	r0, r4, #0
     fd4:	bd10      	pop	{r4, pc}
     fd6:	46c0      	nop			; (mov r8, r8)
     fd8:	00000fbd 	.word	0x00000fbd
     fdc:	00000f69 	.word	0x00000f69
     fe0:	00001365 	.word	0x00001365
     fe4:	00001691 	.word	0x00001691

00000fe8 <AJSVC_PropertyStore_SaveAll>:

    return status;
}

AJ_Status AJSVC_PropertyStore_SaveAll()
{
     fe8:	b508      	push	{r3, lr}
            //    status = PropertyStore_WriteConfig(AJ_PROPERTIES_NV_ID_BEGIN + entry, buf, size, "w");
       //         AJ_InfoPrintf(("nvram write fieldIndex=%d [%s] langIndex=%d [%s] entry=%d val=%s size=%u status=%s\n", (int)fieldIndex, propertyStoreProperties[fieldIndex].keyName, (int)langIndex, propertyStoreDefaultLanguages[langIndex], (int)entry, propertyStoreRuntimeValues[fieldIndex].value[langIndex], (int)size, AJ_StatusText(status)));
            }
        }
    }
    AJ_AboutSetShouldAnnounce(); // Set flag for sending an updated Announcement
     fea:	4b02      	ldr	r3, [pc, #8]	; (ff4 <AJSVC_PropertyStore_SaveAll+0xc>)
     fec:	4798      	blx	r3
    return status;
}
     fee:	2000      	movs	r0, #0
     ff0:	bd08      	pop	{r3, pc}
     ff2:	46c0      	nop			; (mov r8, r8)
     ff4:	00001965 	.word	0x00001965

00000ff8 <AJSVC_PropertyStore_ReadAll>:
{
    return UpdateFieldInRAM(fieldIndex, langIndex, "");
}

AJ_Status AJSVC_PropertyStore_ReadAll(AJ_Message* msg, AJSVC_PropertyStoreCategoryFilter filter, int8_t langIndex)
{
     ff8:	b5f0      	push	{r4, r5, r6, r7, lr}
     ffa:	465f      	mov	r7, fp
     ffc:	4656      	mov	r6, sl
     ffe:	464d      	mov	r5, r9
    1000:	4644      	mov	r4, r8
    1002:	b4f0      	push	{r4, r5, r6, r7}
    1004:	b09b      	sub	sp, #108	; 0x6c
    1006:	9002      	str	r0, [sp, #8]
    1008:	1c0e      	adds	r6, r1, #0
    100a:	466b      	mov	r3, sp
    100c:	7419      	strb	r1, [r3, #16]
    100e:	9203      	str	r2, [sp, #12]
    const char* ajVersion;
    int8_t fieldIndex;

 //  printf("-----------PropertyStore_ReadAll()-------------\n");

    status = AJ_MarshalContainer(msg, &array, AJ_ARG_ARRAY);
    1010:	a916      	add	r1, sp, #88	; 0x58
    1012:	2261      	movs	r2, #97	; 0x61
    1014:	4bbf      	ldr	r3, [pc, #764]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    1016:	4798      	blx	r3
    if (status != AJ_OK) 
	{
//		printf("PropertyStore_ReadAll 1 status= %s\n",AJ_StatusText(status));
        return status;
    1018:	1e03      	subs	r3, r0, #0
    int8_t fieldIndex;

 //  printf("-----------PropertyStore_ReadAll()-------------\n");

    status = AJ_MarshalContainer(msg, &array, AJ_ARG_ARRAY);
    if (status != AJ_OK) 
    101a:	d000      	beq.n	101e <AJSVC_PropertyStore_ReadAll+0x26>
    101c:	e19a      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
    101e:	4fbe      	ldr	r7, [pc, #760]	; (1318 <AJSVC_PropertyStore_ReadAll+0x320>)
    1020:	2501      	movs	r5, #1
    1022:	2400      	movs	r4, #0
    }
  //   printf("AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS= %d\n",AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS);
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS; fieldIndex++) 
	{
        if (propertyStoreProperties[fieldIndex].mode7Public &&
            (filter.bit0About
    1024:	b2f3      	uxtb	r3, r6
    1026:	469b      	mov	fp, r3
    1028:	2301      	movs	r3, #1
    102a:	465a      	mov	r2, fp
    102c:	4013      	ands	r3, r2
    102e:	469a      	mov	sl, r3
    1030:	46d8      	mov	r8, fp
    1032:	e003      	b.n	103c <AJSVC_PropertyStore_ReadAll+0x44>
    1034:	3401      	adds	r4, #1
    1036:	3501      	adds	r5, #1
    1038:	b2ed      	uxtb	r5, r5
    103a:	3708      	adds	r7, #8
    103c:	b2e6      	uxtb	r6, r4
        return status;
    }
  //   printf("AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS= %d\n",AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS);
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS; fieldIndex++) 
	{
        if (propertyStoreProperties[fieldIndex].mode7Public &&
    103e:	1c22      	adds	r2, r4, #0
    1040:	00e3      	lsls	r3, r4, #3
    1042:	49b5      	ldr	r1, [pc, #724]	; (1318 <AJSVC_PropertyStore_ReadAll+0x320>)
    1044:	18cb      	adds	r3, r1, r3
    1046:	791b      	ldrb	r3, [r3, #4]
    1048:	09db      	lsrs	r3, r3, #7
    104a:	d100      	bne.n	104e <AJSVC_PropertyStore_ReadAll+0x56>
    104c:	e0e4      	b.n	1218 <AJSVC_PropertyStore_ReadAll+0x220>
    104e:	4653      	mov	r3, sl
    1050:	2b00      	cmp	r3, #0
    1052:	d117      	bne.n	1084 <AJSVC_PropertyStore_ReadAll+0x8c>
            (filter.bit0About
             || propertyStoreProperties[fieldIndex].mode4
    1054:	00e3      	lsls	r3, r4, #3
    1056:	18cb      	adds	r3, r1, r3
    1058:	791b      	ldrb	r3, [r3, #4]
    105a:	06db      	lsls	r3, r3, #27
    105c:	d412      	bmi.n	1084 <AJSVC_PropertyStore_ReadAll+0x8c>
             || (filter.bit1Config && propertyStoreProperties[fieldIndex].mode0Write)
    105e:	4643      	mov	r3, r8
    1060:	079b      	lsls	r3, r3, #30
    1062:	d504      	bpl.n	106e <AJSVC_PropertyStore_ReadAll+0x76>
    1064:	00e3      	lsls	r3, r4, #3
    1066:	18cb      	adds	r3, r1, r3
    1068:	791b      	ldrb	r3, [r3, #4]
    106a:	07db      	lsls	r3, r3, #31
    106c:	d40a      	bmi.n	1084 <AJSVC_PropertyStore_ReadAll+0x8c>
             || (filter.bit2Announce && propertyStoreProperties[fieldIndex].mode1Announce))) 
    106e:	4643      	mov	r3, r8
    1070:	075b      	lsls	r3, r3, #29
    1072:	d400      	bmi.n	1076 <AJSVC_PropertyStore_ReadAll+0x7e>
    1074:	e0d0      	b.n	1218 <AJSVC_PropertyStore_ReadAll+0x220>
    1076:	00d2      	lsls	r2, r2, #3
    1078:	4ba7      	ldr	r3, [pc, #668]	; (1318 <AJSVC_PropertyStore_ReadAll+0x320>)
    107a:	189a      	adds	r2, r3, r2
    107c:	7913      	ldrb	r3, [r2, #4]
    107e:	079b      	lsls	r3, r3, #30
    1080:	d400      	bmi.n	1084 <AJSVC_PropertyStore_ReadAll+0x8c>
    1082:	e0c9      	b.n	1218 <AJSVC_PropertyStore_ReadAll+0x220>
	    {
            value = AJSVC_PropertyStore_GetValueForLang(fieldIndex, langIndex);
    1084:	b270      	sxtb	r0, r6
    1086:	9903      	ldr	r1, [sp, #12]
    1088:	4ba4      	ldr	r3, [pc, #656]	; (131c <AJSVC_PropertyStore_ReadAll+0x324>)
    108a:	4798      	blx	r3
    108c:	4681      	mov	r9, r0
   
            if (value == NULL && (int8_t)fieldIndex >= (int8_t)AJSVC_PROPERTY_STORE_NUMBER_OF_MANDATORY_KEYS) 
    108e:	2800      	cmp	r0, #0
    1090:	d000      	beq.n	1094 <AJSVC_PropertyStore_ReadAll+0x9c>
    1092:	e137      	b.n	1304 <AJSVC_PropertyStore_ReadAll+0x30c>
    1094:	b273      	sxtb	r3, r6
    1096:	2b0d      	cmp	r3, #13
    1098:	dc00      	bgt.n	109c <AJSVC_PropertyStore_ReadAll+0xa4>
    109a:	e137      	b.n	130c <AJSVC_PropertyStore_ReadAll+0x314>
    109c:	e0bc      	b.n	1218 <AJSVC_PropertyStore_ReadAll+0x220>
					{
    //                    printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    109e:	9e02      	ldr	r6, [sp, #8]
    10a0:	1c30      	adds	r0, r6, #0
    10a2:	a90e      	add	r1, sp, #56	; 0x38
    10a4:	227b      	movs	r2, #123	; 0x7b
    10a6:	4b9b      	ldr	r3, [pc, #620]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    10a8:	4798      	blx	r3
                    if (status != AJ_OK) 
    10aa:	2800      	cmp	r0, #0
    10ac:	d000      	beq.n	10b0 <AJSVC_PropertyStore_ReadAll+0xb8>
    10ae:	e0ff      	b.n	12b0 <AJSVC_PropertyStore_ReadAll+0x2b8>
					{
	//					printf("PropertyStore_ReadAll 2 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    10b0:	1c30      	adds	r0, r6, #0
    10b2:	499b      	ldr	r1, [pc, #620]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    10b4:	683a      	ldr	r2, [r7, #0]
    10b6:	4b9b      	ldr	r3, [pc, #620]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    10b8:	4798      	blx	r3
                    if (status != AJ_OK) 
    10ba:	2800      	cmp	r0, #0
    10bc:	d000      	beq.n	10c0 <AJSVC_PropertyStore_ReadAll+0xc8>
    10be:	e0f9      	b.n	12b4 <AJSVC_PropertyStore_ReadAll+0x2bc>
					{
		//				printf("PropertyStore_ReadAll 3 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "ay");
    10c0:	9602      	str	r6, [sp, #8]
    10c2:	1c30      	adds	r0, r6, #0
    10c4:	4998      	ldr	r1, [pc, #608]	; (1328 <AJSVC_PropertyStore_ReadAll+0x330>)
    10c6:	4b99      	ldr	r3, [pc, #612]	; (132c <AJSVC_PropertyStore_ReadAll+0x334>)
    10c8:	4798      	blx	r3
                    if (status != AJ_OK) 
    10ca:	2800      	cmp	r0, #0
    10cc:	d000      	beq.n	10d0 <AJSVC_PropertyStore_ReadAll+0xd8>
    10ce:	e0f3      	b.n	12b8 <AJSVC_PropertyStore_ReadAll+0x2c0>
					{
		//				printf("PropertyStore_ReadAll 4 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_HexToRaw(value, 0, rawValue, sizeof(rawValue));
    10d0:	4648      	mov	r0, r9
    10d2:	2100      	movs	r1, #0
    10d4:	aa06      	add	r2, sp, #24
    10d6:	2310      	movs	r3, #16
    10d8:	4e95      	ldr	r6, [pc, #596]	; (1330 <AJSVC_PropertyStore_ReadAll+0x338>)
    10da:	47b0      	blx	r6
                    if (status != AJ_OK)
    10dc:	2800      	cmp	r0, #0
    10de:	d000      	beq.n	10e2 <AJSVC_PropertyStore_ReadAll+0xea>
    10e0:	e0ec      	b.n	12bc <AJSVC_PropertyStore_ReadAll+0x2c4>
					{
		//				printf("PropertyStore_ReadAll 5 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArg(msg, AJ_InitArg(&arg, AJ_ARG_BYTE, AJ_ARRAY_FLAG, rawValue, sizeof(rawValue)));
    10e2:	2310      	movs	r3, #16
    10e4:	9300      	str	r3, [sp, #0]
    10e6:	a80a      	add	r0, sp, #40	; 0x28
    10e8:	2179      	movs	r1, #121	; 0x79
    10ea:	2201      	movs	r2, #1
    10ec:	ab06      	add	r3, sp, #24
    10ee:	4e91      	ldr	r6, [pc, #580]	; (1334 <AJSVC_PropertyStore_ReadAll+0x33c>)
    10f0:	47b0      	blx	r6
    10f2:	1c01      	adds	r1, r0, #0
    10f4:	9e02      	ldr	r6, [sp, #8]
    10f6:	1c30      	adds	r0, r6, #0
    10f8:	4b8f      	ldr	r3, [pc, #572]	; (1338 <AJSVC_PropertyStore_ReadAll+0x340>)
    10fa:	4798      	blx	r3
                    if (status != AJ_OK) 
    10fc:	2800      	cmp	r0, #0
    10fe:	d000      	beq.n	1102 <AJSVC_PropertyStore_ReadAll+0x10a>
    1100:	e0de      	b.n	12c0 <AJSVC_PropertyStore_ReadAll+0x2c8>
					{
		//				printf("PropertyStore_ReadAll 6 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    1102:	1c30      	adds	r0, r6, #0
    1104:	a90e      	add	r1, sp, #56	; 0x38
    1106:	4b8d      	ldr	r3, [pc, #564]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    1108:	4798      	blx	r3
                    if (status != AJ_OK) 
    110a:	2800      	cmp	r0, #0
    110c:	d092      	beq.n	1034 <AJSVC_PropertyStore_ReadAll+0x3c>
					{
		//				printf("PropertyStore_ReadAll 6 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    110e:	1c03      	adds	r3, r0, #0
    1110:	e120      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
		//				printf("PropertyStore_ReadAll 7 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                } 
				else if (fieldIndex == AJSVC_PROPERTY_STORE_MAX_LENGTH) 
    1112:	2e0d      	cmp	r6, #13
    1114:	d128      	bne.n	1168 <AJSVC_PropertyStore_ReadAll+0x170>
				{
                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    1116:	9e02      	ldr	r6, [sp, #8]
    1118:	1c30      	adds	r0, r6, #0
    111a:	a90e      	add	r1, sp, #56	; 0x38
    111c:	227b      	movs	r2, #123	; 0x7b
    111e:	4b7d      	ldr	r3, [pc, #500]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    1120:	4798      	blx	r3
                    if (status != AJ_OK) 
    1122:	2800      	cmp	r0, #0
    1124:	d000      	beq.n	1128 <AJSVC_PropertyStore_ReadAll+0x130>
    1126:	e0cd      	b.n	12c4 <AJSVC_PropertyStore_ReadAll+0x2cc>
					{
		//				printf("PropertyStore_ReadAll 8 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    1128:	1c30      	adds	r0, r6, #0
    112a:	497d      	ldr	r1, [pc, #500]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    112c:	683a      	ldr	r2, [r7, #0]
    112e:	4b7d      	ldr	r3, [pc, #500]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    1130:	4798      	blx	r3
                    if (status != AJ_OK) 
    1132:	2800      	cmp	r0, #0
    1134:	d000      	beq.n	1138 <AJSVC_PropertyStore_ReadAll+0x140>
    1136:	e0c7      	b.n	12c8 <AJSVC_PropertyStore_ReadAll+0x2d0>
					{
		//				printf("PropertyStore_ReadAll 9 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "q");
    1138:	1c30      	adds	r0, r6, #0
    113a:	4981      	ldr	r1, [pc, #516]	; (1340 <AJSVC_PropertyStore_ReadAll+0x348>)
    113c:	4b7b      	ldr	r3, [pc, #492]	; (132c <AJSVC_PropertyStore_ReadAll+0x334>)
    113e:	4798      	blx	r3
                    if (status != AJ_OK) 
    1140:	2800      	cmp	r0, #0
    1142:	d000      	beq.n	1146 <AJSVC_PropertyStore_ReadAll+0x14e>
    1144:	e0c2      	b.n	12cc <AJSVC_PropertyStore_ReadAll+0x2d4>
					{
		//				printf("PropertyStore_ReadAll 10 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "q", DEVICE_NAME_VALUE_LENGTH);
    1146:	1c30      	adds	r0, r6, #0
    1148:	497d      	ldr	r1, [pc, #500]	; (1340 <AJSVC_PropertyStore_ReadAll+0x348>)
    114a:	22fe      	movs	r2, #254	; 0xfe
    114c:	4b75      	ldr	r3, [pc, #468]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    114e:	4798      	blx	r3
                    if (status != AJ_OK) 
    1150:	2800      	cmp	r0, #0
    1152:	d000      	beq.n	1156 <AJSVC_PropertyStore_ReadAll+0x15e>
    1154:	e0bc      	b.n	12d0 <AJSVC_PropertyStore_ReadAll+0x2d8>
					{
		//				printf("PropertyStore_ReadAll 11 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    1156:	1c30      	adds	r0, r6, #0
    1158:	a90e      	add	r1, sp, #56	; 0x38
    115a:	4b78      	ldr	r3, [pc, #480]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    115c:	4798      	blx	r3
                    if (status != AJ_OK) 
    115e:	2800      	cmp	r0, #0
    1160:	d100      	bne.n	1164 <AJSVC_PropertyStore_ReadAll+0x16c>
    1162:	e767      	b.n	1034 <AJSVC_PropertyStore_ReadAll+0x3c>
					{
		//				printf("PropertyStore_ReadAll 11 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    1164:	1c03      	adds	r3, r0, #0
    1166:	e0f5      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		//				printf("PropertyStore_ReadAll 12 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
        //            printf("Has key [%s] runtime Value [%d]\n", propertyStoreProperties[AJSVC_PROPERTY_STORE_MAX_LENGTH].keyName, DEVICE_NAME_VALUE_LENGTH);
                }
				else if (fieldIndex == AJSVC_PROPERTY_STORE_AJ_SOFTWARE_VERSION) 
    1168:	2e0c      	cmp	r6, #12
    116a:	d12c      	bne.n	11c6 <AJSVC_PropertyStore_ReadAll+0x1ce>
				{
                    ajVersion = AJ_GetVersion();
    116c:	4b75      	ldr	r3, [pc, #468]	; (1344 <AJSVC_PropertyStore_ReadAll+0x34c>)
    116e:	4798      	blx	r3
    1170:	1e06      	subs	r6, r0, #0
                    if (ajVersion == NULL) 
    1172:	d100      	bne.n	1176 <AJSVC_PropertyStore_ReadAll+0x17e>
    1174:	e0ae      	b.n	12d4 <AJSVC_PropertyStore_ReadAll+0x2dc>
					{
         //               printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    1176:	9802      	ldr	r0, [sp, #8]
    1178:	a90e      	add	r1, sp, #56	; 0x38
    117a:	227b      	movs	r2, #123	; 0x7b
    117c:	4b65      	ldr	r3, [pc, #404]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    117e:	4798      	blx	r3
                    if (status != AJ_OK) 
    1180:	2800      	cmp	r0, #0
    1182:	d000      	beq.n	1186 <AJSVC_PropertyStore_ReadAll+0x18e>
    1184:	e0a8      	b.n	12d8 <AJSVC_PropertyStore_ReadAll+0x2e0>
					{
			//			printf("PropertyStore_ReadAll 13 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    1186:	9802      	ldr	r0, [sp, #8]
    1188:	4965      	ldr	r1, [pc, #404]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    118a:	683a      	ldr	r2, [r7, #0]
    118c:	4b65      	ldr	r3, [pc, #404]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    118e:	4798      	blx	r3
                    if (status != AJ_OK) 
    1190:	2800      	cmp	r0, #0
    1192:	d000      	beq.n	1196 <AJSVC_PropertyStore_ReadAll+0x19e>
    1194:	e0a2      	b.n	12dc <AJSVC_PropertyStore_ReadAll+0x2e4>
					{
			//			printf("PropertyStore_ReadAll 14 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "s");
    1196:	9802      	ldr	r0, [sp, #8]
    1198:	4961      	ldr	r1, [pc, #388]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    119a:	4b64      	ldr	r3, [pc, #400]	; (132c <AJSVC_PropertyStore_ReadAll+0x334>)
    119c:	4798      	blx	r3
                    if (status != AJ_OK) 
    119e:	2800      	cmp	r0, #0
    11a0:	d000      	beq.n	11a4 <AJSVC_PropertyStore_ReadAll+0x1ac>
    11a2:	e09d      	b.n	12e0 <AJSVC_PropertyStore_ReadAll+0x2e8>
					{
		//				printf("PropertyStore_ReadAll 15 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", ajVersion);
    11a4:	9802      	ldr	r0, [sp, #8]
    11a6:	495e      	ldr	r1, [pc, #376]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    11a8:	1c32      	adds	r2, r6, #0
    11aa:	4b5e      	ldr	r3, [pc, #376]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    11ac:	4798      	blx	r3
                    if (status != AJ_OK) 
    11ae:	2800      	cmp	r0, #0
    11b0:	d000      	beq.n	11b4 <AJSVC_PropertyStore_ReadAll+0x1bc>
    11b2:	e097      	b.n	12e4 <AJSVC_PropertyStore_ReadAll+0x2ec>
					{
		//				printf("PropertyStore_ReadAll 16 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    11b4:	9802      	ldr	r0, [sp, #8]
    11b6:	a90e      	add	r1, sp, #56	; 0x38
    11b8:	4b60      	ldr	r3, [pc, #384]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    11ba:	4798      	blx	r3
                    if (status != AJ_OK) 
    11bc:	2800      	cmp	r0, #0
    11be:	d100      	bne.n	11c2 <AJSVC_PropertyStore_ReadAll+0x1ca>
    11c0:	e738      	b.n	1034 <AJSVC_PropertyStore_ReadAll+0x3c>
					{
		//				printf("PropertyStore_ReadAll 16 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    11c2:	1c03      	adds	r3, r0, #0
    11c4:	e0c6      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    }
       //             printf("Has key [%s] runtime Value [%s]\n", propertyStoreProperties[AJSVC_PROPERTY_STORE_AJ_SOFTWARE_VERSION].keyName, ajVersion);
                } 
				else 
				{
                    if (value == NULL) 
    11c6:	464b      	mov	r3, r9
    11c8:	2b00      	cmp	r3, #0
    11ca:	d100      	bne.n	11ce <AJSVC_PropertyStore_ReadAll+0x1d6>
    11cc:	e08c      	b.n	12e8 <AJSVC_PropertyStore_ReadAll+0x2f0>
					{
       //                 printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    11ce:	9e02      	ldr	r6, [sp, #8]
    11d0:	1c30      	adds	r0, r6, #0
    11d2:	a90e      	add	r1, sp, #56	; 0x38
    11d4:	227b      	movs	r2, #123	; 0x7b
    11d6:	4b4f      	ldr	r3, [pc, #316]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    11d8:	4798      	blx	r3
                    if (status != AJ_OK) 
    11da:	2800      	cmp	r0, #0
    11dc:	d000      	beq.n	11e0 <AJSVC_PropertyStore_ReadAll+0x1e8>
    11de:	e085      	b.n	12ec <AJSVC_PropertyStore_ReadAll+0x2f4>
					{
		//				printf("PropertyStore_ReadAll 18 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    11e0:	1c30      	adds	r0, r6, #0
    11e2:	494f      	ldr	r1, [pc, #316]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    11e4:	683a      	ldr	r2, [r7, #0]
    11e6:	4b4f      	ldr	r3, [pc, #316]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    11e8:	4798      	blx	r3
                    if (status != AJ_OK) 
    11ea:	2800      	cmp	r0, #0
    11ec:	d000      	beq.n	11f0 <AJSVC_PropertyStore_ReadAll+0x1f8>
    11ee:	e07f      	b.n	12f0 <AJSVC_PropertyStore_ReadAll+0x2f8>
		//				printf("PropertyStore_ReadAll propertyStoreProperties[%d].keyName = %s\n",fieldIndex,propertyStoreProperties[fieldIndex].keyName);
		//				printf("PropertyStore_ReadAll 19 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "s");
    11f0:	1c30      	adds	r0, r6, #0
    11f2:	494b      	ldr	r1, [pc, #300]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    11f4:	4b4d      	ldr	r3, [pc, #308]	; (132c <AJSVC_PropertyStore_ReadAll+0x334>)
    11f6:	4798      	blx	r3
                    if (status != AJ_OK) 
    11f8:	2800      	cmp	r0, #0
    11fa:	d000      	beq.n	11fe <AJSVC_PropertyStore_ReadAll+0x206>
    11fc:	e07a      	b.n	12f4 <AJSVC_PropertyStore_ReadAll+0x2fc>
					{
		//				printf("PropertyStore_ReadAll 20 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", value);
    11fe:	1c30      	adds	r0, r6, #0
    1200:	4947      	ldr	r1, [pc, #284]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    1202:	464a      	mov	r2, r9
    1204:	4b47      	ldr	r3, [pc, #284]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    1206:	4798      	blx	r3
                    if (status != AJ_OK) 
    1208:	2800      	cmp	r0, #0
    120a:	d175      	bne.n	12f8 <AJSVC_PropertyStore_ReadAll+0x300>
					{
		//				printf("PropertyStore_ReadAll 21 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    120c:	1c30      	adds	r0, r6, #0
    120e:	a90e      	add	r1, sp, #56	; 0x38
    1210:	4b4a      	ldr	r3, [pc, #296]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    1212:	4798      	blx	r3
                    if (status != AJ_OK) 
    1214:	2800      	cmp	r0, #0
    1216:	d171      	bne.n	12fc <AJSVC_PropertyStore_ReadAll+0x304>
	{
//		printf("PropertyStore_ReadAll 1 status= %s\n",AJ_StatusText(status));
        return status;
    }
  //   printf("AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS= %d\n",AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS);
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_KEYS; fieldIndex++) 
    1218:	b26b      	sxtb	r3, r5
    121a:	2b0f      	cmp	r3, #15
    121c:	dc00      	bgt.n	1220 <AJSVC_PropertyStore_ReadAll+0x228>
    121e:	e709      	b.n	1034 <AJSVC_PropertyStore_ReadAll+0x3c>
                }
            }
        }
    }

    if (filter.bit0About) 
    1220:	9b04      	ldr	r3, [sp, #16]
    1222:	07db      	lsls	r3, r3, #31
    1224:	d53e      	bpl.n	12a4 <AJSVC_PropertyStore_ReadAll+0x2ac>
	{
        // Add supported languages
        status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    1226:	9802      	ldr	r0, [sp, #8]
    1228:	a90e      	add	r1, sp, #56	; 0x38
    122a:	227b      	movs	r2, #123	; 0x7b
    122c:	4b39      	ldr	r3, [pc, #228]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    122e:	4798      	blx	r3
        if (status != AJ_OK) 
		{
	//		printf("PropertyStore_ReadAll 23 status= %s\n",AJ_StatusText(status));
            return status;
    1230:	1e03      	subs	r3, r0, #0

    if (filter.bit0About) 
	{
        // Add supported languages
        status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
        if (status != AJ_OK) 
    1232:	d000      	beq.n	1236 <AJSVC_PropertyStore_ReadAll+0x23e>
    1234:	e08e      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		{
	//		printf("PropertyStore_ReadAll 23 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalArgs(msg, "s", defaultLanguagesKeyName);
    1236:	9802      	ldr	r0, [sp, #8]
    1238:	4939      	ldr	r1, [pc, #228]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    123a:	4a43      	ldr	r2, [pc, #268]	; (1348 <AJSVC_PropertyStore_ReadAll+0x350>)
    123c:	4b39      	ldr	r3, [pc, #228]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    123e:	4798      	blx	r3
        if (status != AJ_OK) 
		{
	//		printf("PropertyStore_ReadAll 24 status= %s\n",AJ_StatusText(status));
            return status;
    1240:	1e03      	subs	r3, r0, #0
		{
	//		printf("PropertyStore_ReadAll 23 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalArgs(msg, "s", defaultLanguagesKeyName);
        if (status != AJ_OK) 
    1242:	d000      	beq.n	1246 <AJSVC_PropertyStore_ReadAll+0x24e>
    1244:	e086      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		{
	//		printf("PropertyStore_ReadAll 24 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalVariant(msg, "as");
    1246:	9802      	ldr	r0, [sp, #8]
    1248:	4940      	ldr	r1, [pc, #256]	; (134c <AJSVC_PropertyStore_ReadAll+0x354>)
    124a:	4b38      	ldr	r3, [pc, #224]	; (132c <AJSVC_PropertyStore_ReadAll+0x334>)
    124c:	4798      	blx	r3
        if (status != AJ_OK) 
		{
	//		printf("PropertyStore_ReadAll 25 status= %s\n",AJ_StatusText(status));
            return status;
    124e:	1e03      	subs	r3, r0, #0
		{
	//		printf("PropertyStore_ReadAll 24 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalVariant(msg, "as");
        if (status != AJ_OK) 
    1250:	d000      	beq.n	1254 <AJSVC_PropertyStore_ReadAll+0x25c>
    1252:	e07f      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		{
	//		printf("PropertyStore_ReadAll 25 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalContainer(msg, &array2, AJ_ARG_ARRAY);
    1254:	9c02      	ldr	r4, [sp, #8]
    1256:	1c20      	adds	r0, r4, #0
    1258:	a912      	add	r1, sp, #72	; 0x48
    125a:	2261      	movs	r2, #97	; 0x61
    125c:	4b2d      	ldr	r3, [pc, #180]	; (1314 <AJSVC_PropertyStore_ReadAll+0x31c>)
    125e:	4798      	blx	r3
        if (status != AJ_OK) 
		{
	//		printf("PropertyStore_ReadAll 26 status= %s\n",AJ_StatusText(status));
            return status;
    1260:	1e03      	subs	r3, r0, #0
		{
	//		printf("PropertyStore_ReadAll 25 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalContainer(msg, &array2, AJ_ARG_ARRAY);
        if (status != AJ_OK) 
    1262:	d177      	bne.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
        }

        index = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; index < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; index++) 
		{
            status = AJ_MarshalArgs(msg, "s", propertyStoreDefaultLanguages[index]);
    1264:	4b3a      	ldr	r3, [pc, #232]	; (1350 <AJSVC_PropertyStore_ReadAll+0x358>)
    1266:	681b      	ldr	r3, [r3, #0]
    1268:	681a      	ldr	r2, [r3, #0]
    126a:	1c20      	adds	r0, r4, #0
    126c:	492c      	ldr	r1, [pc, #176]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    126e:	4b2d      	ldr	r3, [pc, #180]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    1270:	4798      	blx	r3
            if (status != AJ_OK) 
    1272:	2800      	cmp	r0, #0
    1274:	d108      	bne.n	1288 <AJSVC_PropertyStore_ReadAll+0x290>
        }

        index = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; index < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; index++) 
		{
            status = AJ_MarshalArgs(msg, "s", propertyStoreDefaultLanguages[index]);
    1276:	4b36      	ldr	r3, [pc, #216]	; (1350 <AJSVC_PropertyStore_ReadAll+0x358>)
    1278:	681b      	ldr	r3, [r3, #0]
    127a:	685a      	ldr	r2, [r3, #4]
    127c:	1c20      	adds	r0, r4, #0
    127e:	4928      	ldr	r1, [pc, #160]	; (1320 <AJSVC_PropertyStore_ReadAll+0x328>)
    1280:	4b28      	ldr	r3, [pc, #160]	; (1324 <AJSVC_PropertyStore_ReadAll+0x32c>)
    1282:	4798      	blx	r3
            if (status != AJ_OK) 
    1284:	2800      	cmp	r0, #0
    1286:	d001      	beq.n	128c <AJSVC_PropertyStore_ReadAll+0x294>
        }

        index = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
        for (; index < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; index++) 
		{
            status = AJ_MarshalArgs(msg, "s", propertyStoreDefaultLanguages[index]);
    1288:	1c03      	adds	r3, r0, #0
    128a:	e063      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
	//			printf("PropertyStore_ReadAll 27 status= %s\n",AJ_StatusText(status));
                return status;
            }
        }

        status = AJ_MarshalCloseContainer(msg, &array2);
    128c:	9802      	ldr	r0, [sp, #8]
    128e:	a912      	add	r1, sp, #72	; 0x48
    1290:	4b2a      	ldr	r3, [pc, #168]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    1292:	4798      	blx	r3
        if (status != AJ_OK)
		{
	//		printf("PropertyStore_ReadAll 28 status= %s\n",AJ_StatusText(status));
            return status;
    1294:	1e03      	subs	r3, r0, #0
                return status;
            }
        }

        status = AJ_MarshalCloseContainer(msg, &array2);
        if (status != AJ_OK)
    1296:	d15d      	bne.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		{
	//		printf("PropertyStore_ReadAll 28 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalCloseContainer(msg, &dict);
    1298:	9802      	ldr	r0, [sp, #8]
    129a:	a90e      	add	r1, sp, #56	; 0x38
    129c:	4b27      	ldr	r3, [pc, #156]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    129e:	4798      	blx	r3
        if (status != AJ_OK)
		{
	//		printf("PropertyStore_ReadAll 29 status= %s\n",AJ_StatusText(status));
            return status;
    12a0:	1e03      	subs	r3, r0, #0
		{
	//		printf("PropertyStore_ReadAll 28 status= %s\n",AJ_StatusText(status));
            return status;
        }
        status = AJ_MarshalCloseContainer(msg, &dict);
        if (status != AJ_OK)
    12a2:	d157      	bne.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		{
	//		printf("PropertyStore_ReadAll 29 status= %s\n",AJ_StatusText(status));
            return status;
        }
    }
    status = AJ_MarshalCloseContainer(msg, &array);
    12a4:	9802      	ldr	r0, [sp, #8]
    12a6:	a916      	add	r1, sp, #88	; 0x58
    12a8:	4b24      	ldr	r3, [pc, #144]	; (133c <AJSVC_PropertyStore_ReadAll+0x344>)
    12aa:	4798      	blx	r3
    if (status != AJ_OK) 
	{
	//	printf("PropertyStore_ReadAll 30 status= %s\n",AJ_StatusText(status));
        return status;
    12ac:	1c03      	adds	r3, r0, #0
    12ae:	e051      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
    //                    printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    12b0:	1c03      	adds	r3, r0, #0
    12b2:	e04f      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
	//					printf("PropertyStore_ReadAll 2 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    12b4:	1c03      	adds	r3, r0, #0
    12b6:	e04d      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
		//				printf("PropertyStore_ReadAll 3 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "ay");
    12b8:	1c03      	adds	r3, r0, #0
    12ba:	e04b      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 4 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_HexToRaw(value, 0, rawValue, sizeof(rawValue));
    12bc:	1c03      	adds	r3, r0, #0
    12be:	e049      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK)
					{
		//				printf("PropertyStore_ReadAll 5 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArg(msg, AJ_InitArg(&arg, AJ_ARG_BYTE, AJ_ARRAY_FLAG, rawValue, sizeof(rawValue)));
    12c0:	1c03      	adds	r3, r0, #0
    12c2:	e047      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                        return status;
                    }
                } 
				else if (fieldIndex == AJSVC_PROPERTY_STORE_MAX_LENGTH) 
				{
                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    12c4:	1c03      	adds	r3, r0, #0
    12c6:	e045      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 8 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    12c8:	1c03      	adds	r3, r0, #0
    12ca:	e043      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
		//				printf("PropertyStore_ReadAll 9 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "q");
    12cc:	1c03      	adds	r3, r0, #0
    12ce:	e041      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 10 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "q", DEVICE_NAME_VALUE_LENGTH);
    12d0:	1c03      	adds	r3, r0, #0
    12d2:	e03f      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
				{
                    ajVersion = AJ_GetVersion();
                    if (ajVersion == NULL) 
					{
         //               printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
    12d4:	2301      	movs	r3, #1
    12d6:	e03d      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    12d8:	1c03      	adds	r3, r0, #0
    12da:	e03b      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
			//			printf("PropertyStore_ReadAll 13 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    12dc:	1c03      	adds	r3, r0, #0
    12de:	e039      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
			//			printf("PropertyStore_ReadAll 14 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "s");
    12e0:	1c03      	adds	r3, r0, #0
    12e2:	e037      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 15 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", ajVersion);
    12e4:	1c03      	adds	r3, r0, #0
    12e6:	e035      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
				else 
				{
                    if (value == NULL) 
					{
       //                 printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
    12e8:	2301      	movs	r3, #1
    12ea:	e033      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    }

                    status = AJ_MarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    12ec:	1c03      	adds	r3, r0, #0
    12ee:	e031      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 18 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", propertyStoreProperties[fieldIndex].keyName);
    12f0:	1c03      	adds	r3, r0, #0
    12f2:	e02f      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
		//				printf("PropertyStore_ReadAll propertyStoreProperties[%d].keyName = %s\n",fieldIndex,propertyStoreProperties[fieldIndex].keyName);
		//				printf("PropertyStore_ReadAll 19 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalVariant(msg, "s");
    12f4:	1c03      	adds	r3, r0, #0
    12f6:	e02d      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                    if (status != AJ_OK) 
					{
		//				printf("PropertyStore_ReadAll 20 status= %s\n",AJ_StatusText(status));
                        return status;
                    }
                    status = AJ_MarshalArgs(msg, "s", value);
    12f8:	1c03      	adds	r3, r0, #0
    12fa:	e02b      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
					{
		//				printf("PropertyStore_ReadAll 21 status= %s\n",AJ_StatusText(status));
                        return status;
                    }

                    status = AJ_MarshalCloseContainer(msg, &dict);
    12fc:	1c03      	adds	r3, r0, #0
    12fe:	e029      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
                if (fieldIndex == AJSVC_PROPERTY_STORE_APP_ID) 
				{
                    if (value == NULL) 
					{
    //                    printf("PropertyStore_ReadAll - Failed to get value for mandatory field=(name=%s, index=%d) and language=(name=%s, index=%d), aborting.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
                        return AJ_ERR_NULL;
    1300:	2301      	movs	r3, #1
    1302:	e027      	b.n	1354 <AJSVC_PropertyStore_ReadAll+0x35c>
			{     // Non existing values are skipped!
  //              printf("PropertyStore_ReadAll - Failed to get value for field=(name=%s, index=%d) and language=(name=%s, index=%d), skipping.\n", AJSVC_PropertyStore_GetFieldName(fieldIndex), (int)fieldIndex, AJSVC_PropertyStore_GetLanguageName(langIndex), (int)langIndex);
            } 
			else 
			{
                if (fieldIndex == AJSVC_PROPERTY_STORE_APP_ID) 
    1304:	2e01      	cmp	r6, #1
    1306:	d000      	beq.n	130a <AJSVC_PropertyStore_ReadAll+0x312>
    1308:	e703      	b.n	1112 <AJSVC_PropertyStore_ReadAll+0x11a>
    130a:	e6c8      	b.n	109e <AJSVC_PropertyStore_ReadAll+0xa6>
    130c:	2e01      	cmp	r6, #1
    130e:	d000      	beq.n	1312 <AJSVC_PropertyStore_ReadAll+0x31a>
    1310:	e6ff      	b.n	1112 <AJSVC_PropertyStore_ReadAll+0x11a>
    1312:	e7f5      	b.n	1300 <AJSVC_PropertyStore_ReadAll+0x308>
    1314:	0000b8a1 	.word	0x0000b8a1
    1318:	00019e24 	.word	0x00019e24
    131c:	00000dc1 	.word	0x00000dc1
    1320:	0001f054 	.word	0x0001f054
    1324:	0000bc85 	.word	0x0000bc85
    1328:	0001ecdc 	.word	0x0001ecdc
    132c:	0000b9fd 	.word	0x0000b9fd
    1330:	0000d8c1 	.word	0x0000d8c1
    1334:	0000b6b5 	.word	0x0000b6b5
    1338:	0000b615 	.word	0x0000b615
    133c:	0000b8d1 	.word	0x0000b8d1
    1340:	0001eda8 	.word	0x0001eda8
    1344:	0000d831 	.word	0x0000d831
    1348:	00019cfc 	.word	0x00019cfc
    134c:	00019d10 	.word	0x00019d10
    1350:	200000c0 	.word	0x200000c0
	//	printf("PropertyStore_ReadAll 30 status= %s\n",AJ_StatusText(status));
        return status;
    }

    return status;
}
    1354:	1c18      	adds	r0, r3, #0
    1356:	b01b      	add	sp, #108	; 0x6c
    1358:	bc3c      	pop	{r2, r3, r4, r5}
    135a:	4690      	mov	r8, r2
    135c:	4699      	mov	r9, r3
    135e:	46a2      	mov	sl, r4
    1360:	46ab      	mov	fp, r5
    1362:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001364 <AboutPropGetter>:

/*
 * This function is registered with About and handles property store read requests
 */
static AJ_Status AboutPropGetter(AJ_Message* msg, const char* language)
{
    1364:	b510      	push	{r4, lr}
    1366:	b082      	sub	sp, #8
    1368:	1c04      	adds	r4, r0, #0
    AJ_Status status = AJ_ERR_INVALID;
    int8_t langIndex;
    AJSVC_PropertyStoreCategoryFilter filter;
  //  printf("-------------AboutPropGetter--------------\n");
    memset(&filter, 0, sizeof(AJSVC_PropertyStoreCategoryFilter));
    136a:	2200      	movs	r2, #0
    136c:	ab01      	add	r3, sp, #4
    136e:	701a      	strb	r2, [r3, #0]

    if (msg->msgId == AJ_SIGNAL_ABOUT_ANNOUNCE) 
    1370:	6803      	ldr	r3, [r0, #0]
    1372:	4a12      	ldr	r2, [pc, #72]	; (13bc <AboutPropGetter+0x58>)
    1374:	4293      	cmp	r3, r2
    1376:	d108      	bne.n	138a <AboutPropGetter+0x26>
	{
        filter.bit2Announce = TRUE;
    1378:	aa01      	add	r2, sp, #4
    137a:	7810      	ldrb	r0, [r2, #0]
    137c:	2304      	movs	r3, #4
    137e:	4303      	orrs	r3, r0
    1380:	7013      	strb	r3, [r2, #0]
        langIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
    1382:	1c08      	adds	r0, r1, #0
    1384:	4b0e      	ldr	r3, [pc, #56]	; (13c0 <AboutPropGetter+0x5c>)
    1386:	4798      	blx	r3
    1388:	e00d      	b.n	13a6 <AboutPropGetter+0x42>
/*
 * This function is registered with About and handles property store read requests
 */
static AJ_Status AboutPropGetter(AJ_Message* msg, const char* language)
{
    AJ_Status status = AJ_ERR_INVALID;
    138a:	2003      	movs	r0, #3
	{
        filter.bit2Announce = TRUE;
        langIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
        status = AJ_OK;
    } 
	else if (msg->msgId == AJ_REPLY_ID(AJ_METHOD_ABOUT_GET_ABOUT_DATA)) 
    138c:	4a0d      	ldr	r2, [pc, #52]	; (13c4 <AboutPropGetter+0x60>)
    138e:	4293      	cmp	r3, r2
    1390:	d111      	bne.n	13b6 <AboutPropGetter+0x52>
	{
        filter.bit0About = TRUE;
    1392:	aa01      	add	r2, sp, #4
    1394:	7810      	ldrb	r0, [r2, #0]
    1396:	2301      	movs	r3, #1
    1398:	4303      	orrs	r3, r0
    139a:	7013      	strb	r3, [r2, #0]
        langIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
    139c:	1c08      	adds	r0, r1, #0
    139e:	4b08      	ldr	r3, [pc, #32]	; (13c0 <AboutPropGetter+0x5c>)
    13a0:	4798      	blx	r3
        status = (langIndex == AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX) ? AJ_ERR_UNKNOWN : AJ_OK;
    13a2:	1c43      	adds	r3, r0, #1
    13a4:	d006      	beq.n	13b4 <AboutPropGetter+0x50>
	//	printf("AboutPropGetter 1 status= %s\n",AJ_StatusText(status));
    }
    if (status == AJ_OK)
	{
        status = AJSVC_PropertyStore_ReadAll(msg, filter, langIndex);
    13a6:	ab01      	add	r3, sp, #4
    13a8:	7819      	ldrb	r1, [r3, #0]
    13aa:	b242      	sxtb	r2, r0
    13ac:	1c20      	adds	r0, r4, #0
    13ae:	4b06      	ldr	r3, [pc, #24]	; (13c8 <AboutPropGetter+0x64>)
    13b0:	4798      	blx	r3
    13b2:	e000      	b.n	13b6 <AboutPropGetter+0x52>
    } 
	else if (msg->msgId == AJ_REPLY_ID(AJ_METHOD_ABOUT_GET_ABOUT_DATA)) 
	{
        filter.bit0About = TRUE;
        langIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
        status = (langIndex == AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX) ? AJ_ERR_UNKNOWN : AJ_OK;
    13b4:	200f      	movs	r0, #15
        status = AJSVC_PropertyStore_ReadAll(msg, filter, langIndex);
	//	printf("AboutPropGetter 2 status= %s\n",AJ_StatusText(status));
    }
	
    return status;
}
    13b6:	b002      	add	sp, #8
    13b8:	bd10      	pop	{r4, pc}
    13ba:	46c0      	nop			; (mov r8, r8)
    13bc:	00050103 	.word	0x00050103
    13c0:	00000e49 	.word	0x00000e49
    13c4:	80050101 	.word	0x80050101
    13c8:	00000ff9 	.word	0x00000ff9

000013cc <AJSVC_PropertyStore_Update>:

    return status;
}

AJ_Status AJSVC_PropertyStore_Update(const char* key, int8_t langIndex, const char* value)
{
    13cc:	b538      	push	{r3, r4, r5, lr}
    13ce:	1c0d      	adds	r5, r1, #0
    13d0:	1c14      	adds	r4, r2, #0
    int8_t fieldIndex = AJSVC_PropertyStore_GetFieldIndex(key);
    13d2:	4b08      	ldr	r3, [pc, #32]	; (13f4 <AJSVC_PropertyStore_Update+0x28>)
    13d4:	4798      	blx	r3
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS) 
    13d6:	b2c2      	uxtb	r2, r0
	{
        return AJ_ERR_INVALID;
    13d8:	2303      	movs	r3, #3
}

AJ_Status AJSVC_PropertyStore_Update(const char* key, int8_t langIndex, const char* value)
{
    int8_t fieldIndex = AJSVC_PropertyStore_GetFieldIndex(key);
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS) 
    13da:	2a05      	cmp	r2, #5
    13dc:	d808      	bhi.n	13f0 <AJSVC_PropertyStore_Update+0x24>
	{
        return AJ_ERR_INVALID;
    }
    if (!UpdateFieldInRAM(fieldIndex, langIndex, value)) 
    13de:	1c29      	adds	r1, r5, #0
    13e0:	1c22      	adds	r2, r4, #0
    13e2:	4b05      	ldr	r3, [pc, #20]	; (13f8 <AJSVC_PropertyStore_Update+0x2c>)
    13e4:	4798      	blx	r3
	{
        return AJ_ERR_FAILURE;
    13e6:	2313      	movs	r3, #19
    }
    return AJ_OK;
    13e8:	4242      	negs	r2, r0
    13ea:	4150      	adcs	r0, r2
    13ec:	4240      	negs	r0, r0
    13ee:	4003      	ands	r3, r0
}
    13f0:	1c18      	adds	r0, r3, #0
    13f2:	bd38      	pop	{r3, r4, r5, pc}
    13f4:	00000d95 	.word	0x00000d95
    13f8:	00000ef5 	.word	0x00000ef5

000013fc <AJSVC_PropertyStore_Reset>:

AJ_Status AJSVC_PropertyStore_Reset(const char* key, int8_t langIndex)
{
    13fc:	b510      	push	{r4, lr}
    13fe:	1c0c      	adds	r4, r1, #0
    int8_t fieldIndex = AJSVC_PropertyStore_GetFieldIndex(key);
    1400:	4b08      	ldr	r3, [pc, #32]	; (1424 <AJSVC_PropertyStore_Reset+0x28>)
    1402:	4798      	blx	r3
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS)
    1404:	b2c2      	uxtb	r2, r0
	{
        return AJ_ERR_INVALID;
    1406:	2303      	movs	r3, #3
}

AJ_Status AJSVC_PropertyStore_Reset(const char* key, int8_t langIndex)
{
    int8_t fieldIndex = AJSVC_PropertyStore_GetFieldIndex(key);
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS)
    1408:	2a05      	cmp	r2, #5
    140a:	d809      	bhi.n	1420 <AJSVC_PropertyStore_Reset+0x24>
    return ret;
}

static uint8_t DeleteFieldFromRAM(AJSVC_PropertyStoreFieldIndices fieldIndex, int8_t langIndex)
{
    return UpdateFieldInRAM(fieldIndex, langIndex, "");
    140c:	1c21      	adds	r1, r4, #0
    140e:	4a06      	ldr	r2, [pc, #24]	; (1428 <AJSVC_PropertyStore_Reset+0x2c>)
    1410:	4b06      	ldr	r3, [pc, #24]	; (142c <AJSVC_PropertyStore_Reset+0x30>)
    1412:	4798      	blx	r3
	{
        return AJ_ERR_INVALID;
    }
    if (!DeleteFieldFromRAM(fieldIndex, langIndex)) 
	{
        return AJ_ERR_FAILURE;
    1414:	2313      	movs	r3, #19
    int8_t fieldIndex = AJSVC_PropertyStore_GetFieldIndex(key);
    if (fieldIndex <= AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX || fieldIndex >= AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS)
	{
        return AJ_ERR_INVALID;
    }
    if (!DeleteFieldFromRAM(fieldIndex, langIndex)) 
    1416:	2800      	cmp	r0, #0
    1418:	d002      	beq.n	1420 <AJSVC_PropertyStore_Reset+0x24>
	{
        return AJ_ERR_FAILURE;
    }
    InitMandatoryPropertiesInRAM();
    141a:	4b05      	ldr	r3, [pc, #20]	; (1430 <AJSVC_PropertyStore_Reset+0x34>)
    141c:	4798      	blx	r3
    return AJ_OK;
    141e:	2300      	movs	r3, #0
}
    1420:	1c18      	adds	r0, r3, #0
    1422:	bd10      	pop	{r4, pc}
    1424:	00000d95 	.word	0x00000d95
    1428:	0001d368 	.word	0x0001d368
    142c:	00000ef5 	.word	0x00000ef5
    1430:	00000f69 	.word	0x00000f69

00001434 <AJSVC_PropertyStore_ResetAll>:

AJ_Status AJSVC_PropertyStore_ResetAll()
{
    1434:	b5f0      	push	{r4, r5, r6, r7, lr}
    1436:	4647      	mov	r7, r8
    1438:	b480      	push	{r7}
    143a:	4d14      	ldr	r5, [pc, #80]	; (148c <AJSVC_PropertyStore_ResetAll+0x58>)
    143c:	2600      	movs	r6, #0
        if (propertyStoreRuntimeValues[fieldIndex].value) 
		{
            langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
            for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++) 
			{
                if (propertyStoreProperties[fieldIndex].mode2MultiLng || langIndex == AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX) 
    143e:	4b14      	ldr	r3, [pc, #80]	; (1490 <AJSVC_PropertyStore_ResetAll+0x5c>)
    1440:	4698      	mov	r8, r3
    int8_t fieldIndex;
    int8_t langIndex;
    char* buf;
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS; fieldIndex++) 
	{
        if (propertyStoreRuntimeValues[fieldIndex].value) 
    1442:	1c34      	adds	r4, r6, #0
    1444:	1c2f      	adds	r7, r5, #0
    1446:	682b      	ldr	r3, [r5, #0]
    1448:	2b00      	cmp	r3, #0
    144a:	d013      	beq.n	1474 <AJSVC_PropertyStore_ResetAll+0x40>
            langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
            for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++) 
			{
                if (propertyStoreProperties[fieldIndex].mode2MultiLng || langIndex == AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX) 
				{
                    buf = propertyStoreRuntimeValues[fieldIndex].value[langIndex];
    144c:	6818      	ldr	r0, [r3, #0]
                    if (buf) 
    144e:	2800      	cmp	r0, #0
    1450:	d003      	beq.n	145a <AJSVC_PropertyStore_ResetAll+0x26>
					{
                        memset(buf, 0, propertyStoreRuntimeValues[fieldIndex].size);
    1452:	792a      	ldrb	r2, [r5, #4]
    1454:	2100      	movs	r1, #0
    1456:	4b0f      	ldr	r3, [pc, #60]	; (1494 <AJSVC_PropertyStore_ResetAll+0x60>)
    1458:	4798      	blx	r3
        if (propertyStoreRuntimeValues[fieldIndex].value) 
		{
            langIndex = AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX;
            for (; langIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_LANGUAGES; langIndex++) 
			{
                if (propertyStoreProperties[fieldIndex].mode2MultiLng || langIndex == AJSVC_PROPERTY_STORE_NO_LANGUAGE_INDEX) 
    145a:	00e4      	lsls	r4, r4, #3
    145c:	4444      	add	r4, r8
    145e:	7923      	ldrb	r3, [r4, #4]
    1460:	075b      	lsls	r3, r3, #29
    1462:	d507      	bpl.n	1474 <AJSVC_PropertyStore_ResetAll+0x40>
				{
                    buf = propertyStoreRuntimeValues[fieldIndex].value[langIndex];
    1464:	683b      	ldr	r3, [r7, #0]
    1466:	6858      	ldr	r0, [r3, #4]
                    if (buf) 
    1468:	2800      	cmp	r0, #0
    146a:	d003      	beq.n	1474 <AJSVC_PropertyStore_ResetAll+0x40>
					{
                        memset(buf, 0, propertyStoreRuntimeValues[fieldIndex].size);
    146c:	793a      	ldrb	r2, [r7, #4]
    146e:	2100      	movs	r1, #0
    1470:	4b08      	ldr	r3, [pc, #32]	; (1494 <AJSVC_PropertyStore_ResetAll+0x60>)
    1472:	4798      	blx	r3
    1474:	3601      	adds	r6, #1
    1476:	3508      	adds	r5, #8
static void ClearPropertiesInRAM()
{
    int8_t fieldIndex;
    int8_t langIndex;
    char* buf;
    for (fieldIndex = 0; fieldIndex < AJSVC_PROPERTY_STORE_NUMBER_OF_RUNTIME_KEYS; fieldIndex++) 
    1478:	2e06      	cmp	r6, #6
    147a:	d1e2      	bne.n	1442 <AJSVC_PropertyStore_ResetAll+0xe>
}

AJ_Status AJSVC_PropertyStore_ResetAll()
{
    ClearPropertiesInRAM();
    InitMandatoryPropertiesInRAM();
    147c:	4b06      	ldr	r3, [pc, #24]	; (1498 <AJSVC_PropertyStore_ResetAll+0x64>)
    147e:	4798      	blx	r3
    return AJSVC_PropertyStore_SaveAll();
    1480:	4b06      	ldr	r3, [pc, #24]	; (149c <AJSVC_PropertyStore_ResetAll+0x68>)
    1482:	4798      	blx	r3
}
    1484:	bc04      	pop	{r2}
    1486:	4690      	mov	r8, r2
    1488:	bdf0      	pop	{r4, r5, r6, r7, pc}
    148a:	46c0      	nop			; (mov r8, r8)
    148c:	20000028 	.word	0x20000028
    1490:	00019e24 	.word	0x00019e24
    1494:	00016773 	.word	0x00016773
    1498:	00000f69 	.word	0x00000f69
    149c:	00000fe9 	.word	0x00000fe9

000014a0 <AboutGetProp>:
    icon.URL = url;
}

//Handles a property GET request so marshals the property value to return
static AJ_Status AboutGetProp(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    14a0:	b508      	push	{r3, lr}
	{
        return AJ_MarshalArgs(replyMsg, "q", (uint16_t)ABOUT_VERSION);
    } 
	else
	{
        return AJ_ERR_UNEXPECTED;
    14a2:	2302      	movs	r3, #2
}

//Handles a property GET request so marshals the property value to return
static AJ_Status AboutGetProp(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    if (propId == AJ_PROPERTY_ABOUT_VERSION) 
    14a4:	4a04      	ldr	r2, [pc, #16]	; (14b8 <AboutGetProp+0x18>)
    14a6:	4291      	cmp	r1, r2
    14a8:	d104      	bne.n	14b4 <AboutGetProp+0x14>
	{
        return AJ_MarshalArgs(replyMsg, "q", (uint16_t)ABOUT_VERSION);
    14aa:	4904      	ldr	r1, [pc, #16]	; (14bc <AboutGetProp+0x1c>)
    14ac:	2201      	movs	r2, #1
    14ae:	4b04      	ldr	r3, [pc, #16]	; (14c0 <AboutGetProp+0x20>)
    14b0:	4798      	blx	r3
    14b2:	1c03      	adds	r3, r0, #0
    } 
	else
	{
        return AJ_ERR_UNEXPECTED;
    }
}
    14b4:	1c18      	adds	r0, r3, #0
    14b6:	bd08      	pop	{r3, pc}
    14b8:	00050100 	.word	0x00050100
    14bc:	0001eda8 	.word	0x0001eda8
    14c0:	0000bc85 	.word	0x0000bc85

000014c4 <AboutIconGetProp>:
        return status;
    }
}

static AJ_Status AboutIconGetProp(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    14c4:	b508      	push	{r3, lr}
    AJ_Status status = AJ_ERR_UNEXPECTED;

    if (propId == AJ_PROPERTY_ABOUT_ICON_VERSION_PROP) 
    14c6:	4b11      	ldr	r3, [pc, #68]	; (150c <AboutIconGetProp+0x48>)
    14c8:	4299      	cmp	r1, r3
    14ca:	d105      	bne.n	14d8 <AboutIconGetProp+0x14>
	{
        status = AJ_MarshalArgs(replyMsg, "q", (uint16_t)ABOUT_ICON_VERSION);
    14cc:	4910      	ldr	r1, [pc, #64]	; (1510 <AboutIconGetProp+0x4c>)
    14ce:	2201      	movs	r2, #1
    14d0:	4b10      	ldr	r3, [pc, #64]	; (1514 <AboutIconGetProp+0x50>)
    14d2:	4798      	blx	r3
    14d4:	1c03      	adds	r3, r0, #0
    14d6:	e016      	b.n	1506 <AboutIconGetProp+0x42>
    }
	else if (propId == AJ_PROPERTY_ABOUT_ICON_MIMETYPE_PROP) 
    14d8:	4b0f      	ldr	r3, [pc, #60]	; (1518 <AboutIconGetProp+0x54>)
    14da:	4299      	cmp	r1, r3
    14dc:	d109      	bne.n	14f2 <AboutIconGetProp+0x2e>
	{
        status = AJ_MarshalArgs(replyMsg, "s", icon.mime ? icon.mime : "");
    14de:	4b0f      	ldr	r3, [pc, #60]	; (151c <AboutIconGetProp+0x58>)
    14e0:	689a      	ldr	r2, [r3, #8]
    14e2:	2a00      	cmp	r2, #0
    14e4:	d100      	bne.n	14e8 <AboutIconGetProp+0x24>
    14e6:	4a0e      	ldr	r2, [pc, #56]	; (1520 <AboutIconGetProp+0x5c>)
    14e8:	490e      	ldr	r1, [pc, #56]	; (1524 <AboutIconGetProp+0x60>)
    14ea:	4b0a      	ldr	r3, [pc, #40]	; (1514 <AboutIconGetProp+0x50>)
    14ec:	4798      	blx	r3
    14ee:	1c03      	adds	r3, r0, #0
    14f0:	e009      	b.n	1506 <AboutIconGetProp+0x42>
    }
}

static AJ_Status AboutIconGetProp(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    AJ_Status status = AJ_ERR_UNEXPECTED;
    14f2:	2302      	movs	r3, #2
        status = AJ_MarshalArgs(replyMsg, "q", (uint16_t)ABOUT_ICON_VERSION);
    }
	else if (propId == AJ_PROPERTY_ABOUT_ICON_MIMETYPE_PROP) 
	{
        status = AJ_MarshalArgs(replyMsg, "s", icon.mime ? icon.mime : "");
    } else if (propId == AJ_PROPERTY_ABOUT_ICON_SIZE_PROP) 
    14f4:	4a0c      	ldr	r2, [pc, #48]	; (1528 <AboutIconGetProp+0x64>)
    14f6:	4291      	cmp	r1, r2
    14f8:	d105      	bne.n	1506 <AboutIconGetProp+0x42>
	{
        status = AJ_MarshalArgs(replyMsg, "u", (uint32_t)icon.size);
    14fa:	4b08      	ldr	r3, [pc, #32]	; (151c <AboutIconGetProp+0x58>)
    14fc:	881a      	ldrh	r2, [r3, #0]
    14fe:	490b      	ldr	r1, [pc, #44]	; (152c <AboutIconGetProp+0x68>)
    1500:	4b04      	ldr	r3, [pc, #16]	; (1514 <AboutIconGetProp+0x50>)
    1502:	4798      	blx	r3
    1504:	1c03      	adds	r3, r0, #0
    }
    return status;
}
    1506:	1c18      	adds	r0, r3, #0
    1508:	bd08      	pop	{r3, pc}
    150a:	46c0      	nop			; (mov r8, r8)
    150c:	00060100 	.word	0x00060100
    1510:	0001eda8 	.word	0x0001eda8
    1514:	0000bc85 	.word	0x0000bc85
    1518:	00060101 	.word	0x00060101
    151c:	2000058c 	.word	0x2000058c
    1520:	0001d368 	.word	0x0001d368
    1524:	0001f054 	.word	0x0001f054
    1528:	00060102 	.word	0x00060102
    152c:	0002192c 	.word	0x0002192c

00001530 <MarshalDefaultProps>:
	{ "SupportUrl",           0, 0, 1, 0, 0, 0, 0, 1 },
	// Add other optional about keys above this line
};*/
// Default about properties if there is no property store getter registered
static AJ_Status MarshalDefaultProps(AJ_Message* msg)
{
    1530:	b530      	push	{r4, r5, lr}
    1532:	b095      	sub	sp, #84	; 0x54
    1534:	1c04      	adds	r4, r0, #0
	AJ_Arg dict;
	AJ_Arg arg;
	uint8_t rawValue[16];
	uint8_t buffer[33];
	uint8_t bufLen=33;
    const char value[16] ={0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04,0x01,0x02,0x03,0x04};
    1536:	a803      	add	r0, sp, #12
    1538:	490c      	ldr	r1, [pc, #48]	; (156c <MarshalDefaultProps+0x3c>)
    153a:	2210      	movs	r2, #16
    153c:	4b0c      	ldr	r3, [pc, #48]	; (1570 <MarshalDefaultProps+0x40>)
    153e:	4798      	blx	r3
	const char value2[]="EcoDim";
	const char value3[]="en";
	const char value4[]="Light dimmer";
	AJ_RawToHex(&value, 16, buffer, bufLen, TRUE);	
    1540:	2301      	movs	r3, #1
    1542:	9300      	str	r3, [sp, #0]
    1544:	a803      	add	r0, sp, #12
    1546:	2110      	movs	r1, #16
    1548:	aa07      	add	r2, sp, #28
    154a:	3320      	adds	r3, #32
    154c:	4d09      	ldr	r5, [pc, #36]	; (1574 <MarshalDefaultProps+0x44>)
    154e:	47a8      	blx	r5
    status = AJ_MarshalContainer(msg, &array, AJ_ARG_ARRAY);
    1550:	1c20      	adds	r0, r4, #0
    1552:	a910      	add	r1, sp, #64	; 0x40
    1554:	2261      	movs	r2, #97	; 0x61
    1556:	4b08      	ldr	r3, [pc, #32]	; (1578 <MarshalDefaultProps+0x48>)
    1558:	4798      	blx	r3
    155a:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK)
    155c:	d103      	bne.n	1566 <MarshalDefaultProps+0x36>
    status = AJ_MarshalCloseContainer(msg, &dict);
    if (status != AJ_OK)
    {
	   return status;
    }
*/	status = AJ_MarshalCloseContainer(msg, &array);
    155e:	1c20      	adds	r0, r4, #0
    1560:	a910      	add	r1, sp, #64	; 0x40
    1562:	4b06      	ldr	r3, [pc, #24]	; (157c <MarshalDefaultProps+0x4c>)
    1564:	4798      	blx	r3
	if (status != AJ_OK)
	{
		    return status;
     }
    return status;
}
    1566:	b015      	add	sp, #84	; 0x54
    1568:	bd30      	pop	{r4, r5, pc}
    156a:	46c0      	nop			; (mov r8, r8)
    156c:	00019ee0 	.word	0x00019ee0
    1570:	00016739 	.word	0x00016739
    1574:	0000d86d 	.word	0x0000d86d
    1578:	0000b8a1 	.word	0x0000b8a1
    157c:	0000b8d1 	.word	0x0000b8d1

00001580 <MarshalObjectDescriptions>:
    }
    return status;
}

static AJ_Status MarshalObjectDescriptions(AJ_Message* msg)
{
    1580:	b5f0      	push	{r4, r5, r6, r7, lr}
    1582:	4647      	mov	r7, r8
    1584:	b480      	push	{r7}
    1586:	b090      	sub	sp, #64	; 0x40
    1588:	9001      	str	r0, [sp, #4]
    AJ_Status status;
    AJ_Arg objList;
    AJ_ObjectIterator iter;
    const AJ_Object* obj;

    status = AJ_MarshalContainer(msg, &objList, AJ_ARG_ARRAY);
    158a:	a90c      	add	r1, sp, #48	; 0x30
    158c:	2261      	movs	r2, #97	; 0x61
    158e:	4b36      	ldr	r3, [pc, #216]	; (1668 <MarshalObjectDescriptions+0xe8>)
    1590:	4798      	blx	r3
    1592:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    1594:	d164      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
	{
        goto ErrorExit;
    }
    // Announce objects that are flagged for announcement and not hidden
    for (obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAG_ANNOUNCED | AJ_OBJ_FLAG_DESCRIBED, AJ_OBJ_FLAG_HIDDEN); obj != NULL; obj = AJ_NextObject(&iter)) 
    1596:	a80a      	add	r0, sp, #40	; 0x28
    1598:	2128      	movs	r1, #40	; 0x28
    159a:	2202      	movs	r2, #2
    159c:	4b33      	ldr	r3, [pc, #204]	; (166c <MarshalObjectDescriptions+0xec>)
    159e:	4798      	blx	r3
    15a0:	1e07      	subs	r7, r0, #0
    15a2:	d059      	beq.n	1658 <MarshalObjectDescriptions+0xd8>
        size_t i;
        AJ_Arg structure;
        AJ_Arg ifcList;
        const char* iface;

        status = AJ_MarshalContainer(msg, &structure, AJ_ARG_STRUCT);
    15a4:	4b30      	ldr	r3, [pc, #192]	; (1668 <MarshalObjectDescriptions+0xe8>)
    15a6:	4698      	mov	r8, r3
    15a8:	9c01      	ldr	r4, [sp, #4]
    15aa:	1c20      	adds	r0, r4, #0
    15ac:	a902      	add	r1, sp, #8
    15ae:	2228      	movs	r2, #40	; 0x28
    15b0:	47c0      	blx	r8
        if (status != AJ_OK) 
    15b2:	2800      	cmp	r0, #0
    15b4:	d154      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
		{
            goto ErrorExit;
        }
   //     printf("Announcing object %s\n", obj->path);
        status = AJ_MarshalArgs(msg, "o", obj->path);
    15b6:	1c20      	adds	r0, r4, #0
    15b8:	492d      	ldr	r1, [pc, #180]	; (1670 <MarshalObjectDescriptions+0xf0>)
    15ba:	683a      	ldr	r2, [r7, #0]
    15bc:	4b2d      	ldr	r3, [pc, #180]	; (1674 <MarshalObjectDescriptions+0xf4>)
    15be:	4798      	blx	r3
        if (status != AJ_OK) 
    15c0:	2800      	cmp	r0, #0
    15c2:	d14d      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalContainer(msg, &ifcList, AJ_ARG_ARRAY);
    15c4:	1c20      	adds	r0, r4, #0
    15c6:	a906      	add	r1, sp, #24
    15c8:	2261      	movs	r2, #97	; 0x61
    15ca:	4b27      	ldr	r3, [pc, #156]	; (1668 <MarshalObjectDescriptions+0xe8>)
    15cc:	4798      	blx	r3
        if (status != AJ_OK) 
    15ce:	2800      	cmp	r0, #0
    15d0:	d146      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
		{
            goto ErrorExit;
        }
        // Add the AllSeenIntrospectableInterface if this object is flagged as being described
        if (obj->flags & AJ_OBJ_FLAG_DESCRIBED) 
    15d2:	7a3b      	ldrb	r3, [r7, #8]
    15d4:	069b      	lsls	r3, r3, #26
    15d6:	d405      	bmi.n	15e4 <MarshalObjectDescriptions+0x64>
            if (status != AJ_OK) 
			{
                goto ErrorExit;
            }
        }
        for (i = 0; obj->interfaces[i]; ++i) 
    15d8:	687b      	ldr	r3, [r7, #4]
    15da:	681b      	ldr	r3, [r3, #0]
    15dc:	2404      	movs	r4, #4
    15de:	2b00      	cmp	r3, #0
    15e0:	d10f      	bne.n	1602 <MarshalObjectDescriptions+0x82>
    15e2:	e027      	b.n	1634 <MarshalObjectDescriptions+0xb4>
        // Add the AllSeenIntrospectableInterface if this object is flagged as being described
        if (obj->flags & AJ_OBJ_FLAG_DESCRIBED) 
		{
            iface = AllSeenIntrospectableInterface;
            // Don't need the $ or # that indicate the interface is secure or not
            if (*iface == '$' || *iface == '#') 
    15e4:	4b24      	ldr	r3, [pc, #144]	; (1678 <MarshalObjectDescriptions+0xf8>)
    15e6:	781b      	ldrb	r3, [r3, #0]
    15e8:	3b23      	subs	r3, #35	; 0x23
    15ea:	2b01      	cmp	r3, #1
    15ec:	d801      	bhi.n	15f2 <MarshalObjectDescriptions+0x72>
			{
                ++iface;
    15ee:	4a23      	ldr	r2, [pc, #140]	; (167c <MarshalObjectDescriptions+0xfc>)
    15f0:	e000      	b.n	15f4 <MarshalObjectDescriptions+0x74>
            goto ErrorExit;
        }
        // Add the AllSeenIntrospectableInterface if this object is flagged as being described
        if (obj->flags & AJ_OBJ_FLAG_DESCRIBED) 
		{
            iface = AllSeenIntrospectableInterface;
    15f2:	4a21      	ldr	r2, [pc, #132]	; (1678 <MarshalObjectDescriptions+0xf8>)
            if (*iface == '$' || *iface == '#') 
			{
                ++iface;
            }
   //         printf("  %s\n", iface);
            status = AJ_MarshalArgs(msg, "s", iface);
    15f4:	9801      	ldr	r0, [sp, #4]
    15f6:	4922      	ldr	r1, [pc, #136]	; (1680 <MarshalObjectDescriptions+0x100>)
    15f8:	4b1e      	ldr	r3, [pc, #120]	; (1674 <MarshalObjectDescriptions+0xf4>)
    15fa:	4798      	blx	r3
            if (status != AJ_OK) 
    15fc:	2800      	cmp	r0, #0
    15fe:	d0eb      	beq.n	15d8 <MarshalObjectDescriptions+0x58>
    1600:	e02e      	b.n	1660 <MarshalObjectDescriptions+0xe0>
                goto ErrorExit;
            }
        }
        for (i = 0; obj->interfaces[i]; ++i) 
		{
            if (obj->interfaces[i] != AJ_PropertiesIface)
    1602:	4d20      	ldr	r5, [pc, #128]	; (1684 <MarshalObjectDescriptions+0x104>)
                    if (*iface == '$' || *iface == '#') 
					{
                        ++iface;
                    }
    //                printf("  %s\n", iface);
                    status = AJ_MarshalArgs(msg, "s", iface);
    1604:	4e1b      	ldr	r6, [pc, #108]	; (1674 <MarshalObjectDescriptions+0xf4>)
                goto ErrorExit;
            }
        }
        for (i = 0; obj->interfaces[i]; ++i) 
		{
            if (obj->interfaces[i] != AJ_PropertiesIface)
    1606:	42ab      	cmp	r3, r5
    1608:	d00f      	beq.n	162a <MarshalObjectDescriptions+0xaa>
			{
                iface = obj->interfaces[i][0];
    160a:	681a      	ldr	r2, [r3, #0]
                if (iface) 
    160c:	2a00      	cmp	r2, #0
    160e:	d00c      	beq.n	162a <MarshalObjectDescriptions+0xaa>
				{
                    // Don't need the $ or # that indicate the interface is secure or not
                    if (*iface == '$' || *iface == '#') 
    1610:	7813      	ldrb	r3, [r2, #0]
    1612:	3b23      	subs	r3, #35	; 0x23
    1614:	b2db      	uxtb	r3, r3
					{
                        ++iface;
    1616:	2100      	movs	r1, #0
    1618:	2001      	movs	r0, #1
    161a:	4298      	cmp	r0, r3
    161c:	4149      	adcs	r1, r1
    161e:	1852      	adds	r2, r2, r1
                    }
    //                printf("  %s\n", iface);
                    status = AJ_MarshalArgs(msg, "s", iface);
    1620:	9801      	ldr	r0, [sp, #4]
    1622:	4917      	ldr	r1, [pc, #92]	; (1680 <MarshalObjectDescriptions+0x100>)
    1624:	47b0      	blx	r6
                    if (status != AJ_OK)
    1626:	2800      	cmp	r0, #0
    1628:	d11a      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
            if (status != AJ_OK) 
			{
                goto ErrorExit;
            }
        }
        for (i = 0; obj->interfaces[i]; ++i) 
    162a:	687b      	ldr	r3, [r7, #4]
    162c:	591b      	ldr	r3, [r3, r4]
    162e:	3404      	adds	r4, #4
    1630:	2b00      	cmp	r3, #0
    1632:	d1e8      	bne.n	1606 <MarshalObjectDescriptions+0x86>
                        goto ErrorExit;
                    }
                }
            }
        }
        status = AJ_MarshalCloseContainer(msg, &ifcList);
    1634:	9c01      	ldr	r4, [sp, #4]
    1636:	1c20      	adds	r0, r4, #0
    1638:	a906      	add	r1, sp, #24
    163a:	4b13      	ldr	r3, [pc, #76]	; (1688 <MarshalObjectDescriptions+0x108>)
    163c:	4798      	blx	r3
        if (status != AJ_OK) 
    163e:	2800      	cmp	r0, #0
    1640:	d10e      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &structure);
    1642:	1c20      	adds	r0, r4, #0
    1644:	a902      	add	r1, sp, #8
    1646:	4b10      	ldr	r3, [pc, #64]	; (1688 <MarshalObjectDescriptions+0x108>)
    1648:	4798      	blx	r3
        if (status != AJ_OK) 
    164a:	2800      	cmp	r0, #0
    164c:	d108      	bne.n	1660 <MarshalObjectDescriptions+0xe0>
    if (status != AJ_OK) 
	{
        goto ErrorExit;
    }
    // Announce objects that are flagged for announcement and not hidden
    for (obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAG_ANNOUNCED | AJ_OBJ_FLAG_DESCRIBED, AJ_OBJ_FLAG_HIDDEN); obj != NULL; obj = AJ_NextObject(&iter)) 
    164e:	a80a      	add	r0, sp, #40	; 0x28
    1650:	4b0e      	ldr	r3, [pc, #56]	; (168c <MarshalObjectDescriptions+0x10c>)
    1652:	4798      	blx	r3
    1654:	1e07      	subs	r7, r0, #0
    1656:	d1a7      	bne.n	15a8 <MarshalObjectDescriptions+0x28>
        if (status != AJ_OK) 
		{
            goto ErrorExit;
        }
    }
    return AJ_MarshalCloseContainer(msg, &objList);
    1658:	9801      	ldr	r0, [sp, #4]
    165a:	a90c      	add	r1, sp, #48	; 0x30
    165c:	4b0a      	ldr	r3, [pc, #40]	; (1688 <MarshalObjectDescriptions+0x108>)
    165e:	4798      	blx	r3

ErrorExit:
    return status;
}
    1660:	b010      	add	sp, #64	; 0x40
    1662:	bc04      	pop	{r2}
    1664:	4690      	mov	r8, r2
    1666:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1668:	0000b8a1 	.word	0x0000b8a1
    166c:	00008b19 	.word	0x00008b19
    1670:	00019ef0 	.word	0x00019ef0
    1674:	0000bc85 	.word	0x0000bc85
    1678:	0001e990 	.word	0x0001e990
    167c:	0001e991 	.word	0x0001e991
    1680:	0001f054 	.word	0x0001f054
    1684:	0001e8d4 	.word	0x0001e8d4
    1688:	0000b8d1 	.word	0x0000b8d1
    168c:	00008aad 	.word	0x00008aad

00001690 <AJ_AboutRegisterPropStoreGetter>:
void AJ_AboutRegisterPropStoreGetter(AJ_AboutPropGetter propGetter)
{
/*	printf("!!!!!AJ_AboutRegisterPropStoreGetter!!!!\n");
	printf("PropStoreGetter = %d\n",PropStoreGetter);
	printf("propGetter= %d\n",propGetter);*/
    PropStoreGetter = propGetter;
    1690:	4b01      	ldr	r3, [pc, #4]	; (1698 <AJ_AboutRegisterPropStoreGetter+0x8>)
    1692:	6018      	str	r0, [r3, #0]
}
    1694:	4770      	bx	lr
    1696:	46c0      	nop			; (mov r8, r8)
    1698:	2000059c 	.word	0x2000059c

0000169c <AJ_AboutSetIcon>:
    doAnnounce = TRUE;
    return AJ_AboutAnnounce(bus);
}

void AJ_AboutSetIcon(const uint8_t* data, uint16_t size, const char* mime, const char* url)
{
    169c:	b510      	push	{r4, lr}
    icon.data = data;
    169e:	4c05      	ldr	r4, [pc, #20]	; (16b4 <AJ_AboutSetIcon+0x18>)
    16a0:	6060      	str	r0, [r4, #4]
    icon.size = data ? size : 0;
    16a2:	2800      	cmp	r0, #0
    16a4:	d100      	bne.n	16a8 <AJ_AboutSetIcon+0xc>
    16a6:	2100      	movs	r1, #0
    16a8:	4802      	ldr	r0, [pc, #8]	; (16b4 <AJ_AboutSetIcon+0x18>)
    16aa:	8001      	strh	r1, [r0, #0]
    icon.mime = mime;
    16ac:	6082      	str	r2, [r0, #8]
    icon.URL = url;
    16ae:	60c3      	str	r3, [r0, #12]
}
    16b0:	bd10      	pop	{r4, pc}
    16b2:	46c0      	nop			; (mov r8, r8)
    16b4:	2000058c 	.word	0x2000058c

000016b8 <AJ_AboutHandleGetProp>:
        return AJ_ERR_UNEXPECTED;
    }
}

AJ_Status AJ_AboutHandleGetProp(AJ_Message* msg)
{
    16b8:	b508      	push	{r3, lr}
    return AJ_BusPropGet(msg, AboutGetProp, NULL);
    16ba:	4902      	ldr	r1, [pc, #8]	; (16c4 <AJ_AboutHandleGetProp+0xc>)
    16bc:	2200      	movs	r2, #0
    16be:	4b02      	ldr	r3, [pc, #8]	; (16c8 <AJ_AboutHandleGetProp+0x10>)
    16c0:	4798      	blx	r3
}
    16c2:	bd08      	pop	{r3, pc}
    16c4:	000014a1 	.word	0x000014a1
    16c8:	000030d1 	.word	0x000030d1

000016cc <AJ_AboutHandleGetAboutData>:

AJ_Status AJ_AboutHandleGetAboutData(AJ_Message* msg, AJ_Message* reply)
{
    16cc:	b530      	push	{r4, r5, lr}
    16ce:	b083      	sub	sp, #12
    16d0:	1c04      	adds	r4, r0, #0
    16d2:	1c0d      	adds	r5, r1, #0
    AJ_Status status = AJ_OK;
    const char* language;

    status = AJ_UnmarshalArgs(msg, "s", &language);
    16d4:	490e      	ldr	r1, [pc, #56]	; (1710 <AJ_AboutHandleGetAboutData+0x44>)
    16d6:	aa01      	add	r2, sp, #4
    16d8:	4b0e      	ldr	r3, [pc, #56]	; (1714 <AJ_AboutHandleGetAboutData+0x48>)
    16da:	4798      	blx	r3
    if (status == AJ_OK)
    16dc:	2800      	cmp	r0, #0
    16de:	d115      	bne.n	170c <AJ_AboutHandleGetAboutData+0x40>
	{
        AJ_MarshalReplyMsg(msg, reply);
    16e0:	1c20      	adds	r0, r4, #0
    16e2:	1c29      	adds	r1, r5, #0
    16e4:	4b0c      	ldr	r3, [pc, #48]	; (1718 <AJ_AboutHandleGetAboutData+0x4c>)
    16e6:	4798      	blx	r3
        if (PropStoreGetter)
    16e8:	4b0c      	ldr	r3, [pc, #48]	; (171c <AJ_AboutHandleGetAboutData+0x50>)
    16ea:	681b      	ldr	r3, [r3, #0]
    16ec:	2b00      	cmp	r3, #0
    16ee:	d003      	beq.n	16f8 <AJ_AboutHandleGetAboutData+0x2c>
		{
            status = PropStoreGetter(reply, language);
    16f0:	1c28      	adds	r0, r5, #0
    16f2:	9901      	ldr	r1, [sp, #4]
    16f4:	4798      	blx	r3
    16f6:	e002      	b.n	16fe <AJ_AboutHandleGetAboutData+0x32>
        } 
		else
		{
            status = MarshalDefaultProps(reply);
    16f8:	1c28      	adds	r0, r5, #0
    16fa:	4b09      	ldr	r3, [pc, #36]	; (1720 <AJ_AboutHandleGetAboutData+0x54>)
    16fc:	4798      	blx	r3
        }
        if (status != AJ_OK)
    16fe:	2800      	cmp	r0, #0
    1700:	d004      	beq.n	170c <AJ_AboutHandleGetAboutData+0x40>
		{
            status = AJ_MarshalErrorMsg(msg, reply, AJ_ErrLanguageNotSuppored);
    1702:	1c20      	adds	r0, r4, #0
    1704:	1c29      	adds	r1, r5, #0
    1706:	4a07      	ldr	r2, [pc, #28]	; (1724 <AJ_AboutHandleGetAboutData+0x58>)
    1708:	4b07      	ldr	r3, [pc, #28]	; (1728 <AJ_AboutHandleGetAboutData+0x5c>)
    170a:	4798      	blx	r3
        }
    }
    return status;
}
    170c:	b003      	add	sp, #12
    170e:	bd30      	pop	{r4, r5, pc}
    1710:	0001f054 	.word	0x0001f054
    1714:	0000b5f5 	.word	0x0000b5f5
    1718:	0000bd45 	.word	0x0000bd45
    171c:	2000059c 	.word	0x2000059c
    1720:	00001531 	.word	0x00001531
    1724:	0001eadc 	.word	0x0001eadc
    1728:	0000be55 	.word	0x0000be55

0000172c <AJ_AboutAnnounce>:
ErrorExit:
    return status;
}

AJ_Status AJ_AboutAnnounce(AJ_BusAttachment* bus)
{
    172c:	b530      	push	{r4, r5, lr}
    172e:	b095      	sub	sp, #84	; 0x54
    AJ_Status status = AJ_OK;
    AJ_Message announcement;

    if (!doAnnounce) 
    1730:	4b42      	ldr	r3, [pc, #264]	; (183c <AJ_AboutAnnounce+0x110>)
    1732:	781a      	ldrb	r2, [r3, #0]
	{
        return status;
    1734:	2300      	movs	r3, #0
AJ_Status AJ_AboutAnnounce(AJ_BusAttachment* bus)
{
    AJ_Status status = AJ_OK;
    AJ_Message announcement;

    if (!doAnnounce) 
    1736:	2a00      	cmp	r2, #0
    1738:	d100      	bne.n	173c <AJ_AboutAnnounce+0x10>
    173a:	e07b      	b.n	1834 <AJ_AboutAnnounce+0x108>
    173c:	1c05      	adds	r5, r0, #0
	{
        return status;
    }
    doAnnounce = FALSE;
    173e:	2200      	movs	r2, #0
    1740:	4b3e      	ldr	r3, [pc, #248]	; (183c <AJ_AboutAnnounce+0x110>)
    1742:	701a      	strb	r2, [r3, #0]
    if (!bus->aboutPort)
    1744:	8801      	ldrh	r1, [r0, #0]
    1746:	2900      	cmp	r1, #0
    1748:	d104      	bne.n	1754 <AJ_AboutAnnounce+0x28>
	{
        printf("AJ_AboutAnnounce - nothing to announce\n");
    174a:	483d      	ldr	r0, [pc, #244]	; (1840 <AJ_AboutAnnounce+0x114>)
    174c:	4b3d      	ldr	r3, [pc, #244]	; (1844 <AJ_AboutAnnounce+0x118>)
    174e:	4798      	blx	r3
        return status;
    1750:	2300      	movs	r3, #0
    1752:	e06f      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }

    printf("AJ_AboutAnnounce - announcing port=%d\n", bus->aboutPort);
    1754:	483c      	ldr	r0, [pc, #240]	; (1848 <AJ_AboutAnnounce+0x11c>)
    1756:	4b3d      	ldr	r3, [pc, #244]	; (184c <AJ_AboutAnnounce+0x120>)
    1758:	4798      	blx	r3

    status = AJ_MarshalSignal(bus, &announcement, AJ_SIGNAL_ABOUT_ANNOUNCE, NULL, 0, AJ_FLAG_SESSIONLESS, 0);
    175a:	2300      	movs	r3, #0
    175c:	9300      	str	r3, [sp, #0]
    175e:	2210      	movs	r2, #16
    1760:	9201      	str	r2, [sp, #4]
    1762:	9302      	str	r3, [sp, #8]
    1764:	1c28      	adds	r0, r5, #0
    1766:	a904      	add	r1, sp, #16
    1768:	4a39      	ldr	r2, [pc, #228]	; (1850 <AJ_AboutAnnounce+0x124>)
    176a:	4c3a      	ldr	r4, [pc, #232]	; (1854 <AJ_AboutAnnounce+0x128>)
    176c:	47a0      	blx	r4
    176e:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    1770:	d007      	beq.n	1782 <AJ_AboutAnnounce+0x56>
	{
		printf("AJ_AboutAnnounce error 1 status= %s\n",AJ_StatusText(status));
    1772:	4b39      	ldr	r3, [pc, #228]	; (1858 <AJ_AboutAnnounce+0x12c>)
    1774:	4798      	blx	r3
    1776:	1c01      	adds	r1, r0, #0
    1778:	4838      	ldr	r0, [pc, #224]	; (185c <AJ_AboutAnnounce+0x130>)
    177a:	4b34      	ldr	r3, [pc, #208]	; (184c <AJ_AboutAnnounce+0x120>)
    177c:	4798      	blx	r3
        return status;
    }

    printf("AJ_AboutAnnounce - announcing port=%d\n", bus->aboutPort);

    status = AJ_MarshalSignal(bus, &announcement, AJ_SIGNAL_ABOUT_ANNOUNCE, NULL, 0, AJ_FLAG_SESSIONLESS, 0);
    177e:	1c23      	adds	r3, r4, #0
    if (status != AJ_OK) 
	{
		printf("AJ_AboutAnnounce error 1 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    1780:	e058      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }
    status = AJ_MarshalArgs(&announcement, "q", (uint16_t)ABOUT_VERSION);
    1782:	a804      	add	r0, sp, #16
    1784:	4936      	ldr	r1, [pc, #216]	; (1860 <AJ_AboutAnnounce+0x134>)
    1786:	2201      	movs	r2, #1
    1788:	4b36      	ldr	r3, [pc, #216]	; (1864 <AJ_AboutAnnounce+0x138>)
    178a:	4798      	blx	r3
    178c:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK)
    178e:	d007      	beq.n	17a0 <AJ_AboutAnnounce+0x74>
	{
		printf("AJ_AboutAnnounce error 2 status= %s\n",AJ_StatusText(status));
    1790:	4b31      	ldr	r3, [pc, #196]	; (1858 <AJ_AboutAnnounce+0x12c>)
    1792:	4798      	blx	r3
    1794:	1c01      	adds	r1, r0, #0
    1796:	4834      	ldr	r0, [pc, #208]	; (1868 <AJ_AboutAnnounce+0x13c>)
    1798:	4b2c      	ldr	r3, [pc, #176]	; (184c <AJ_AboutAnnounce+0x120>)
    179a:	4798      	blx	r3
    if (status != AJ_OK) 
	{
		printf("AJ_AboutAnnounce error 1 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    }
    status = AJ_MarshalArgs(&announcement, "q", (uint16_t)ABOUT_VERSION);
    179c:	1c23      	adds	r3, r4, #0
    if (status != AJ_OK)
	{
		printf("AJ_AboutAnnounce error 2 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    179e:	e049      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }
    status = AJ_MarshalArgs(&announcement, "q", bus->aboutPort);
    17a0:	882a      	ldrh	r2, [r5, #0]
    17a2:	a804      	add	r0, sp, #16
    17a4:	492e      	ldr	r1, [pc, #184]	; (1860 <AJ_AboutAnnounce+0x134>)
    17a6:	4b2f      	ldr	r3, [pc, #188]	; (1864 <AJ_AboutAnnounce+0x138>)
    17a8:	4798      	blx	r3
    17aa:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    17ac:	d007      	beq.n	17be <AJ_AboutAnnounce+0x92>
	{
		printf("AJ_AboutAnnounce error 3 status= %s\n",AJ_StatusText(status));
    17ae:	4b2a      	ldr	r3, [pc, #168]	; (1858 <AJ_AboutAnnounce+0x12c>)
    17b0:	4798      	blx	r3
    17b2:	1c01      	adds	r1, r0, #0
    17b4:	482d      	ldr	r0, [pc, #180]	; (186c <AJ_AboutAnnounce+0x140>)
    17b6:	4b25      	ldr	r3, [pc, #148]	; (184c <AJ_AboutAnnounce+0x120>)
    17b8:	4798      	blx	r3
    if (status != AJ_OK)
	{
		printf("AJ_AboutAnnounce error 2 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    }
    status = AJ_MarshalArgs(&announcement, "q", bus->aboutPort);
    17ba:	1c23      	adds	r3, r4, #0
    if (status != AJ_OK) 
	{
		printf("AJ_AboutAnnounce error 3 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    17bc:	e03a      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }
	printf("Announce object ... \n");
    17be:	482c      	ldr	r0, [pc, #176]	; (1870 <AJ_AboutAnnounce+0x144>)
    17c0:	4b20      	ldr	r3, [pc, #128]	; (1844 <AJ_AboutAnnounce+0x118>)
    17c2:	4798      	blx	r3
    status = MarshalObjectDescriptions(&announcement);
    17c4:	a804      	add	r0, sp, #16
    17c6:	4b2b      	ldr	r3, [pc, #172]	; (1874 <AJ_AboutAnnounce+0x148>)
    17c8:	4798      	blx	r3
    17ca:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK)
    17cc:	d007      	beq.n	17de <AJ_AboutAnnounce+0xb2>
	{
		printf("AJ_AboutAnnounce error 4 status= %s\n",AJ_StatusText(status));
    17ce:	4b22      	ldr	r3, [pc, #136]	; (1858 <AJ_AboutAnnounce+0x12c>)
    17d0:	4798      	blx	r3
    17d2:	1c01      	adds	r1, r0, #0
    17d4:	4828      	ldr	r0, [pc, #160]	; (1878 <AJ_AboutAnnounce+0x14c>)
    17d6:	4b1d      	ldr	r3, [pc, #116]	; (184c <AJ_AboutAnnounce+0x120>)
    17d8:	4798      	blx	r3
	{
		printf("AJ_AboutAnnounce error 3 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    }
	printf("Announce object ... \n");
    status = MarshalObjectDescriptions(&announcement);
    17da:	1c23      	adds	r3, r4, #0
    if (status != AJ_OK)
	{
		printf("AJ_AboutAnnounce error 4 status= %s\n",AJ_StatusText(status));
        goto ErrorExit;
    17dc:	e02a      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }
    if (PropStoreGetter)
    17de:	4b27      	ldr	r3, [pc, #156]	; (187c <AJ_AboutAnnounce+0x150>)
    17e0:	681b      	ldr	r3, [r3, #0]
    17e2:	2b00      	cmp	r3, #0
    17e4:	d00a      	beq.n	17fc <AJ_AboutAnnounce+0xd0>
	{
        status = PropStoreGetter(&announcement, "");
    17e6:	a804      	add	r0, sp, #16
    17e8:	4925      	ldr	r1, [pc, #148]	; (1880 <AJ_AboutAnnounce+0x154>)
    17ea:	4798      	blx	r3
    17ec:	1c04      	adds	r4, r0, #0
		printf("AJ_AboutAnnounce 5 status= %s\n",AJ_StatusText(status));
    17ee:	4b1a      	ldr	r3, [pc, #104]	; (1858 <AJ_AboutAnnounce+0x12c>)
    17f0:	4798      	blx	r3
    17f2:	1c01      	adds	r1, r0, #0
    17f4:	4823      	ldr	r0, [pc, #140]	; (1884 <AJ_AboutAnnounce+0x158>)
    17f6:	4b15      	ldr	r3, [pc, #84]	; (184c <AJ_AboutAnnounce+0x120>)
    17f8:	4798      	blx	r3
    17fa:	e009      	b.n	1810 <AJ_AboutAnnounce+0xe4>
    }
	else
	{
        status = MarshalDefaultProps(&announcement);
    17fc:	a804      	add	r0, sp, #16
    17fe:	4b22      	ldr	r3, [pc, #136]	; (1888 <AJ_AboutAnnounce+0x15c>)
    1800:	4798      	blx	r3
    1802:	1c04      	adds	r4, r0, #0
		printf("AJ_AboutAnnounce 6 status= %s\n",AJ_StatusText(status));
    1804:	4b14      	ldr	r3, [pc, #80]	; (1858 <AJ_AboutAnnounce+0x12c>)
    1806:	4798      	blx	r3
    1808:	1c01      	adds	r1, r0, #0
    180a:	4820      	ldr	r0, [pc, #128]	; (188c <AJ_AboutAnnounce+0x160>)
    180c:	4b0f      	ldr	r3, [pc, #60]	; (184c <AJ_AboutAnnounce+0x120>)
    180e:	4798      	blx	r3
    }
    if (status != AJ_OK) 
    1810:	2c00      	cmp	r4, #0
    1812:	d008      	beq.n	1826 <AJ_AboutAnnounce+0xfa>
	{
		printf("AJ_AboutAnnounce error 7 status= %s\n",AJ_StatusText(status));
    1814:	1c20      	adds	r0, r4, #0
    1816:	4b10      	ldr	r3, [pc, #64]	; (1858 <AJ_AboutAnnounce+0x12c>)
    1818:	4798      	blx	r3
    181a:	1c01      	adds	r1, r0, #0
    181c:	481c      	ldr	r0, [pc, #112]	; (1890 <AJ_AboutAnnounce+0x164>)
    181e:	4b0b      	ldr	r3, [pc, #44]	; (184c <AJ_AboutAnnounce+0x120>)
    1820:	4798      	blx	r3
        goto ErrorExit;
    1822:	1c23      	adds	r3, r4, #0
    1824:	e006      	b.n	1834 <AJ_AboutAnnounce+0x108>
    }
    bus->aboutSerial = announcement.hdr->serialNum;
    1826:	9b05      	ldr	r3, [sp, #20]
    1828:	689b      	ldr	r3, [r3, #8]
    182a:	65ab      	str	r3, [r5, #88]	; 0x58
    return AJ_DeliverMsg(&announcement);
    182c:	a804      	add	r0, sp, #16
    182e:	4b19      	ldr	r3, [pc, #100]	; (1894 <AJ_AboutAnnounce+0x168>)
    1830:	4798      	blx	r3
    1832:	1c03      	adds	r3, r0, #0

ErrorExit:
    return status;
}
    1834:	1c18      	adds	r0, r3, #0
    1836:	b015      	add	sp, #84	; 0x54
    1838:	bd30      	pop	{r4, r5, pc}
    183a:	46c0      	nop			; (mov r8, r8)
    183c:	20000120 	.word	0x20000120
    1840:	00019ef4 	.word	0x00019ef4
    1844:	00016f5d 	.word	0x00016f5d
    1848:	00019f1c 	.word	0x00019f1c
    184c:	00016e3d 	.word	0x00016e3d
    1850:	00050103 	.word	0x00050103
    1854:	0000bcfd 	.word	0x0000bcfd
    1858:	000063c5 	.word	0x000063c5
    185c:	00019f44 	.word	0x00019f44
    1860:	0001eda8 	.word	0x0001eda8
    1864:	0000bc85 	.word	0x0000bc85
    1868:	00019f6c 	.word	0x00019f6c
    186c:	00019f94 	.word	0x00019f94
    1870:	00019fbc 	.word	0x00019fbc
    1874:	00001581 	.word	0x00001581
    1878:	00019fd4 	.word	0x00019fd4
    187c:	2000059c 	.word	0x2000059c
    1880:	0001d368 	.word	0x0001d368
    1884:	00019ffc 	.word	0x00019ffc
    1888:	00001531 	.word	0x00001531
    188c:	0001a01c 	.word	0x0001a01c
    1890:	0001a03c 	.word	0x0001a03c
    1894:	0000a539 	.word	0x0000a539

00001898 <AJ_AboutInit>:
     }
    return status;
}

AJ_Status AJ_AboutInit(AJ_BusAttachment* bus, uint16_t boundPort)
{
    1898:	b508      	push	{r3, lr}
    bus->aboutPort = boundPort;
    189a:	8001      	strh	r1, [r0, #0]
    doAnnounce = TRUE;
    189c:	2201      	movs	r2, #1
    189e:	4b02      	ldr	r3, [pc, #8]	; (18a8 <AJ_AboutInit+0x10>)
    18a0:	701a      	strb	r2, [r3, #0]
    return AJ_AboutAnnounce(bus);
    18a2:	4b02      	ldr	r3, [pc, #8]	; (18ac <AJ_AboutInit+0x14>)
    18a4:	4798      	blx	r3
}
    18a6:	bd08      	pop	{r3, pc}
    18a8:	20000120 	.word	0x20000120
    18ac:	0000172d 	.word	0x0000172d

000018b0 <AJ_AboutHandleGetObjectDescription>:
        return AJ_ERR_DISALLOWED;
    }
}

AJ_Status AJ_AboutHandleGetObjectDescription(AJ_Message* msg, AJ_Message* reply)
{
    18b0:	b510      	push	{r4, lr}
    18b2:	1c0c      	adds	r4, r1, #0
    AJ_Status status = AJ_MarshalReplyMsg(msg, reply);
    18b4:	4b03      	ldr	r3, [pc, #12]	; (18c4 <AJ_AboutHandleGetObjectDescription+0x14>)
    18b6:	4798      	blx	r3
    18b8:	1e03      	subs	r3, r0, #0
    if (status == AJ_OK)
    18ba:	d102      	bne.n	18c2 <AJ_AboutHandleGetObjectDescription+0x12>
    {
        return MarshalObjectDescriptions(reply);
    18bc:	1c20      	adds	r0, r4, #0
    18be:	4b02      	ldr	r3, [pc, #8]	; (18c8 <AJ_AboutHandleGetObjectDescription+0x18>)
    18c0:	4798      	blx	r3
    } 
	else
	{
        return status;
    }
}
    18c2:	bd10      	pop	{r4, pc}
    18c4:	0000bd45 	.word	0x0000bd45
    18c8:	00001581 	.word	0x00001581

000018cc <AJ_AboutIconHandleGetProp>:
    }
    return status;
}

AJ_Status AJ_AboutIconHandleGetProp(AJ_Message* msg)
{
    18cc:	b508      	push	{r3, lr}
    return AJ_BusPropGet(msg, AboutIconGetProp, NULL);
    18ce:	4902      	ldr	r1, [pc, #8]	; (18d8 <AJ_AboutIconHandleGetProp+0xc>)
    18d0:	2200      	movs	r2, #0
    18d2:	4b02      	ldr	r3, [pc, #8]	; (18dc <AJ_AboutIconHandleGetProp+0x10>)
    18d4:	4798      	blx	r3
}
    18d6:	bd08      	pop	{r3, pc}
    18d8:	000014c5 	.word	0x000014c5
    18dc:	000030d1 	.word	0x000030d1

000018e0 <AJ_AboutIconHandleGetURL>:

AJ_Status AJ_AboutIconHandleGetURL(AJ_Message* msg, AJ_Message* reply)
{
    18e0:	b510      	push	{r4, lr}
    18e2:	1c0c      	adds	r4, r1, #0
    AJ_Status status;

    status = AJ_MarshalReplyMsg(msg, reply);
    18e4:	4b06      	ldr	r3, [pc, #24]	; (1900 <AJ_AboutIconHandleGetURL+0x20>)
    18e6:	4798      	blx	r3
    18e8:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    18ea:	d108      	bne.n	18fe <AJ_AboutIconHandleGetURL+0x1e>
	{
        goto ErrorExit;
    }
    return AJ_MarshalArgs(reply, "s", icon.URL ? icon.URL : "");
    18ec:	4b05      	ldr	r3, [pc, #20]	; (1904 <AJ_AboutIconHandleGetURL+0x24>)
    18ee:	68da      	ldr	r2, [r3, #12]
    18f0:	2a00      	cmp	r2, #0
    18f2:	d100      	bne.n	18f6 <AJ_AboutIconHandleGetURL+0x16>
    18f4:	4a04      	ldr	r2, [pc, #16]	; (1908 <AJ_AboutIconHandleGetURL+0x28>)
    18f6:	1c20      	adds	r0, r4, #0
    18f8:	4904      	ldr	r1, [pc, #16]	; (190c <AJ_AboutIconHandleGetURL+0x2c>)
    18fa:	4b05      	ldr	r3, [pc, #20]	; (1910 <AJ_AboutIconHandleGetURL+0x30>)
    18fc:	4798      	blx	r3

ErrorExit:
    return status;
}
    18fe:	bd10      	pop	{r4, pc}
    1900:	0000bd45 	.word	0x0000bd45
    1904:	2000058c 	.word	0x2000058c
    1908:	0001d368 	.word	0x0001d368
    190c:	0001f054 	.word	0x0001f054
    1910:	0000bc85 	.word	0x0000bc85

00001914 <AJ_AboutIconHandleGetContent>:

AJ_Status AJ_AboutIconHandleGetContent(AJ_Message* msg, AJ_Message* reply)
{
    1914:	b510      	push	{r4, lr}
    1916:	b082      	sub	sp, #8
    1918:	1c0c      	adds	r4, r1, #0
    AJ_Status status;
    uint32_t u = (uint32_t)icon.size;
    191a:	4b0e      	ldr	r3, [pc, #56]	; (1954 <AJ_AboutIconHandleGetContent+0x40>)
    191c:	881b      	ldrh	r3, [r3, #0]
    191e:	9301      	str	r3, [sp, #4]

    status = AJ_MarshalReplyMsg(msg, reply);
    1920:	4b0d      	ldr	r3, [pc, #52]	; (1958 <AJ_AboutIconHandleGetContent+0x44>)
    1922:	4798      	blx	r3
    1924:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    1926:	d113      	bne.n	1950 <AJ_AboutIconHandleGetContent+0x3c>
	{
        goto ErrorExit;
    }
    status = AJ_DeliverMsgPartial(reply, u + 4);
    1928:	9b01      	ldr	r3, [sp, #4]
    192a:	1d19      	adds	r1, r3, #4
    192c:	1c20      	adds	r0, r4, #0
    192e:	4b0b      	ldr	r3, [pc, #44]	; (195c <AJ_AboutIconHandleGetContent+0x48>)
    1930:	4798      	blx	r3
    1932:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK)
    1934:	d10c      	bne.n	1950 <AJ_AboutIconHandleGetContent+0x3c>
	{
        goto ErrorExit;
    }
    status = AJ_MarshalRaw(reply, &u, 4);
    1936:	1c20      	adds	r0, r4, #0
    1938:	a901      	add	r1, sp, #4
    193a:	2204      	movs	r2, #4
    193c:	4b08      	ldr	r3, [pc, #32]	; (1960 <AJ_AboutIconHandleGetContent+0x4c>)
    193e:	4798      	blx	r3
    1940:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    1942:	d105      	bne.n	1950 <AJ_AboutIconHandleGetContent+0x3c>
	{
        goto ErrorExit;
    }
    return AJ_MarshalRaw(reply, icon.data, u);
    1944:	4b03      	ldr	r3, [pc, #12]	; (1954 <AJ_AboutIconHandleGetContent+0x40>)
    1946:	6859      	ldr	r1, [r3, #4]
    1948:	1c20      	adds	r0, r4, #0
    194a:	9a01      	ldr	r2, [sp, #4]
    194c:	4b04      	ldr	r3, [pc, #16]	; (1960 <AJ_AboutIconHandleGetContent+0x4c>)
    194e:	4798      	blx	r3

ErrorExit:
    return status;
}
    1950:	b002      	add	sp, #8
    1952:	bd10      	pop	{r4, pc}
    1954:	2000058c 	.word	0x2000058c
    1958:	0000bd45 	.word	0x0000bd45
    195c:	0000b701 	.word	0x0000b701
    1960:	0000b82d 	.word	0x0000b82d

00001964 <AJ_AboutSetShouldAnnounce>:

void AJ_AboutSetShouldAnnounce()
{
    doAnnounce = TRUE;
    1964:	2201      	movs	r2, #1
    1966:	4b01      	ldr	r3, [pc, #4]	; (196c <AJ_AboutSetShouldAnnounce+0x8>)
    1968:	701a      	strb	r2, [r3, #0]
}
    196a:	4770      	bx	lr
    196c:	20000120 	.word	0x20000120

00001970 <AJ_AboutSetAnnounceObjects>:

void AJ_AboutSetAnnounceObjects(AJ_Object* objList)
{
    if (objList) 
    1970:	2800      	cmp	r0, #0
    1972:	d00a      	beq.n	198a <AJ_AboutSetAnnounceObjects+0x1a>
	{
        while (objList->path) 
    1974:	6803      	ldr	r3, [r0, #0]
    1976:	2b00      	cmp	r3, #0
    1978:	d007      	beq.n	198a <AJ_AboutSetAnnounceObjects+0x1a>
		{
            objList->flags |= AJ_OBJ_FLAG_ANNOUNCED;
    197a:	2208      	movs	r2, #8
    197c:	7a03      	ldrb	r3, [r0, #8]
    197e:	4313      	orrs	r3, r2
    1980:	7203      	strb	r3, [r0, #8]
            ++objList;
    1982:	3010      	adds	r0, #16

void AJ_AboutSetAnnounceObjects(AJ_Object* objList)
{
    if (objList) 
	{
        while (objList->path) 
    1984:	6803      	ldr	r3, [r0, #0]
    1986:	2b00      	cmp	r3, #0
    1988:	d1f8      	bne.n	197c <AJ_AboutSetAnnounceObjects+0xc>
		{
            objList->flags |= AJ_OBJ_FLAG_ANNOUNCED;
            ++objList;
        }
    }
}
    198a:	4770      	bx	lr

0000198c <PSKCallback>:

    return status;
}

static AJ_Status PSKCallback(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    198c:	b570      	push	{r4, r5, r6, lr}
    198e:	b0a2      	sub	sp, #136	; 0x88
    1990:	1c04      	adds	r4, r0, #0
    AJ_Status status;

    AJ_InfoPrintf(("PSKCallback(ctx=%p, msg=%p)\n", ctx, msg));

    if (ctx->bus->authListenerCallback) {
    1992:	6803      	ldr	r3, [r0, #0]
    1994:	6d1d      	ldr	r5, [r3, #80]	; 0x50
    1996:	2d00      	cmp	r5, #0
    1998:	d043      	beq.n	1a22 <PSKCallback+0x96>
static AJ_Status PSKCallbackV2(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status;
    AJ_Credential cred;

    switch (ctx->role) {
    199a:	7903      	ldrb	r3, [r0, #4]
    199c:	2b00      	cmp	r3, #0
    199e:	d002      	beq.n	19a6 <PSKCallback+0x1a>
    19a0:	2b01      	cmp	r3, #1
    19a2:	d011      	beq.n	19c8 <PSKCallback+0x3c>
    19a4:	e01d      	b.n	19e2 <PSKCallback+0x56>
    case AUTH_CLIENT:
        cred.direction = AJ_CRED_REQUEST;
    19a6:	2300      	movs	r3, #0
    19a8:	aa02      	add	r2, sp, #8
    19aa:	7013      	strb	r3, [r2, #0]
        status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_PSK, AJ_CRED_PUB_KEY, &cred);
    19ac:	482d      	ldr	r0, [pc, #180]	; (1a64 <PSKCallback+0xd8>)
    19ae:	2102      	movs	r1, #2
    19b0:	47a8      	blx	r5
        if (AJ_OK == status) {
    19b2:	2800      	cmp	r0, #0
    19b4:	d115      	bne.n	19e2 <PSKCallback+0x56>
            ctx->kactx.psk.hint = cred.data;
    19b6:	9b04      	ldr	r3, [sp, #16]
    19b8:	9301      	str	r3, [sp, #4]
    19ba:	23e8      	movs	r3, #232	; 0xe8
    19bc:	9a01      	ldr	r2, [sp, #4]
    19be:	50e2      	str	r2, [r4, r3]
            ctx->kactx.psk.size = cred.len;
    19c0:	9a05      	ldr	r2, [sp, #20]
    19c2:	3304      	adds	r3, #4
    19c4:	50e2      	str	r2, [r4, r3]
    19c6:	e00c      	b.n	19e2 <PSKCallback+0x56>
        }
        break;

    case AUTH_SERVER:
        cred.direction = AJ_CRED_RESPONSE;
    19c8:	2301      	movs	r3, #1
    19ca:	aa02      	add	r2, sp, #8
    19cc:	7013      	strb	r3, [r2, #0]
        cred.data = ctx->kactx.psk.hint;
    19ce:	33e7      	adds	r3, #231	; 0xe7
    19d0:	58c3      	ldr	r3, [r0, r3]
    19d2:	9304      	str	r3, [sp, #16]
        cred.len = ctx->kactx.psk.size;
    19d4:	23ec      	movs	r3, #236	; 0xec
    19d6:	58c3      	ldr	r3, [r0, r3]
    19d8:	9301      	str	r3, [sp, #4]
    19da:	9305      	str	r3, [sp, #20]
        status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_PSK, AJ_CRED_PUB_KEY, &cred);
    19dc:	4821      	ldr	r0, [pc, #132]	; (1a64 <PSKCallback+0xd8>)
    19de:	2102      	movs	r1, #2
    19e0:	47a8      	blx	r5
        break;
    }
    cred.direction = AJ_CRED_REQUEST;
    19e2:	2300      	movs	r3, #0
    19e4:	aa02      	add	r2, sp, #8
    19e6:	7013      	strb	r3, [r2, #0]
    status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_PSK, AJ_CRED_PRV_KEY, &cred);
    19e8:	6823      	ldr	r3, [r4, #0]
    19ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    19ec:	481d      	ldr	r0, [pc, #116]	; (1a64 <PSKCallback+0xd8>)
    19ee:	2101      	movs	r1, #1
    19f0:	4798      	blx	r3
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    19f2:	230d      	movs	r3, #13
        status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_PSK, AJ_CRED_PUB_KEY, &cred);
        break;
    }
    cred.direction = AJ_CRED_REQUEST;
    status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_PSK, AJ_CRED_PRV_KEY, &cred);
    if (AJ_OK != status) {
    19f4:	2800      	cmp	r0, #0
    19f6:	d132      	bne.n	1a5e <PSKCallback+0xd2>
        return AJ_ERR_SECURITY;
    }
    ctx->expiration = cred.expiration;
    19f8:	9b03      	ldr	r3, [sp, #12]
    19fa:	9301      	str	r3, [sp, #4]
    19fc:	2390      	movs	r3, #144	; 0x90
    19fe:	005b      	lsls	r3, r3, #1
    1a00:	9a01      	ldr	r2, [sp, #4]
    1a02:	50e2      	str	r2, [r4, r3]
    // Hash in psk hint, then psk
    AJ_SHA256_Update(&ctx->hash, ctx->kactx.psk.hint, ctx->kactx.psk.size);
    1a04:	1c25      	adds	r5, r4, #0
    1a06:	3510      	adds	r5, #16
    1a08:	3b38      	subs	r3, #56	; 0x38
    1a0a:	58e1      	ldr	r1, [r4, r3]
    1a0c:	3304      	adds	r3, #4
    1a0e:	58e2      	ldr	r2, [r4, r3]
    1a10:	1c28      	adds	r0, r5, #0
    1a12:	4c15      	ldr	r4, [pc, #84]	; (1a68 <PSKCallback+0xdc>)
    1a14:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, cred.data, cred.len);
    1a16:	9904      	ldr	r1, [sp, #16]
    1a18:	9a05      	ldr	r2, [sp, #20]
    1a1a:	1c28      	adds	r0, r5, #0
    1a1c:	47a0      	blx	r4

    return status;
    1a1e:	2300      	movs	r3, #0
    1a20:	e01d      	b.n	1a5e <PSKCallback+0xd2>

    AJ_InfoPrintf(("PSKCallback(ctx=%p, msg=%p)\n", ctx, msg));

    if (ctx->bus->authListenerCallback) {
        status = PSKCallbackV2(ctx, msg);
    } else if (ctx->bus->pwdCallback) {
    1a22:	6cda      	ldr	r2, [r3, #76]	; 0x4c
        status = PSKCallbackV1(ctx, msg);
    } else {
        status = AJ_ERR_SECURITY;
    1a24:	230d      	movs	r3, #13

    AJ_InfoPrintf(("PSKCallback(ctx=%p, msg=%p)\n", ctx, msg));

    if (ctx->bus->authListenerCallback) {
        status = PSKCallbackV2(ctx, msg);
    } else if (ctx->bus->pwdCallback) {
    1a26:	2a00      	cmp	r2, #0
    1a28:	d019      	beq.n	1a5e <PSKCallback+0xd2>

    /*
     * Assume application does not copy in more than this size buffer
     * Expiration not set by application
     */
    size = ctx->bus->pwdCallback(data, size);
    1a2a:	a802      	add	r0, sp, #8
    1a2c:	2180      	movs	r1, #128	; 0x80
    1a2e:	4790      	blx	r2
    1a30:	1c05      	adds	r5, r0, #0
    if (sizeof (data) < size) {
        return AJ_ERR_RESOURCES;
    1a32:	230b      	movs	r3, #11
    /*
     * Assume application does not copy in more than this size buffer
     * Expiration not set by application
     */
    size = ctx->bus->pwdCallback(data, size);
    if (sizeof (data) < size) {
    1a34:	2880      	cmp	r0, #128	; 0x80
    1a36:	d812      	bhi.n	1a5e <PSKCallback+0xd2>
        return AJ_ERR_RESOURCES;
    }
    ctx->expiration = 0xFFFFFFFF;
    1a38:	2201      	movs	r2, #1
    1a3a:	4252      	negs	r2, r2
    1a3c:	3316      	adds	r3, #22
    1a3e:	33ff      	adds	r3, #255	; 0xff
    1a40:	50e2      	str	r2, [r4, r3]
    AJ_SHA256_Update(&ctx->hash, ctx->kactx.psk.hint, ctx->kactx.psk.size);
    1a42:	1c26      	adds	r6, r4, #0
    1a44:	3610      	adds	r6, #16
    1a46:	3b38      	subs	r3, #56	; 0x38
    1a48:	58e1      	ldr	r1, [r4, r3]
    1a4a:	3304      	adds	r3, #4
    1a4c:	58e2      	ldr	r2, [r4, r3]
    1a4e:	1c30      	adds	r0, r6, #0
    1a50:	4c05      	ldr	r4, [pc, #20]	; (1a68 <PSKCallback+0xdc>)
    1a52:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, data, size);
    1a54:	1c30      	adds	r0, r6, #0
    1a56:	a902      	add	r1, sp, #8
    1a58:	1c2a      	adds	r2, r5, #0
    1a5a:	47a0      	blx	r4

    return AJ_OK;
    1a5c:	2300      	movs	r3, #0
    } else {
        status = AJ_ERR_SECURITY;
    }

    return status;
}
    1a5e:	1c18      	adds	r0, r3, #0
    1a60:	b022      	add	sp, #136	; 0x88
    1a62:	bd70      	pop	{r4, r5, r6, pc}
    1a64:	00400002 	.word	0x00400002
    1a68:	00006139 	.word	0x00006139

00001a6c <ComputeVerifier>:

    return AJ_Crypto_PRF_SHA256(data, lens, ArraySize(data), ctx->mastersecret, AJ_MASTER_SECRET_LEN);
}

static AJ_Status ComputeVerifier(AJ_AuthenticationContext* ctx, const char* label, uint8_t* buffer, size_t bufferlen)
{
    1a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a6e:	b091      	sub	sp, #68	; 0x44
    1a70:	1c04      	adds	r4, r0, #0
    1a72:	1c0d      	adds	r5, r1, #0
    1a74:	9203      	str	r2, [sp, #12]
    1a76:	1c1e      	adds	r6, r3, #0
    const uint8_t* data[3];
    uint8_t lens[3];
    uint8_t digest[SHA256_DIGEST_LENGTH];

    AJ_SHA256_GetDigest(&ctx->hash, digest, 1);
    1a78:	3010      	adds	r0, #16
    1a7a:	af04      	add	r7, sp, #16
    1a7c:	1c39      	adds	r1, r7, #0
    1a7e:	2201      	movs	r2, #1
    1a80:	4b0b      	ldr	r3, [pc, #44]	; (1ab0 <ComputeVerifier+0x44>)
    1a82:	4798      	blx	r3

    data[0] = ctx->mastersecret;
    1a84:	34f0      	adds	r4, #240	; 0xf0
    1a86:	940d      	str	r4, [sp, #52]	; 0x34
    lens[0] = AJ_MASTER_SECRET_LEN;
    1a88:	ac0c      	add	r4, sp, #48	; 0x30
    1a8a:	2330      	movs	r3, #48	; 0x30
    1a8c:	7023      	strb	r3, [r4, #0]
    data[1] = (uint8_t*) label;
    1a8e:	950e      	str	r5, [sp, #56]	; 0x38
    lens[1] = (uint8_t) strlen(label);
    1a90:	1c28      	adds	r0, r5, #0
    1a92:	4b08      	ldr	r3, [pc, #32]	; (1ab4 <ComputeVerifier+0x48>)
    1a94:	4798      	blx	r3
    1a96:	7060      	strb	r0, [r4, #1]
    data[2] = digest;
    1a98:	970f      	str	r7, [sp, #60]	; 0x3c
    lens[2] = sizeof (digest);
    1a9a:	2320      	movs	r3, #32
    1a9c:	70a3      	strb	r3, [r4, #2]

    return AJ_Crypto_PRF_SHA256(data, lens, ArraySize(data), buffer, bufferlen);
    1a9e:	9600      	str	r6, [sp, #0]
    1aa0:	a80d      	add	r0, sp, #52	; 0x34
    1aa2:	1c21      	adds	r1, r4, #0
    1aa4:	2203      	movs	r2, #3
    1aa6:	9b03      	ldr	r3, [sp, #12]
    1aa8:	4c03      	ldr	r4, [pc, #12]	; (1ab8 <ComputeVerifier+0x4c>)
    1aaa:	47a0      	blx	r4
}
    1aac:	b011      	add	sp, #68	; 0x44
    1aae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1ab0:	00006145 	.word	0x00006145
    1ab4:	0001715b 	.word	0x0001715b
    1ab8:	00006299 	.word	0x00006299

00001abc <ECDHEUnmarshalV2>:

    return status;
}

static AJ_Status ECDHEUnmarshalV2(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    1abc:	b570      	push	{r4, r5, r6, lr}
    1abe:	b0ca      	sub	sp, #296	; 0x128
    1ac0:	1c05      	adds	r5, r0, #0
    AJ_SHA256_Context sha;

    AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p)\n", ctx, msg));

    // Unmarshal the encoded key
    status = AJ_UnmarshalArgs(msg, "v", "(yay)", &fmt, &data, &size);
    1ac2:	ab48      	add	r3, sp, #288	; 0x120
    1ac4:	9300      	str	r3, [sp, #0]
    1ac6:	ab47      	add	r3, sp, #284	; 0x11c
    1ac8:	9301      	str	r3, [sp, #4]
    1aca:	1c08      	adds	r0, r1, #0
    1acc:	493a      	ldr	r1, [pc, #232]	; (1bb8 <ECDHEUnmarshalV2+0xfc>)
    1ace:	4a3b      	ldr	r2, [pc, #236]	; (1bbc <ECDHEUnmarshalV2+0x100>)
    1ad0:	2328      	movs	r3, #40	; 0x28
    1ad2:	33ff      	adds	r3, #255	; 0xff
    1ad4:	446b      	add	r3, sp
    1ad6:	4c3a      	ldr	r4, [pc, #232]	; (1bc0 <ECDHEUnmarshalV2+0x104>)
    1ad8:	47a0      	blx	r4
    if (AJ_OK != status) {
    1ada:	2800      	cmp	r0, #0
    1adc:	d166      	bne.n	1bac <ECDHEUnmarshalV2+0xf0>
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return status;
    }
    if (ECC_NIST_P256 != fmt) {
    1ade:	2328      	movs	r3, #40	; 0x28
    1ae0:	33ff      	adds	r3, #255	; 0xff
    1ae2:	446b      	add	r3, sp
    1ae4:	781b      	ldrb	r3, [r3, #0]
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Invalid curve\n", ctx, msg));
        return AJ_ERR_SECURITY;
    1ae6:	240d      	movs	r4, #13
    status = AJ_UnmarshalArgs(msg, "v", "(yay)", &fmt, &data, &size);
    if (AJ_OK != status) {
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return status;
    }
    if (ECC_NIST_P256 != fmt) {
    1ae8:	2b00      	cmp	r3, #0
    1aea:	d162      	bne.n	1bb2 <ECDHEUnmarshalV2+0xf6>
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Invalid curve\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    if (KEY_ECC_PUB_SZ != size) {
    1aec:	9b47      	ldr	r3, [sp, #284]	; 0x11c
    1aee:	2b40      	cmp	r3, #64	; 0x40
    1af0:	d15f      	bne.n	1bb2 <ECDHEUnmarshalV2+0xf6>
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Invalid key material\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    // Decode the public key
    memset(&pub, 0, sizeof (ecc_publickey));
    1af2:	a834      	add	r0, sp, #208	; 0xd0
    1af4:	2100      	movs	r1, #0
    1af6:	224c      	movs	r2, #76	; 0x4c
    1af8:	4b32      	ldr	r3, [pc, #200]	; (1bc4 <ECDHEUnmarshalV2+0x108>)
    1afa:	4798      	blx	r3
    AJ_BigvalDecode(data, &pub.x, KEY_ECC_SZ);
    1afc:	9848      	ldr	r0, [sp, #288]	; 0x120
    1afe:	a934      	add	r1, sp, #208	; 0xd0
    1b00:	2220      	movs	r2, #32
    1b02:	4c31      	ldr	r4, [pc, #196]	; (1bc8 <ECDHEUnmarshalV2+0x10c>)
    1b04:	47a0      	blx	r4
    AJ_BigvalDecode(data + KEY_ECC_SZ, &pub.y, KEY_ECC_SZ);
    1b06:	9848      	ldr	r0, [sp, #288]	; 0x120
    1b08:	3020      	adds	r0, #32
    1b0a:	a93d      	add	r1, sp, #244	; 0xf4
    1b0c:	2220      	movs	r2, #32
    1b0e:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, &fmt, sizeof (fmt));
    1b10:	1c2e      	adds	r6, r5, #0
    1b12:	3610      	adds	r6, #16
    1b14:	1c30      	adds	r0, r6, #0
    1b16:	2128      	movs	r1, #40	; 0x28
    1b18:	31ff      	adds	r1, #255	; 0xff
    1b1a:	4469      	add	r1, sp
    1b1c:	2201      	movs	r2, #1
    1b1e:	4c2b      	ldr	r4, [pc, #172]	; (1bcc <ECDHEUnmarshalV2+0x110>)
    1b20:	47a0      	blx	r4

    AJ_SHA256_Update(&ctx->hash, data, size);
    1b22:	1c30      	adds	r0, r6, #0
    1b24:	9948      	ldr	r1, [sp, #288]	; 0x120
    1b26:	9a47      	ldr	r2, [sp, #284]	; 0x11c
    1b28:	47a0      	blx	r4

    // Generate shared secret
    status = AJ_GenerateShareSecret(&pub, &ctx->kectx.prv, &secret);
    1b2a:	1c29      	adds	r1, r5, #0
    1b2c:	31c4      	adds	r1, #196	; 0xc4
    1b2e:	a834      	add	r0, sp, #208	; 0xd0
    1b30:	aa21      	add	r2, sp, #132	; 0x84
    1b32:	4b27      	ldr	r3, [pc, #156]	; (1bd0 <ECDHEUnmarshalV2+0x114>)
    1b34:	4798      	blx	r3
    if (AJ_OK != status) {
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Generate secret error\n", ctx, msg));
        return status;
    1b36:	1e04      	subs	r4, r0, #0

    AJ_SHA256_Update(&ctx->hash, data, size);

    // Generate shared secret
    status = AJ_GenerateShareSecret(&pub, &ctx->kectx.prv, &secret);
    if (AJ_OK != status) {
    1b38:	d13b      	bne.n	1bb2 <ECDHEUnmarshalV2+0xf6>
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Generate secret error\n", ctx, msg));
        return status;
    }

    // Encode the shared secret
    size = KEY_ECC_PRV_SZ;
    1b3a:	2320      	movs	r3, #32
    1b3c:	9347      	str	r3, [sp, #284]	; 0x11c
    data = AJ_Malloc(size);
    1b3e:	3020      	adds	r0, #32
    1b40:	4b24      	ldr	r3, [pc, #144]	; (1bd4 <ECDHEUnmarshalV2+0x118>)
    1b42:	4798      	blx	r3
    1b44:	1e01      	subs	r1, r0, #0
    1b46:	9048      	str	r0, [sp, #288]	; 0x120
    if (NULL == data) {
    1b48:	d032      	beq.n	1bb0 <ECDHEUnmarshalV2+0xf4>
        return AJ_ERR_RESOURCES;
    }
    // Only use x-coordinate for secret
    AJ_BigvalEncode(&secret.x, data, KEY_ECC_SZ);
    1b4a:	a821      	add	r0, sp, #132	; 0x84
    1b4c:	2220      	movs	r2, #32
    1b4e:	4b22      	ldr	r3, [pc, #136]	; (1bd8 <ECDHEUnmarshalV2+0x11c>)
    1b50:	4798      	blx	r3
    // Reuse the data buffer - hash of the point
    AJ_ASSERT(SHA256_DIGEST_LENGTH <= size);
    1b52:	9b47      	ldr	r3, [sp, #284]	; 0x11c
    1b54:	2b1f      	cmp	r3, #31
    1b56:	d805      	bhi.n	1b64 <ECDHEUnmarshalV2+0xa8>
    1b58:	4820      	ldr	r0, [pc, #128]	; (1bdc <ECDHEUnmarshalV2+0x120>)
    1b5a:	21fd      	movs	r1, #253	; 0xfd
    1b5c:	4a20      	ldr	r2, [pc, #128]	; (1be0 <ECDHEUnmarshalV2+0x124>)
    1b5e:	4b21      	ldr	r3, [pc, #132]	; (1be4 <ECDHEUnmarshalV2+0x128>)
    1b60:	4c21      	ldr	r4, [pc, #132]	; (1be8 <ECDHEUnmarshalV2+0x12c>)
    1b62:	47a0      	blx	r4
    AJ_SHA256_Init(&sha);
    1b64:	a806      	add	r0, sp, #24
    1b66:	4b21      	ldr	r3, [pc, #132]	; (1bec <ECDHEUnmarshalV2+0x130>)
    1b68:	4798      	blx	r3
    AJ_SHA256_Update(&sha, data, size);
    1b6a:	a806      	add	r0, sp, #24
    1b6c:	9948      	ldr	r1, [sp, #288]	; 0x120
    1b6e:	9a47      	ldr	r2, [sp, #284]	; 0x11c
    1b70:	4b16      	ldr	r3, [pc, #88]	; (1bcc <ECDHEUnmarshalV2+0x110>)
    1b72:	4798      	blx	r3
    AJ_SHA256_Final(&sha, data);
    1b74:	a806      	add	r0, sp, #24
    1b76:	9948      	ldr	r1, [sp, #288]	; 0x120
    1b78:	4b1d      	ldr	r3, [pc, #116]	; (1bf0 <ECDHEUnmarshalV2+0x134>)
    1b7a:	4798      	blx	r3
    size = SHA256_DIGEST_LENGTH;
    1b7c:	2220      	movs	r2, #32
    1b7e:	9247      	str	r2, [sp, #284]	; 0x11c
    const uint8_t* data[2];
    uint8_t lens[2];

    AJ_InfoPrintf(("ComputeMasterSecret(ctx=%p, pms=%p, len=%d)\n", ctx, pms, len));

    data[0] = pms;
    1b80:	9b48      	ldr	r3, [sp, #288]	; 0x120
    1b82:	9304      	str	r3, [sp, #16]
    lens[0] = len;
    1b84:	ab03      	add	r3, sp, #12
    1b86:	701a      	strb	r2, [r3, #0]
    data[1] = (uint8_t*) "master secret";
    1b88:	4a1a      	ldr	r2, [pc, #104]	; (1bf4 <ECDHEUnmarshalV2+0x138>)
    1b8a:	9205      	str	r2, [sp, #20]
    lens[1] = 13;
    1b8c:	220d      	movs	r2, #13
    1b8e:	705a      	strb	r2, [r3, #1]

    return AJ_Crypto_PRF_SHA256(data, lens, ArraySize(data), ctx->mastersecret, AJ_MASTER_SECRET_LEN);
    1b90:	1c2b      	adds	r3, r5, #0
    1b92:	33f0      	adds	r3, #240	; 0xf0
    1b94:	3223      	adds	r2, #35	; 0x23
    1b96:	9200      	str	r2, [sp, #0]
    1b98:	a804      	add	r0, sp, #16
    1b9a:	a903      	add	r1, sp, #12
    1b9c:	3a2e      	subs	r2, #46	; 0x2e
    1b9e:	4c16      	ldr	r4, [pc, #88]	; (1bf8 <ECDHEUnmarshalV2+0x13c>)
    1ba0:	47a0      	blx	r4
    1ba2:	1c04      	adds	r4, r0, #0
    AJ_SHA256_Init(&sha);
    AJ_SHA256_Update(&sha, data, size);
    AJ_SHA256_Final(&sha, data);
    size = SHA256_DIGEST_LENGTH;
    status = ComputeMasterSecret(ctx, data, size);
    AJ_Free(data);
    1ba4:	9848      	ldr	r0, [sp, #288]	; 0x120
    1ba6:	4b15      	ldr	r3, [pc, #84]	; (1bfc <ECDHEUnmarshalV2+0x140>)
    1ba8:	4798      	blx	r3

    return status;
    1baa:	e002      	b.n	1bb2 <ECDHEUnmarshalV2+0xf6>

    // Unmarshal the encoded key
    status = AJ_UnmarshalArgs(msg, "v", "(yay)", &fmt, &data, &size);
    if (AJ_OK != status) {
        AJ_InfoPrintf(("ECDHEUnmarshalV2(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return status;
    1bac:	1c04      	adds	r4, r0, #0
    1bae:	e000      	b.n	1bb2 <ECDHEUnmarshalV2+0xf6>

    // Encode the shared secret
    size = KEY_ECC_PRV_SZ;
    data = AJ_Malloc(size);
    if (NULL == data) {
        return AJ_ERR_RESOURCES;
    1bb0:	240b      	movs	r4, #11
    size = SHA256_DIGEST_LENGTH;
    status = ComputeMasterSecret(ctx, data, size);
    AJ_Free(data);

    return status;
}
    1bb2:	1c20      	adds	r0, r4, #0
    1bb4:	b04a      	add	sp, #296	; 0x128
    1bb6:	bd70      	pop	{r4, r5, r6, pc}
    1bb8:	0001f18c 	.word	0x0001f18c
    1bbc:	0001a09c 	.word	0x0001a09c
    1bc0:	0000b5f5 	.word	0x0000b5f5
    1bc4:	00016773 	.word	0x00016773
    1bc8:	00005ee5 	.word	0x00005ee5
    1bcc:	00006139 	.word	0x00006139
    1bd0:	00005fa5 	.word	0x00005fa5
    1bd4:	0000d7dd 	.word	0x0000d7dd
    1bd8:	00005e9d 	.word	0x00005e9d
    1bdc:	0001a0a4 	.word	0x0001a0a4
    1be0:	0001a4b8 	.word	0x0001a4b8
    1be4:	0001a0d8 	.word	0x0001a0d8
    1be8:	00016629 	.word	0x00016629
    1bec:	0000612d 	.word	0x0000612d
    1bf0:	00006181 	.word	0x00006181
    1bf4:	0001a0e4 	.word	0x0001a0e4
    1bf8:	00006299 	.word	0x00006299
    1bfc:	0000d7e9 	.word	0x0000d7e9

00001c00 <AJ_KeyExchangeMarshal>:

    return status;
}

AJ_Status AJ_KeyExchangeMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    1c00:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c02:	b09b      	sub	sp, #108	; 0x6c
    AJ_Status status = AJ_ERR_SECURITY;
    switch (0xFFFF0000 & ctx->suite)
    1c04:	8943      	ldrh	r3, [r0, #10]
    return status;
}

AJ_Status AJ_KeyExchangeMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_SECURITY;
    1c06:	250d      	movs	r5, #13
    switch (0xFFFF0000 & ctx->suite)
    1c08:	2b40      	cmp	r3, #64	; 0x40
    1c0a:	d177      	bne.n	1cfc <AJ_KeyExchangeMarshal+0xfc>
    1c0c:	1c0a      	adds	r2, r1, #0
    1c0e:	9103      	str	r1, [sp, #12]
    1c10:	1c04      	adds	r4, r0, #0

static AJ_Status ECDHEMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status;

    printf("ECDHEMarshal(ctx=%p, msg=%p)\n", ctx, msg);
    1c12:	483c      	ldr	r0, [pc, #240]	; (1d04 <AJ_KeyExchangeMarshal+0x104>)
    1c14:	1c21      	adds	r1, r4, #0
    1c16:	4b3c      	ldr	r3, [pc, #240]	; (1d08 <AJ_KeyExchangeMarshal+0x108>)
    1c18:	4798      	blx	r3

    // Generate key pair if client
    if (AUTH_CLIENT == ctx->role) 
    1c1a:	7923      	ldrb	r3, [r4, #4]
    1c1c:	2b00      	cmp	r3, #0
    1c1e:	d112      	bne.n	1c46 <AJ_KeyExchangeMarshal+0x46>
	{
		printf("ECDHEMarshal if (AUTH_CLIENT == ctx->role)  \n", ctx, msg);
    1c20:	483a      	ldr	r0, [pc, #232]	; (1d0c <AJ_KeyExchangeMarshal+0x10c>)
    1c22:	1c21      	adds	r1, r4, #0
    1c24:	9a03      	ldr	r2, [sp, #12]
    1c26:	4f38      	ldr	r7, [pc, #224]	; (1d08 <AJ_KeyExchangeMarshal+0x108>)
    1c28:	47b8      	blx	r7
        status = AJ_GenerateDHKeyPair(&ctx->kectx.pub, &ctx->kectx.prv);
    1c2a:	1c20      	adds	r0, r4, #0
    1c2c:	3078      	adds	r0, #120	; 0x78
    1c2e:	1c21      	adds	r1, r4, #0
    1c30:	31c4      	adds	r1, #196	; 0xc4
    1c32:	4b37      	ldr	r3, [pc, #220]	; (1d10 <AJ_KeyExchangeMarshal+0x110>)
    1c34:	4798      	blx	r3
    1c36:	1c05      	adds	r5, r0, #0
		printf("ECDHEMarshal AJ_GenerateDHKeyPair status=%s\n",AJ_StatusText(status));
    1c38:	4b36      	ldr	r3, [pc, #216]	; (1d14 <AJ_KeyExchangeMarshal+0x114>)
    1c3a:	4798      	blx	r3
    1c3c:	1c01      	adds	r1, r0, #0
    1c3e:	4836      	ldr	r0, [pc, #216]	; (1d18 <AJ_KeyExchangeMarshal+0x118>)
    1c40:	47b8      	blx	r7
        if (AJ_OK != status) 
    1c42:	2d00      	cmp	r5, #0
    1c44:	d15a      	bne.n	1cfc <AJ_KeyExchangeMarshal+0xfc>
           
            return status;
        }
    }
    
    if ((ctx->version >> 16) < 3) 
    1c46:	89e3      	ldrh	r3, [r4, #14]
    1c48:	2b02      	cmp	r3, #2
    1c4a:	d825      	bhi.n	1c98 <AJ_KeyExchangeMarshal+0x98>
	{
	    printf("ECDHEMarshal if ((ctx->version >> 16) < 3) \n");
    1c4c:	4833      	ldr	r0, [pc, #204]	; (1d1c <AJ_KeyExchangeMarshal+0x11c>)
    1c4e:	4b34      	ldr	r3, [pc, #208]	; (1d20 <AJ_KeyExchangeMarshal+0x120>)
    1c50:	4798      	blx	r3
    uint8_t buf[1 + sizeof (ecc_publickey)];

    AJ_InfoPrintf(("ECDHEMarshalV1(ctx=%p, msg=%p)\n", ctx, msg));

    // Encode the public key
    buf[0] = ECC_NIST_P256;
    1c52:	af06      	add	r7, sp, #24
    1c54:	2300      	movs	r3, #0
    1c56:	703b      	strb	r3, [r7, #0]
    AJ_BigEndianEncodePublicKey(&ctx->kectx.pub, &buf[1]);
    1c58:	1c20      	adds	r0, r4, #0
    1c5a:	3078      	adds	r0, #120	; 0x78
    1c5c:	2111      	movs	r1, #17
    1c5e:	ab02      	add	r3, sp, #8
    1c60:	469c      	mov	ip, r3
    1c62:	4461      	add	r1, ip
    1c64:	4b2f      	ldr	r3, [pc, #188]	; (1d24 <AJ_KeyExchangeMarshal+0x124>)
    1c66:	4798      	blx	r3
    // Marshal the encoded key
    status = AJ_MarshalArgs(msg, "v", "ay", buf, sizeof (buf));
    1c68:	234d      	movs	r3, #77	; 0x4d
    1c6a:	9300      	str	r3, [sp, #0]
    1c6c:	9803      	ldr	r0, [sp, #12]
    1c6e:	492e      	ldr	r1, [pc, #184]	; (1d28 <AJ_KeyExchangeMarshal+0x128>)
    1c70:	4a2e      	ldr	r2, [pc, #184]	; (1d2c <AJ_KeyExchangeMarshal+0x12c>)
    1c72:	1c3b      	adds	r3, r7, #0
    1c74:	4d2e      	ldr	r5, [pc, #184]	; (1d30 <AJ_KeyExchangeMarshal+0x130>)
    1c76:	47a8      	blx	r5
    1c78:	1c06      	adds	r6, r0, #0
    1c7a:	1c05      	adds	r5, r0, #0
    AJ_SHA256_Update(&ctx->hash, buf, sizeof (buf));
    1c7c:	1c20      	adds	r0, r4, #0
    1c7e:	3010      	adds	r0, #16
    1c80:	1c39      	adds	r1, r7, #0
    1c82:	224d      	movs	r2, #77	; 0x4d
    1c84:	4b2b      	ldr	r3, [pc, #172]	; (1d34 <AJ_KeyExchangeMarshal+0x134>)
    1c86:	4798      	blx	r3
    
    if ((ctx->version >> 16) < 3) 
	{
	    printf("ECDHEMarshal if ((ctx->version >> 16) < 3) \n");
        status = ECDHEMarshalV1(ctx, msg);
		printf("ECDHEMarshal ECDHEMarshalV1 status=%s\n",AJ_StatusText(status));
    1c88:	1c30      	adds	r0, r6, #0
    1c8a:	4b22      	ldr	r3, [pc, #136]	; (1d14 <AJ_KeyExchangeMarshal+0x114>)
    1c8c:	4798      	blx	r3
    1c8e:	1c01      	adds	r1, r0, #0
    1c90:	4829      	ldr	r0, [pc, #164]	; (1d38 <AJ_KeyExchangeMarshal+0x138>)
    1c92:	4b1d      	ldr	r3, [pc, #116]	; (1d08 <AJ_KeyExchangeMarshal+0x108>)
    1c94:	4798      	blx	r3
    1c96:	e031      	b.n	1cfc <AJ_KeyExchangeMarshal+0xfc>
    } 
	else 
	{
		printf("ECDHEMarshal if ((ctx->version >> 16) < 3) else \n");
    1c98:	4828      	ldr	r0, [pc, #160]	; (1d3c <AJ_KeyExchangeMarshal+0x13c>)
    1c9a:	4b21      	ldr	r3, [pc, #132]	; (1d20 <AJ_KeyExchangeMarshal+0x120>)
    1c9c:	4798      	blx	r3

static AJ_Status ECDHEMarshalV2(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status;
    uint8_t buf[KEY_ECC_PUB_SZ];
    uint8_t fmt = ECC_NIST_P256;
    1c9e:	270f      	movs	r7, #15
    1ca0:	ab02      	add	r3, sp, #8
    1ca2:	469c      	mov	ip, r3
    1ca4:	4467      	add	r7, ip
    1ca6:	2300      	movs	r3, #0
    1ca8:	703b      	strb	r3, [r7, #0]

    AJ_InfoPrintf(("ECDHEMarshalV2(ctx=%p, msg=%p)\n", ctx, msg));

    // Encode the public key
    AJ_BigvalEncode(&ctx->kectx.pub.x, buf, KEY_ECC_SZ);
    1caa:	1c20      	adds	r0, r4, #0
    1cac:	3078      	adds	r0, #120	; 0x78
    1cae:	ae06      	add	r6, sp, #24
    1cb0:	1c31      	adds	r1, r6, #0
    1cb2:	2220      	movs	r2, #32
    1cb4:	4d22      	ldr	r5, [pc, #136]	; (1d40 <AJ_KeyExchangeMarshal+0x140>)
    1cb6:	47a8      	blx	r5
    AJ_BigvalEncode(&ctx->kectx.pub.y, buf + KEY_ECC_SZ, KEY_ECC_SZ);
    1cb8:	1c20      	adds	r0, r4, #0
    1cba:	309c      	adds	r0, #156	; 0x9c
    1cbc:	a90e      	add	r1, sp, #56	; 0x38
    1cbe:	2220      	movs	r2, #32
    1cc0:	47a8      	blx	r5
    // Marshal the encoded key
    status = AJ_MarshalArgs(msg, "v", "(yay)", fmt, buf, sizeof (buf));
    1cc2:	783b      	ldrb	r3, [r7, #0]
    1cc4:	9600      	str	r6, [sp, #0]
    1cc6:	2240      	movs	r2, #64	; 0x40
    1cc8:	9201      	str	r2, [sp, #4]
    1cca:	9803      	ldr	r0, [sp, #12]
    1ccc:	4916      	ldr	r1, [pc, #88]	; (1d28 <AJ_KeyExchangeMarshal+0x128>)
    1cce:	4a1d      	ldr	r2, [pc, #116]	; (1d44 <AJ_KeyExchangeMarshal+0x144>)
    1cd0:	4d17      	ldr	r5, [pc, #92]	; (1d30 <AJ_KeyExchangeMarshal+0x130>)
    1cd2:	47a8      	blx	r5
    1cd4:	9003      	str	r0, [sp, #12]
    1cd6:	1c05      	adds	r5, r0, #0
    AJ_SHA256_Update(&ctx->hash, &fmt, sizeof (fmt));
    1cd8:	3410      	adds	r4, #16
    1cda:	1c20      	adds	r0, r4, #0
    1cdc:	1c39      	adds	r1, r7, #0
    1cde:	2201      	movs	r2, #1
    1ce0:	4f14      	ldr	r7, [pc, #80]	; (1d34 <AJ_KeyExchangeMarshal+0x134>)
    1ce2:	47b8      	blx	r7
    AJ_SHA256_Update(&ctx->hash, buf, sizeof (buf));
    1ce4:	1c20      	adds	r0, r4, #0
    1ce6:	1c31      	adds	r1, r6, #0
    1ce8:	2240      	movs	r2, #64	; 0x40
    1cea:	47b8      	blx	r7
    } 
	else 
	{
		printf("ECDHEMarshal if ((ctx->version >> 16) < 3) else \n");
        status = ECDHEMarshalV2(ctx, msg);
		printf("ECDHEMarshal ECDHEMarshalV2 status=%s\n",AJ_StatusText(status));
    1cec:	9803      	ldr	r0, [sp, #12]
    1cee:	4b09      	ldr	r3, [pc, #36]	; (1d14 <AJ_KeyExchangeMarshal+0x114>)
    1cf0:	4798      	blx	r3
    1cf2:	1c01      	adds	r1, r0, #0
    1cf4:	4814      	ldr	r0, [pc, #80]	; (1d48 <AJ_KeyExchangeMarshal+0x148>)
    1cf6:	4b04      	ldr	r3, [pc, #16]	; (1d08 <AJ_KeyExchangeMarshal+0x108>)
    1cf8:	4798      	blx	r3
    1cfa:	e7ff      	b.n	1cfc <AJ_KeyExchangeMarshal+0xfc>
    case AUTH_KEYX_ECDHE:
        status = ECDHEMarshal(ctx, msg);
        break;
    }
    return status;
}
    1cfc:	1c28      	adds	r0, r5, #0
    1cfe:	b01b      	add	sp, #108	; 0x6c
    1d00:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d02:	46c0      	nop			; (mov r8, r8)
    1d04:	0001a0f4 	.word	0x0001a0f4
    1d08:	00016e3d 	.word	0x00016e3d
    1d0c:	0001a114 	.word	0x0001a114
    1d10:	00005f8d 	.word	0x00005f8d
    1d14:	000063c5 	.word	0x000063c5
    1d18:	0001a144 	.word	0x0001a144
    1d1c:	0001a174 	.word	0x0001a174
    1d20:	00016f5d 	.word	0x00016f5d
    1d24:	00003181 	.word	0x00003181
    1d28:	0001f18c 	.word	0x0001f18c
    1d2c:	0001ecdc 	.word	0x0001ecdc
    1d30:	0000bc85 	.word	0x0000bc85
    1d34:	00006139 	.word	0x00006139
    1d38:	0001a1a0 	.word	0x0001a1a0
    1d3c:	0001a1c8 	.word	0x0001a1c8
    1d40:	00005e9d 	.word	0x00005e9d
    1d44:	0001a09c 	.word	0x0001a09c
    1d48:	0001a1fc 	.word	0x0001a1fc

00001d4c <AJ_KeyExchangeUnmarshal>:

AJ_Status AJ_KeyExchangeUnmarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    1d4c:	b570      	push	{r4, r5, r6, lr}
    1d4e:	b0ae      	sub	sp, #184	; 0xb8
    AJ_Status status = AJ_ERR_SECURITY;
    switch (0xFFFF0000 & ctx->suite) 
    1d50:	8943      	ldrh	r3, [r0, #10]
    return status;
}

AJ_Status AJ_KeyExchangeUnmarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_SECURITY;
    1d52:	250d      	movs	r5, #13
    switch (0xFFFF0000 & ctx->suite) 
    1d54:	2b40      	cmp	r3, #64	; 0x40
    1d56:	d000      	beq.n	1d5a <AJ_KeyExchangeUnmarshal+0xe>
    1d58:	e07d      	b.n	1e56 <AJ_KeyExchangeUnmarshal+0x10a>
    1d5a:	1c0e      	adds	r6, r1, #0
    1d5c:	1c04      	adds	r4, r0, #0

static AJ_Status ECDHEUnmarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status;

    printf("ECDHEUnmarshal(ctx=%p, msg=%p)\n", ctx, msg);
    1d5e:	483f      	ldr	r0, [pc, #252]	; (1e5c <AJ_KeyExchangeUnmarshal+0x110>)
    1d60:	1c21      	adds	r1, r4, #0
    1d62:	1c32      	adds	r2, r6, #0
    1d64:	4b3e      	ldr	r3, [pc, #248]	; (1e60 <AJ_KeyExchangeUnmarshal+0x114>)
    1d66:	4798      	blx	r3

    // Generate key pair if server
    if (AUTH_SERVER == ctx->role) 
    1d68:	7923      	ldrb	r3, [r4, #4]
    1d6a:	2b01      	cmp	r3, #1
    1d6c:	d111      	bne.n	1d92 <AJ_KeyExchangeUnmarshal+0x46>
	{
		printf("ECDHEUnmarshal if (AUTH_SERVER == ctx->role) \n");
    1d6e:	483d      	ldr	r0, [pc, #244]	; (1e64 <AJ_KeyExchangeUnmarshal+0x118>)
    1d70:	4b3d      	ldr	r3, [pc, #244]	; (1e68 <AJ_KeyExchangeUnmarshal+0x11c>)
    1d72:	4798      	blx	r3
        status = AJ_GenerateDHKeyPair(&ctx->kectx.pub, &ctx->kectx.prv);
    1d74:	1c20      	adds	r0, r4, #0
    1d76:	3078      	adds	r0, #120	; 0x78
    1d78:	1c21      	adds	r1, r4, #0
    1d7a:	31c4      	adds	r1, #196	; 0xc4
    1d7c:	4b3b      	ldr	r3, [pc, #236]	; (1e6c <AJ_KeyExchangeUnmarshal+0x120>)
    1d7e:	4798      	blx	r3
    1d80:	1c05      	adds	r5, r0, #0
		printf("ECDHEUnmarshal status=%s \n", AJ_StatusText(status));
    1d82:	4b3b      	ldr	r3, [pc, #236]	; (1e70 <AJ_KeyExchangeUnmarshal+0x124>)
    1d84:	4798      	blx	r3
    1d86:	1c01      	adds	r1, r0, #0
    1d88:	483a      	ldr	r0, [pc, #232]	; (1e74 <AJ_KeyExchangeUnmarshal+0x128>)
    1d8a:	4b35      	ldr	r3, [pc, #212]	; (1e60 <AJ_KeyExchangeUnmarshal+0x114>)
    1d8c:	4798      	blx	r3
        if (AJ_OK != status) 
    1d8e:	2d00      	cmp	r5, #0
    1d90:	d161      	bne.n	1e56 <AJ_KeyExchangeUnmarshal+0x10a>
		{            
            return status;
        }
    }
    if ((ctx->version >> 16) < 3) 
    1d92:	89e3      	ldrh	r3, [r4, #14]
    1d94:	2b02      	cmp	r3, #2
    1d96:	d84f      	bhi.n	1e38 <AJ_KeyExchangeUnmarshal+0xec>
	{
		printf("ECDHEUnmarshal if ((ctx->version >> 16) < 3) \n");
    1d98:	4837      	ldr	r0, [pc, #220]	; (1e78 <AJ_KeyExchangeUnmarshal+0x12c>)
    1d9a:	4b33      	ldr	r3, [pc, #204]	; (1e68 <AJ_KeyExchangeUnmarshal+0x11c>)
    1d9c:	4798      	blx	r3
    ecc_secret secret;

    AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p)\n", ctx, msg));

    // Unmarshal the encoded key
    status = AJ_UnmarshalArgs(msg, "v", "ay", &data, &size);
    1d9e:	ab05      	add	r3, sp, #20
    1da0:	9300      	str	r3, [sp, #0]
    1da2:	1c30      	adds	r0, r6, #0
    1da4:	4935      	ldr	r1, [pc, #212]	; (1e7c <AJ_KeyExchangeUnmarshal+0x130>)
    1da6:	4a36      	ldr	r2, [pc, #216]	; (1e80 <AJ_KeyExchangeUnmarshal+0x134>)
    1da8:	ab04      	add	r3, sp, #16
    1daa:	4d36      	ldr	r5, [pc, #216]	; (1e84 <AJ_KeyExchangeUnmarshal+0x138>)
    1dac:	47a8      	blx	r5
    1dae:	1e05      	subs	r5, r0, #0
    if (AJ_OK != status) {
    1db0:	d13a      	bne.n	1e28 <AJ_KeyExchangeUnmarshal+0xdc>
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return status;
    }
    if (1 + sizeof (ecc_publickey) != size) {
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Invalid key material\n", ctx, msg));
        return AJ_ERR_SECURITY;
    1db2:	350d      	adds	r5, #13
    status = AJ_UnmarshalArgs(msg, "v", "ay", &data, &size);
    if (AJ_OK != status) {
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return status;
    }
    if (1 + sizeof (ecc_publickey) != size) {
    1db4:	9b05      	ldr	r3, [sp, #20]
    1db6:	2b4d      	cmp	r3, #77	; 0x4d
    1db8:	d136      	bne.n	1e28 <AJ_KeyExchangeUnmarshal+0xdc>
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Invalid key material\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    if (ECC_NIST_P256 != data[0]) {
    1dba:	9904      	ldr	r1, [sp, #16]
    1dbc:	780b      	ldrb	r3, [r1, #0]
    1dbe:	2b00      	cmp	r3, #0
    1dc0:	d132      	bne.n	1e28 <AJ_KeyExchangeUnmarshal+0xdc>
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Invalid curve\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    // Decode the public key
    AJ_BigEndianDecodePublicKey(&pub, &data[1]);
    1dc2:	3101      	adds	r1, #1
    1dc4:	a808      	add	r0, sp, #32
    1dc6:	4b30      	ldr	r3, [pc, #192]	; (1e88 <AJ_KeyExchangeUnmarshal+0x13c>)
    1dc8:	4798      	blx	r3

    AJ_SHA256_Update(&ctx->hash, data, size);
    1dca:	1c20      	adds	r0, r4, #0
    1dcc:	3010      	adds	r0, #16
    1dce:	9904      	ldr	r1, [sp, #16]
    1dd0:	9a05      	ldr	r2, [sp, #20]
    1dd2:	4b2e      	ldr	r3, [pc, #184]	; (1e8c <AJ_KeyExchangeUnmarshal+0x140>)
    1dd4:	4798      	blx	r3

    // Generate shared secret
    status = AJ_GenerateShareSecret(&pub, &ctx->kectx.prv, &secret);
    1dd6:	1c21      	adds	r1, r4, #0
    1dd8:	31c4      	adds	r1, #196	; 0xc4
    1dda:	a808      	add	r0, sp, #32
    1ddc:	aa1b      	add	r2, sp, #108	; 0x6c
    1dde:	4b2c      	ldr	r3, [pc, #176]	; (1e90 <AJ_KeyExchangeUnmarshal+0x144>)
    1de0:	4798      	blx	r3
    1de2:	1e05      	subs	r5, r0, #0
    if (AJ_OK != status) {
    1de4:	d120      	bne.n	1e28 <AJ_KeyExchangeUnmarshal+0xdc>
        AJ_InfoPrintf(("ECDHEUnmarshalV1(ctx=%p, msg=%p): Generate secret error\n", ctx, msg));
        return status;
    }

    // Encode the shared secret
    size = sizeof (ecc_secret);
    1de6:	204c      	movs	r0, #76	; 0x4c
    1de8:	9005      	str	r0, [sp, #20]
    data = AJ_Malloc(size);
    1dea:	4b2a      	ldr	r3, [pc, #168]	; (1e94 <AJ_KeyExchangeUnmarshal+0x148>)
    1dec:	4798      	blx	r3
    1dee:	1c01      	adds	r1, r0, #0
    1df0:	9004      	str	r0, [sp, #16]
    if (NULL == data) {
        return AJ_ERR_RESOURCES;
    1df2:	350b      	adds	r5, #11
    }

    // Encode the shared secret
    size = sizeof (ecc_secret);
    data = AJ_Malloc(size);
    if (NULL == data) {
    1df4:	2800      	cmp	r0, #0
    1df6:	d017      	beq.n	1e28 <AJ_KeyExchangeUnmarshal+0xdc>
        return AJ_ERR_RESOURCES;
    }
    AJ_BigEndianEncodePublicKey(&secret, data);
    1df8:	a81b      	add	r0, sp, #108	; 0x6c
    1dfa:	4b27      	ldr	r3, [pc, #156]	; (1e98 <AJ_KeyExchangeUnmarshal+0x14c>)
    1dfc:	4798      	blx	r3
    const uint8_t* data[2];
    uint8_t lens[2];

    AJ_InfoPrintf(("ComputeMasterSecret(ctx=%p, pms=%p, len=%d)\n", ctx, pms, len));

    data[0] = pms;
    1dfe:	9b04      	ldr	r3, [sp, #16]
    1e00:	9306      	str	r3, [sp, #24]
    lens[0] = len;
    1e02:	a903      	add	r1, sp, #12
    1e04:	9b05      	ldr	r3, [sp, #20]
    1e06:	700b      	strb	r3, [r1, #0]
    data[1] = (uint8_t*) "master secret";
    1e08:	4b24      	ldr	r3, [pc, #144]	; (1e9c <AJ_KeyExchangeUnmarshal+0x150>)
    1e0a:	9307      	str	r3, [sp, #28]
    lens[1] = 13;
    1e0c:	230d      	movs	r3, #13
    1e0e:	704b      	strb	r3, [r1, #1]

    return AJ_Crypto_PRF_SHA256(data, lens, ArraySize(data), ctx->mastersecret, AJ_MASTER_SECRET_LEN);
    1e10:	1c23      	adds	r3, r4, #0
    1e12:	33f0      	adds	r3, #240	; 0xf0
    1e14:	2230      	movs	r2, #48	; 0x30
    1e16:	9200      	str	r2, [sp, #0]
    1e18:	a806      	add	r0, sp, #24
    1e1a:	3a2e      	subs	r2, #46	; 0x2e
    1e1c:	4c20      	ldr	r4, [pc, #128]	; (1ea0 <AJ_KeyExchangeUnmarshal+0x154>)
    1e1e:	47a0      	blx	r4
    1e20:	1c05      	adds	r5, r0, #0
    if (NULL == data) {
        return AJ_ERR_RESOURCES;
    }
    AJ_BigEndianEncodePublicKey(&secret, data);
    status = ComputeMasterSecret(ctx, data, size);
    AJ_Free(data);
    1e22:	9804      	ldr	r0, [sp, #16]
    1e24:	4b1f      	ldr	r3, [pc, #124]	; (1ea4 <AJ_KeyExchangeUnmarshal+0x158>)
    1e26:	4798      	blx	r3
    }
    if ((ctx->version >> 16) < 3) 
	{
		printf("ECDHEUnmarshal if ((ctx->version >> 16) < 3) \n");
        status = ECDHEUnmarshalV1(ctx, msg);
		printf("ECDHEUnmarshal ECDHEUnmarshalV1 status=%s \n", AJ_StatusText(status));
    1e28:	1c28      	adds	r0, r5, #0
    1e2a:	4b11      	ldr	r3, [pc, #68]	; (1e70 <AJ_KeyExchangeUnmarshal+0x124>)
    1e2c:	4798      	blx	r3
    1e2e:	1c01      	adds	r1, r0, #0
    1e30:	481d      	ldr	r0, [pc, #116]	; (1ea8 <AJ_KeyExchangeUnmarshal+0x15c>)
    1e32:	4b0b      	ldr	r3, [pc, #44]	; (1e60 <AJ_KeyExchangeUnmarshal+0x114>)
    1e34:	4798      	blx	r3
    1e36:	e00e      	b.n	1e56 <AJ_KeyExchangeUnmarshal+0x10a>
    }
	else 
	{
		printf("ECDHEUnmarshal else \n");
    1e38:	481c      	ldr	r0, [pc, #112]	; (1eac <AJ_KeyExchangeUnmarshal+0x160>)
    1e3a:	4b0b      	ldr	r3, [pc, #44]	; (1e68 <AJ_KeyExchangeUnmarshal+0x11c>)
    1e3c:	4798      	blx	r3
        status = ECDHEUnmarshalV2(ctx, msg);
    1e3e:	1c20      	adds	r0, r4, #0
    1e40:	1c31      	adds	r1, r6, #0
    1e42:	4b1b      	ldr	r3, [pc, #108]	; (1eb0 <AJ_KeyExchangeUnmarshal+0x164>)
    1e44:	4798      	blx	r3
    1e46:	1c05      	adds	r5, r0, #0
		printf("ECDHEUnmarshal ECDHEUnmarshalV2 status=%s\n", AJ_StatusText(status));
    1e48:	4b09      	ldr	r3, [pc, #36]	; (1e70 <AJ_KeyExchangeUnmarshal+0x124>)
    1e4a:	4798      	blx	r3
    1e4c:	1c01      	adds	r1, r0, #0
    1e4e:	4819      	ldr	r0, [pc, #100]	; (1eb4 <AJ_KeyExchangeUnmarshal+0x168>)
    1e50:	4b03      	ldr	r3, [pc, #12]	; (1e60 <AJ_KeyExchangeUnmarshal+0x114>)
    1e52:	4798      	blx	r3
    1e54:	e7ff      	b.n	1e56 <AJ_KeyExchangeUnmarshal+0x10a>
    case AUTH_KEYX_ECDHE:
        status = ECDHEUnmarshal(ctx, msg);
        break;
    }
    return status;
}
    1e56:	1c28      	adds	r0, r5, #0
    1e58:	b02e      	add	sp, #184	; 0xb8
    1e5a:	bd70      	pop	{r4, r5, r6, pc}
    1e5c:	0001a224 	.word	0x0001a224
    1e60:	00016e3d 	.word	0x00016e3d
    1e64:	0001a244 	.word	0x0001a244
    1e68:	00016f5d 	.word	0x00016f5d
    1e6c:	00005f8d 	.word	0x00005f8d
    1e70:	000063c5 	.word	0x000063c5
    1e74:	0001a274 	.word	0x0001a274
    1e78:	0001a290 	.word	0x0001a290
    1e7c:	0001f18c 	.word	0x0001f18c
    1e80:	0001ecdc 	.word	0x0001ecdc
    1e84:	0000b5f5 	.word	0x0000b5f5
    1e88:	00003191 	.word	0x00003191
    1e8c:	00006139 	.word	0x00006139
    1e90:	00005fa5 	.word	0x00005fa5
    1e94:	0000d7dd 	.word	0x0000d7dd
    1e98:	00003181 	.word	0x00003181
    1e9c:	0001a0e4 	.word	0x0001a0e4
    1ea0:	00006299 	.word	0x00006299
    1ea4:	0000d7e9 	.word	0x0000d7e9
    1ea8:	0001a2c0 	.word	0x0001a2c0
    1eac:	0001a2ec 	.word	0x0001a2ec
    1eb0:	00001abd 	.word	0x00001abd
    1eb4:	0001a304 	.word	0x0001a304

00001eb8 <AJ_KeyAuthenticationMarshal>:
    }
    return trusted ? AJ_OK : AJ_ERR_SECURITY;
}

AJ_Status AJ_KeyAuthenticationMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    1eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1eba:	4657      	mov	r7, sl
    1ebc:	464e      	mov	r6, r9
    1ebe:	4645      	mov	r5, r8
    1ec0:	b4e0      	push	{r5, r6, r7}
    1ec2:	b09e      	sub	sp, #120	; 0x78
    1ec4:	1c07      	adds	r7, r0, #0
    1ec6:	1c0d      	adds	r5, r1, #0
    AJ_Status status = AJ_ERR_SECURITY;
    switch (ctx->suite) {
    1ec8:	6883      	ldr	r3, [r0, #8]
    1eca:	4ac4      	ldr	r2, [pc, #784]	; (21dc <STACK_SIZE+0x1dc>)
    1ecc:	4293      	cmp	r3, r2
    1ece:	d039      	beq.n	1f44 <AJ_KeyAuthenticationMarshal+0x8c>
    1ed0:	4ac3      	ldr	r2, [pc, #780]	; (21e0 <STACK_SIZE+0x1e0>)
    1ed2:	4293      	cmp	r3, r2
    1ed4:	d072      	beq.n	1fbc <AJ_KeyAuthenticationMarshal+0x104>
    1ed6:	4ac3      	ldr	r2, [pc, #780]	; (21e4 <STACK_SIZE+0x1e4>)
    return trusted ? AJ_OK : AJ_ERR_SECURITY;
}

AJ_Status AJ_KeyAuthenticationMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_SECURITY;
    1ed8:	240d      	movs	r4, #13
    switch (ctx->suite) {
    1eda:	4293      	cmp	r3, r2
    1edc:	d000      	beq.n	1ee0 <AJ_KeyAuthenticationMarshal+0x28>
    1ede:	e176      	b.n	21ce <STACK_SIZE+0x1ce>
    AJ_Credential cred;
    uint8_t verifier[AUTH_VERIFIER_LEN];

    AJ_InfoPrintf(("NULLMarshal(ctx=%p, msg=%p)\n", ctx, msg));

    if (ctx->bus->authListenerCallback) {
    1ee0:	6803      	ldr	r3, [r0, #0]
    1ee2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1ee4:	2b00      	cmp	r3, #0
    1ee6:	d009      	beq.n	1efc <AJ_KeyAuthenticationMarshal+0x44>
        status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_NULL, 0, &cred);
    1ee8:	1c10      	adds	r0, r2, #0
    1eea:	2100      	movs	r1, #0
    1eec:	aa12      	add	r2, sp, #72	; 0x48
    1eee:	4798      	blx	r3
        if (AJ_OK == status) {
    1ef0:	2800      	cmp	r0, #0
    1ef2:	d103      	bne.n	1efc <AJ_KeyAuthenticationMarshal+0x44>
            ctx->expiration = cred.expiration;
    1ef4:	2390      	movs	r3, #144	; 0x90
    1ef6:	005b      	lsls	r3, r3, #1
    1ef8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    1efa:	50fa      	str	r2, [r7, r3]
        }
    }
    if (AUTH_CLIENT == ctx->role) {
    1efc:	793b      	ldrb	r3, [r7, #4]
    1efe:	2b00      	cmp	r3, #0
    1f00:	d106      	bne.n	1f10 <AJ_KeyAuthenticationMarshal+0x58>
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
    1f02:	1c38      	adds	r0, r7, #0
    1f04:	49b8      	ldr	r1, [pc, #736]	; (21e8 <STACK_SIZE+0x1e8>)
    1f06:	aa16      	add	r2, sp, #88	; 0x58
    1f08:	3320      	adds	r3, #32
    1f0a:	4cb8      	ldr	r4, [pc, #736]	; (21ec <STACK_SIZE+0x1ec>)
    1f0c:	47a0      	blx	r4
    1f0e:	e005      	b.n	1f1c <AJ_KeyAuthenticationMarshal+0x64>
    } else {
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
    1f10:	1c38      	adds	r0, r7, #0
    1f12:	49b7      	ldr	r1, [pc, #732]	; (21f0 <STACK_SIZE+0x1f0>)
    1f14:	aa16      	add	r2, sp, #88	; 0x58
    1f16:	2320      	movs	r3, #32
    1f18:	4cb4      	ldr	r4, [pc, #720]	; (21ec <STACK_SIZE+0x1ec>)
    1f1a:	47a0      	blx	r4
    }
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    1f1c:	240d      	movs	r4, #13
    if (AUTH_CLIENT == ctx->role) {
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
    } else {
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
    }
    if (AJ_OK != status) {
    1f1e:	2800      	cmp	r0, #0
    1f20:	d000      	beq.n	1f24 <AJ_KeyAuthenticationMarshal+0x6c>
    1f22:	e154      	b.n	21ce <STACK_SIZE+0x1ce>
        return AJ_ERR_SECURITY;
    }
    status = AJ_MarshalArgs(msg, "v", "ay", verifier, sizeof (verifier));
    1f24:	2320      	movs	r3, #32
    1f26:	9300      	str	r3, [sp, #0]
    1f28:	1c28      	adds	r0, r5, #0
    1f2a:	49b2      	ldr	r1, [pc, #712]	; (21f4 <STACK_SIZE+0x1f4>)
    1f2c:	4ab2      	ldr	r2, [pc, #712]	; (21f8 <STACK_SIZE+0x1f8>)
    1f2e:	ab16      	add	r3, sp, #88	; 0x58
    1f30:	4cb2      	ldr	r4, [pc, #712]	; (21fc <STACK_SIZE+0x1fc>)
    1f32:	47a0      	blx	r4
    1f34:	1c04      	adds	r4, r0, #0
    AJ_SHA256_Update(&ctx->hash, verifier, sizeof (verifier));
    1f36:	1c38      	adds	r0, r7, #0
    1f38:	3010      	adds	r0, #16
    1f3a:	a916      	add	r1, sp, #88	; 0x58
    1f3c:	2220      	movs	r2, #32
    1f3e:	4bb0      	ldr	r3, [pc, #704]	; (2200 <STACK_SIZE+0x200>)
    1f40:	4798      	blx	r3
    1f42:	e144      	b.n	21ce <STACK_SIZE+0x1ce>
    const char* anon = "<anonymous>";
    uint8_t verifier[AUTH_VERIFIER_LEN];

    AJ_InfoPrintf(("PSKMarshal(ctx=%p, msg=%p)\n", ctx, msg));

    switch (ctx->role) {
    1f44:	7903      	ldrb	r3, [r0, #4]
    1f46:	2b00      	cmp	r3, #0
    1f48:	d002      	beq.n	1f50 <AJ_KeyAuthenticationMarshal+0x98>
    1f4a:	2b01      	cmp	r3, #1
    1f4c:	d01a      	beq.n	1f84 <AJ_KeyAuthenticationMarshal+0xcc>
    1f4e:	e020      	b.n	1f92 <AJ_KeyAuthenticationMarshal+0xda>
    case AUTH_CLIENT:
        // Default to anonymous
        ctx->kactx.psk.hint = (uint8_t*) anon;
    1f50:	4aac      	ldr	r2, [pc, #688]	; (2204 <STACK_SIZE+0x204>)
    1f52:	23e8      	movs	r3, #232	; 0xe8
    1f54:	50c2      	str	r2, [r0, r3]
        ctx->kactx.psk.size = strlen(anon);
    1f56:	220b      	movs	r2, #11
    1f58:	3304      	adds	r3, #4
    1f5a:	50c2      	str	r2, [r0, r3]
        status = PSKCallback(ctx, msg);
    1f5c:	4baa      	ldr	r3, [pc, #680]	; (2208 <STACK_SIZE+0x208>)
    1f5e:	4798      	blx	r3
        if (AJ_OK != status) {
            return AJ_ERR_SECURITY;
    1f60:	240d      	movs	r4, #13
    case AUTH_CLIENT:
        // Default to anonymous
        ctx->kactx.psk.hint = (uint8_t*) anon;
        ctx->kactx.psk.size = strlen(anon);
        status = PSKCallback(ctx, msg);
        if (AJ_OK != status) {
    1f62:	2800      	cmp	r0, #0
    1f64:	d000      	beq.n	1f68 <AJ_KeyAuthenticationMarshal+0xb0>
    1f66:	e132      	b.n	21ce <STACK_SIZE+0x1ce>
            return AJ_ERR_SECURITY;
        }
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
    1f68:	1c38      	adds	r0, r7, #0
    1f6a:	499f      	ldr	r1, [pc, #636]	; (21e8 <STACK_SIZE+0x1e8>)
    1f6c:	aa16      	add	r2, sp, #88	; 0x58
    1f6e:	2320      	movs	r3, #32
    1f70:	4c9e      	ldr	r4, [pc, #632]	; (21ec <STACK_SIZE+0x1ec>)
    1f72:	47a0      	blx	r4
    1f74:	1c06      	adds	r6, r0, #0
        AJ_SHA256_Update(&ctx->hash, verifier, sizeof (verifier));
    1f76:	1c38      	adds	r0, r7, #0
    1f78:	3010      	adds	r0, #16
    1f7a:	a916      	add	r1, sp, #88	; 0x58
    1f7c:	2220      	movs	r2, #32
    1f7e:	4ba0      	ldr	r3, [pc, #640]	; (2200 <STACK_SIZE+0x200>)
    1f80:	4798      	blx	r3
    1f82:	e007      	b.n	1f94 <AJ_KeyAuthenticationMarshal+0xdc>
        break;

    case AUTH_SERVER:
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
    1f84:	499a      	ldr	r1, [pc, #616]	; (21f0 <STACK_SIZE+0x1f0>)
    1f86:	aa16      	add	r2, sp, #88	; 0x58
    1f88:	2320      	movs	r3, #32
    1f8a:	4c98      	ldr	r4, [pc, #608]	; (21ec <STACK_SIZE+0x1ec>)
    1f8c:	47a0      	blx	r4
    1f8e:	1c06      	adds	r6, r0, #0
    1f90:	e000      	b.n	1f94 <AJ_KeyAuthenticationMarshal+0xdc>
    return status;
}

static AJ_Status PSKMarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_SECURITY;
    1f92:	260d      	movs	r6, #13
    case AUTH_SERVER:
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
        break;
    }
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    1f94:	240d      	movs	r4, #13

    case AUTH_SERVER:
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
        break;
    }
    if (AJ_OK != status) {
    1f96:	2e00      	cmp	r6, #0
    1f98:	d000      	beq.n	1f9c <AJ_KeyAuthenticationMarshal+0xe4>
    1f9a:	e118      	b.n	21ce <STACK_SIZE+0x1ce>
        return AJ_ERR_SECURITY;
    }

    status = AJ_MarshalArgs(msg, "v", "(ayay)", ctx->kactx.psk.hint, ctx->kactx.psk.size, verifier, sizeof (verifier));
    1f9c:	23e8      	movs	r3, #232	; 0xe8
    1f9e:	58fb      	ldr	r3, [r7, r3]
    1fa0:	22ec      	movs	r2, #236	; 0xec
    1fa2:	58ba      	ldr	r2, [r7, r2]
    1fa4:	9200      	str	r2, [sp, #0]
    1fa6:	aa16      	add	r2, sp, #88	; 0x58
    1fa8:	9201      	str	r2, [sp, #4]
    1faa:	2220      	movs	r2, #32
    1fac:	9202      	str	r2, [sp, #8]
    1fae:	1c28      	adds	r0, r5, #0
    1fb0:	4990      	ldr	r1, [pc, #576]	; (21f4 <STACK_SIZE+0x1f4>)
    1fb2:	4a96      	ldr	r2, [pc, #600]	; (220c <STACK_SIZE+0x20c>)
    1fb4:	4c91      	ldr	r4, [pc, #580]	; (21fc <STACK_SIZE+0x1fc>)
    1fb6:	47a0      	blx	r4
    1fb8:	1c04      	adds	r4, r0, #0
    1fba:	e108      	b.n	21ce <STACK_SIZE+0x1ce>
    X509CertificateChain* chain = NULL;
    uint8_t fmt;

    AJ_InfoPrintf(("AJ_ECDSA_Marshal(ctx=%p, msg=%p)\n", ctx, msg));

    if (NULL == ctx->bus->authListenerCallback) {
    1fbc:	6803      	ldr	r3, [r0, #0]
    1fbe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1fc0:	2b00      	cmp	r3, #0
    1fc2:	d100      	bne.n	1fc6 <AJ_KeyAuthenticationMarshal+0x10e>
    1fc4:	e100      	b.n	21c8 <STACK_SIZE+0x1c8>
        status = AJ_ERR_INVALID;
        goto Exit;
    }

    if (AUTH_CLIENT == ctx->role) {
    1fc6:	7903      	ldrb	r3, [r0, #4]
    1fc8:	2b00      	cmp	r3, #0
    1fca:	d106      	bne.n	1fda <AJ_KeyAuthenticationMarshal+0x122>
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
    1fcc:	4986      	ldr	r1, [pc, #536]	; (21e8 <STACK_SIZE+0x1e8>)
    1fce:	aa16      	add	r2, sp, #88	; 0x58
    1fd0:	3320      	adds	r3, #32
    1fd2:	4c86      	ldr	r4, [pc, #536]	; (21ec <STACK_SIZE+0x1ec>)
    1fd4:	47a0      	blx	r4
    1fd6:	1c04      	adds	r4, r0, #0
    1fd8:	e005      	b.n	1fe6 <AJ_KeyAuthenticationMarshal+0x12e>
    } else {
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
    1fda:	4985      	ldr	r1, [pc, #532]	; (21f0 <STACK_SIZE+0x1f0>)
    1fdc:	aa16      	add	r2, sp, #88	; 0x58
    1fde:	2320      	movs	r3, #32
    1fe0:	4c82      	ldr	r4, [pc, #520]	; (21ec <STACK_SIZE+0x1ec>)
    1fe2:	47a0      	blx	r4
    1fe4:	1c04      	adds	r4, r0, #0
    }
    if (AJ_OK != status) {
    1fe6:	2c00      	cmp	r4, #0
    1fe8:	d000      	beq.n	1fec <AJ_KeyAuthenticationMarshal+0x134>
    1fea:	e0f0      	b.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }

    // Request private key from application
    cred.direction = AJ_CRED_REQUEST;
    1fec:	aa12      	add	r2, sp, #72	; 0x48
    1fee:	2300      	movs	r3, #0
    1ff0:	7013      	strb	r3, [r2, #0]
    status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_ECDSA, AJ_CRED_PRV_KEY, &cred);
    1ff2:	683b      	ldr	r3, [r7, #0]
    1ff4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1ff6:	487a      	ldr	r0, [pc, #488]	; (21e0 <STACK_SIZE+0x1e0>)
    1ff8:	2101      	movs	r1, #1
    1ffa:	4798      	blx	r3
    1ffc:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    1ffe:	d00c      	beq.n	201a <STACK_SIZE+0x1a>
        AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Private key required\n", msg));
    2000:	2002      	movs	r0, #2
    2002:	4983      	ldr	r1, [pc, #524]	; (2210 <STACK_SIZE+0x210>)
    2004:	4a83      	ldr	r2, [pc, #524]	; (2214 <STACK_SIZE+0x214>)
    2006:	4b84      	ldr	r3, [pc, #528]	; (2218 <STACK_SIZE+0x218>)
    2008:	4798      	blx	r3
    200a:	2800      	cmp	r0, #0
    200c:	d100      	bne.n	2010 <STACK_SIZE+0x10>
    200e:	e0de      	b.n	21ce <STACK_SIZE+0x1ce>
    2010:	4882      	ldr	r0, [pc, #520]	; (221c <STACK_SIZE+0x21c>)
    2012:	1c29      	adds	r1, r5, #0
    2014:	4b82      	ldr	r3, [pc, #520]	; (2220 <STACK_SIZE+0x220>)
    2016:	4798      	blx	r3
    2018:	e0d9      	b.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }

    // Put the signature context on the heap
    sig = (SigInfoCtx*) AJ_Malloc(sizeof (SigInfoCtx));
    201a:	20ac      	movs	r0, #172	; 0xac
    201c:	4b81      	ldr	r3, [pc, #516]	; (2224 <STACK_SIZE+0x224>)
    201e:	4798      	blx	r3
    2020:	1e06      	subs	r6, r0, #0
    if (NULL == sig) {
    2022:	d100      	bne.n	2026 <STACK_SIZE+0x26>
    2024:	e0d2      	b.n	21cc <STACK_SIZE+0x1cc>
        status = AJ_ERR_RESOURCES;
        goto Exit;
    }
    // The credential holds a pointer to an ecc_privatekey
    if (sizeof (ecc_privatekey) != cred.len) {
        status = AJ_ERR_INVALID;
    2026:	2403      	movs	r4, #3
    if (NULL == sig) {
        status = AJ_ERR_RESOURCES;
        goto Exit;
    }
    // The credential holds a pointer to an ecc_privatekey
    if (sizeof (ecc_privatekey) != cred.len) {
    2028:	9b15      	ldr	r3, [sp, #84]	; 0x54
    202a:	2b24      	cmp	r3, #36	; 0x24
    202c:	d000      	beq.n	2030 <STACK_SIZE+0x30>
    202e:	e0c7      	b.n	21c0 <STACK_SIZE+0x1c0>
        status = AJ_ERR_INVALID;
        goto Exit;
    }
    memcpy((uint8_t*) &sig->prv, cred.data, cred.len);
    2030:	9b14      	ldr	r3, [sp, #80]	; 0x50
    2032:	9307      	str	r3, [sp, #28]
    2034:	1c19      	adds	r1, r3, #0
    2036:	2224      	movs	r2, #36	; 0x24
    2038:	4b7b      	ldr	r3, [pc, #492]	; (2228 <STACK_SIZE+0x228>)
    203a:	4798      	blx	r3
    ctx->expiration = cred.expiration;
    203c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    203e:	2390      	movs	r3, #144	; 0x90
    2040:	005b      	lsls	r3, r3, #1
    2042:	50fa      	str	r2, [r7, r3]

    // Sign verifier
    status = AJ_DSASignDigest(verifier, &sig->prv, &sig->sig);
    2044:	3bfc      	subs	r3, #252	; 0xfc
    2046:	469c      	mov	ip, r3
    2048:	44b4      	add	ip, r6
    204a:	4663      	mov	r3, ip
    204c:	4662      	mov	r2, ip
    204e:	9307      	str	r3, [sp, #28]
    2050:	a816      	add	r0, sp, #88	; 0x58
    2052:	1c31      	adds	r1, r6, #0
    2054:	4b75      	ldr	r3, [pc, #468]	; (222c <STACK_SIZE+0x22c>)
    2056:	4798      	blx	r3
    2058:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    205a:	d00d      	beq.n	2078 <STACK_SIZE+0x78>
        AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Sign verifier error\n", msg));
    205c:	2002      	movs	r0, #2
    205e:	496c      	ldr	r1, [pc, #432]	; (2210 <STACK_SIZE+0x210>)
    2060:	2294      	movs	r2, #148	; 0x94
    2062:	0092      	lsls	r2, r2, #2
    2064:	4b6c      	ldr	r3, [pc, #432]	; (2218 <STACK_SIZE+0x218>)
    2066:	4798      	blx	r3
    2068:	2800      	cmp	r0, #0
    206a:	d100      	bne.n	206e <STACK_SIZE+0x6e>
    206c:	e0a8      	b.n	21c0 <STACK_SIZE+0x1c0>
    206e:	4870      	ldr	r0, [pc, #448]	; (2230 <STACK_SIZE+0x230>)
    2070:	1c29      	adds	r1, r5, #0
    2072:	4b6b      	ldr	r3, [pc, #428]	; (2220 <STACK_SIZE+0x220>)
    2074:	4798      	blx	r3
    2076:	e0a3      	b.n	21c0 <STACK_SIZE+0x1c0>
        goto Exit;
    }
    AJ_BigvalEncode(&sig->sig.r, sig->sig_r, KEY_ECC_SZ);
    2078:	236c      	movs	r3, #108	; 0x6c
    207a:	469a      	mov	sl, r3
    207c:	44b2      	add	sl, r6
    207e:	9807      	ldr	r0, [sp, #28]
    2080:	4651      	mov	r1, sl
    2082:	2220      	movs	r2, #32
    2084:	4c6b      	ldr	r4, [pc, #428]	; (2234 <STACK_SIZE+0x234>)
    2086:	47a0      	blx	r4
    AJ_BigvalEncode(&sig->sig.s, sig->sig_s, KEY_ECC_SZ);
    2088:	238c      	movs	r3, #140	; 0x8c
    208a:	4699      	mov	r9, r3
    208c:	44b1      	add	r9, r6
    208e:	1c30      	adds	r0, r6, #0
    2090:	3048      	adds	r0, #72	; 0x48
    2092:	4649      	mov	r1, r9
    2094:	2220      	movs	r2, #32
    2096:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, sig->sig_r, KEY_ECC_SZ);
    2098:	2310      	movs	r3, #16
    209a:	469c      	mov	ip, r3
    209c:	44bc      	add	ip, r7
    209e:	4663      	mov	r3, ip
    20a0:	9307      	str	r3, [sp, #28]
    20a2:	4660      	mov	r0, ip
    20a4:	4651      	mov	r1, sl
    20a6:	2220      	movs	r2, #32
    20a8:	4c55      	ldr	r4, [pc, #340]	; (2200 <STACK_SIZE+0x200>)
    20aa:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, sig->sig_s, KEY_ECC_SZ);
    20ac:	9807      	ldr	r0, [sp, #28]
    20ae:	4649      	mov	r1, r9
    20b0:	2220      	movs	r2, #32
    20b2:	47a0      	blx	r4

    // Marshal signature
    status = AJ_MarshalVariant(msg, "(vyv)");
    20b4:	1c28      	adds	r0, r5, #0
    20b6:	4960      	ldr	r1, [pc, #384]	; (2238 <STACK_SIZE+0x238>)
    20b8:	4b60      	ldr	r3, [pc, #384]	; (223c <STACK_SIZE+0x23c>)
    20ba:	4798      	blx	r3
    20bc:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    20be:	d000      	beq.n	20c2 <STACK_SIZE+0xc2>
    20c0:	e07e      	b.n	21c0 <STACK_SIZE+0x1c0>
        goto Exit;
    }
    status = AJ_MarshalContainer(msg, &container1, AJ_ARG_STRUCT);
    20c2:	1c28      	adds	r0, r5, #0
    20c4:	a90a      	add	r1, sp, #40	; 0x28
    20c6:	2228      	movs	r2, #40	; 0x28
    20c8:	4b5d      	ldr	r3, [pc, #372]	; (2240 <STACK_SIZE+0x240>)
    20ca:	4798      	blx	r3
    20cc:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    20ce:	d177      	bne.n	21c0 <STACK_SIZE+0x1c0>
        goto Exit;
    }
    status = AJ_MarshalArgs(msg, "v", "(yv)", SIG_FMT, "(ayay)", sig->sig_r, KEY_ECC_SZ, sig->sig_s, KEY_ECC_SZ);
    20d0:	4b4e      	ldr	r3, [pc, #312]	; (220c <STACK_SIZE+0x20c>)
    20d2:	9300      	str	r3, [sp, #0]
    20d4:	4653      	mov	r3, sl
    20d6:	9301      	str	r3, [sp, #4]
    20d8:	2320      	movs	r3, #32
    20da:	9302      	str	r3, [sp, #8]
    20dc:	464a      	mov	r2, r9
    20de:	9203      	str	r2, [sp, #12]
    20e0:	9304      	str	r3, [sp, #16]
    20e2:	1c28      	adds	r0, r5, #0
    20e4:	4943      	ldr	r1, [pc, #268]	; (21f4 <STACK_SIZE+0x1f4>)
    20e6:	4a57      	ldr	r2, [pc, #348]	; (2244 <STACK_SIZE+0x244>)
    20e8:	2300      	movs	r3, #0
    20ea:	4c44      	ldr	r4, [pc, #272]	; (21fc <STACK_SIZE+0x1fc>)
    20ec:	47a0      	blx	r4
    20ee:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    20f0:	d166      	bne.n	21c0 <STACK_SIZE+0x1c0>
        goto Exit;
    }
    AJ_Free(sig);
    20f2:	1c30      	adds	r0, r6, #0
    20f4:	4b54      	ldr	r3, [pc, #336]	; (2248 <STACK_SIZE+0x248>)
    20f6:	4798      	blx	r3
    sig = NULL;

    // Marshal certificate chain
    fmt = CERT_FMT_X509_DER;
    20f8:	341f      	adds	r4, #31
    20fa:	ab02      	add	r3, sp, #8
    20fc:	469c      	mov	ip, r3
    20fe:	4464      	add	r4, ip
    2100:	2300      	movs	r3, #0
    2102:	7023      	strb	r3, [r4, #0]
    AJ_SHA256_Update(&ctx->hash, &fmt, 1);
    2104:	9807      	ldr	r0, [sp, #28]
    2106:	1c21      	adds	r1, r4, #0
    2108:	2201      	movs	r2, #1
    210a:	4b3d      	ldr	r3, [pc, #244]	; (2200 <STACK_SIZE+0x200>)
    210c:	4798      	blx	r3
    status = AJ_MarshalArgs(msg, "y", fmt);
    210e:	7822      	ldrb	r2, [r4, #0]
    2110:	1c28      	adds	r0, r5, #0
    2112:	494e      	ldr	r1, [pc, #312]	; (224c <STACK_SIZE+0x24c>)
    2114:	4b39      	ldr	r3, [pc, #228]	; (21fc <STACK_SIZE+0x1fc>)
    2116:	4798      	blx	r3
    2118:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    211a:	d158      	bne.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }
    status = AJ_MarshalVariant(msg, "a(ay)");
    211c:	1c28      	adds	r0, r5, #0
    211e:	494c      	ldr	r1, [pc, #304]	; (2250 <STACK_SIZE+0x250>)
    2120:	4b46      	ldr	r3, [pc, #280]	; (223c <STACK_SIZE+0x23c>)
    2122:	4798      	blx	r3
    2124:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    2126:	d152      	bne.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }
    status = AJ_MarshalContainer(msg, &container2, AJ_ARG_ARRAY);
    2128:	1c28      	adds	r0, r5, #0
    212a:	a90e      	add	r1, sp, #56	; 0x38
    212c:	2261      	movs	r2, #97	; 0x61
    212e:	4b44      	ldr	r3, [pc, #272]	; (2240 <STACK_SIZE+0x240>)
    2130:	4798      	blx	r3
    2132:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    2134:	d14b      	bne.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }

    // Request certificate chain from application
    cred.direction = AJ_CRED_REQUEST;
    2136:	aa12      	add	r2, sp, #72	; 0x48
    2138:	2300      	movs	r3, #0
    213a:	7013      	strb	r3, [r2, #0]
    status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_ECDSA, AJ_CRED_CERT_CHAIN, &cred);
    213c:	683b      	ldr	r3, [r7, #0]
    213e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    2140:	4827      	ldr	r0, [pc, #156]	; (21e0 <STACK_SIZE+0x1e0>)
    2142:	2103      	movs	r1, #3
    2144:	4798      	blx	r3
    2146:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    2148:	d00c      	beq.n	2164 <STACK_SIZE+0x164>
        AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Certificate chain required\n", msg));
    214a:	2002      	movs	r0, #2
    214c:	4930      	ldr	r1, [pc, #192]	; (2210 <STACK_SIZE+0x210>)
    214e:	229f      	movs	r2, #159	; 0x9f
    2150:	0092      	lsls	r2, r2, #2
    2152:	4b31      	ldr	r3, [pc, #196]	; (2218 <STACK_SIZE+0x218>)
    2154:	4798      	blx	r3
    2156:	2800      	cmp	r0, #0
    2158:	d039      	beq.n	21ce <STACK_SIZE+0x1ce>
    215a:	483e      	ldr	r0, [pc, #248]	; (2254 <STACK_SIZE+0x254>)
    215c:	1c29      	adds	r1, r5, #0
    215e:	4b30      	ldr	r3, [pc, #192]	; (2220 <STACK_SIZE+0x220>)
    2160:	4798      	blx	r3
    2162:	e034      	b.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }
    // The credential holds a pointer to a certificate chain
    chain = (X509CertificateChain*) cred.data;
    2164:	9e14      	ldr	r6, [sp, #80]	; 0x50
        if (AJ_OK != status) {
            AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Marshal certificate error\n", msg));
            goto Exit;
        }
        AJ_SHA256_Update(&ctx->hash, chain->certificate.der.data, chain->certificate.der.size);
        chain = chain->next;
    2166:	23e0      	movs	r3, #224	; 0xe0
    2168:	4698      	mov	r8, r3
    216a:	e01b      	b.n	21a4 <STACK_SIZE+0x1a4>
        goto Exit;
    }
    // The credential holds a pointer to a certificate chain
    chain = (X509CertificateChain*) cred.data;
    while (chain) {
        status = AJ_MarshalArgs(msg, "(ay)", chain->certificate.der.data, chain->certificate.der.size);
    216c:	1c28      	adds	r0, r5, #0
    216e:	493a      	ldr	r1, [pc, #232]	; (2258 <STACK_SIZE+0x258>)
    2170:	6872      	ldr	r2, [r6, #4]
    2172:	6833      	ldr	r3, [r6, #0]
    2174:	4c21      	ldr	r4, [pc, #132]	; (21fc <STACK_SIZE+0x1fc>)
    2176:	47a0      	blx	r4
    2178:	1e04      	subs	r4, r0, #0
        if (AJ_OK != status) {
    217a:	d00c      	beq.n	2196 <STACK_SIZE+0x196>
            AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Marshal certificate error\n", msg));
    217c:	2002      	movs	r0, #2
    217e:	4924      	ldr	r1, [pc, #144]	; (2210 <STACK_SIZE+0x210>)
    2180:	22a1      	movs	r2, #161	; 0xa1
    2182:	0092      	lsls	r2, r2, #2
    2184:	4b24      	ldr	r3, [pc, #144]	; (2218 <STACK_SIZE+0x218>)
    2186:	4798      	blx	r3
    2188:	2800      	cmp	r0, #0
    218a:	d020      	beq.n	21ce <STACK_SIZE+0x1ce>
    218c:	4833      	ldr	r0, [pc, #204]	; (225c <STACK_SIZE+0x25c>)
    218e:	1c29      	adds	r1, r5, #0
    2190:	4b23      	ldr	r3, [pc, #140]	; (2220 <STACK_SIZE+0x220>)
    2192:	4798      	blx	r3
    2194:	e01b      	b.n	21ce <STACK_SIZE+0x1ce>
            goto Exit;
        }
        AJ_SHA256_Update(&ctx->hash, chain->certificate.der.data, chain->certificate.der.size);
    2196:	9807      	ldr	r0, [sp, #28]
    2198:	6871      	ldr	r1, [r6, #4]
    219a:	6832      	ldr	r2, [r6, #0]
    219c:	4b18      	ldr	r3, [pc, #96]	; (2200 <STACK_SIZE+0x200>)
    219e:	4798      	blx	r3
        chain = chain->next;
    21a0:	4643      	mov	r3, r8
    21a2:	58f6      	ldr	r6, [r6, r3]
        AJ_WarnPrintf(("AJ_ECDSA_Marshal(msg=%p): Certificate chain required\n", msg));
        goto Exit;
    }
    // The credential holds a pointer to a certificate chain
    chain = (X509CertificateChain*) cred.data;
    while (chain) {
    21a4:	2e00      	cmp	r6, #0
    21a6:	d1e1      	bne.n	216c <STACK_SIZE+0x16c>
            goto Exit;
        }
        AJ_SHA256_Update(&ctx->hash, chain->certificate.der.data, chain->certificate.der.size);
        chain = chain->next;
    }
    status = AJ_MarshalCloseContainer(msg, &container2);
    21a8:	1c28      	adds	r0, r5, #0
    21aa:	a90e      	add	r1, sp, #56	; 0x38
    21ac:	4b2c      	ldr	r3, [pc, #176]	; (2260 <STACK_SIZE+0x260>)
    21ae:	4798      	blx	r3
    21b0:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) {
    21b2:	d10c      	bne.n	21ce <STACK_SIZE+0x1ce>
        goto Exit;
    }
    status = AJ_MarshalCloseContainer(msg, &container1);
    21b4:	1c28      	adds	r0, r5, #0
    21b6:	a90a      	add	r1, sp, #40	; 0x28
    21b8:	4b29      	ldr	r3, [pc, #164]	; (2260 <STACK_SIZE+0x260>)
    21ba:	4798      	blx	r3
    21bc:	1c04      	adds	r4, r0, #0
    21be:	e006      	b.n	21ce <STACK_SIZE+0x1ce>

Exit:
    if (sig) {
        AJ_Free(sig);
    21c0:	1c30      	adds	r0, r6, #0
    21c2:	4b21      	ldr	r3, [pc, #132]	; (2248 <STACK_SIZE+0x248>)
    21c4:	4798      	blx	r3
    21c6:	e002      	b.n	21ce <STACK_SIZE+0x1ce>
    uint8_t fmt;

    AJ_InfoPrintf(("AJ_ECDSA_Marshal(ctx=%p, msg=%p)\n", ctx, msg));

    if (NULL == ctx->bus->authListenerCallback) {
        status = AJ_ERR_INVALID;
    21c8:	2403      	movs	r4, #3
    21ca:	e000      	b.n	21ce <STACK_SIZE+0x1ce>
    }

    // Put the signature context on the heap
    sig = (SigInfoCtx*) AJ_Malloc(sizeof (SigInfoCtx));
    if (NULL == sig) {
        status = AJ_ERR_RESOURCES;
    21cc:	240b      	movs	r4, #11
    case AUTH_SUITE_ECDHE_ECDSA:
        status = ECDSAMarshal(ctx, msg);
        break;
    }
    return status;
}
    21ce:	1c20      	adds	r0, r4, #0
    21d0:	b01e      	add	sp, #120	; 0x78
    21d2:	bc1c      	pop	{r2, r3, r4}
    21d4:	4690      	mov	r8, r2
    21d6:	4699      	mov	r9, r3
    21d8:	46a2      	mov	sl, r4
    21da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    21dc:	00400002 	.word	0x00400002
    21e0:	00400004 	.word	0x00400004
    21e4:	00400001 	.word	0x00400001
    21e8:	0001a330 	.word	0x0001a330
    21ec:	00001a6d 	.word	0x00001a6d
    21f0:	0001a340 	.word	0x0001a340
    21f4:	0001f18c 	.word	0x0001f18c
    21f8:	0001ecdc 	.word	0x0001ecdc
    21fc:	0000bc85 	.word	0x0000bc85
    2200:	00006139 	.word	0x00006139
    2204:	0001a350 	.word	0x0001a350
    2208:	0000198d 	.word	0x0000198d
    220c:	0001a35c 	.word	0x0001a35c
    2210:	0001a0a4 	.word	0x0001a0a4
    2214:	0000023b 	.word	0x0000023b
    2218:	0000636d 	.word	0x0000636d
    221c:	0001a364 	.word	0x0001a364
    2220:	00016e3d 	.word	0x00016e3d
    2224:	0000d7dd 	.word	0x0000d7dd
    2228:	00016739 	.word	0x00016739
    222c:	0000601d 	.word	0x0000601d
    2230:	0001a394 	.word	0x0001a394
    2234:	00005e9d 	.word	0x00005e9d
    2238:	0001a3c4 	.word	0x0001a3c4
    223c:	0000b9fd 	.word	0x0000b9fd
    2240:	0000b8a1 	.word	0x0000b8a1
    2244:	0001a3cc 	.word	0x0001a3cc
    2248:	0000d7e9 	.word	0x0000d7e9
    224c:	0001ccb0 	.word	0x0001ccb0
    2250:	0001a3d4 	.word	0x0001a3d4
    2254:	0001a3dc 	.word	0x0001a3dc
    2258:	0001a414 	.word	0x0001a414
    225c:	0001a41c 	.word	0x0001a41c
    2260:	0000b8d1 	.word	0x0000b8d1

00002264 <AJ_KeyAuthenticationUnmarshal>:

AJ_Status AJ_KeyAuthenticationUnmarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    2264:	b5f0      	push	{r4, r5, r6, r7, lr}
    2266:	4657      	mov	r7, sl
    2268:	4646      	mov	r6, r8
    226a:	b4c0      	push	{r6, r7}
    226c:	b0b7      	sub	sp, #220	; 0xdc
    226e:	1c05      	adds	r5, r0, #0
    2270:	1c0e      	adds	r6, r1, #0
    AJ_Status status = AJ_ERR_SECURITY;
    switch (ctx->suite) {
    2272:	6883      	ldr	r3, [r0, #8]
    2274:	4ad8      	ldr	r2, [pc, #864]	; (25d8 <AJ_KeyAuthenticationUnmarshal+0x374>)
    2276:	4293      	cmp	r3, r2
    2278:	d041      	beq.n	22fe <AJ_KeyAuthenticationUnmarshal+0x9a>
    227a:	4ad8      	ldr	r2, [pc, #864]	; (25dc <AJ_KeyAuthenticationUnmarshal+0x378>)
    227c:	4293      	cmp	r3, r2
    227e:	d100      	bne.n	2282 <AJ_KeyAuthenticationUnmarshal+0x1e>
    2280:	e088      	b.n	2394 <AJ_KeyAuthenticationUnmarshal+0x130>
    2282:	4ad7      	ldr	r2, [pc, #860]	; (25e0 <AJ_KeyAuthenticationUnmarshal+0x37c>)
    return status;
}

AJ_Status AJ_KeyAuthenticationUnmarshal(AJ_AuthenticationContext* ctx, AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_SECURITY;
    2284:	200d      	movs	r0, #13
    switch (ctx->suite) {
    2286:	4293      	cmp	r3, r2
    2288:	d000      	beq.n	228c <AJ_KeyAuthenticationUnmarshal+0x28>
    228a:	e20d      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    uint8_t* remote;
    size_t len;

    AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p)\n", ctx, msg));

    if (AUTH_CLIENT == ctx->role) {
    228c:	792b      	ldrb	r3, [r5, #4]
    228e:	2b00      	cmp	r3, #0
    2290:	d107      	bne.n	22a2 <AJ_KeyAuthenticationUnmarshal+0x3e>
        status = ComputeVerifier(ctx, "server finished", local, sizeof (local));
    2292:	1c28      	adds	r0, r5, #0
    2294:	49d3      	ldr	r1, [pc, #844]	; (25e4 <AJ_KeyAuthenticationUnmarshal+0x380>)
    2296:	aa24      	add	r2, sp, #144	; 0x90
    2298:	3320      	adds	r3, #32
    229a:	4cd3      	ldr	r4, [pc, #844]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    229c:	47a0      	blx	r4
    229e:	1c03      	adds	r3, r0, #0
    22a0:	e006      	b.n	22b0 <AJ_KeyAuthenticationUnmarshal+0x4c>
    } else {
        status = ComputeVerifier(ctx, "client finished", local, sizeof (local));
    22a2:	1c28      	adds	r0, r5, #0
    22a4:	49d1      	ldr	r1, [pc, #836]	; (25ec <AJ_KeyAuthenticationUnmarshal+0x388>)
    22a6:	aa24      	add	r2, sp, #144	; 0x90
    22a8:	2320      	movs	r3, #32
    22aa:	4ccf      	ldr	r4, [pc, #828]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    22ac:	47a0      	blx	r4
    22ae:	1c03      	adds	r3, r0, #0
    }
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    22b0:	200d      	movs	r0, #13
    if (AUTH_CLIENT == ctx->role) {
        status = ComputeVerifier(ctx, "server finished", local, sizeof (local));
    } else {
        status = ComputeVerifier(ctx, "client finished", local, sizeof (local));
    }
    if (AJ_OK != status) {
    22b2:	2b00      	cmp	r3, #0
    22b4:	d000      	beq.n	22b8 <AJ_KeyAuthenticationUnmarshal+0x54>
    22b6:	e1f7      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        return AJ_ERR_SECURITY;
    }
    status = AJ_UnmarshalArgs(msg, "v", "ay", &remote, &len);
    22b8:	ab1c      	add	r3, sp, #112	; 0x70
    22ba:	9300      	str	r3, [sp, #0]
    22bc:	1c30      	adds	r0, r6, #0
    22be:	49cc      	ldr	r1, [pc, #816]	; (25f0 <AJ_KeyAuthenticationUnmarshal+0x38c>)
    22c0:	4acc      	ldr	r2, [pc, #816]	; (25f4 <AJ_KeyAuthenticationUnmarshal+0x390>)
    22c2:	ab18      	add	r3, sp, #96	; 0x60
    22c4:	4ccc      	ldr	r4, [pc, #816]	; (25f8 <AJ_KeyAuthenticationUnmarshal+0x394>)
    22c6:	47a0      	blx	r4
    22c8:	1c03      	adds	r3, r0, #0
    if (AJ_OK != status) {
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return AJ_ERR_SECURITY;
    22ca:	200d      	movs	r0, #13
    }
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    }
    status = AJ_UnmarshalArgs(msg, "v", "ay", &remote, &len);
    if (AJ_OK != status) {
    22cc:	2b00      	cmp	r3, #0
    22ce:	d000      	beq.n	22d2 <AJ_KeyAuthenticationUnmarshal+0x6e>
    22d0:	e1ea      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Unmarshal error\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    if (AUTH_VERIFIER_LEN != len) {
    22d2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    22d4:	2b20      	cmp	r3, #32
    22d6:	d000      	beq.n	22da <AJ_KeyAuthenticationUnmarshal+0x76>
    22d8:	e1e6      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Invalid signature size\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    if (0 != memcmp(local, remote, AUTH_VERIFIER_LEN)) {
    22da:	a824      	add	r0, sp, #144	; 0x90
    22dc:	9918      	ldr	r1, [sp, #96]	; 0x60
    22de:	2220      	movs	r2, #32
    22e0:	4bc6      	ldr	r3, [pc, #792]	; (25fc <AJ_KeyAuthenticationUnmarshal+0x398>)
    22e2:	4798      	blx	r3
    22e4:	1c03      	adds	r3, r0, #0
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Invalid verifier\n", ctx, msg));
        return AJ_ERR_SECURITY;
    22e6:	200d      	movs	r0, #13
    }
    if (AUTH_VERIFIER_LEN != len) {
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Invalid signature size\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    if (0 != memcmp(local, remote, AUTH_VERIFIER_LEN)) {
    22e8:	2b00      	cmp	r3, #0
    22ea:	d000      	beq.n	22ee <AJ_KeyAuthenticationUnmarshal+0x8a>
    22ec:	e1dc      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        AJ_InfoPrintf(("NULLUnmarshal(ctx=%p, msg=%p): Invalid verifier\n", ctx, msg));
        return AJ_ERR_SECURITY;
    }
    AJ_SHA256_Update(&ctx->hash, local, sizeof (local));
    22ee:	1c28      	adds	r0, r5, #0
    22f0:	3010      	adds	r0, #16
    22f2:	a924      	add	r1, sp, #144	; 0x90
    22f4:	2220      	movs	r2, #32
    22f6:	4bc2      	ldr	r3, [pc, #776]	; (2600 <AJ_KeyAuthenticationUnmarshal+0x39c>)
    22f8:	4798      	blx	r3

    return status;
    22fa:	2000      	movs	r0, #0
    22fc:	e1d4      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    uint8_t* data;
    size_t size;

    AJ_InfoPrintf(("PSKUnmarshal(ctx=%p, msg=%p)\n", ctx, msg));

    status = AJ_UnmarshalArgs(msg, "v", "(ayay)", &ctx->kactx.psk.hint, &ctx->kactx.psk.size, &data, &size);
    22fe:	1c03      	adds	r3, r0, #0
    2300:	33e8      	adds	r3, #232	; 0xe8
    2302:	1c02      	adds	r2, r0, #0
    2304:	32ec      	adds	r2, #236	; 0xec
    2306:	9200      	str	r2, [sp, #0]
    2308:	aa18      	add	r2, sp, #96	; 0x60
    230a:	9201      	str	r2, [sp, #4]
    230c:	aa1c      	add	r2, sp, #112	; 0x70
    230e:	9202      	str	r2, [sp, #8]
    2310:	1c08      	adds	r0, r1, #0
    2312:	49b7      	ldr	r1, [pc, #732]	; (25f0 <AJ_KeyAuthenticationUnmarshal+0x38c>)
    2314:	4abb      	ldr	r2, [pc, #748]	; (2604 <AJ_KeyAuthenticationUnmarshal+0x3a0>)
    2316:	4cb8      	ldr	r4, [pc, #736]	; (25f8 <AJ_KeyAuthenticationUnmarshal+0x394>)
    2318:	47a0      	blx	r4
    231a:	1c04      	adds	r4, r0, #0
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    231c:	200d      	movs	r0, #13
    size_t size;

    AJ_InfoPrintf(("PSKUnmarshal(ctx=%p, msg=%p)\n", ctx, msg));

    status = AJ_UnmarshalArgs(msg, "v", "(ayay)", &ctx->kactx.psk.hint, &ctx->kactx.psk.size, &data, &size);
    if (AJ_OK != status) {
    231e:	2c00      	cmp	r4, #0
    2320:	d000      	beq.n	2324 <AJ_KeyAuthenticationUnmarshal+0xc0>
    2322:	e1c1      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        return AJ_ERR_SECURITY;
    }
    if (AUTH_VERIFIER_LEN != size) {
    2324:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    2326:	2b20      	cmp	r3, #32
    2328:	d000      	beq.n	232c <AJ_KeyAuthenticationUnmarshal+0xc8>
    232a:	e1bd      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        return AJ_ERR_SECURITY;
    }

    switch (ctx->role) {
    232c:	792b      	ldrb	r3, [r5, #4]
    232e:	2b00      	cmp	r3, #0
    2330:	d002      	beq.n	2338 <AJ_KeyAuthenticationUnmarshal+0xd4>
    2332:	2b01      	cmp	r3, #1
    2334:	d008      	beq.n	2348 <AJ_KeyAuthenticationUnmarshal+0xe4>
    2336:	e01d      	b.n	2374 <AJ_KeyAuthenticationUnmarshal+0x110>
    case AUTH_CLIENT:
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
    2338:	1c28      	adds	r0, r5, #0
    233a:	49aa      	ldr	r1, [pc, #680]	; (25e4 <AJ_KeyAuthenticationUnmarshal+0x380>)
    233c:	aa24      	add	r2, sp, #144	; 0x90
    233e:	2320      	movs	r3, #32
    2340:	4ca9      	ldr	r4, [pc, #676]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    2342:	47a0      	blx	r4
    2344:	1c04      	adds	r4, r0, #0
    2346:	e015      	b.n	2374 <AJ_KeyAuthenticationUnmarshal+0x110>
        break;

    case AUTH_SERVER:
        status = PSKCallback(ctx, msg);
    2348:	1c28      	adds	r0, r5, #0
    234a:	1c31      	adds	r1, r6, #0
    234c:	4bae      	ldr	r3, [pc, #696]	; (2608 <AJ_KeyAuthenticationUnmarshal+0x3a4>)
    234e:	4798      	blx	r3
    2350:	1c03      	adds	r3, r0, #0
        if (AJ_OK != status) {
            return AJ_ERR_SECURITY;
    2352:	200d      	movs	r0, #13
        status = ComputeVerifier(ctx, "server finished", verifier, sizeof (verifier));
        break;

    case AUTH_SERVER:
        status = PSKCallback(ctx, msg);
        if (AJ_OK != status) {
    2354:	2b00      	cmp	r3, #0
    2356:	d000      	beq.n	235a <AJ_KeyAuthenticationUnmarshal+0xf6>
    2358:	e1a6      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
            return AJ_ERR_SECURITY;
        }
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
    235a:	1c28      	adds	r0, r5, #0
    235c:	49a3      	ldr	r1, [pc, #652]	; (25ec <AJ_KeyAuthenticationUnmarshal+0x388>)
    235e:	aa24      	add	r2, sp, #144	; 0x90
    2360:	3320      	adds	r3, #32
    2362:	4ca1      	ldr	r4, [pc, #644]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    2364:	47a0      	blx	r4
    2366:	1c04      	adds	r4, r0, #0
        AJ_SHA256_Update(&ctx->hash, verifier, sizeof (verifier));
    2368:	1c28      	adds	r0, r5, #0
    236a:	3010      	adds	r0, #16
    236c:	a924      	add	r1, sp, #144	; 0x90
    236e:	2220      	movs	r2, #32
    2370:	4ba3      	ldr	r3, [pc, #652]	; (2600 <AJ_KeyAuthenticationUnmarshal+0x39c>)
    2372:	4798      	blx	r3
        break;
    }
    if (AJ_OK != status) {
        return AJ_ERR_SECURITY;
    2374:	200d      	movs	r0, #13
        }
        status = ComputeVerifier(ctx, "client finished", verifier, sizeof (verifier));
        AJ_SHA256_Update(&ctx->hash, verifier, sizeof (verifier));
        break;
    }
    if (AJ_OK != status) {
    2376:	2c00      	cmp	r4, #0
    2378:	d000      	beq.n	237c <AJ_KeyAuthenticationUnmarshal+0x118>
    237a:	e195      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        return AJ_ERR_SECURITY;
    }

    if (0 != memcmp(verifier, data, AUTH_VERIFIER_LEN)) {
    237c:	a824      	add	r0, sp, #144	; 0x90
    237e:	9918      	ldr	r1, [sp, #96]	; 0x60
    2380:	2220      	movs	r2, #32
    2382:	4b9e      	ldr	r3, [pc, #632]	; (25fc <AJ_KeyAuthenticationUnmarshal+0x398>)
    2384:	4798      	blx	r3
    2386:	1c03      	adds	r3, r0, #0
        AJ_InfoPrintf(("PSKUnmarshal(ctx=%p, msg=%p): Invalid verifier\n", ctx, msg));
        return AJ_ERR_SECURITY;
    2388:	200d      	movs	r0, #13
    }

    return status;
    238a:	1e5a      	subs	r2, r3, #1
    238c:	4193      	sbcs	r3, r2
    238e:	425b      	negs	r3, r3
    2390:	4018      	ands	r0, r3
    2392:	e189      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    X509CertificateChain* node = NULL;
    uint8_t trusted = 0;

    AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p)\n", msg));

    if (NULL == ctx->bus->authListenerCallback) {
    2394:	6803      	ldr	r3, [r0, #0]
    2396:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    2398:	2b00      	cmp	r3, #0
    239a:	d100      	bne.n	239e <AJ_KeyAuthenticationUnmarshal+0x13a>
    239c:	e16d      	b.n	267a <AJ_KeyAuthenticationUnmarshal+0x416>
        return AJ_ERR_SECURITY;
    }

    if (AUTH_CLIENT == ctx->role) {
    239e:	7903      	ldrb	r3, [r0, #4]
    23a0:	2b00      	cmp	r3, #0
    23a2:	d105      	bne.n	23b0 <AJ_KeyAuthenticationUnmarshal+0x14c>
        status = ComputeVerifier(ctx, "server finished", digest, sizeof (digest));
    23a4:	498f      	ldr	r1, [pc, #572]	; (25e4 <AJ_KeyAuthenticationUnmarshal+0x380>)
    23a6:	aa1c      	add	r2, sp, #112	; 0x70
    23a8:	3320      	adds	r3, #32
    23aa:	4c8f      	ldr	r4, [pc, #572]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    23ac:	47a0      	blx	r4
    23ae:	e004      	b.n	23ba <AJ_KeyAuthenticationUnmarshal+0x156>
    } else {
        status = ComputeVerifier(ctx, "client finished", digest, sizeof (digest));
    23b0:	498e      	ldr	r1, [pc, #568]	; (25ec <AJ_KeyAuthenticationUnmarshal+0x388>)
    23b2:	aa1c      	add	r2, sp, #112	; 0x70
    23b4:	2320      	movs	r3, #32
    23b6:	4c8c      	ldr	r4, [pc, #560]	; (25e8 <AJ_KeyAuthenticationUnmarshal+0x384>)
    23b8:	47a0      	blx	r4
    }
    if (AJ_OK != status) {
    23ba:	2800      	cmp	r0, #0
    23bc:	d000      	beq.n	23c0 <AJ_KeyAuthenticationUnmarshal+0x15c>
    23be:	e15e      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }

    status = AJ_UnmarshalVariant(msg, &variant);
    23c0:	1c30      	adds	r0, r6, #0
    23c2:	a909      	add	r1, sp, #36	; 0x24
    23c4:	4b91      	ldr	r3, [pc, #580]	; (260c <AJ_KeyAuthenticationUnmarshal+0x3a8>)
    23c6:	4798      	blx	r3
    if (AJ_OK != status) {
    23c8:	2800      	cmp	r0, #0
    23ca:	d000      	beq.n	23ce <AJ_KeyAuthenticationUnmarshal+0x16a>
    23cc:	e157      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    if (0 != strncmp(variant, "(vyv)", 5)) {
    23ce:	9809      	ldr	r0, [sp, #36]	; 0x24
    23d0:	498f      	ldr	r1, [pc, #572]	; (2610 <AJ_KeyAuthenticationUnmarshal+0x3ac>)
    23d2:	2205      	movs	r2, #5
    23d4:	4b8f      	ldr	r3, [pc, #572]	; (2614 <AJ_KeyAuthenticationUnmarshal+0x3b0>)
    23d6:	4798      	blx	r3
    23d8:	2800      	cmp	r0, #0
    23da:	d000      	beq.n	23de <AJ_KeyAuthenticationUnmarshal+0x17a>
    23dc:	e14f      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    status = AJ_UnmarshalContainer(msg, &container1, AJ_ARG_STRUCT);
    23de:	1c30      	adds	r0, r6, #0
    23e0:	a914      	add	r1, sp, #80	; 0x50
    23e2:	2228      	movs	r2, #40	; 0x28
    23e4:	4b8c      	ldr	r3, [pc, #560]	; (2618 <AJ_KeyAuthenticationUnmarshal+0x3b4>)
    23e6:	4798      	blx	r3
    if (AJ_OK != status) {
    23e8:	2800      	cmp	r0, #0
    23ea:	d000      	beq.n	23ee <AJ_KeyAuthenticationUnmarshal+0x18a>
    23ec:	e147      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }

    // Unmarshal signature
    status = AJ_UnmarshalArgs(msg, "v", "(yv)", &fmt, "(ayay)", &sig_r, &len_r, &sig_s, &len_s);
    23ee:	4b85      	ldr	r3, [pc, #532]	; (2604 <AJ_KeyAuthenticationUnmarshal+0x3a0>)
    23f0:	9300      	str	r3, [sp, #0]
    23f2:	ab0a      	add	r3, sp, #40	; 0x28
    23f4:	9301      	str	r3, [sp, #4]
    23f6:	ab0c      	add	r3, sp, #48	; 0x30
    23f8:	9302      	str	r3, [sp, #8]
    23fa:	ab0b      	add	r3, sp, #44	; 0x2c
    23fc:	9303      	str	r3, [sp, #12]
    23fe:	ab0d      	add	r3, sp, #52	; 0x34
    2400:	9304      	str	r3, [sp, #16]
    2402:	1c30      	adds	r0, r6, #0
    2404:	497a      	ldr	r1, [pc, #488]	; (25f0 <AJ_KeyAuthenticationUnmarshal+0x38c>)
    2406:	4a85      	ldr	r2, [pc, #532]	; (261c <AJ_KeyAuthenticationUnmarshal+0x3b8>)
    2408:	231b      	movs	r3, #27
    240a:	ac02      	add	r4, sp, #8
    240c:	46a4      	mov	ip, r4
    240e:	4463      	add	r3, ip
    2410:	4c79      	ldr	r4, [pc, #484]	; (25f8 <AJ_KeyAuthenticationUnmarshal+0x394>)
    2412:	47a0      	blx	r4
    if (AJ_OK != status) {
    2414:	2800      	cmp	r0, #0
    2416:	d000      	beq.n	241a <AJ_KeyAuthenticationUnmarshal+0x1b6>
    2418:	e131      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    if (SIG_FMT != fmt) {
    241a:	231b      	movs	r3, #27
    241c:	aa02      	add	r2, sp, #8
    241e:	4694      	mov	ip, r2
    2420:	4463      	add	r3, ip
    2422:	781b      	ldrb	r3, [r3, #0]
    2424:	2b00      	cmp	r3, #0
    2426:	d000      	beq.n	242a <AJ_KeyAuthenticationUnmarshal+0x1c6>
    2428:	e129      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    if ((KEY_ECC_SZ != len_r) || (KEY_ECC_SZ != len_s)) {
    242a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    242c:	2b20      	cmp	r3, #32
    242e:	d000      	beq.n	2432 <AJ_KeyAuthenticationUnmarshal+0x1ce>
    2430:	e125      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
    2432:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2434:	2b20      	cmp	r3, #32
    2436:	d000      	beq.n	243a <AJ_KeyAuthenticationUnmarshal+0x1d6>
    2438:	e121      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    AJ_BigvalDecode(sig_r, &sig.r, KEY_ECC_SZ);
    243a:	980a      	ldr	r0, [sp, #40]	; 0x28
    243c:	a924      	add	r1, sp, #144	; 0x90
    243e:	2220      	movs	r2, #32
    2440:	4c77      	ldr	r4, [pc, #476]	; (2620 <AJ_KeyAuthenticationUnmarshal+0x3bc>)
    2442:	47a0      	blx	r4
    AJ_BigvalDecode(sig_s, &sig.s, KEY_ECC_SZ);
    2444:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2446:	a92d      	add	r1, sp, #180	; 0xb4
    2448:	2220      	movs	r2, #32
    244a:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, sig_r, KEY_ECC_SZ);
    244c:	2310      	movs	r3, #16
    244e:	469c      	mov	ip, r3
    2450:	44ac      	add	ip, r5
    2452:	4663      	mov	r3, ip
    2454:	4667      	mov	r7, ip
    2456:	9306      	str	r3, [sp, #24]
    2458:	1c18      	adds	r0, r3, #0
    245a:	990a      	ldr	r1, [sp, #40]	; 0x28
    245c:	2220      	movs	r2, #32
    245e:	4c68      	ldr	r4, [pc, #416]	; (2600 <AJ_KeyAuthenticationUnmarshal+0x39c>)
    2460:	47a0      	blx	r4
    AJ_SHA256_Update(&ctx->hash, sig_s, KEY_ECC_SZ);
    2462:	1c38      	adds	r0, r7, #0
    2464:	990b      	ldr	r1, [sp, #44]	; 0x2c
    2466:	2220      	movs	r2, #32
    2468:	47a0      	blx	r4

    // Unmarshal certificate chain
    status = AJ_UnmarshalArgs(msg, "y", &fmt);
    246a:	1c30      	adds	r0, r6, #0
    246c:	496d      	ldr	r1, [pc, #436]	; (2624 <AJ_KeyAuthenticationUnmarshal+0x3c0>)
    246e:	221b      	movs	r2, #27
    2470:	ab02      	add	r3, sp, #8
    2472:	469c      	mov	ip, r3
    2474:	4462      	add	r2, ip
    2476:	4b60      	ldr	r3, [pc, #384]	; (25f8 <AJ_KeyAuthenticationUnmarshal+0x394>)
    2478:	4798      	blx	r3
    if (AJ_OK != status) {
    247a:	2800      	cmp	r0, #0
    247c:	d000      	beq.n	2480 <AJ_KeyAuthenticationUnmarshal+0x21c>
    247e:	e0fe      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    if (CERT_FMT_X509_DER != fmt) {
    2480:	231b      	movs	r3, #27
    2482:	aa02      	add	r2, sp, #8
    2484:	4694      	mov	ip, r2
    2486:	4463      	add	r3, ip
    2488:	781b      	ldrb	r3, [r3, #0]
    248a:	2b00      	cmp	r3, #0
    248c:	d000      	beq.n	2490 <AJ_KeyAuthenticationUnmarshal+0x22c>
    248e:	e0f6      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): DER encoding expected\n", msg));
        goto Exit;
    }
    AJ_SHA256_Update(&ctx->hash, &fmt, 1);
    2490:	9806      	ldr	r0, [sp, #24]
    2492:	211b      	movs	r1, #27
    2494:	4461      	add	r1, ip
    2496:	2201      	movs	r2, #1
    2498:	4b59      	ldr	r3, [pc, #356]	; (2600 <AJ_KeyAuthenticationUnmarshal+0x39c>)
    249a:	4798      	blx	r3
    status = AJ_UnmarshalVariant(msg, &variant);
    249c:	1c30      	adds	r0, r6, #0
    249e:	a909      	add	r1, sp, #36	; 0x24
    24a0:	4b5a      	ldr	r3, [pc, #360]	; (260c <AJ_KeyAuthenticationUnmarshal+0x3a8>)
    24a2:	4798      	blx	r3
    if (AJ_OK != status) {
    24a4:	2800      	cmp	r0, #0
    24a6:	d000      	beq.n	24aa <AJ_KeyAuthenticationUnmarshal+0x246>
    24a8:	e0e9      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    if (0 != strncmp(variant, "a(ay)", 5)) {
    24aa:	9809      	ldr	r0, [sp, #36]	; 0x24
    24ac:	495e      	ldr	r1, [pc, #376]	; (2628 <AJ_KeyAuthenticationUnmarshal+0x3c4>)
    24ae:	2205      	movs	r2, #5
    24b0:	4b58      	ldr	r3, [pc, #352]	; (2614 <AJ_KeyAuthenticationUnmarshal+0x3b0>)
    24b2:	4798      	blx	r3
    24b4:	2800      	cmp	r0, #0
    24b6:	d000      	beq.n	24ba <AJ_KeyAuthenticationUnmarshal+0x256>
    24b8:	e0e1      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        goto Exit;
    }
    status = AJ_UnmarshalContainer(msg, &container2, AJ_ARG_ARRAY);
    24ba:	1c30      	adds	r0, r6, #0
    24bc:	a918      	add	r1, sp, #96	; 0x60
    24be:	2261      	movs	r2, #97	; 0x61
    24c0:	4b55      	ldr	r3, [pc, #340]	; (2618 <AJ_KeyAuthenticationUnmarshal+0x3b4>)
    24c2:	4798      	blx	r3
    if (AJ_OK != status) {
    24c4:	2800      	cmp	r0, #0
    24c6:	d000      	beq.n	24ca <AJ_KeyAuthenticationUnmarshal+0x266>
    24c8:	e0d9      	b.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
    24ca:	2400      	movs	r4, #0
        goto Exit;
    }
    while (AJ_OK == status) {
        status = AJ_UnmarshalArgs(msg, "(ay)", &der.data, &der.size);
    24cc:	4b57      	ldr	r3, [pc, #348]	; (262c <AJ_KeyAuthenticationUnmarshal+0x3c8>)
    24ce:	469a      	mov	sl, r3
                AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Signature invalid\n", msg));
                goto Exit;
            }
        }
        // Push the certificate on to the front of the chain
        node->next = head;
    24d0:	23e0      	movs	r3, #224	; 0xe0
    24d2:	4698      	mov	r8, r3
    status = AJ_UnmarshalContainer(msg, &container2, AJ_ARG_ARRAY);
    if (AJ_OK != status) {
        goto Exit;
    }
    while (AJ_OK == status) {
        status = AJ_UnmarshalArgs(msg, "(ay)", &der.data, &der.size);
    24d4:	1c30      	adds	r0, r6, #0
    24d6:	4651      	mov	r1, sl
    24d8:	aa0f      	add	r2, sp, #60	; 0x3c
    24da:	ab0e      	add	r3, sp, #56	; 0x38
    24dc:	4f46      	ldr	r7, [pc, #280]	; (25f8 <AJ_KeyAuthenticationUnmarshal+0x394>)
    24de:	47b8      	blx	r7
        if (AJ_OK != status) {
    24e0:	2800      	cmp	r0, #0
    24e2:	d140      	bne.n	2566 <AJ_KeyAuthenticationUnmarshal+0x302>
            // No more in array
            break;
        }
        AJ_SHA256_Update(&ctx->hash, der.data, der.size);
    24e4:	9806      	ldr	r0, [sp, #24]
    24e6:	990f      	ldr	r1, [sp, #60]	; 0x3c
    24e8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    24ea:	4b45      	ldr	r3, [pc, #276]	; (2600 <AJ_KeyAuthenticationUnmarshal+0x39c>)
    24ec:	4798      	blx	r3

        node = (X509CertificateChain*) AJ_Malloc(sizeof (X509CertificateChain));
    24ee:	20e8      	movs	r0, #232	; 0xe8
    24f0:	4b4f      	ldr	r3, [pc, #316]	; (2630 <AJ_KeyAuthenticationUnmarshal+0x3cc>)
    24f2:	4798      	blx	r3
    24f4:	1e07      	subs	r7, r0, #0
        if (NULL == node) {
    24f6:	d10f      	bne.n	2518 <AJ_KeyAuthenticationUnmarshal+0x2b4>
            AJ_WarnPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Resource error\n", msg));
    24f8:	2002      	movs	r0, #2
    24fa:	494e      	ldr	r1, [pc, #312]	; (2634 <AJ_KeyAuthenticationUnmarshal+0x3d0>)
    24fc:	22bd      	movs	r2, #189	; 0xbd
    24fe:	0092      	lsls	r2, r2, #2
    2500:	4b4d      	ldr	r3, [pc, #308]	; (2638 <AJ_KeyAuthenticationUnmarshal+0x3d4>)
    2502:	4798      	blx	r3
    2504:	1c23      	adds	r3, r4, #0
    2506:	2800      	cmp	r0, #0
    2508:	d100      	bne.n	250c <AJ_KeyAuthenticationUnmarshal+0x2a8>
    250a:	e0c3      	b.n	2694 <AJ_KeyAuthenticationUnmarshal+0x430>
    250c:	484b      	ldr	r0, [pc, #300]	; (263c <AJ_KeyAuthenticationUnmarshal+0x3d8>)
    250e:	1c31      	adds	r1, r6, #0
    2510:	4b4b      	ldr	r3, [pc, #300]	; (2640 <AJ_KeyAuthenticationUnmarshal+0x3dc>)
    2512:	4798      	blx	r3
    2514:	1c23      	adds	r3, r4, #0
    2516:	e0bd      	b.n	2694 <AJ_KeyAuthenticationUnmarshal+0x430>
            goto Exit;
        }
        // Set the der before its consumed
        node->certificate.der.size = der.size;
    2518:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    251a:	6003      	str	r3, [r0, #0]
        node->certificate.der.data = der.data;
    251c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    251e:	9307      	str	r3, [sp, #28]
    2520:	6043      	str	r3, [r0, #4]
        status = AJ_X509DecodeCertificateDER(&node->certificate, &der);
    2522:	a90e      	add	r1, sp, #56	; 0x38
    2524:	4b47      	ldr	r3, [pc, #284]	; (2644 <AJ_KeyAuthenticationUnmarshal+0x3e0>)
    2526:	4798      	blx	r3
        if (AJ_OK != status) {
    2528:	2800      	cmp	r0, #0
    252a:	d00e      	beq.n	254a <AJ_KeyAuthenticationUnmarshal+0x2e6>
    252c:	1c25      	adds	r5, r4, #0
            AJ_WarnPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Certificate decode failed\n", msg));
    252e:	2002      	movs	r0, #2
    2530:	4940      	ldr	r1, [pc, #256]	; (2634 <AJ_KeyAuthenticationUnmarshal+0x3d0>)
    2532:	22bf      	movs	r2, #191	; 0xbf
    2534:	0092      	lsls	r2, r2, #2
    2536:	4b40      	ldr	r3, [pc, #256]	; (2638 <AJ_KeyAuthenticationUnmarshal+0x3d4>)
    2538:	4798      	blx	r3
    253a:	2800      	cmp	r0, #0
    253c:	d100      	bne.n	2540 <AJ_KeyAuthenticationUnmarshal+0x2dc>
    253e:	e0a4      	b.n	268a <AJ_KeyAuthenticationUnmarshal+0x426>
    2540:	4841      	ldr	r0, [pc, #260]	; (2648 <AJ_KeyAuthenticationUnmarshal+0x3e4>)
    2542:	1c31      	adds	r1, r6, #0
    2544:	4b3e      	ldr	r3, [pc, #248]	; (2640 <AJ_KeyAuthenticationUnmarshal+0x3dc>)
    2546:	4798      	blx	r3
    2548:	e09f      	b.n	268a <AJ_KeyAuthenticationUnmarshal+0x426>
            goto Exit;
        }
        if (NULL == head) {
    254a:	2c00      	cmp	r4, #0
    254c:	d107      	bne.n	255e <AJ_KeyAuthenticationUnmarshal+0x2fa>
            // If this is the first certificate, check that it signed the verifier.
            status = AJ_DSAVerifyDigest(digest, &sig, &node->certificate.tbs.publickey);
    254e:	1c3a      	adds	r2, r7, #0
    2550:	3248      	adds	r2, #72	; 0x48
    2552:	a81c      	add	r0, sp, #112	; 0x70
    2554:	a924      	add	r1, sp, #144	; 0x90
    2556:	4b3d      	ldr	r3, [pc, #244]	; (264c <AJ_KeyAuthenticationUnmarshal+0x3e8>)
    2558:	4798      	blx	r3
            if (AJ_OK != status) {
    255a:	2800      	cmp	r0, #0
    255c:	d137      	bne.n	25ce <AJ_KeyAuthenticationUnmarshal+0x36a>
                AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Signature invalid\n", msg));
                goto Exit;
            }
        }
        // Push the certificate on to the front of the chain
        node->next = head;
    255e:	4643      	mov	r3, r8
    2560:	50fc      	str	r4, [r7, r3]
            // No more in array
            break;
        }
        AJ_SHA256_Update(&ctx->hash, der.data, der.size);

        node = (X509CertificateChain*) AJ_Malloc(sizeof (X509CertificateChain));
    2562:	1c3c      	adds	r4, r7, #0
    2564:	e7b6      	b.n	24d4 <AJ_KeyAuthenticationUnmarshal+0x270>
        }
        // Push the certificate on to the front of the chain
        node->next = head;
        head = node;
    }
    if (AJ_ERR_NO_MORE != status) {
    2566:	280c      	cmp	r0, #12
    2568:	d123      	bne.n	25b2 <AJ_KeyAuthenticationUnmarshal+0x34e>
        AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Certificate chain error %s\n", msg, AJ_StatusText(status)));
        goto Exit;
    }
    status = AJ_UnmarshalCloseContainer(msg, &container2);
    256a:	1c30      	adds	r0, r6, #0
    256c:	a918      	add	r1, sp, #96	; 0x60
    256e:	4b38      	ldr	r3, [pc, #224]	; (2650 <AJ_KeyAuthenticationUnmarshal+0x3ec>)
    2570:	4798      	blx	r3
    if (AJ_OK != status) {
    2572:	2800      	cmp	r0, #0
    2574:	d120      	bne.n	25b8 <AJ_KeyAuthenticationUnmarshal+0x354>
        goto Exit;
    }
    status = AJ_UnmarshalCloseContainer(msg, &container1);
    2576:	1c30      	adds	r0, r6, #0
    2578:	a914      	add	r1, sp, #80	; 0x50
    257a:	4b35      	ldr	r3, [pc, #212]	; (2650 <AJ_KeyAuthenticationUnmarshal+0x3ec>)
    257c:	4798      	blx	r3
    if (AJ_OK != status) {
    257e:	2800      	cmp	r0, #0
    2580:	d11d      	bne.n	25be <AJ_KeyAuthenticationUnmarshal+0x35a>
        goto Exit;
    }
    if (NULL == head) {
    2582:	2c00      	cmp	r4, #0
    2584:	d07b      	beq.n	267e <AJ_KeyAuthenticationUnmarshal+0x41a>
        AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Missing certificate chain\n", msg));
        goto Exit;
    }

    // Verify the chain
    status = AJ_X509VerifyChain(head, NULL);
    2586:	1c20      	adds	r0, r4, #0
    2588:	2100      	movs	r1, #0
    258a:	4b32      	ldr	r3, [pc, #200]	; (2654 <AJ_KeyAuthenticationUnmarshal+0x3f0>)
    258c:	4798      	blx	r3
    uint8_t* sig_s;
    size_t len_r;
    size_t len_s;
    X509CertificateChain* head = NULL;
    X509CertificateChain* node = NULL;
    uint8_t trusted = 0;
    258e:	2300      	movs	r3, #0
    2590:	4698      	mov	r8, r3
        goto Exit;
    }

    // Verify the chain
    status = AJ_X509VerifyChain(head, NULL);
    if (AJ_OK != status) {
    2592:	4298      	cmp	r0, r3
    2594:	d176      	bne.n	2684 <AJ_KeyAuthenticationUnmarshal+0x420>
        AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Certificate chain invalid\n", msg));
        goto Exit;
    }
    // Send the certificate chain to the application
    cred.direction = AJ_CRED_RESPONSE;
    2596:	aa10      	add	r2, sp, #64	; 0x40
    2598:	3301      	adds	r3, #1
    259a:	7013      	strb	r3, [r2, #0]
    cred.data = (uint8_t*) head;
    259c:	6094      	str	r4, [r2, #8]
    status = ctx->bus->authListenerCallback(AUTH_SUITE_ECDHE_ECDSA, AJ_CRED_CERT_CHAIN, &cred);
    259e:	682b      	ldr	r3, [r5, #0]
    25a0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    25a2:	480e      	ldr	r0, [pc, #56]	; (25dc <AJ_KeyAuthenticationUnmarshal+0x378>)
    25a4:	2103      	movs	r1, #3
    25a6:	4798      	blx	r3
    if (AJ_OK == status) {
    25a8:	4243      	negs	r3, r0
    25aa:	4143      	adcs	r3, r0
    uint8_t* sig_s;
    size_t len_r;
    size_t len_s;
    X509CertificateChain* head = NULL;
    X509CertificateChain* node = NULL;
    uint8_t trusted = 0;
    25ac:	b2db      	uxtb	r3, r3
    25ae:	4698      	mov	r8, r3
    25b0:	e068      	b.n	2684 <AJ_KeyAuthenticationUnmarshal+0x420>
        }
        // Push the certificate on to the front of the chain
        node->next = head;
        head = node;
    }
    if (AJ_ERR_NO_MORE != status) {
    25b2:	1c27      	adds	r7, r4, #0
    25b4:	1c23      	adds	r3, r4, #0
    25b6:	e004      	b.n	25c2 <AJ_KeyAuthenticationUnmarshal+0x35e>
        AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p): Certificate chain error %s\n", msg, AJ_StatusText(status)));
        goto Exit;
    }
    status = AJ_UnmarshalCloseContainer(msg, &container2);
    if (AJ_OK != status) {
    25b8:	1c27      	adds	r7, r4, #0
    25ba:	1c23      	adds	r3, r4, #0
    25bc:	e001      	b.n	25c2 <AJ_KeyAuthenticationUnmarshal+0x35e>
        goto Exit;
    }
    status = AJ_UnmarshalCloseContainer(msg, &container1);
    if (AJ_OK != status) {
    25be:	1c27      	adds	r7, r4, #0
    25c0:	1c23      	adds	r3, r4, #0
        trusted = 1;
    }

Exit:
    /* In case the list is empty and just node was allocated */
    if (!head) {
    25c2:	2200      	movs	r2, #0
    25c4:	4690      	mov	r8, r2
    25c6:	2b00      	cmp	r3, #0
    25c8:	d148      	bne.n	265c <AJ_KeyAuthenticationUnmarshal+0x3f8>
        if (node) {
    25ca:	2f00      	cmp	r7, #0
    25cc:	d060      	beq.n	2690 <AJ_KeyAuthenticationUnmarshal+0x42c>
            AJ_Free(node);
    25ce:	1c38      	adds	r0, r7, #0
    25d0:	4b21      	ldr	r3, [pc, #132]	; (2658 <AJ_KeyAuthenticationUnmarshal+0x3f4>)
    25d2:	4798      	blx	r3
    25d4:	e05c      	b.n	2690 <AJ_KeyAuthenticationUnmarshal+0x42c>
    25d6:	46c0      	nop			; (mov r8, r8)
    25d8:	00400002 	.word	0x00400002
    25dc:	00400004 	.word	0x00400004
    25e0:	00400001 	.word	0x00400001
    25e4:	0001a340 	.word	0x0001a340
    25e8:	00001a6d 	.word	0x00001a6d
    25ec:	0001a330 	.word	0x0001a330
    25f0:	0001f18c 	.word	0x0001f18c
    25f4:	0001ecdc 	.word	0x0001ecdc
    25f8:	0000b5f5 	.word	0x0000b5f5
    25fc:	0001671b 	.word	0x0001671b
    2600:	00006139 	.word	0x00006139
    2604:	0001a35c 	.word	0x0001a35c
    2608:	0000198d 	.word	0x0000198d
    260c:	0000b319 	.word	0x0000b319
    2610:	0001a3c4 	.word	0x0001a3c4
    2614:	00017169 	.word	0x00017169
    2618:	0000a951 	.word	0x0000a951
    261c:	0001a3cc 	.word	0x0001a3cc
    2620:	00005ee5 	.word	0x00005ee5
    2624:	0001ccb0 	.word	0x0001ccb0
    2628:	0001a3d4 	.word	0x0001a3d4
    262c:	0001a414 	.word	0x0001a414
    2630:	0000d7dd 	.word	0x0000d7dd
    2634:	0001a0a4 	.word	0x0001a0a4
    2638:	0000636d 	.word	0x0000636d
    263c:	0001a454 	.word	0x0001a454
    2640:	00016e3d 	.word	0x00016e3d
    2644:	000033e9 	.word	0x000033e9
    2648:	0001a480 	.word	0x0001a480
    264c:	000060b5 	.word	0x000060b5
    2650:	0000a9d9 	.word	0x0000a9d9
    2654:	000038ad 	.word	0x000038ad
    2658:	0000d7e9 	.word	0x0000d7e9
        }
    }
    while (head) {
        node = head;
        head = head->next;
    265c:	26e0      	movs	r6, #224	; 0xe0
        if (node) {
            AJ_Free(node);
    265e:	4f15      	ldr	r7, [pc, #84]	; (26b4 <AJ_KeyAuthenticationUnmarshal+0x450>)
            AJ_Free(node);
        }
    }
    while (head) {
        node = head;
        head = head->next;
    2660:	59a5      	ldr	r5, [r4, r6]
        if (node) {
    2662:	2c00      	cmp	r4, #0
    2664:	d001      	beq.n	266a <AJ_KeyAuthenticationUnmarshal+0x406>
            AJ_Free(node);
    2666:	1c20      	adds	r0, r4, #0
    2668:	47b8      	blx	r7
    266a:	1e2c      	subs	r4, r5, #0
    if (!head) {
        if (node) {
            AJ_Free(node);
        }
    }
    while (head) {
    266c:	d1f8      	bne.n	2660 <AJ_KeyAuthenticationUnmarshal+0x3fc>
        head = head->next;
        if (node) {
            AJ_Free(node);
        }
    }
    return trusted ? AJ_OK : AJ_ERR_SECURITY;
    266e:	2000      	movs	r0, #0
    2670:	4643      	mov	r3, r8
    2672:	2b00      	cmp	r3, #0
    2674:	d118      	bne.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    2676:	300d      	adds	r0, #13
    2678:	e016      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    uint8_t trusted = 0;

    AJ_InfoPrintf(("AJ_ECDSA_Unmarshal(msg=%p)\n", msg));

    if (NULL == ctx->bus->authListenerCallback) {
        return AJ_ERR_SECURITY;
    267a:	200d      	movs	r0, #13
    267c:	e014      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
    if (!head) {
        if (node) {
            AJ_Free(node);
        }
    }
    while (head) {
    267e:	2300      	movs	r3, #0
    2680:	4698      	mov	r8, r3
    2682:	e7f4      	b.n	266e <AJ_KeyAuthenticationUnmarshal+0x40a>
    2684:	2c00      	cmp	r4, #0
    2686:	d1e9      	bne.n	265c <AJ_KeyAuthenticationUnmarshal+0x3f8>
    2688:	e7f1      	b.n	266e <AJ_KeyAuthenticationUnmarshal+0x40a>
        trusted = 1;
    }

Exit:
    /* In case the list is empty and just node was allocated */
    if (!head) {
    268a:	2d00      	cmp	r5, #0
    268c:	d107      	bne.n	269e <AJ_KeyAuthenticationUnmarshal+0x43a>
    268e:	e79e      	b.n	25ce <AJ_KeyAuthenticationUnmarshal+0x36a>
        head = head->next;
        if (node) {
            AJ_Free(node);
        }
    }
    return trusted ? AJ_OK : AJ_ERR_SECURITY;
    2690:	200d      	movs	r0, #13
    2692:	e009      	b.n	26a8 <AJ_KeyAuthenticationUnmarshal+0x444>
        trusted = 1;
    }

Exit:
    /* In case the list is empty and just node was allocated */
    if (!head) {
    2694:	2b00      	cmp	r3, #0
    2696:	d0fb      	beq.n	2690 <AJ_KeyAuthenticationUnmarshal+0x42c>
    2698:	2300      	movs	r3, #0
    269a:	4698      	mov	r8, r3
    269c:	e7de      	b.n	265c <AJ_KeyAuthenticationUnmarshal+0x3f8>
        if (node) {
            AJ_Free(node);
        }
    }
    while (head) {
    269e:	2300      	movs	r3, #0
    26a0:	4698      	mov	r8, r3
    26a2:	429c      	cmp	r4, r3
    26a4:	d1da      	bne.n	265c <AJ_KeyAuthenticationUnmarshal+0x3f8>
        head = head->next;
        if (node) {
            AJ_Free(node);
        }
    }
    return trusted ? AJ_OK : AJ_ERR_SECURITY;
    26a6:	200d      	movs	r0, #13
    case AUTH_SUITE_ECDHE_ECDSA:
        status = ECDSAUnmarshal(ctx, msg);
        break;
    }
    return status;
}
    26a8:	b037      	add	sp, #220	; 0xdc
    26aa:	bc0c      	pop	{r2, r3}
    26ac:	4690      	mov	r8, r2
    26ae:	469a      	mov	sl, r3
    26b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26b2:	46c0      	nop			; (mov r8, r8)
    26b4:	0000d7e9 	.word	0x0000d7e9

000026b8 <AJ_IsSuiteEnabled>:

uint8_t AJ_IsSuiteEnabled(uint32_t suite, uint32_t version)
{
    switch (suite) {
    26b8:	4b11      	ldr	r3, [pc, #68]	; (2700 <AJ_IsSuiteEnabled+0x48>)
    26ba:	4298      	cmp	r0, r3
    26bc:	d00c      	beq.n	26d8 <AJ_IsSuiteEnabled+0x20>
    26be:	4b11      	ldr	r3, [pc, #68]	; (2704 <AJ_IsSuiteEnabled+0x4c>)
    26c0:	4298      	cmp	r0, r3
    26c2:	d010      	beq.n	26e6 <AJ_IsSuiteEnabled+0x2e>
    26c4:	4b10      	ldr	r3, [pc, #64]	; (2708 <AJ_IsSuiteEnabled+0x50>)
    26c6:	4298      	cmp	r0, r3
    26c8:	d117      	bne.n	26fa <AJ_IsSuiteEnabled+0x42>
    case AUTH_SUITE_ECDHE_NULL:
        return 1 == suites[0];
    26ca:	4b10      	ldr	r3, [pc, #64]	; (270c <AJ_IsSuiteEnabled+0x54>)
    26cc:	6818      	ldr	r0, [r3, #0]
    26ce:	3801      	subs	r0, #1
    26d0:	4243      	negs	r3, r0
    26d2:	4158      	adcs	r0, r3
    26d4:	b2c0      	uxtb	r0, r0
    26d6:	e011      	b.n	26fc <AJ_IsSuiteEnabled+0x44>

    case AUTH_SUITE_ECDHE_PSK:
        return 1 == suites[1];
    26d8:	4b0c      	ldr	r3, [pc, #48]	; (270c <AJ_IsSuiteEnabled+0x54>)
    26da:	6858      	ldr	r0, [r3, #4]
    26dc:	3801      	subs	r0, #1
    26de:	4243      	negs	r3, r0
    26e0:	4158      	adcs	r0, r3
    26e2:	b2c0      	uxtb	r0, r0
    26e4:	e00a      	b.n	26fc <AJ_IsSuiteEnabled+0x44>

    case AUTH_SUITE_ECDHE_ECDSA:
        if (version < 3) {
            return 0;
    26e6:	2000      	movs	r0, #0

    case AUTH_SUITE_ECDHE_PSK:
        return 1 == suites[1];

    case AUTH_SUITE_ECDHE_ECDSA:
        if (version < 3) {
    26e8:	2902      	cmp	r1, #2
    26ea:	d907      	bls.n	26fc <AJ_IsSuiteEnabled+0x44>
            return 0;
        }
        return 1 == suites[2];
    26ec:	4b07      	ldr	r3, [pc, #28]	; (270c <AJ_IsSuiteEnabled+0x54>)
    26ee:	6898      	ldr	r0, [r3, #8]
    26f0:	3801      	subs	r0, #1
    26f2:	4243      	negs	r3, r0
    26f4:	4158      	adcs	r0, r3
    26f6:	b2c0      	uxtb	r0, r0
    26f8:	e000      	b.n	26fc <AJ_IsSuiteEnabled+0x44>

    default:
        return 0;
    26fa:	2000      	movs	r0, #0
    }

    return 0;
}
    26fc:	4770      	bx	lr
    26fe:	46c0      	nop			; (mov r8, r8)
    2700:	00400002 	.word	0x00400002
    2704:	00400004 	.word	0x00400004
    2708:	00400001 	.word	0x00400001
    270c:	200005a0 	.word	0x200005a0

00002710 <AJ_EnableSuite>:

void AJ_EnableSuite(uint32_t suite)
{
    switch (suite) {
    2710:	4b0a      	ldr	r3, [pc, #40]	; (273c <AJ_EnableSuite+0x2c>)
    2712:	4298      	cmp	r0, r3
    2714:	d009      	beq.n	272a <AJ_EnableSuite+0x1a>
    2716:	4b0a      	ldr	r3, [pc, #40]	; (2740 <AJ_EnableSuite+0x30>)
    2718:	4298      	cmp	r0, r3
    271a:	d00a      	beq.n	2732 <AJ_EnableSuite+0x22>
    271c:	4b09      	ldr	r3, [pc, #36]	; (2744 <AJ_EnableSuite+0x34>)
    271e:	4298      	cmp	r0, r3
    2720:	d10a      	bne.n	2738 <AJ_EnableSuite+0x28>
    case AUTH_SUITE_ECDHE_NULL:
        suites[0] = 1;
    2722:	2201      	movs	r2, #1
    2724:	4b08      	ldr	r3, [pc, #32]	; (2748 <AJ_EnableSuite+0x38>)
    2726:	601a      	str	r2, [r3, #0]
        break;
    2728:	e006      	b.n	2738 <AJ_EnableSuite+0x28>

    case AUTH_SUITE_ECDHE_PSK:
        suites[1] = 1;
    272a:	2201      	movs	r2, #1
    272c:	4b06      	ldr	r3, [pc, #24]	; (2748 <AJ_EnableSuite+0x38>)
    272e:	605a      	str	r2, [r3, #4]
        break;
    2730:	e002      	b.n	2738 <AJ_EnableSuite+0x28>

    case AUTH_SUITE_ECDHE_ECDSA:
        suites[2] = 1;
    2732:	2201      	movs	r2, #1
    2734:	4b04      	ldr	r3, [pc, #16]	; (2748 <AJ_EnableSuite+0x38>)
    2736:	609a      	str	r2, [r3, #8]
        break;
    }
}
    2738:	4770      	bx	lr
    273a:	46c0      	nop			; (mov r8, r8)
    273c:	00400002 	.word	0x00400002
    2740:	00400004 	.word	0x00400004
    2744:	00400001 	.word	0x00400001
    2748:	200005a0 	.word	0x200005a0

0000274c <AJ_IOBufRebase>:
    ioBuf->direction = direction;
    ioBuf->context = context;
}

void AJ_IOBufRebase(AJ_IOBuffer* ioBuf, size_t preserve)
{
    274c:	b570      	push	{r4, r5, r6, lr}
    274e:	1c05      	adds	r5, r0, #0
    2750:	1c0c      	adds	r4, r1, #0
    int32_t unconsumed = AJ_IO_BUF_AVAIL(ioBuf);
    2752:	6881      	ldr	r1, [r0, #8]
    2754:	68c3      	ldr	r3, [r0, #12]
    2756:	1a5e      	subs	r6, r3, r1
    // Move any unconsumed data to the start of the I/O buffer
    if (unconsumed) 
    2758:	d004      	beq.n	2764 <AJ_IOBufRebase+0x18>
	{
        memmove(ioBuf->bufStart + preserve, ioBuf->readPtr, unconsumed);
    275a:	6843      	ldr	r3, [r0, #4]
    275c:	1918      	adds	r0, r3, r4
    275e:	1c32      	adds	r2, r6, #0
    2760:	4b04      	ldr	r3, [pc, #16]	; (2774 <AJ_IOBufRebase+0x28>)
    2762:	4798      	blx	r3
    }

    ioBuf->readPtr = ioBuf->bufStart + preserve;
    2764:	686b      	ldr	r3, [r5, #4]
    2766:	191a      	adds	r2, r3, r4
    2768:	60aa      	str	r2, [r5, #8]
    ioBuf->writePtr = ioBuf->bufStart + preserve + unconsumed;
    276a:	1934      	adds	r4, r6, r4
    276c:	191c      	adds	r4, r3, r4
    276e:	60ec      	str	r4, [r5, #12]
}
    2770:	bd70      	pop	{r4, r5, r6, pc}
    2772:	46c0      	nop			; (mov r8, r8)
    2774:	0001674b 	.word	0x0001674b

00002778 <MarshalSessionOpts>:
    }
    return status;
}

static AJ_Status MarshalSessionOpts(AJ_Message* msg, const AJ_SessionOpts* opts)
{
    2778:	b5f0      	push	{r4, r5, r6, r7, lr}
    277a:	b089      	sub	sp, #36	; 0x24
    277c:	1c05      	adds	r5, r0, #0
    277e:	1c0c      	adds	r4, r1, #0
    AJ_Arg dictionary;

    AJ_MarshalContainer(msg, &dictionary, AJ_ARG_ARRAY);
    2780:	a904      	add	r1, sp, #16
    2782:	2261      	movs	r2, #97	; 0x61
    2784:	4b14      	ldr	r3, [pc, #80]	; (27d8 <MarshalSessionOpts+0x60>)
    2786:	4798      	blx	r3

    AJ_MarshalArgs(msg, "{sv}", "traf",  "y", opts->traffic);
    2788:	4e14      	ldr	r6, [pc, #80]	; (27dc <MarshalSessionOpts+0x64>)
    278a:	4f15      	ldr	r7, [pc, #84]	; (27e0 <MarshalSessionOpts+0x68>)
    278c:	7823      	ldrb	r3, [r4, #0]
    278e:	9300      	str	r3, [sp, #0]
    2790:	9503      	str	r5, [sp, #12]
    2792:	1c28      	adds	r0, r5, #0
    2794:	1c31      	adds	r1, r6, #0
    2796:	4a13      	ldr	r2, [pc, #76]	; (27e4 <MarshalSessionOpts+0x6c>)
    2798:	1c3b      	adds	r3, r7, #0
    279a:	4d13      	ldr	r5, [pc, #76]	; (27e8 <MarshalSessionOpts+0x70>)
    279c:	47a8      	blx	r5
    AJ_MarshalArgs(msg, "{sv}", "multi", "b", opts->isMultipoint);
    279e:	6863      	ldr	r3, [r4, #4]
    27a0:	9300      	str	r3, [sp, #0]
    27a2:	9803      	ldr	r0, [sp, #12]
    27a4:	1c31      	adds	r1, r6, #0
    27a6:	4a11      	ldr	r2, [pc, #68]	; (27ec <MarshalSessionOpts+0x74>)
    27a8:	4b11      	ldr	r3, [pc, #68]	; (27f0 <MarshalSessionOpts+0x78>)
    27aa:	47a8      	blx	r5
    AJ_MarshalArgs(msg, "{sv}", "prox",  "y", opts->proximity);
    27ac:	7863      	ldrb	r3, [r4, #1]
    27ae:	9300      	str	r3, [sp, #0]
    27b0:	9803      	ldr	r0, [sp, #12]
    27b2:	1c31      	adds	r1, r6, #0
    27b4:	4a0f      	ldr	r2, [pc, #60]	; (27f4 <MarshalSessionOpts+0x7c>)
    27b6:	1c3b      	adds	r3, r7, #0
    27b8:	47a8      	blx	r5
    AJ_MarshalArgs(msg, "{sv}", "trans", "q", opts->transports);
    27ba:	8863      	ldrh	r3, [r4, #2]
    27bc:	9300      	str	r3, [sp, #0]
    27be:	9c03      	ldr	r4, [sp, #12]
    27c0:	1c20      	adds	r0, r4, #0
    27c2:	1c31      	adds	r1, r6, #0
    27c4:	4a0c      	ldr	r2, [pc, #48]	; (27f8 <MarshalSessionOpts+0x80>)
    27c6:	4b0d      	ldr	r3, [pc, #52]	; (27fc <MarshalSessionOpts+0x84>)
    27c8:	47a8      	blx	r5

    AJ_MarshalCloseContainer(msg, &dictionary);
    27ca:	1c20      	adds	r0, r4, #0
    27cc:	a904      	add	r1, sp, #16
    27ce:	4b0c      	ldr	r3, [pc, #48]	; (2800 <MarshalSessionOpts+0x88>)
    27d0:	4798      	blx	r3

    return AJ_OK;
}
    27d2:	2000      	movs	r0, #0
    27d4:	b009      	add	sp, #36	; 0x24
    27d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27d8:	0000b8a1 	.word	0x0000b8a1
    27dc:	0001f938 	.word	0x0001f938
    27e0:	0001ccb0 	.word	0x0001ccb0
    27e4:	0001a4d4 	.word	0x0001a4d4
    27e8:	0000bc85 	.word	0x0000bc85
    27ec:	0001a4dc 	.word	0x0001a4dc
    27f0:	0001ed84 	.word	0x0001ed84
    27f4:	0001a4e4 	.word	0x0001a4e4
    27f8:	0001a4ec 	.word	0x0001a4ec
    27fc:	0001eda8 	.word	0x0001eda8
    2800:	0000b8d1 	.word	0x0000b8d1

00002804 <PropAccess>:
        AJ_BusPropSetCallback Set;
    };
} PropCallback;

static AJ_Status PropAccess(AJ_Message* msg, PropCallback* cb, uint8_t op)
{
    2804:	b570      	push	{r4, r5, r6, lr}
    2806:	b094      	sub	sp, #80	; 0x50
    2808:	1c04      	adds	r4, r0, #0
    280a:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    AJ_Message reply;
    uint32_t propId;
    const char* sig;

    printf("PropAccess(msg=0x%p, cb=0x%p, op=%s)\n", msg, cb, (op == AJ_PROP_GET) ? "get" : "set");
    280c:	2a00      	cmp	r2, #0
    280e:	d03e      	beq.n	288e <PropAccess+0x8a>
    2810:	e020      	b.n	2854 <PropAccess+0x50>
            const char* variant;
            AJ_UnmarshalVariant(msg, &variant);
            // Check that the value has the expected signature
            if (strcmp(sig, variant) == 0) 
			{
                status = cb->Set(msg, propId, cb->context);
    2812:	682a      	ldr	r2, [r5, #0]
    2814:	686b      	ldr	r3, [r5, #4]
    2816:	1c20      	adds	r0, r4, #0
    2818:	9903      	ldr	r1, [sp, #12]
    281a:	4798      	blx	r3
    281c:	1c02      	adds	r2, r0, #0
    281e:	e003      	b.n	2828 <PropAccess+0x24>
            } 
			else
			{
                printf("PropAccess(): AJ_ERR_SIGNATURE\n");
    2820:	4824      	ldr	r0, [pc, #144]	; (28b4 <PropAccess+0xb0>)
    2822:	4b25      	ldr	r3, [pc, #148]	; (28b8 <PropAccess+0xb4>)
    2824:	4798      	blx	r3
                status = AJ_ERR_SIGNATURE;
    2826:	2211      	movs	r2, #17
            }
        }
    }
    if (status != AJ_OK) 
    2828:	2a00      	cmp	r2, #0
    282a:	d03e      	beq.n	28aa <PropAccess+0xa6>
	{
        AJ_MarshalStatusMsg(msg, &reply, status);
    282c:	1c20      	adds	r0, r4, #0
    282e:	a904      	add	r1, sp, #16
    2830:	4b22      	ldr	r3, [pc, #136]	; (28bc <PropAccess+0xb8>)
    2832:	4798      	blx	r3
    2834:	e039      	b.n	28aa <PropAccess+0xa6>

    // Find out which property is being accessed and whether the access is a GET or SET
    status = AJ_UnmarshalPropertyArgs(msg, &propId, &sig);
    if (status == AJ_OK) 
	{
        AJ_MarshalReplyMsg(msg, &reply);
    2836:	1c20      	adds	r0, r4, #0
    2838:	a904      	add	r1, sp, #16
    283a:	4b21      	ldr	r3, [pc, #132]	; (28c0 <PropAccess+0xbc>)
    283c:	4798      	blx	r3
            status = cb->Get(&reply, propId, cb->context);
        } 
		else
		{
            const char* variant;
            AJ_UnmarshalVariant(msg, &variant);
    283e:	1c20      	adds	r0, r4, #0
    2840:	a901      	add	r1, sp, #4
    2842:	4b20      	ldr	r3, [pc, #128]	; (28c4 <PropAccess+0xc0>)
    2844:	4798      	blx	r3
            // Check that the value has the expected signature
            if (strcmp(sig, variant) == 0) 
    2846:	9802      	ldr	r0, [sp, #8]
    2848:	9901      	ldr	r1, [sp, #4]
    284a:	4b1f      	ldr	r3, [pc, #124]	; (28c8 <PropAccess+0xc4>)
    284c:	4798      	blx	r3
    284e:	2800      	cmp	r0, #0
    2850:	d0df      	beq.n	2812 <PropAccess+0xe>
    2852:	e7e5      	b.n	2820 <PropAccess+0x1c>
    AJ_Status status;
    AJ_Message reply;
    uint32_t propId;
    const char* sig;

    printf("PropAccess(msg=0x%p, cb=0x%p, op=%s)\n", msg, cb, (op == AJ_PROP_GET) ? "get" : "set");
    2854:	481d      	ldr	r0, [pc, #116]	; (28cc <PropAccess+0xc8>)
    2856:	1c21      	adds	r1, r4, #0
    2858:	1c2a      	adds	r2, r5, #0
    285a:	4b1d      	ldr	r3, [pc, #116]	; (28d0 <PropAccess+0xcc>)
    285c:	4e1d      	ldr	r6, [pc, #116]	; (28d4 <PropAccess+0xd0>)
    285e:	47b0      	blx	r6

    // Find out which property is being accessed and whether the access is a GET or SET
    status = AJ_UnmarshalPropertyArgs(msg, &propId, &sig);
    2860:	1c20      	adds	r0, r4, #0
    2862:	a903      	add	r1, sp, #12
    2864:	aa02      	add	r2, sp, #8
    2866:	4b1c      	ldr	r3, [pc, #112]	; (28d8 <PropAccess+0xd4>)
    2868:	4798      	blx	r3
    286a:	1e02      	subs	r2, r0, #0
    if (status == AJ_OK) 
    286c:	d1de      	bne.n	282c <PropAccess+0x28>
    286e:	e7e2      	b.n	2836 <PropAccess+0x32>
	{
        AJ_MarshalReplyMsg(msg, &reply);
    2870:	1c20      	adds	r0, r4, #0
    2872:	a904      	add	r1, sp, #16
    2874:	4b12      	ldr	r3, [pc, #72]	; (28c0 <PropAccess+0xbc>)
    2876:	4798      	blx	r3
        // Callback to let the application marshal or unmarshal the value
        if (op == AJ_PROP_GET) 
		{
            AJ_MarshalVariant(&reply, sig);
    2878:	a804      	add	r0, sp, #16
    287a:	9902      	ldr	r1, [sp, #8]
    287c:	4b17      	ldr	r3, [pc, #92]	; (28dc <PropAccess+0xd8>)
    287e:	4798      	blx	r3
            status = cb->Get(&reply, propId, cb->context);
    2880:	686b      	ldr	r3, [r5, #4]
    2882:	a804      	add	r0, sp, #16
    2884:	9903      	ldr	r1, [sp, #12]
    2886:	682a      	ldr	r2, [r5, #0]
    2888:	4798      	blx	r3
    288a:	1c02      	adds	r2, r0, #0
    288c:	e7cc      	b.n	2828 <PropAccess+0x24>
    AJ_Status status;
    AJ_Message reply;
    uint32_t propId;
    const char* sig;

    printf("PropAccess(msg=0x%p, cb=0x%p, op=%s)\n", msg, cb, (op == AJ_PROP_GET) ? "get" : "set");
    288e:	480f      	ldr	r0, [pc, #60]	; (28cc <PropAccess+0xc8>)
    2890:	1c21      	adds	r1, r4, #0
    2892:	1c2a      	adds	r2, r5, #0
    2894:	4b12      	ldr	r3, [pc, #72]	; (28e0 <PropAccess+0xdc>)
    2896:	4e0f      	ldr	r6, [pc, #60]	; (28d4 <PropAccess+0xd0>)
    2898:	47b0      	blx	r6

    // Find out which property is being accessed and whether the access is a GET or SET
    status = AJ_UnmarshalPropertyArgs(msg, &propId, &sig);
    289a:	1c20      	adds	r0, r4, #0
    289c:	a903      	add	r1, sp, #12
    289e:	aa02      	add	r2, sp, #8
    28a0:	4b0d      	ldr	r3, [pc, #52]	; (28d8 <PropAccess+0xd4>)
    28a2:	4798      	blx	r3
    28a4:	1e02      	subs	r2, r0, #0
    if (status == AJ_OK) 
    28a6:	d1c1      	bne.n	282c <PropAccess+0x28>
    28a8:	e7e2      	b.n	2870 <PropAccess+0x6c>
    }
    if (status != AJ_OK) 
	{
        AJ_MarshalStatusMsg(msg, &reply, status);
    }
    return AJ_DeliverMsg(&reply);
    28aa:	a804      	add	r0, sp, #16
    28ac:	4b0d      	ldr	r3, [pc, #52]	; (28e4 <PropAccess+0xe0>)
    28ae:	4798      	blx	r3
}
    28b0:	b014      	add	sp, #80	; 0x50
    28b2:	bd70      	pop	{r4, r5, r6, pc}
    28b4:	0001a4f4 	.word	0x0001a4f4
    28b8:	00016f5d 	.word	0x00016f5d
    28bc:	0000be65 	.word	0x0000be65
    28c0:	0000bd45 	.word	0x0000bd45
    28c4:	0000b319 	.word	0x0000b319
    28c8:	00017137 	.word	0x00017137
    28cc:	0001a514 	.word	0x0001a514
    28d0:	0001a53c 	.word	0x0001a53c
    28d4:	00016e3d 	.word	0x00016e3d
    28d8:	000092b9 	.word	0x000092b9
    28dc:	0000b9fd 	.word	0x0000b9fd
    28e0:	0001a540 	.word	0x0001a540
    28e4:	0000a539 	.word	0x0000a539

000028e8 <AJ_GetUniqueName>:
uint8_t dbgBUS = 0;
#endif

const char* AJ_GetUniqueName(AJ_BusAttachment* bus)
{
    return (*bus->uniqueName) ? bus->uniqueName : NULL;
    28e8:	7883      	ldrb	r3, [r0, #2]
    28ea:	2b00      	cmp	r3, #0
    28ec:	d001      	beq.n	28f2 <AJ_GetUniqueName+0xa>
    28ee:	3002      	adds	r0, #2
    28f0:	e000      	b.n	28f4 <AJ_GetUniqueName+0xc>
    28f2:	2000      	movs	r0, #0
}
    28f4:	4770      	bx	lr
    28f6:	46c0      	nop			; (mov r8, r8)

000028f8 <AJ_BusBindSessionPort>:
    AJ_TRANSPORT_ANY,
    FALSE
};

AJ_Status AJ_BusBindSessionPort(AJ_BusAttachment* bus, uint16_t port, const AJ_SessionOpts* opts, uint8_t flags)
{
    28f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    28fa:	b097      	sub	sp, #92	; 0x5c
    28fc:	1c06      	adds	r6, r0, #0
    28fe:	1c0d      	adds	r5, r1, #0
    2900:	9105      	str	r1, [sp, #20]
    2902:	1c14      	adds	r4, r2, #0
    2904:	1c1f      	adds	r7, r3, #0
    AJ_Status status;
    AJ_Message msg;

   printf("AJ_BusBindSessionPort(bus=0x%p, port=%d., opts=0x%p)\n", bus, port, opts);
    2906:	4813      	ldr	r0, [pc, #76]	; (2954 <AJ_BusBindSessionPort+0x5c>)
    2908:	1c31      	adds	r1, r6, #0
    290a:	1c2a      	adds	r2, r5, #0
    290c:	1c23      	adds	r3, r4, #0
    290e:	4d12      	ldr	r5, [pc, #72]	; (2958 <AJ_BusBindSessionPort+0x60>)
    2910:	47a8      	blx	r5

    if (!opts)
    2912:	2c00      	cmp	r4, #0
    2914:	d100      	bne.n	2918 <AJ_BusBindSessionPort+0x20>
	{
        opts = &defaultSessionOpts;
    2916:	4c11      	ldr	r4, [pc, #68]	; (295c <AJ_BusBindSessionPort+0x64>)
    }
    status = AJ_MarshalMethodCall(bus, &msg, AJ_METHOD_BIND_SESSION_PORT, AJ_BusDestination, 0, flags, AJ_METHOD_TIMEOUT);
    2918:	2300      	movs	r3, #0
    291a:	9300      	str	r3, [sp, #0]
    291c:	9701      	str	r7, [sp, #4]
    291e:	4b10      	ldr	r3, [pc, #64]	; (2960 <AJ_BusBindSessionPort+0x68>)
    2920:	9302      	str	r3, [sp, #8]
    2922:	1c30      	adds	r0, r6, #0
    2924:	a906      	add	r1, sp, #24
    2926:	4a0f      	ldr	r2, [pc, #60]	; (2964 <AJ_BusBindSessionPort+0x6c>)
    2928:	4b0f      	ldr	r3, [pc, #60]	; (2968 <AJ_BusBindSessionPort+0x70>)
    292a:	4e10      	ldr	r6, [pc, #64]	; (296c <AJ_BusBindSessionPort+0x74>)
    292c:	47b0      	blx	r6
    if (status == AJ_OK) 
    292e:	2800      	cmp	r0, #0
    2930:	d10d      	bne.n	294e <AJ_BusBindSessionPort+0x56>
	{
        AJ_MarshalArgs(&msg, "q", port);
    2932:	a806      	add	r0, sp, #24
    2934:	490e      	ldr	r1, [pc, #56]	; (2970 <AJ_BusBindSessionPort+0x78>)
    2936:	9a05      	ldr	r2, [sp, #20]
    2938:	4b0e      	ldr	r3, [pc, #56]	; (2974 <AJ_BusBindSessionPort+0x7c>)
    293a:	4798      	blx	r3
        status = MarshalSessionOpts(&msg, opts);
    293c:	a806      	add	r0, sp, #24
    293e:	1c21      	adds	r1, r4, #0
    2940:	4b0d      	ldr	r3, [pc, #52]	; (2978 <AJ_BusBindSessionPort+0x80>)
    2942:	4798      	blx	r3
    }
    if (status == AJ_OK) 
    2944:	2800      	cmp	r0, #0
    2946:	d102      	bne.n	294e <AJ_BusBindSessionPort+0x56>
	{
        status = AJ_DeliverMsg(&msg);
    2948:	a806      	add	r0, sp, #24
    294a:	4b0c      	ldr	r3, [pc, #48]	; (297c <AJ_BusBindSessionPort+0x84>)
    294c:	4798      	blx	r3
    }
    return status;
}
    294e:	b017      	add	sp, #92	; 0x5c
    2950:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2952:	46c0      	nop			; (mov r8, r8)
    2954:	0001a684 	.word	0x0001a684
    2958:	00016e3d 	.word	0x00016e3d
    295c:	0001a4cc 	.word	0x0001a4cc
    2960:	00000bb8 	.word	0x00000bb8
    2964:	00010008 	.word	0x00010008
    2968:	0001ebc0 	.word	0x0001ebc0
    296c:	0000bca5 	.word	0x0000bca5
    2970:	0001eda8 	.word	0x0001eda8
    2974:	0000bc85 	.word	0x0000bc85
    2978:	00002779 	.word	0x00002779
    297c:	0000a539 	.word	0x0000a539

00002980 <AJ_BusUnbindSession>:

AJ_Status AJ_BusUnbindSession(AJ_BusAttachment* bus, uint16_t port)
{
    2980:	b530      	push	{r4, r5, lr}
    2982:	b095      	sub	sp, #84	; 0x54
    2984:	1c04      	adds	r4, r0, #0
    2986:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    AJ_Message msg;

    printf("AJ_BusUnbindSession(bus=0x%p, port=%d.)\n", bus, port);
    2988:	480d      	ldr	r0, [pc, #52]	; (29c0 <AJ_BusUnbindSession+0x40>)
    298a:	1c21      	adds	r1, r4, #0
    298c:	1c2a      	adds	r2, r5, #0
    298e:	4b0d      	ldr	r3, [pc, #52]	; (29c4 <AJ_BusUnbindSession+0x44>)
    2990:	4798      	blx	r3

    status = AJ_MarshalMethodCall(bus, &msg, AJ_METHOD_UNBIND_SESSION, AJ_BusDestination, 0, 0, AJ_METHOD_TIMEOUT);
    2992:	2300      	movs	r3, #0
    2994:	9300      	str	r3, [sp, #0]
    2996:	9301      	str	r3, [sp, #4]
    2998:	4b0b      	ldr	r3, [pc, #44]	; (29c8 <AJ_BusUnbindSession+0x48>)
    299a:	9302      	str	r3, [sp, #8]
    299c:	1c20      	adds	r0, r4, #0
    299e:	a904      	add	r1, sp, #16
    29a0:	4a0a      	ldr	r2, [pc, #40]	; (29cc <AJ_BusUnbindSession+0x4c>)
    29a2:	4b0b      	ldr	r3, [pc, #44]	; (29d0 <AJ_BusUnbindSession+0x50>)
    29a4:	4c0b      	ldr	r4, [pc, #44]	; (29d4 <AJ_BusUnbindSession+0x54>)
    29a6:	47a0      	blx	r4
    if (status == AJ_OK) 
    29a8:	2800      	cmp	r0, #0
    29aa:	d107      	bne.n	29bc <AJ_BusUnbindSession+0x3c>
	{
        AJ_MarshalArgs(&msg, "q", port);
    29ac:	a804      	add	r0, sp, #16
    29ae:	490a      	ldr	r1, [pc, #40]	; (29d8 <AJ_BusUnbindSession+0x58>)
    29b0:	1c2a      	adds	r2, r5, #0
    29b2:	4b0a      	ldr	r3, [pc, #40]	; (29dc <AJ_BusUnbindSession+0x5c>)
    29b4:	4798      	blx	r3
    }
    if (status == AJ_OK) 
	{
        status = AJ_DeliverMsg(&msg);
    29b6:	a804      	add	r0, sp, #16
    29b8:	4b09      	ldr	r3, [pc, #36]	; (29e0 <AJ_BusUnbindSession+0x60>)
    29ba:	4798      	blx	r3
    }
    return status;
}
    29bc:	b015      	add	sp, #84	; 0x54
    29be:	bd30      	pop	{r4, r5, pc}
    29c0:	0001a6bc 	.word	0x0001a6bc
    29c4:	00016e3d 	.word	0x00016e3d
    29c8:	00000bb8 	.word	0x00000bb8
    29cc:	00010009 	.word	0x00010009
    29d0:	0001ebc0 	.word	0x0001ebc0
    29d4:	0000bca5 	.word	0x0000bca5
    29d8:	0001eda8 	.word	0x0001eda8
    29dc:	0000bc85 	.word	0x0000bc85
    29e0:	0000a539 	.word	0x0000a539

000029e4 <AJ_BusCancelSessionless>:

AJ_Status AJ_BusCancelSessionless(AJ_BusAttachment* bus, uint32_t serialNum)
{
    29e4:	b530      	push	{r4, r5, lr}
    29e6:	b095      	sub	sp, #84	; 0x54
    29e8:	1c04      	adds	r4, r0, #0
    29ea:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    AJ_Message msg;

   printf("AJ_BusCancelSessionless(bus=0x%p, serialNum=%d.)\n", bus, serialNum);
    29ec:	480d      	ldr	r0, [pc, #52]	; (2a24 <AJ_BusCancelSessionless+0x40>)
    29ee:	1c21      	adds	r1, r4, #0
    29f0:	1c2a      	adds	r2, r5, #0
    29f2:	4b0d      	ldr	r3, [pc, #52]	; (2a28 <AJ_BusCancelSessionless+0x44>)
    29f4:	4798      	blx	r3

    status = AJ_MarshalMethodCall(bus, &msg, AJ_METHOD_CANCEL_SESSIONLESS, AJ_BusDestination, 0, 0, AJ_METHOD_TIMEOUT);
    29f6:	2300      	movs	r3, #0
    29f8:	9300      	str	r3, [sp, #0]
    29fa:	9301      	str	r3, [sp, #4]
    29fc:	4b0b      	ldr	r3, [pc, #44]	; (2a2c <AJ_BusCancelSessionless+0x48>)
    29fe:	9302      	str	r3, [sp, #8]
    2a00:	1c20      	adds	r0, r4, #0
    2a02:	a904      	add	r1, sp, #16
    2a04:	4a0a      	ldr	r2, [pc, #40]	; (2a30 <AJ_BusCancelSessionless+0x4c>)
    2a06:	4b0b      	ldr	r3, [pc, #44]	; (2a34 <AJ_BusCancelSessionless+0x50>)
    2a08:	4c0b      	ldr	r4, [pc, #44]	; (2a38 <AJ_BusCancelSessionless+0x54>)
    2a0a:	47a0      	blx	r4
    if (status == AJ_OK)
    2a0c:	2800      	cmp	r0, #0
    2a0e:	d107      	bne.n	2a20 <AJ_BusCancelSessionless+0x3c>
	{
        AJ_MarshalArgs(&msg, "u", serialNum);
    2a10:	a804      	add	r0, sp, #16
    2a12:	490a      	ldr	r1, [pc, #40]	; (2a3c <AJ_BusCancelSessionless+0x58>)
    2a14:	1c2a      	adds	r2, r5, #0
    2a16:	4b0a      	ldr	r3, [pc, #40]	; (2a40 <AJ_BusCancelSessionless+0x5c>)
    2a18:	4798      	blx	r3
    }
    if (status == AJ_OK) 
	{
        status = AJ_DeliverMsg(&msg);
    2a1a:	a804      	add	r0, sp, #16
    2a1c:	4b09      	ldr	r3, [pc, #36]	; (2a44 <AJ_BusCancelSessionless+0x60>)
    2a1e:	4798      	blx	r3
    }
    return status;
}
    2a20:	b015      	add	sp, #84	; 0x54
    2a22:	bd30      	pop	{r4, r5, pc}
    2a24:	0001a6e8 	.word	0x0001a6e8
    2a28:	00016e3d 	.word	0x00016e3d
    2a2c:	00000bb8 	.word	0x00000bb8
    2a30:	0001000c 	.word	0x0001000c
    2a34:	0001ebc0 	.word	0x0001ebc0
    2a38:	0000bca5 	.word	0x0000bca5
    2a3c:	0002192c 	.word	0x0002192c
    2a40:	0000bc85 	.word	0x0000bc85
    2a44:	0000a539 	.word	0x0000a539

00002a48 <AJ_BusSetLinkTimeout>:
    }
    return status;
}

AJ_Status AJ_BusSetLinkTimeout(AJ_BusAttachment* bus, uint32_t sessionId, uint32_t linkTimeout)
{
    2a48:	b5f0      	push	{r4, r5, r6, r7, lr}
    2a4a:	b095      	sub	sp, #84	; 0x54
    2a4c:	1c06      	adds	r6, r0, #0
    2a4e:	1c0d      	adds	r5, r1, #0
    2a50:	1c14      	adds	r4, r2, #0
    AJ_Status status;
    AJ_Message msg;

   printf("AJ_BusSetLinkTimeout(bus=0x%p, sessionId=%d., linkTimeout=%d.)\n", bus, sessionId, linkTimeout);
    2a52:	4811      	ldr	r0, [pc, #68]	; (2a98 <AJ_BusSetLinkTimeout+0x50>)
    2a54:	1c31      	adds	r1, r6, #0
    2a56:	1c2a      	adds	r2, r5, #0
    2a58:	1c23      	adds	r3, r4, #0
    2a5a:	4f10      	ldr	r7, [pc, #64]	; (2a9c <AJ_BusSetLinkTimeout+0x54>)
    2a5c:	47b8      	blx	r7

    status = AJ_MarshalMethodCall(bus, &msg, AJ_METHOD_SET_LINK_TIMEOUT, AJ_BusDestination, 0, 0, AJ_METHOD_TIMEOUT);
    2a5e:	2300      	movs	r3, #0
    2a60:	9300      	str	r3, [sp, #0]
    2a62:	9301      	str	r3, [sp, #4]
    2a64:	4b0e      	ldr	r3, [pc, #56]	; (2aa0 <AJ_BusSetLinkTimeout+0x58>)
    2a66:	9302      	str	r3, [sp, #8]
    2a68:	1c30      	adds	r0, r6, #0
    2a6a:	a904      	add	r1, sp, #16
    2a6c:	4a0d      	ldr	r2, [pc, #52]	; (2aa4 <AJ_BusSetLinkTimeout+0x5c>)
    2a6e:	4b0e      	ldr	r3, [pc, #56]	; (2aa8 <AJ_BusSetLinkTimeout+0x60>)
    2a70:	4e0e      	ldr	r6, [pc, #56]	; (2aac <AJ_BusSetLinkTimeout+0x64>)
    2a72:	47b0      	blx	r6
    if (status == AJ_OK) 
    2a74:	2800      	cmp	r0, #0
    2a76:	d10c      	bne.n	2a92 <AJ_BusSetLinkTimeout+0x4a>
	{
        (void)AJ_MarshalArgs(&msg, "u", sessionId);
    2a78:	4e0d      	ldr	r6, [pc, #52]	; (2ab0 <AJ_BusSetLinkTimeout+0x68>)
    2a7a:	a804      	add	r0, sp, #16
    2a7c:	1c31      	adds	r1, r6, #0
    2a7e:	1c2a      	adds	r2, r5, #0
    2a80:	4d0c      	ldr	r5, [pc, #48]	; (2ab4 <AJ_BusSetLinkTimeout+0x6c>)
    2a82:	47a8      	blx	r5
        (void)AJ_MarshalArgs(&msg, "u", linkTimeout);
    2a84:	a804      	add	r0, sp, #16
    2a86:	1c31      	adds	r1, r6, #0
    2a88:	1c22      	adds	r2, r4, #0
    2a8a:	47a8      	blx	r5
        status = AJ_DeliverMsg(&msg);
    2a8c:	a804      	add	r0, sp, #16
    2a8e:	4b0a      	ldr	r3, [pc, #40]	; (2ab8 <AJ_BusSetLinkTimeout+0x70>)
    2a90:	4798      	blx	r3
    }
    return status;
}
    2a92:	b015      	add	sp, #84	; 0x54
    2a94:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2a96:	46c0      	nop			; (mov r8, r8)
    2a98:	0001a790 	.word	0x0001a790
    2a9c:	00016e3d 	.word	0x00016e3d
    2aa0:	00000bb8 	.word	0x00000bb8
    2aa4:	0001000f 	.word	0x0001000f
    2aa8:	0001ebc0 	.word	0x0001ebc0
    2aac:	0000bca5 	.word	0x0000bca5
    2ab0:	0002192c 	.word	0x0002192c
    2ab4:	0000bc85 	.word	0x0000bc85
    2ab8:	0000a539 	.word	0x0000a539

00002abc <AJ_BusSetSignalRuleSerial>:
{
    return AJ_BusSetSignalRuleFlags(bus, ruleString, rule, 0);
}

AJ_Status AJ_BusSetSignalRuleSerial(AJ_BusAttachment* bus, const char* ruleString, uint8_t rule, uint8_t flags, uint32_t* serialNum)
{
    2abc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2abe:	b099      	sub	sp, #100	; 0x64
    2ac0:	9005      	str	r0, [sp, #20]
    2ac2:	1c0d      	adds	r5, r1, #0
    2ac4:	1c17      	adds	r7, r2, #0
    2ac6:	1c1e      	adds	r6, r3, #0
    AJ_Status status;
    AJ_Message msg;
    uint32_t msgId = (rule == AJ_BUS_SIGNAL_ALLOW) ? AJ_METHOD_ADD_MATCH : AJ_METHOD_REMOVE_MATCH;
    2ac8:	4254      	negs	r4, r2
    2aca:	4154      	adcs	r4, r2
    2acc:	2307      	movs	r3, #7
    2ace:	1b1c      	subs	r4, r3, r4

   printf("AJ_BusSetSignalRuleSerial(bus=0x%p, ruleString=\"%s\", rule=%d.)\n", bus, ruleString, rule);
    2ad0:	4823      	ldr	r0, [pc, #140]	; (2b60 <AJ_BusSetSignalRuleSerial+0xa4>)
    2ad2:	9905      	ldr	r1, [sp, #20]
    2ad4:	1c2a      	adds	r2, r5, #0
    2ad6:	1c3b      	adds	r3, r7, #0
    2ad8:	4f22      	ldr	r7, [pc, #136]	; (2b64 <AJ_BusSetSignalRuleSerial+0xa8>)
    2ada:	47b8      	blx	r7

    status = AJ_MarshalMethodCall(bus, &msg, msgId, AJ_DBusDestination, 0, flags, AJ_METHOD_TIMEOUT);
    2adc:	2300      	movs	r3, #0
    2ade:	9300      	str	r3, [sp, #0]
    2ae0:	9601      	str	r6, [sp, #4]
    2ae2:	4b21      	ldr	r3, [pc, #132]	; (2b68 <AJ_BusSetSignalRuleSerial+0xac>)
    2ae4:	9302      	str	r3, [sp, #8]
    2ae6:	9805      	ldr	r0, [sp, #20]
    2ae8:	a908      	add	r1, sp, #32
    2aea:	1c22      	adds	r2, r4, #0
    2aec:	4b1f      	ldr	r3, [pc, #124]	; (2b6c <AJ_BusSetSignalRuleSerial+0xb0>)
    2aee:	4c20      	ldr	r4, [pc, #128]	; (2b70 <AJ_BusSetSignalRuleSerial+0xb4>)
    2af0:	47a0      	blx	r4
    2af2:	1e04      	subs	r4, r0, #0
    if (status == AJ_OK) 
    2af4:	d130      	bne.n	2b58 <AJ_BusSetSignalRuleSerial+0x9c>
	{
        uint32_t sz = 0;
    2af6:	2300      	movs	r3, #0
    2af8:	9307      	str	r3, [sp, #28]
        uint8_t nul = 0;
    2afa:	2213      	movs	r2, #19
    2afc:	a902      	add	r1, sp, #8
    2afe:	468c      	mov	ip, r1
    2b00:	4462      	add	r2, ip
    2b02:	7013      	strb	r3, [r2, #0]
        if (serialNum)
    2b04:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    2b06:	2b00      	cmp	r3, #0
    2b08:	d005      	beq.n	2b16 <AJ_BusSetSignalRuleSerial+0x5a>
		{
            *serialNum = msg.hdr->serialNum;
    2b0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    2b0c:	689b      	ldr	r3, [r3, #8]
    2b0e:	9305      	str	r3, [sp, #20]
    2b10:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    2b12:	9a05      	ldr	r2, [sp, #20]
    2b14:	601a      	str	r2, [r3, #0]
        }
        sz = (uint32_t)strlen(ruleString);
    2b16:	1c28      	adds	r0, r5, #0
    2b18:	4f16      	ldr	r7, [pc, #88]	; (2b74 <AJ_BusSetSignalRuleSerial+0xb8>)
    2b1a:	47b8      	blx	r7
    2b1c:	9007      	str	r0, [sp, #28]
		//    
        status = AJ_DeliverMsgPartial(&msg, sz + 5);
    2b1e:	1d41      	adds	r1, r0, #5
    2b20:	a808      	add	r0, sp, #32
    2b22:	4b15      	ldr	r3, [pc, #84]	; (2b78 <AJ_BusSetSignalRuleSerial+0xbc>)
    2b24:	4798      	blx	r3
    2b26:	1c04      	adds	r4, r0, #0
		// 
        AJ_MarshalRaw(&msg, &sz, 4);
    2b28:	a808      	add	r0, sp, #32
    2b2a:	a907      	add	r1, sp, #28
    2b2c:	2204      	movs	r2, #4
    2b2e:	4e13      	ldr	r6, [pc, #76]	; (2b7c <AJ_BusSetSignalRuleSerial+0xc0>)
    2b30:	47b0      	blx	r6
        AJ_MarshalRaw(&msg, ruleString, strlen(ruleString));
    2b32:	1c28      	adds	r0, r5, #0
    2b34:	47b8      	blx	r7
    2b36:	1c02      	adds	r2, r0, #0
    2b38:	a808      	add	r0, sp, #32
    2b3a:	1c29      	adds	r1, r5, #0
    2b3c:	47b0      	blx	r6
        AJ_MarshalRaw(&msg, &nul, 1);
    2b3e:	a808      	add	r0, sp, #32
    2b40:	2113      	movs	r1, #19
    2b42:	ab02      	add	r3, sp, #8
    2b44:	469c      	mov	ip, r3
    2b46:	4461      	add	r1, ip
    2b48:	2201      	movs	r2, #1
    2b4a:	47b0      	blx	r6
    }
    if (status == AJ_OK)
    2b4c:	2c00      	cmp	r4, #0
    2b4e:	d103      	bne.n	2b58 <AJ_BusSetSignalRuleSerial+0x9c>
	{
        status = AJ_DeliverMsg(&msg);
    2b50:	a808      	add	r0, sp, #32
    2b52:	4b0b      	ldr	r3, [pc, #44]	; (2b80 <AJ_BusSetSignalRuleSerial+0xc4>)
    2b54:	4798      	blx	r3
    2b56:	1c04      	adds	r4, r0, #0
    }
    return status;
}
    2b58:	1c20      	adds	r0, r4, #0
    2b5a:	b019      	add	sp, #100	; 0x64
    2b5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2b5e:	46c0      	nop			; (mov r8, r8)
    2b60:	0001a7d0 	.word	0x0001a7d0
    2b64:	00016e3d 	.word	0x00016e3d
    2b68:	00000bb8 	.word	0x00000bb8
    2b6c:	0001e7b8 	.word	0x0001e7b8
    2b70:	0000bca5 	.word	0x0000bca5
    2b74:	0001715b 	.word	0x0001715b
    2b78:	0000b701 	.word	0x0000b701
    2b7c:	0000b82d 	.word	0x0000b82d
    2b80:	0000a539 	.word	0x0000a539

00002b84 <AJ_BusSetSignalRuleFlags>:
    }
    return status;
}

AJ_Status AJ_BusSetSignalRuleFlags(AJ_BusAttachment* bus, const char* ruleString, uint8_t rule, uint8_t flags)
{
    2b84:	b510      	push	{r4, lr}
    2b86:	b082      	sub	sp, #8
    return AJ_BusSetSignalRuleSerial(bus, ruleString, rule, flags, NULL);
    2b88:	2400      	movs	r4, #0
    2b8a:	9400      	str	r4, [sp, #0]
    2b8c:	4c01      	ldr	r4, [pc, #4]	; (2b94 <AJ_BusSetSignalRuleFlags+0x10>)
    2b8e:	47a0      	blx	r4
}
    2b90:	b002      	add	sp, #8
    2b92:	bd10      	pop	{r4, pc}
    2b94:	00002abd 	.word	0x00002abd

00002b98 <AJ_BusSetSignalRule>:
    }
    return status;
}

AJ_Status AJ_BusSetSignalRule(AJ_BusAttachment* bus, const char* ruleString, uint8_t rule)
{
    2b98:	b510      	push	{r4, lr}
    return AJ_BusSetSignalRuleFlags(bus, ruleString, rule, 0);
    2b9a:	2300      	movs	r3, #0
    2b9c:	4c01      	ldr	r4, [pc, #4]	; (2ba4 <AJ_BusSetSignalRule+0xc>)
    2b9e:	47a0      	blx	r4
}
    2ba0:	bd10      	pop	{r4, pc}
    2ba2:	46c0      	nop			; (mov r8, r8)
    2ba4:	00002b85 	.word	0x00002b85

00002ba8 <AJ_BusReplyAcceptSession>:
{
    return AJ_BusSetSignalRuleSerial(bus, ruleString, rule, flags, NULL);
}

AJ_Status AJ_BusReplyAcceptSession(AJ_Message* msg, uint32_t accept)
{
    2ba8:	b530      	push	{r4, r5, lr}
    2baa:	b091      	sub	sp, #68	; 0x44
    2bac:	1c05      	adds	r5, r0, #0
    2bae:	1c0c      	adds	r4, r1, #0
    AJ_Message reply;

   printf("AJ_BusReplyAcceptSession(msg=0x%p, accept=%d.)\n", msg, accept);
    2bb0:	4809      	ldr	r0, [pc, #36]	; (2bd8 <AJ_BusReplyAcceptSession+0x30>)
    2bb2:	1c29      	adds	r1, r5, #0
    2bb4:	1c22      	adds	r2, r4, #0
    2bb6:	4b09      	ldr	r3, [pc, #36]	; (2bdc <AJ_BusReplyAcceptSession+0x34>)
    2bb8:	4798      	blx	r3

    AJ_MarshalReplyMsg(msg, &reply);
    2bba:	1c28      	adds	r0, r5, #0
    2bbc:	4669      	mov	r1, sp
    2bbe:	4b08      	ldr	r3, [pc, #32]	; (2be0 <AJ_BusReplyAcceptSession+0x38>)
    2bc0:	4798      	blx	r3
    AJ_MarshalArgs(&reply, "b", accept);
    2bc2:	4668      	mov	r0, sp
    2bc4:	4907      	ldr	r1, [pc, #28]	; (2be4 <AJ_BusReplyAcceptSession+0x3c>)
    2bc6:	1c22      	adds	r2, r4, #0
    2bc8:	4b07      	ldr	r3, [pc, #28]	; (2be8 <AJ_BusReplyAcceptSession+0x40>)
    2bca:	4798      	blx	r3
    return AJ_DeliverMsg(&reply);
    2bcc:	4668      	mov	r0, sp
    2bce:	4b07      	ldr	r3, [pc, #28]	; (2bec <AJ_BusReplyAcceptSession+0x44>)
    2bd0:	4798      	blx	r3
}
    2bd2:	b011      	add	sp, #68	; 0x44
    2bd4:	bd30      	pop	{r4, r5, pc}
    2bd6:	46c0      	nop			; (mov r8, r8)
    2bd8:	0001a888 	.word	0x0001a888
    2bdc:	00016e3d 	.word	0x00016e3d
    2be0:	0000bd45 	.word	0x0000bd45
    2be4:	0001ed84 	.word	0x0001ed84
    2be8:	0000bc85 	.word	0x0000bc85
    2bec:	0000a539 	.word	0x0000a539

00002bf0 <AJ_BusHandleBusMessage>:
    return status;

}

AJ_Status AJ_BusHandleBusMessage(AJ_Message* msg)
{
    2bf0:	b570      	push	{r4, r5, r6, lr}
    2bf2:	b09e      	sub	sp, #120	; 0x78
    2bf4:	1c04      	adds	r4, r0, #0
    AJ_Status status = AJ_OK;
    AJ_BusAttachment* bus = msg->bus;
    2bf6:	6b06      	ldr	r6, [r0, #48]	; 0x30
    char* languageTag;
    AJ_Message reply;

    printf("AJ_BusHandleBusMessage(msg=0x%p)\n", msg);
    2bf8:	48b4      	ldr	r0, [pc, #720]	; (2ecc <AJ_BusHandleBusMessage+0x2dc>)
    2bfa:	1c21      	adds	r1, r4, #0
    2bfc:	4bb4      	ldr	r3, [pc, #720]	; (2ed0 <AJ_BusHandleBusMessage+0x2e0>)
    2bfe:	4798      	blx	r3
    memset(&reply, 0, sizeof(AJ_Message));
    2c00:	a80d      	add	r0, sp, #52	; 0x34
    2c02:	2100      	movs	r1, #0
    2c04:	2240      	movs	r2, #64	; 0x40
    2c06:	4bb3      	ldr	r3, [pc, #716]	; (2ed4 <AJ_BusHandleBusMessage+0x2e4>)
    2c08:	4798      	blx	r3
    // Check we actually have a message to handle
    if (!msg->hdr) 
    2c0a:	6863      	ldr	r3, [r4, #4]
    2c0c:	2b00      	cmp	r3, #0
    2c0e:	d100      	bne.n	2c12 <AJ_BusHandleBusMessage+0x22>
    2c10:	e223      	b.n	305a <AJ_BusHandleBusMessage+0x46a>
	{
        return AJ_OK;
    }
	// printf("1 msg->hdr->msgType = %d\n",msg->hdr->msgType);
  //  printf("msg->msgId: %d\n", msg->msgId);
    switch (msg->msgId) 
    2c12:	6823      	ldr	r3, [r4, #0]
    2c14:	22a0      	movs	r2, #160	; 0xa0
    2c16:	02d2      	lsls	r2, r2, #11
    2c18:	4293      	cmp	r3, r2
    2c1a:	d100      	bne.n	2c1e <AJ_BusHandleBusMessage+0x2e>
    2c1c:	e124      	b.n	2e68 <AJ_BusHandleBusMessage+0x278>
    2c1e:	d837      	bhi.n	2c90 <AJ_BusHandleBusMessage+0xa0>
    2c20:	4aad      	ldr	r2, [pc, #692]	; (2ed8 <AJ_BusHandleBusMessage+0x2e8>)
    2c22:	4293      	cmp	r3, r2
    2c24:	d100      	bne.n	2c28 <AJ_BusHandleBusMessage+0x38>
    2c26:	e0d1      	b.n	2dcc <AJ_BusHandleBusMessage+0x1dc>
    2c28:	d818      	bhi.n	2c5c <AJ_BusHandleBusMessage+0x6c>
    2c2a:	4aac      	ldr	r2, [pc, #688]	; (2edc <AJ_BusHandleBusMessage+0x2ec>)
    2c2c:	4293      	cmp	r3, r2
    2c2e:	d100      	bne.n	2c32 <AJ_BusHandleBusMessage+0x42>
    2c30:	e10d      	b.n	2e4e <AJ_BusHandleBusMessage+0x25e>
    2c32:	d806      	bhi.n	2c42 <AJ_BusHandleBusMessage+0x52>
    2c34:	2b02      	cmp	r3, #2
    2c36:	d100      	bne.n	2c3a <AJ_BusHandleBusMessage+0x4a>
    2c38:	e109      	b.n	2e4e <AJ_BusHandleBusMessage+0x25e>
    2c3a:	4aa9      	ldr	r2, [pc, #676]	; (2ee0 <AJ_BusHandleBusMessage+0x2f0>)
    2c3c:	4293      	cmp	r3, r2
    2c3e:	d06c      	beq.n	2d1a <AJ_BusHandleBusMessage+0x12a>
    2c40:	e1de      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2c42:	4aa8      	ldr	r2, [pc, #672]	; (2ee4 <AJ_BusHandleBusMessage+0x2f4>)
    2c44:	4293      	cmp	r3, r2
    2c46:	d100      	bne.n	2c4a <AJ_BusHandleBusMessage+0x5a>
    2c48:	e0ae      	b.n	2da8 <AJ_BusHandleBusMessage+0x1b8>
    2c4a:	4aa7      	ldr	r2, [pc, #668]	; (2ee8 <AJ_BusHandleBusMessage+0x2f8>)
    2c4c:	4293      	cmp	r3, r2
    2c4e:	d100      	bne.n	2c52 <AJ_BusHandleBusMessage+0x62>
    2c50:	e0b3      	b.n	2dba <AJ_BusHandleBusMessage+0x1ca>
    2c52:	4aa6      	ldr	r2, [pc, #664]	; (2eec <AJ_BusHandleBusMessage+0x2fc>)
    2c54:	4293      	cmp	r3, r2
    2c56:	d000      	beq.n	2c5a <AJ_BusHandleBusMessage+0x6a>
    2c58:	e1d2      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2c5a:	e09c      	b.n	2d96 <AJ_BusHandleBusMessage+0x1a6>
    2c5c:	4aa4      	ldr	r2, [pc, #656]	; (2ef0 <AJ_BusHandleBusMessage+0x300>)
    2c5e:	4293      	cmp	r3, r2
    2c60:	d052      	beq.n	2d08 <AJ_BusHandleBusMessage+0x118>
    2c62:	d80a      	bhi.n	2c7a <AJ_BusHandleBusMessage+0x8a>
    2c64:	4aa3      	ldr	r2, [pc, #652]	; (2ef4 <AJ_BusHandleBusMessage+0x304>)
    2c66:	4293      	cmp	r3, r2
    2c68:	d100      	bne.n	2c6c <AJ_BusHandleBusMessage+0x7c>
    2c6a:	e0c7      	b.n	2dfc <AJ_BusHandleBusMessage+0x20c>
    2c6c:	d200      	bcs.n	2c70 <AJ_BusHandleBusMessage+0x80>
    2c6e:	e0b6      	b.n	2dde <AJ_BusHandleBusMessage+0x1ee>
    2c70:	22c0      	movs	r2, #192	; 0xc0
    2c72:	0292      	lsls	r2, r2, #10
    2c74:	4293      	cmp	r3, r2
    2c76:	d06c      	beq.n	2d52 <AJ_BusHandleBusMessage+0x162>
    2c78:	e1c2      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2c7a:	4a9f      	ldr	r2, [pc, #636]	; (2ef8 <AJ_BusHandleBusMessage+0x308>)
    2c7c:	4293      	cmp	r3, r2
    2c7e:	d072      	beq.n	2d66 <AJ_BusHandleBusMessage+0x176>
    2c80:	4a9e      	ldr	r2, [pc, #632]	; (2efc <AJ_BusHandleBusMessage+0x30c>)
    2c82:	4293      	cmp	r3, r2
    2c84:	d078      	beq.n	2d78 <AJ_BusHandleBusMessage+0x188>
    2c86:	4a9e      	ldr	r2, [pc, #632]	; (2f00 <AJ_BusHandleBusMessage+0x310>)
    2c88:	4293      	cmp	r3, r2
    2c8a:	d000      	beq.n	2c8e <AJ_BusHandleBusMessage+0x9e>
    2c8c:	e1b8      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2c8e:	e048      	b.n	2d22 <AJ_BusHandleBusMessage+0x132>
    2c90:	4a9c      	ldr	r2, [pc, #624]	; (2f04 <AJ_BusHandleBusMessage+0x314>)
    2c92:	4293      	cmp	r3, r2
    2c94:	d81b      	bhi.n	2cce <AJ_BusHandleBusMessage+0xde>
    2c96:	4a9c      	ldr	r2, [pc, #624]	; (2f08 <AJ_BusHandleBusMessage+0x318>)
    2c98:	4293      	cmp	r3, r2
    2c9a:	d300      	bcc.n	2c9e <AJ_BusHandleBusMessage+0xae>
    2c9c:	e0db      	b.n	2e56 <AJ_BusHandleBusMessage+0x266>
    2c9e:	22c0      	movs	r2, #192	; 0xc0
    2ca0:	02d2      	lsls	r2, r2, #11
    2ca2:	4293      	cmp	r3, r2
    2ca4:	d100      	bne.n	2ca8 <AJ_BusHandleBusMessage+0xb8>
    2ca6:	e0f8      	b.n	2e9a <AJ_BusHandleBusMessage+0x2aa>
    2ca8:	d808      	bhi.n	2cbc <AJ_BusHandleBusMessage+0xcc>
    2caa:	4a98      	ldr	r2, [pc, #608]	; (2f0c <AJ_BusHandleBusMessage+0x31c>)
    2cac:	4293      	cmp	r3, r2
    2cae:	d100      	bne.n	2cb2 <AJ_BusHandleBusMessage+0xc2>
    2cb0:	e0e1      	b.n	2e76 <AJ_BusHandleBusMessage+0x286>
    2cb2:	4a97      	ldr	r2, [pc, #604]	; (2f10 <AJ_BusHandleBusMessage+0x320>)
    2cb4:	4293      	cmp	r3, r2
    2cb6:	d100      	bne.n	2cba <AJ_BusHandleBusMessage+0xca>
    2cb8:	e0e6      	b.n	2e88 <AJ_BusHandleBusMessage+0x298>
    2cba:	e1a1      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2cbc:	4a95      	ldr	r2, [pc, #596]	; (2f14 <AJ_BusHandleBusMessage+0x324>)
    2cbe:	4293      	cmp	r3, r2
    2cc0:	d100      	bne.n	2cc4 <AJ_BusHandleBusMessage+0xd4>
    2cc2:	e0f1      	b.n	2ea8 <AJ_BusHandleBusMessage+0x2b8>
    2cc4:	4a94      	ldr	r2, [pc, #592]	; (2f18 <AJ_BusHandleBusMessage+0x328>)
    2cc6:	4293      	cmp	r3, r2
    2cc8:	d100      	bne.n	2ccc <AJ_BusHandleBusMessage+0xdc>
    2cca:	e0f6      	b.n	2eba <AJ_BusHandleBusMessage+0x2ca>
    2ccc:	e198      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2cce:	4a93      	ldr	r2, [pc, #588]	; (2f1c <AJ_BusHandleBusMessage+0x32c>)
    2cd0:	4293      	cmp	r3, r2
    2cd2:	d100      	bne.n	2cd6 <AJ_BusHandleBusMessage+0xe6>
    2cd4:	e0b3      	b.n	2e3e <AJ_BusHandleBusMessage+0x24e>
    2cd6:	d80a      	bhi.n	2cee <AJ_BusHandleBusMessage+0xfe>
    2cd8:	4a91      	ldr	r2, [pc, #580]	; (2f20 <AJ_BusHandleBusMessage+0x330>)
    2cda:	4293      	cmp	r3, r2
    2cdc:	d100      	bne.n	2ce0 <AJ_BusHandleBusMessage+0xf0>
    2cde:	e096      	b.n	2e0e <AJ_BusHandleBusMessage+0x21e>
    2ce0:	d900      	bls.n	2ce4 <AJ_BusHandleBusMessage+0xf4>
    2ce2:	e0a8      	b.n	2e36 <AJ_BusHandleBusMessage+0x246>
    2ce4:	4a8f      	ldr	r2, [pc, #572]	; (2f24 <AJ_BusHandleBusMessage+0x334>)
    2ce6:	4293      	cmp	r3, r2
    2ce8:	d100      	bne.n	2cec <AJ_BusHandleBusMessage+0xfc>
    2cea:	e0ac      	b.n	2e46 <AJ_BusHandleBusMessage+0x256>
    2cec:	e188      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2cee:	4a8e      	ldr	r2, [pc, #568]	; (2f28 <AJ_BusHandleBusMessage+0x338>)
    2cf0:	4293      	cmp	r3, r2
    2cf2:	d100      	bne.n	2cf6 <AJ_BusHandleBusMessage+0x106>
    2cf4:	e093      	b.n	2e1e <AJ_BusHandleBusMessage+0x22e>
    2cf6:	4a8d      	ldr	r2, [pc, #564]	; (2f2c <AJ_BusHandleBusMessage+0x33c>)
    2cf8:	4293      	cmp	r3, r2
    2cfa:	d100      	bne.n	2cfe <AJ_BusHandleBusMessage+0x10e>
    2cfc:	e093      	b.n	2e26 <AJ_BusHandleBusMessage+0x236>
    2cfe:	4a8c      	ldr	r2, [pc, #560]	; (2f30 <AJ_BusHandleBusMessage+0x340>)
    2d00:	4293      	cmp	r3, r2
    2d02:	d000      	beq.n	2d06 <AJ_BusHandleBusMessage+0x116>
    2d04:	e17c      	b.n	3000 <AJ_BusHandleBusMessage+0x410>
    2d06:	e086      	b.n	2e16 <AJ_BusHandleBusMessage+0x226>
	{
    case AJ_METHOD_PING:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_PING\n");
    2d08:	488a      	ldr	r0, [pc, #552]	; (2f34 <AJ_BusHandleBusMessage+0x344>)
    2d0a:	4b8b      	ldr	r3, [pc, #556]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d0c:	4798      	blx	r3
        status = AJ_MarshalReplyMsg(msg, &reply);
    2d0e:	1c20      	adds	r0, r4, #0
    2d10:	a90d      	add	r1, sp, #52	; 0x34
    2d12:	4b8a      	ldr	r3, [pc, #552]	; (2f3c <AJ_BusHandleBusMessage+0x34c>)
    2d14:	4798      	blx	r3
    2d16:	1c05      	adds	r5, r0, #0
        break;
    2d18:	e182      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_JOIN_SESSION:
    printf("AJ_METHOD_JOIN_SESSION\n");
    2d1a:	4889      	ldr	r0, [pc, #548]	; (2f40 <AJ_BusHandleBusMessage+0x350>)
    2d1c:	4b86      	ldr	r3, [pc, #536]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d1e:	4798      	blx	r3

    break;
    2d20:	e19d      	b.n	305e <AJ_BusHandleBusMessage+0x46e>
    case AJ_METHOD_GET_MACHINE_ID:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_GET_MACHINE_ID\n");
    2d22:	4888      	ldr	r0, [pc, #544]	; (2f44 <AJ_BusHandleBusMessage+0x354>)
    2d24:	4b84      	ldr	r3, [pc, #528]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d26:	4798      	blx	r3
static AJ_Status HandleGetMachineId(AJ_Message* msg, AJ_Message* reply)
{
    char guidStr[33];
    AJ_GUID localGuid;

   printf("HandleGetMachineId(msg=0x%p, reply=0x%p)\n", msg, reply);
    2d28:	4887      	ldr	r0, [pc, #540]	; (2f48 <AJ_BusHandleBusMessage+0x358>)
    2d2a:	1c21      	adds	r1, r4, #0
    2d2c:	aa0d      	add	r2, sp, #52	; 0x34
    2d2e:	4b68      	ldr	r3, [pc, #416]	; (2ed0 <AJ_BusHandleBusMessage+0x2e0>)
    2d30:	4798      	blx	r3

    AJ_MarshalReplyMsg(msg, reply);
    2d32:	1c20      	adds	r0, r4, #0
    2d34:	a90d      	add	r1, sp, #52	; 0x34
    2d36:	4b81      	ldr	r3, [pc, #516]	; (2f3c <AJ_BusHandleBusMessage+0x34c>)
    2d38:	4798      	blx	r3
    //AJ_GetLocalGUID(&localGuid);
    AJ_GUID_ToString(&localGuid, guidStr, sizeof(guidStr));
    2d3a:	4668      	mov	r0, sp
    2d3c:	a904      	add	r1, sp, #16
    2d3e:	2221      	movs	r2, #33	; 0x21
    2d40:	4b82      	ldr	r3, [pc, #520]	; (2f4c <AJ_BusHandleBusMessage+0x35c>)
    2d42:	4798      	blx	r3
    return AJ_MarshalArgs(reply, "s", guidStr);
    2d44:	a80d      	add	r0, sp, #52	; 0x34
    2d46:	4982      	ldr	r1, [pc, #520]	; (2f50 <AJ_BusHandleBusMessage+0x360>)
    2d48:	aa04      	add	r2, sp, #16
    2d4a:	4b82      	ldr	r3, [pc, #520]	; (2f54 <AJ_BusHandleBusMessage+0x364>)
    2d4c:	4798      	blx	r3
    2d4e:	1c05      	adds	r5, r0, #0

    break;
    case AJ_METHOD_GET_MACHINE_ID:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_GET_MACHINE_ID\n");
        status = HandleGetMachineId(msg, &reply);
        break;
    2d50:	e166      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_INTROSPECT:
	 //   printf("2 msg->hdr->msgType = %d\n",msg->hdr->msgType);
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_INTROSPECT\n");
    2d52:	4881      	ldr	r0, [pc, #516]	; (2f58 <AJ_BusHandleBusMessage+0x368>)
    2d54:	4b78      	ldr	r3, [pc, #480]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d56:	4798      	blx	r3
		
        status = AJ_HandleIntrospectRequest(msg, &reply, NULL);
    2d58:	1c20      	adds	r0, r4, #0
    2d5a:	a90d      	add	r1, sp, #52	; 0x34
    2d5c:	2200      	movs	r2, #0
    2d5e:	4b7f      	ldr	r3, [pc, #508]	; (2f5c <AJ_BusHandleBusMessage+0x36c>)
    2d60:	4798      	blx	r3
    2d62:	1c05      	adds	r5, r0, #0
		// printf("3 msg->hdr->msgType = %d\n",msg->hdr->msgType);
        break;
    2d64:	e15c      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_GET_DESCRIPTION_LANG:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_GET_DESCRIPTION_LANG\n");
    2d66:	487e      	ldr	r0, [pc, #504]	; (2f60 <AJ_BusHandleBusMessage+0x370>)
    2d68:	4b73      	ldr	r3, [pc, #460]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d6a:	4798      	blx	r3
        status = AJ_HandleGetDescriptionLanguages(msg, &reply);
    2d6c:	1c20      	adds	r0, r4, #0
    2d6e:	a90d      	add	r1, sp, #52	; 0x34
    2d70:	4b7c      	ldr	r3, [pc, #496]	; (2f64 <AJ_BusHandleBusMessage+0x374>)
    2d72:	4798      	blx	r3
    2d74:	1c05      	adds	r5, r0, #0
        break;
    2d76:	e153      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_INTROSPECT_WITH_DESC:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_INTROSPECT_WITH_DESC\n");
    2d78:	487b      	ldr	r0, [pc, #492]	; (2f68 <AJ_BusHandleBusMessage+0x378>)
    2d7a:	4b6f      	ldr	r3, [pc, #444]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d7c:	4798      	blx	r3
        AJ_UnmarshalArgs(msg, "s", &languageTag);
    2d7e:	1c20      	adds	r0, r4, #0
    2d80:	4973      	ldr	r1, [pc, #460]	; (2f50 <AJ_BusHandleBusMessage+0x360>)
    2d82:	aa1d      	add	r2, sp, #116	; 0x74
    2d84:	4b79      	ldr	r3, [pc, #484]	; (2f6c <AJ_BusHandleBusMessage+0x37c>)
    2d86:	4798      	blx	r3
        status = AJ_HandleIntrospectRequest(msg, &reply, languageTag);
    2d88:	1c20      	adds	r0, r4, #0
    2d8a:	a90d      	add	r1, sp, #52	; 0x34
    2d8c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    2d8e:	4b73      	ldr	r3, [pc, #460]	; (2f5c <AJ_BusHandleBusMessage+0x36c>)
    2d90:	4798      	blx	r3
    2d92:	1c05      	adds	r5, r0, #0
        break;
    2d94:	e144      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_EXCHANGE_GUIDS:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_EXCHANGE_GUIDS\n");
    2d96:	4876      	ldr	r0, [pc, #472]	; (2f70 <AJ_BusHandleBusMessage+0x380>)
    2d98:	4b67      	ldr	r3, [pc, #412]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2d9a:	4798      	blx	r3
        status = AJ_PeerHandleExchangeGUIDs(msg, &reply);
    2d9c:	1c20      	adds	r0, r4, #0
    2d9e:	a90d      	add	r1, sp, #52	; 0x34
    2da0:	4b74      	ldr	r3, [pc, #464]	; (2f74 <AJ_BusHandleBusMessage+0x384>)
    2da2:	4798      	blx	r3
    2da4:	1c05      	adds	r5, r0, #0
        break;
    2da6:	e13b      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_GEN_SESSION_KEY:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_GEN_SESSION_KEY\n");
    2da8:	4873      	ldr	r0, [pc, #460]	; (2f78 <AJ_BusHandleBusMessage+0x388>)
    2daa:	4b63      	ldr	r3, [pc, #396]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2dac:	4798      	blx	r3
        status = AJ_PeerHandleGenSessionKey(msg, &reply);
    2dae:	1c20      	adds	r0, r4, #0
    2db0:	a90d      	add	r1, sp, #52	; 0x34
    2db2:	4b72      	ldr	r3, [pc, #456]	; (2f7c <AJ_BusHandleBusMessage+0x38c>)
    2db4:	4798      	blx	r3
    2db6:	1c05      	adds	r5, r0, #0
        break;
    2db8:	e132      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_EXCHANGE_GROUP_KEYS:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_EXCHANGE_GROUP_KEYS\n");
    2dba:	4871      	ldr	r0, [pc, #452]	; (2f80 <AJ_BusHandleBusMessage+0x390>)
    2dbc:	4b5e      	ldr	r3, [pc, #376]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2dbe:	4798      	blx	r3
        status = AJ_PeerHandleExchangeGroupKeys(msg, &reply);
    2dc0:	1c20      	adds	r0, r4, #0
    2dc2:	a90d      	add	r1, sp, #52	; 0x34
    2dc4:	4b6f      	ldr	r3, [pc, #444]	; (2f84 <AJ_BusHandleBusMessage+0x394>)
    2dc6:	4798      	blx	r3
    2dc8:	1c05      	adds	r5, r0, #0
        break;
    2dca:	e129      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_EXCHANGE_SUITES:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_EXCHANGE_SUITES\n");
    2dcc:	486e      	ldr	r0, [pc, #440]	; (2f88 <AJ_BusHandleBusMessage+0x398>)
    2dce:	4b5a      	ldr	r3, [pc, #360]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2dd0:	4798      	blx	r3
        status = AJ_PeerHandleExchangeSuites(msg, &reply);
    2dd2:	1c20      	adds	r0, r4, #0
    2dd4:	a90d      	add	r1, sp, #52	; 0x34
    2dd6:	4b6d      	ldr	r3, [pc, #436]	; (2f8c <AJ_BusHandleBusMessage+0x39c>)
    2dd8:	4798      	blx	r3
    2dda:	1c05      	adds	r5, r0, #0
        break;
    2ddc:	e120      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_KEY_EXCHANGE:
        printf("AJ_BusHandleBusMessage(): AJ_METHOD_KEY_EXCHANGE\n");
    2dde:	486c      	ldr	r0, [pc, #432]	; (2f90 <AJ_BusHandleBusMessage+0x3a0>)
    2de0:	4b55      	ldr	r3, [pc, #340]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2de2:	4798      	blx	r3
        status = AJ_PeerHandleKeyExchange(msg, &reply);
    2de4:	1c20      	adds	r0, r4, #0
    2de6:	a90d      	add	r1, sp, #52	; 0x34
    2de8:	4b6a      	ldr	r3, [pc, #424]	; (2f94 <AJ_BusHandleBusMessage+0x3a4>)
    2dea:	4798      	blx	r3
    2dec:	1c05      	adds	r5, r0, #0
		printf("AJ_METHOD_KEY_EXCHANGE status=%s\n",AJ_StatusText(status));
    2dee:	4b6a      	ldr	r3, [pc, #424]	; (2f98 <AJ_BusHandleBusMessage+0x3a8>)
    2df0:	4798      	blx	r3
    2df2:	1c01      	adds	r1, r0, #0
    2df4:	4869      	ldr	r0, [pc, #420]	; (2f9c <AJ_BusHandleBusMessage+0x3ac>)
    2df6:	4b36      	ldr	r3, [pc, #216]	; (2ed0 <AJ_BusHandleBusMessage+0x2e0>)
    2df8:	4798      	blx	r3
		
        break;
    2dfa:	e111      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_KEY_AUTHENTICATION:
       printf("AJ_BusHandleBusMessage(): AJ_METHOD_KEY_AUTHENTICATION\n");
    2dfc:	4868      	ldr	r0, [pc, #416]	; (2fa0 <AJ_BusHandleBusMessage+0x3b0>)
    2dfe:	4b4e      	ldr	r3, [pc, #312]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e00:	4798      	blx	r3
        status = AJ_PeerHandleKeyAuthentication(msg, &reply);
    2e02:	1c20      	adds	r0, r4, #0
    2e04:	a90d      	add	r1, sp, #52	; 0x34
    2e06:	4b67      	ldr	r3, [pc, #412]	; (2fa4 <AJ_BusHandleBusMessage+0x3b4>)
    2e08:	4798      	blx	r3
    2e0a:	1c05      	adds	r5, r0, #0
        break;
    2e0c:	e108      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_REPLY_ID(AJ_METHOD_EXCHANGE_GUIDS):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_EXCHANGE_GUIDS)\n");
    2e0e:	4866      	ldr	r0, [pc, #408]	; (2fa8 <AJ_BusHandleBusMessage+0x3b8>)
    2e10:	4b49      	ldr	r3, [pc, #292]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e12:	4798      	blx	r3
    //    status = AJ_PeerHandleExchangeGUIDsReply(msg);
        break;
    2e14:	e123      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_EXCHANGE_SUITES):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_EXCHANGE_SUITES)\n");
    2e16:	4865      	ldr	r0, [pc, #404]	; (2fac <AJ_BusHandleBusMessage+0x3bc>)
    2e18:	4b47      	ldr	r3, [pc, #284]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e1a:	4798      	blx	r3
    //    status = AJ_PeerHandleExchangeSuitesReply(msg);
        break;
    2e1c:	e11f      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_KEY_EXCHANGE):
       printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_KEY_EXCHANGE)\n");
    2e1e:	4864      	ldr	r0, [pc, #400]	; (2fb0 <AJ_BusHandleBusMessage+0x3c0>)
    2e20:	4b45      	ldr	r3, [pc, #276]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e22:	4798      	blx	r3
      //  status = AJ_PeerHandleKeyExchangeReply(msg);
        break;
    2e24:	e11b      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_KEY_AUTHENTICATION):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_KEY_AUTHENTICATION)\n");
    2e26:	4863      	ldr	r0, [pc, #396]	; (2fb4 <AJ_BusHandleBusMessage+0x3c4>)
    2e28:	4b43      	ldr	r3, [pc, #268]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e2a:	4798      	blx	r3
        status = AJ_PeerHandleKeyAuthenticationReply(msg);
    2e2c:	1c20      	adds	r0, r4, #0
    2e2e:	4b62      	ldr	r3, [pc, #392]	; (2fb8 <AJ_BusHandleBusMessage+0x3c8>)
    2e30:	4798      	blx	r3
    2e32:	1c05      	adds	r5, r0, #0
        break;
    2e34:	e0f4      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_REPLY_ID(AJ_METHOD_GEN_SESSION_KEY):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_GEN_SESSION_KEY)\n");
    2e36:	4861      	ldr	r0, [pc, #388]	; (2fbc <AJ_BusHandleBusMessage+0x3cc>)
    2e38:	4b3f      	ldr	r3, [pc, #252]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e3a:	4798      	blx	r3
     //   status = AJ_PeerHandleGenSessionKeyReply(msg);
        break;
    2e3c:	e10f      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_EXCHANGE_GROUP_KEYS):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_EXCHANGE_GROUP_KEYS)\n");
    2e3e:	4860      	ldr	r0, [pc, #384]	; (2fc0 <AJ_BusHandleBusMessage+0x3d0>)
    2e40:	4b3d      	ldr	r3, [pc, #244]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e42:	4798      	blx	r3
      //  status = AJ_PeerHandleExchangeGroupKeysReply(msg);
        break;
    2e44:	e10b      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_CANCEL_SESSIONLESS):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_CANCEL_SESSIONLESS)\n");
    2e46:	485f      	ldr	r0, [pc, #380]	; (2fc4 <AJ_BusHandleBusMessage+0x3d4>)
    2e48:	4b3b      	ldr	r3, [pc, #236]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e4a:	4798      	blx	r3
        // handle return code here
        status = AJ_OK;
        break;
    2e4c:	e107      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_SIGNAL_SESSION_JOINED:
    case AJ_SIGNAL_NAME_ACQUIRED:
        printf("AJ_BusHandleBusMessage(): AJ_SIGNAL_{SESSION_JOINED|NAME_ACQUIRED}\n");
    2e4e:	485e      	ldr	r0, [pc, #376]	; (2fc8 <AJ_BusHandleBusMessage+0x3d8>)
    2e50:	4b39      	ldr	r3, [pc, #228]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e52:	4798      	blx	r3
        // nothing to do here
        status = AJ_OK;
        break;
    2e54:	e103      	b.n	305e <AJ_BusHandleBusMessage+0x46e>

    case AJ_REPLY_ID(AJ_METHOD_CANCEL_ADVERTISE):
    case AJ_REPLY_ID(AJ_METHOD_ADVERTISE_NAME):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_{CANCEL_ADVERTISE|ADVERTISE_NAME})\n");
    2e56:	485d      	ldr	r0, [pc, #372]	; (2fcc <AJ_BusHandleBusMessage+0x3dc>)
    2e58:	4b37      	ldr	r3, [pc, #220]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e5a:	4798      	blx	r3
        if (msg->hdr->msgType == AJ_MSG_ERROR) 
    2e5c:	6863      	ldr	r3, [r4, #4]
    2e5e:	785b      	ldrb	r3, [r3, #1]
    2e60:	2b03      	cmp	r3, #3
    2e62:	d000      	beq.n	2e66 <AJ_BusHandleBusMessage+0x276>
    2e64:	e0fb      	b.n	305e <AJ_BusHandleBusMessage+0x46e>
    2e66:	e102      	b.n	306e <AJ_BusHandleBusMessage+0x47e>
            status = AJ_ERR_FAILURE;
        }
        break;

    case AJ_METHOD_ABOUT_GET_PROP:
	    printf("AJ_AboutHandleGetProp\n");
    2e68:	4859      	ldr	r0, [pc, #356]	; (2fd0 <AJ_BusHandleBusMessage+0x3e0>)
    2e6a:	4b33      	ldr	r3, [pc, #204]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e6c:	4798      	blx	r3
        return AJ_AboutHandleGetProp(msg);
    2e6e:	1c20      	adds	r0, r4, #0
    2e70:	4b58      	ldr	r3, [pc, #352]	; (2fd4 <AJ_BusHandleBusMessage+0x3e4>)
    2e72:	4798      	blx	r3
    2e74:	e103      	b.n	307e <AJ_BusHandleBusMessage+0x48e>

    case AJ_METHOD_ABOUT_GET_ABOUT_DATA:
	    printf("AJ_AboutHandleGetAboutData\n");
    2e76:	4858      	ldr	r0, [pc, #352]	; (2fd8 <AJ_BusHandleBusMessage+0x3e8>)
    2e78:	4b2f      	ldr	r3, [pc, #188]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e7a:	4798      	blx	r3
        status = AJ_AboutHandleGetAboutData(msg, &reply);
    2e7c:	1c20      	adds	r0, r4, #0
    2e7e:	a90d      	add	r1, sp, #52	; 0x34
    2e80:	4b56      	ldr	r3, [pc, #344]	; (2fdc <AJ_BusHandleBusMessage+0x3ec>)
    2e82:	4798      	blx	r3
    2e84:	1c05      	adds	r5, r0, #0
        break;
    2e86:	e0cb      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_ABOUT_GET_OBJECT_DESCRIPTION:
	    printf("AJ_AboutHandleGetObjectDescription\n");
    2e88:	4855      	ldr	r0, [pc, #340]	; (2fe0 <AJ_BusHandleBusMessage+0x3f0>)
    2e8a:	4b2b      	ldr	r3, [pc, #172]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e8c:	4798      	blx	r3
        status = AJ_AboutHandleGetObjectDescription(msg, &reply);
    2e8e:	1c20      	adds	r0, r4, #0
    2e90:	a90d      	add	r1, sp, #52	; 0x34
    2e92:	4b54      	ldr	r3, [pc, #336]	; (2fe4 <AJ_BusHandleBusMessage+0x3f4>)
    2e94:	4798      	blx	r3
    2e96:	1c05      	adds	r5, r0, #0
        break;
    2e98:	e0c2      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_ABOUT_ICON_GET_PROP:
	    printf("AJ_AboutIconHandleGetProp\n");
    2e9a:	4853      	ldr	r0, [pc, #332]	; (2fe8 <AJ_BusHandleBusMessage+0x3f8>)
    2e9c:	4b26      	ldr	r3, [pc, #152]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2e9e:	4798      	blx	r3
        return AJ_AboutIconHandleGetProp(msg);
    2ea0:	1c20      	adds	r0, r4, #0
    2ea2:	4b52      	ldr	r3, [pc, #328]	; (2fec <AJ_BusHandleBusMessage+0x3fc>)
    2ea4:	4798      	blx	r3
    2ea6:	e0ea      	b.n	307e <AJ_BusHandleBusMessage+0x48e>

    case AJ_METHOD_ABOUT_ICON_GET_URL:
	    printf("AJ_AboutIconHandleGetURL\n");
    2ea8:	4851      	ldr	r0, [pc, #324]	; (2ff0 <AJ_BusHandleBusMessage+0x400>)
    2eaa:	4b23      	ldr	r3, [pc, #140]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2eac:	4798      	blx	r3
        status = AJ_AboutIconHandleGetURL(msg, &reply);
    2eae:	1c20      	adds	r0, r4, #0
    2eb0:	a90d      	add	r1, sp, #52	; 0x34
    2eb2:	4b50      	ldr	r3, [pc, #320]	; (2ff4 <AJ_BusHandleBusMessage+0x404>)
    2eb4:	4798      	blx	r3
    2eb6:	1c05      	adds	r5, r0, #0
        break;
    2eb8:	e0b2      	b.n	3020 <AJ_BusHandleBusMessage+0x430>

    case AJ_METHOD_ABOUT_ICON_GET_CONTENT:
	    printf("AJ_AboutIconHandleGetContent\n");
    2eba:	484f      	ldr	r0, [pc, #316]	; (2ff8 <AJ_BusHandleBusMessage+0x408>)
    2ebc:	4b1e      	ldr	r3, [pc, #120]	; (2f38 <AJ_BusHandleBusMessage+0x348>)
    2ebe:	4798      	blx	r3
        status = AJ_AboutIconHandleGetContent(msg, &reply);
    2ec0:	1c20      	adds	r0, r4, #0
    2ec2:	a90d      	add	r1, sp, #52	; 0x34
    2ec4:	4b4d      	ldr	r3, [pc, #308]	; (2ffc <AJ_BusHandleBusMessage+0x40c>)
    2ec6:	4798      	blx	r3
    2ec8:	1c05      	adds	r5, r0, #0
        break;
    2eca:	e0a9      	b.n	3020 <AJ_BusHandleBusMessage+0x430>
    2ecc:	0001a924 	.word	0x0001a924
    2ed0:	00016e3d 	.word	0x00016e3d
    2ed4:	00016773 	.word	0x00016773
    2ed8:	00020104 	.word	0x00020104
    2edc:	00020001 	.word	0x00020001
    2ee0:	0001000a 	.word	0x0001000a
    2ee4:	00020101 	.word	0x00020101
    2ee8:	00020102 	.word	0x00020102
    2eec:	00020100 	.word	0x00020100
    2ef0:	00030100 	.word	0x00030100
    2ef4:	00020106 	.word	0x00020106
    2ef8:	00030200 	.word	0x00030200
    2efc:	00030201 	.word	0x00030201
    2f00:	00030101 	.word	0x00030101
    2f04:	80010005 	.word	0x80010005
    2f08:	80010004 	.word	0x80010004
    2f0c:	00050101 	.word	0x00050101
    2f10:	00050102 	.word	0x00050102
    2f14:	00060103 	.word	0x00060103
    2f18:	00060104 	.word	0x00060104
    2f1c:	80020102 	.word	0x80020102
    2f20:	80020100 	.word	0x80020100
    2f24:	8001000c 	.word	0x8001000c
    2f28:	80020105 	.word	0x80020105
    2f2c:	80020106 	.word	0x80020106
    2f30:	80020104 	.word	0x80020104
    2f34:	0001a948 	.word	0x0001a948
    2f38:	00016f5d 	.word	0x00016f5d
    2f3c:	0000bd45 	.word	0x0000bd45
    2f40:	0001a974 	.word	0x0001a974
    2f44:	0001a98c 	.word	0x0001a98c
    2f48:	0001a9c0 	.word	0x0001a9c0
    2f4c:	00007a7d 	.word	0x00007a7d
    2f50:	0001f054 	.word	0x0001f054
    2f54:	0000bc85 	.word	0x0000bc85
    2f58:	0001a9ec 	.word	0x0001a9ec
    2f5c:	00009795 	.word	0x00009795
    2f60:	0001aa1c 	.word	0x0001aa1c
    2f64:	00008879 	.word	0x00008879
    2f68:	0001aa58 	.word	0x0001aa58
    2f6c:	0000b5f5 	.word	0x0000b5f5
    2f70:	0001aa94 	.word	0x0001aa94
    2f74:	0000c685 	.word	0x0000c685
    2f78:	0001aac8 	.word	0x0001aac8
    2f7c:	0000cde9 	.word	0x0000cde9
    2f80:	0001aafc 	.word	0x0001aafc
    2f84:	0000cf71 	.word	0x0000cf71
    2f88:	0001ab34 	.word	0x0001ab34
    2f8c:	0000c925 	.word	0x0000c925
    2f90:	0001ab68 	.word	0x0001ab68
    2f94:	0000ca7d 	.word	0x0000ca7d
    2f98:	000063c5 	.word	0x000063c5
    2f9c:	0001ab9c 	.word	0x0001ab9c
    2fa0:	0001abc0 	.word	0x0001abc0
    2fa4:	0000cbed 	.word	0x0000cbed
    2fa8:	0001abf8 	.word	0x0001abf8
    2fac:	0001ac38 	.word	0x0001ac38
    2fb0:	0001ac7c 	.word	0x0001ac7c
    2fb4:	0001acbc 	.word	0x0001acbc
    2fb8:	0000ccd1 	.word	0x0000ccd1
    2fbc:	0001ad00 	.word	0x0001ad00
    2fc0:	0001ad44 	.word	0x0001ad44
    2fc4:	0001ad8c 	.word	0x0001ad8c
    2fc8:	0001add0 	.word	0x0001add0
    2fcc:	0001ae14 	.word	0x0001ae14
    2fd0:	0001ae68 	.word	0x0001ae68
    2fd4:	000016b9 	.word	0x000016b9
    2fd8:	0001ae80 	.word	0x0001ae80
    2fdc:	000016cd 	.word	0x000016cd
    2fe0:	0001ae9c 	.word	0x0001ae9c
    2fe4:	000018b1 	.word	0x000018b1
    2fe8:	0001aec0 	.word	0x0001aec0
    2fec:	000018cd 	.word	0x000018cd
    2ff0:	0001aedc 	.word	0x0001aedc
    2ff4:	000018e1 	.word	0x000018e1
    2ff8:	0001aef8 	.word	0x0001aef8
    2ffc:	00001915 	.word	0x00001915
        status = AJ_AboutHandleAnnounce(msg, NULL, NULL, NULL, NULL);
        break;
#endif

    default:
        printf("AJ_BusHandleBusMessage() switch: default\n");
    3000:	4820      	ldr	r0, [pc, #128]	; (3084 <AJ_BusHandleBusMessage+0x494>)
    3002:	4b21      	ldr	r3, [pc, #132]	; (3088 <AJ_BusHandleBusMessage+0x498>)
    3004:	4798      	blx	r3
		
        if (msg->hdr->msgType == AJ_MSG_METHOD_CALL) 
    3006:	6863      	ldr	r3, [r4, #4]
    3008:	785b      	ldrb	r3, [r3, #1]
    300a:	2b01      	cmp	r3, #1
    300c:	d127      	bne.n	305e <AJ_BusHandleBusMessage+0x46e>
		{
			 printf("AJ_MSG_METHOD_CALL\n");
    300e:	481f      	ldr	r0, [pc, #124]	; (308c <AJ_BusHandleBusMessage+0x49c>)
    3010:	4b1d      	ldr	r3, [pc, #116]	; (3088 <AJ_BusHandleBusMessage+0x498>)
    3012:	4798      	blx	r3
            status = AJ_MarshalErrorMsg(msg, &reply, AJ_ErrRejected);
    3014:	1c20      	adds	r0, r4, #0
    3016:	a90d      	add	r1, sp, #52	; 0x34
    3018:	4a1d      	ldr	r2, [pc, #116]	; (3090 <AJ_BusHandleBusMessage+0x4a0>)
    301a:	4b1e      	ldr	r3, [pc, #120]	; (3094 <AJ_BusHandleBusMessage+0x4a4>)
    301c:	4798      	blx	r3
    301e:	1c05      	adds	r5, r0, #0
        }
        break;
    }
	 printf("switch end status= %s\n", AJ_StatusText(status));
    3020:	1c28      	adds	r0, r5, #0
    3022:	4b1d      	ldr	r3, [pc, #116]	; (3098 <AJ_BusHandleBusMessage+0x4a8>)
    3024:	4798      	blx	r3
    3026:	1c01      	adds	r1, r0, #0
    3028:	481c      	ldr	r0, [pc, #112]	; (309c <AJ_BusHandleBusMessage+0x4ac>)
    302a:	4b1d      	ldr	r3, [pc, #116]	; (30a0 <AJ_BusHandleBusMessage+0x4b0>)
    302c:	4798      	blx	r3
    302e:	1e28      	subs	r0, r5, #0
	// printf("msg->hdr->msgType = %d\n",msg->hdr->msgType);
    if ((status == AJ_OK) && (msg->hdr->msgType == AJ_MSG_METHOD_CALL)) 
    3030:	d125      	bne.n	307e <AJ_BusHandleBusMessage+0x48e>
    3032:	6863      	ldr	r3, [r4, #4]
    3034:	785b      	ldrb	r3, [r3, #1]
    3036:	2b01      	cmp	r3, #1
    3038:	d107      	bne.n	304a <AJ_BusHandleBusMessage+0x45a>
	{
		printf("msg->hdr->msgType == AJ_MSG_METHOD_CALL\n");
    303a:	481a      	ldr	r0, [pc, #104]	; (30a4 <AJ_BusHandleBusMessage+0x4b4>)
    303c:	4b12      	ldr	r3, [pc, #72]	; (3088 <AJ_BusHandleBusMessage+0x498>)
    303e:	4798      	blx	r3
        status = AJ_DeliverMsg(&reply);
    3040:	a80d      	add	r0, sp, #52	; 0x34
    3042:	4b19      	ldr	r3, [pc, #100]	; (30a8 <AJ_BusHandleBusMessage+0x4b8>)
    3044:	4798      	blx	r3
    3046:	1e03      	subs	r3, r0, #0
    }
    // Check if there is anything to announce
    if (status == AJ_OK) 
    3048:	d119      	bne.n	307e <AJ_BusHandleBusMessage+0x48e>
	{
		printf("AJ_AboutAnnounce\n");
    304a:	4818      	ldr	r0, [pc, #96]	; (30ac <AJ_BusHandleBusMessage+0x4bc>)
    304c:	4b0e      	ldr	r3, [pc, #56]	; (3088 <AJ_BusHandleBusMessage+0x498>)
    304e:	4798      	blx	r3
        AJ_AboutAnnounce(bus);
    3050:	1c30      	adds	r0, r6, #0
    3052:	4b17      	ldr	r3, [pc, #92]	; (30b0 <AJ_BusHandleBusMessage+0x4c0>)
    3054:	4798      	blx	r3
    }
    return status;
    3056:	2000      	movs	r0, #0
    3058:	e011      	b.n	307e <AJ_BusHandleBusMessage+0x48e>
    printf("AJ_BusHandleBusMessage(msg=0x%p)\n", msg);
    memset(&reply, 0, sizeof(AJ_Message));
    // Check we actually have a message to handle
    if (!msg->hdr) 
	{
        return AJ_OK;
    305a:	2000      	movs	r0, #0
    305c:	e00f      	b.n	307e <AJ_BusHandleBusMessage+0x48e>
			 printf("AJ_MSG_METHOD_CALL\n");
            status = AJ_MarshalErrorMsg(msg, &reply, AJ_ErrRejected);
        }
        break;
    }
	 printf("switch end status= %s\n", AJ_StatusText(status));
    305e:	2000      	movs	r0, #0
    3060:	4b0d      	ldr	r3, [pc, #52]	; (3098 <AJ_BusHandleBusMessage+0x4a8>)
    3062:	4798      	blx	r3
    3064:	1c01      	adds	r1, r0, #0
    3066:	480d      	ldr	r0, [pc, #52]	; (309c <AJ_BusHandleBusMessage+0x4ac>)
    3068:	4b0d      	ldr	r3, [pc, #52]	; (30a0 <AJ_BusHandleBusMessage+0x4b0>)
    306a:	4798      	blx	r3
    306c:	e7e1      	b.n	3032 <AJ_BusHandleBusMessage+0x442>
    306e:	2013      	movs	r0, #19
    3070:	4b09      	ldr	r3, [pc, #36]	; (3098 <AJ_BusHandleBusMessage+0x4a8>)
    3072:	4798      	blx	r3
    3074:	1c01      	adds	r1, r0, #0
    3076:	4809      	ldr	r0, [pc, #36]	; (309c <AJ_BusHandleBusMessage+0x4ac>)
    3078:	4b09      	ldr	r3, [pc, #36]	; (30a0 <AJ_BusHandleBusMessage+0x4b0>)
    307a:	4798      	blx	r3
    case AJ_REPLY_ID(AJ_METHOD_CANCEL_ADVERTISE):
    case AJ_REPLY_ID(AJ_METHOD_ADVERTISE_NAME):
        printf("AJ_BusHandleBusMessage(): AJ_REPLY_ID(AJ_METHOD_{CANCEL_ADVERTISE|ADVERTISE_NAME})\n");
        if (msg->hdr->msgType == AJ_MSG_ERROR) 
		{
            status = AJ_ERR_FAILURE;
    307c:	2013      	movs	r0, #19
	{
		printf("AJ_AboutAnnounce\n");
        AJ_AboutAnnounce(bus);
    }
    return status;
}
    307e:	b01e      	add	sp, #120	; 0x78
    3080:	bd70      	pop	{r4, r5, r6, pc}
    3082:	46c0      	nop			; (mov r8, r8)
    3084:	0001af18 	.word	0x0001af18
    3088:	00016f5d 	.word	0x00016f5d
    308c:	0001af44 	.word	0x0001af44
    3090:	0001e924 	.word	0x0001e924
    3094:	0000be55 	.word	0x0000be55
    3098:	000063c5 	.word	0x000063c5
    309c:	0001af58 	.word	0x0001af58
    30a0:	00016e3d 	.word	0x00016e3d
    30a4:	0001af70 	.word	0x0001af70
    30a8:	0000a539 	.word	0x0000a539
    30ac:	0001af98 	.word	0x0001af98
    30b0:	0000172d 	.word	0x0000172d

000030b4 <AJ_BusSetPasswordCallback>:

void AJ_BusSetPasswordCallback(AJ_BusAttachment* bus, AJ_AuthPwdFunc pwdCallback)
{
    30b4:	b538      	push	{r3, r4, r5, lr}
    30b6:	1c04      	adds	r4, r0, #0
    30b8:	1c0d      	adds	r5, r1, #0
#ifndef NO_SECURITY
    printf("AJ_BusSetPasswordCallback(bus=0x%p, pwdCallback=0x%p)\n", bus, pwdCallback);
    30ba:	4803      	ldr	r0, [pc, #12]	; (30c8 <AJ_BusSetPasswordCallback+0x14>)
    30bc:	1c21      	adds	r1, r4, #0
    30be:	1c2a      	adds	r2, r5, #0
    30c0:	4b02      	ldr	r3, [pc, #8]	; (30cc <AJ_BusSetPasswordCallback+0x18>)
    30c2:	4798      	blx	r3
    bus->pwdCallback = pwdCallback;
    30c4:	64e5      	str	r5, [r4, #76]	; 0x4c
#endif
}
    30c6:	bd38      	pop	{r3, r4, r5, pc}
    30c8:	0001afac 	.word	0x0001afac
    30cc:	00016e3d 	.word	0x00016e3d

000030d0 <AJ_BusPropGet>:
    }
    return AJ_DeliverMsg(&reply);
}

AJ_Status AJ_BusPropGet(AJ_Message* msg, AJ_BusPropGetCallback callback, void* context)
{
    30d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    30d2:	b083      	sub	sp, #12
    30d4:	1c04      	adds	r4, r0, #0
    30d6:	1c0d      	adds	r5, r1, #0
    30d8:	1c16      	adds	r6, r2, #0
    PropCallback cb;

    printf("AJ_BusPropGet(msg=0x%p, callback=0x%p, context=0x%p)\n", msg, callback, context);
    30da:	4807      	ldr	r0, [pc, #28]	; (30f8 <AJ_BusPropGet+0x28>)
    30dc:	1c21      	adds	r1, r4, #0
    30de:	1c2a      	adds	r2, r5, #0
    30e0:	1c33      	adds	r3, r6, #0
    30e2:	4f06      	ldr	r7, [pc, #24]	; (30fc <AJ_BusPropGet+0x2c>)
    30e4:	47b8      	blx	r7

    cb.context = context;
    30e6:	9600      	str	r6, [sp, #0]
    cb.Get = callback;
    30e8:	9501      	str	r5, [sp, #4]
    return PropAccess(msg, &cb, AJ_PROP_GET);
    30ea:	1c20      	adds	r0, r4, #0
    30ec:	4669      	mov	r1, sp
    30ee:	2200      	movs	r2, #0
    30f0:	4b03      	ldr	r3, [pc, #12]	; (3100 <AJ_BusPropGet+0x30>)
    30f2:	4798      	blx	r3
}
    30f4:	b003      	add	sp, #12
    30f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30f8:	0001b078 	.word	0x0001b078
    30fc:	00016e3d 	.word	0x00016e3d
    3100:	00002805 	.word	0x00002805

00003104 <AJ_BusPropSet>:

AJ_Status AJ_BusPropSet(AJ_Message* msg, AJ_BusPropSetCallback callback, void* context)
{
    3104:	b5f0      	push	{r4, r5, r6, r7, lr}
    3106:	b083      	sub	sp, #12
    3108:	1c04      	adds	r4, r0, #0
    310a:	1c0d      	adds	r5, r1, #0
    310c:	1c16      	adds	r6, r2, #0
    PropCallback cb;

    printf("AJ_BusPropSet(msg=0x%p, callback=0x%p, context=0x%p)\n", msg, callback, context);
    310e:	4807      	ldr	r0, [pc, #28]	; (312c <AJ_BusPropSet+0x28>)
    3110:	1c21      	adds	r1, r4, #0
    3112:	1c2a      	adds	r2, r5, #0
    3114:	1c33      	adds	r3, r6, #0
    3116:	4f06      	ldr	r7, [pc, #24]	; (3130 <AJ_BusPropSet+0x2c>)
    3118:	47b8      	blx	r7

    cb.context = context;
    311a:	9600      	str	r6, [sp, #0]
    cb.Set = callback;
    311c:	9501      	str	r5, [sp, #4]
    return PropAccess(msg, &cb, AJ_PROP_SET);
    311e:	1c20      	adds	r0, r4, #0
    3120:	4669      	mov	r1, sp
    3122:	2201      	movs	r2, #1
    3124:	4b03      	ldr	r3, [pc, #12]	; (3134 <AJ_BusPropSet+0x30>)
    3126:	4798      	blx	r3
}
    3128:	b003      	add	sp, #12
    312a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    312c:	0001b0b0 	.word	0x0001b0b0
    3130:	00016e3d 	.word	0x00016e3d
    3134:	00002805 	.word	0x00002805

00003138 <HostU32ToBigEndianU8>:
#define PEM_PRIV_END "-----END EC PRIVATE KEY-----"
#define PEM_CERT_BEG "-----BEGIN CERTIFICATE-----"
#define PEM_CERT_END "-----END CERTIFICATE-----"

void HostU32ToBigEndianU8(uint32_t* u32, size_t len, uint8_t* u8)
{
    3138:	b5f0      	push	{r4, r5, r6, r7, lr}
    313a:	464f      	mov	r7, r9
    313c:	4646      	mov	r6, r8
    313e:	b4c0      	push	{r6, r7}
    3140:	b083      	sub	sp, #12
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
    3142:	2900      	cmp	r1, #0
    3144:	d013      	beq.n	316e <HostU32ToBigEndianU8+0x36>
    3146:	1c17      	adds	r7, r2, #0
    3148:	1c0d      	adds	r5, r1, #0
    314a:	1c06      	adds	r6, r0, #0
    314c:	2400      	movs	r4, #0
	{
        x = u32[i / sizeof (uint32_t)];
#if HOST_IS_LITTLE_ENDIAN
        x = AJ_ByteSwap32(x);
    314e:	4b0a      	ldr	r3, [pc, #40]	; (3178 <HostU32ToBigEndianU8+0x40>)
    3150:	4699      	mov	r9, r3
#endif
        memcpy(&u8[i], &x, sizeof (x));
    3152:	4b0a      	ldr	r3, [pc, #40]	; (317c <HostU32ToBigEndianU8+0x44>)
    3154:	4698      	mov	r8, r3
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
	{
        x = u32[i / sizeof (uint32_t)];
    3156:	08a3      	lsrs	r3, r4, #2
    3158:	009b      	lsls	r3, r3, #2
#if HOST_IS_LITTLE_ENDIAN
        x = AJ_ByteSwap32(x);
    315a:	5998      	ldr	r0, [r3, r6]
    315c:	47c8      	blx	r9
    315e:	9001      	str	r0, [sp, #4]
    3160:	1938      	adds	r0, r7, r4
#endif
        memcpy(&u8[i], &x, sizeof (x));
    3162:	a901      	add	r1, sp, #4
    3164:	2204      	movs	r2, #4
    3166:	47c0      	blx	r8
void HostU32ToBigEndianU8(uint32_t* u32, size_t len, uint8_t* u8)
{
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
    3168:	3404      	adds	r4, #4
    316a:	42a5      	cmp	r5, r4
    316c:	d8f3      	bhi.n	3156 <HostU32ToBigEndianU8+0x1e>
#if HOST_IS_LITTLE_ENDIAN
        x = AJ_ByteSwap32(x);
#endif
        memcpy(&u8[i], &x, sizeof (x));
    }
}
    316e:	b003      	add	sp, #12
    3170:	bc0c      	pop	{r2, r3}
    3172:	4690      	mov	r8, r2
    3174:	4699      	mov	r9, r3
    3176:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3178:	0000d749 	.word	0x0000d749
    317c:	00016739 	.word	0x00016739

00003180 <AJ_BigEndianEncodePublicKey>:
        u32[i / sizeof (uint32_t)] = x;
    }
}

void AJ_BigEndianEncodePublicKey(ecc_publickey* publickey, uint8_t* b8)
{
    3180:	b508      	push	{r3, lr}
    3182:	1c0a      	adds	r2, r1, #0
    HostU32ToBigEndianU8((uint32_t*) publickey, sizeof (ecc_publickey), b8);
    3184:	214c      	movs	r1, #76	; 0x4c
    3186:	4b01      	ldr	r3, [pc, #4]	; (318c <AJ_BigEndianEncodePublicKey+0xc>)
    3188:	4798      	blx	r3
}
    318a:	bd08      	pop	{r3, pc}
    318c:	00003139 	.word	0x00003139

00003190 <AJ_BigEndianDecodePublicKey>:

void AJ_BigEndianDecodePublicKey(ecc_publickey* publickey, uint8_t* b8)
{
    3190:	b5f0      	push	{r4, r5, r6, r7, lr}
    3192:	4647      	mov	r7, r8
    3194:	b480      	push	{r7}
    3196:	b082      	sub	sp, #8
    3198:	4680      	mov	r8, r0
    319a:	1c0f      	adds	r7, r1, #0
static void BigEndianU8ToHostU32(uint8_t* u8, uint32_t* u32, size_t len)
{
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
    319c:	2400      	movs	r4, #0
	{
        memcpy(&x, &u8[i], sizeof (x));
    319e:	4e0a      	ldr	r6, [pc, #40]	; (31c8 <AJ_BigEndianDecodePublicKey+0x38>)
#if HOST_IS_LITTLE_ENDIAN
        x = AJ_ByteSwap32(x);
    31a0:	4d0a      	ldr	r5, [pc, #40]	; (31cc <AJ_BigEndianDecodePublicKey+0x3c>)
    31a2:	1939      	adds	r1, r7, r4
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
	{
        memcpy(&x, &u8[i], sizeof (x));
    31a4:	a801      	add	r0, sp, #4
    31a6:	2204      	movs	r2, #4
    31a8:	47b0      	blx	r6
#if HOST_IS_LITTLE_ENDIAN
        x = AJ_ByteSwap32(x);
    31aa:	9801      	ldr	r0, [sp, #4]
    31ac:	47a8      	blx	r5
    31ae:	9001      	str	r0, [sp, #4]
#endif
        u32[i / sizeof (uint32_t)] = x;
    31b0:	08a3      	lsrs	r3, r4, #2
    31b2:	009b      	lsls	r3, r3, #2
    31b4:	4642      	mov	r2, r8
    31b6:	5098      	str	r0, [r3, r2]
static void BigEndianU8ToHostU32(uint8_t* u8, uint32_t* u32, size_t len)
{
    uint32_t x;
    size_t i;

    for (i = 0; i < len; i += sizeof (uint32_t)) 
    31b8:	3404      	adds	r4, #4
    31ba:	2c4c      	cmp	r4, #76	; 0x4c
    31bc:	d1f1      	bne.n	31a2 <AJ_BigEndianDecodePublicKey+0x12>
}

void AJ_BigEndianDecodePublicKey(ecc_publickey* publickey, uint8_t* b8)
{
    BigEndianU8ToHostU32(b8, (uint32_t*) publickey, sizeof (ecc_publickey));
}
    31be:	b002      	add	sp, #8
    31c0:	bc04      	pop	{r2}
    31c2:	4690      	mov	r8, r2
    31c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    31c6:	46c0      	nop			; (mov r8, r8)
    31c8:	00016739 	.word	0x00016739
    31cc:	0000d749 	.word	0x0000d749

000031d0 <AJ_ASN1DecodeElement>:
    return TRUE;

}

AJ_Status AJ_ASN1DecodeElement(DER_Element* der, uint8_t tag, DER_Element* out)
{
    31d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    31d2:	4647      	mov	r7, r8
    31d4:	b480      	push	{r7}
    uint8_t tmp;

    if ((NULL == der) || (NULL == out)) 
    31d6:	2800      	cmp	r0, #0
    31d8:	d051      	beq.n	327e <AJ_ASN1DecodeElement+0xae>
    31da:	2a00      	cmp	r2, #0
    31dc:	d051      	beq.n	3282 <AJ_ASN1DecodeElement+0xb2>
	{
        return AJ_ERR_INVALID;
    }
    if ((NULL == der->data) || (0 == der->size)) 
    31de:	6844      	ldr	r4, [r0, #4]
    31e0:	2c00      	cmp	r4, #0
    31e2:	d050      	beq.n	3286 <AJ_ASN1DecodeElement+0xb6>
    31e4:	6805      	ldr	r5, [r0, #0]
	{
        return AJ_ERR_INVALID;
    31e6:	2303      	movs	r3, #3

    if ((NULL == der) || (NULL == out)) 
	{
        return AJ_ERR_INVALID;
    }
    if ((NULL == der->data) || (0 == der->size)) 
    31e8:	2d00      	cmp	r5, #0
    31ea:	d04f      	beq.n	328c <AJ_ASN1DecodeElement+0xbc>
	{
        return AJ_ERR_INVALID;
    }

    // Decode tag and check it is what we expect
    tmp = *(der->data)++;
    31ec:	1c63      	adds	r3, r4, #1
    31ee:	4698      	mov	r8, r3
    31f0:	6043      	str	r3, [r0, #4]
    31f2:	7826      	ldrb	r6, [r4, #0]
    der->size--;
    31f4:	1e6b      	subs	r3, r5, #1
    31f6:	469c      	mov	ip, r3
    31f8:	6003      	str	r3, [r0, #0]
    if (ASN_CONTEXT_SPECIFIC != (tmp & ASN_CONTEXT_SPECIFIC)) 
    31fa:	235f      	movs	r3, #95	; 0x5f
    31fc:	1c37      	adds	r7, r6, #0
    31fe:	439f      	bics	r7, r3
    3200:	2fa0      	cmp	r7, #160	; 0xa0
    3202:	d001      	beq.n	3208 <AJ_ASN1DecodeElement+0x38>
	{
        tmp &= 0x1F;
    3204:	231f      	movs	r3, #31
    3206:	401e      	ands	r6, r3
    }
    if (tmp != tag) 
	{
        AJ_InfoPrintf(("AJ_ASN1DecodeElement(der=%p, tag=%x, out=%p): Tag error %x\n", der, tag, out, tmp));
        return AJ_ERR_INVALID;
    3208:	2303      	movs	r3, #3
    der->size--;
    if (ASN_CONTEXT_SPECIFIC != (tmp & ASN_CONTEXT_SPECIFIC)) 
	{
        tmp &= 0x1F;
    }
    if (tmp != tag) 
    320a:	428e      	cmp	r6, r1
    320c:	d13e      	bne.n	328c <AJ_ASN1DecodeElement+0xbc>
static AJ_Status ASN1DecodeLength(DER_Element* der, DER_Element* out)
{
    size_t n;
    size_t len;

    if ((NULL == der->data) || (0 == der->size)) 
    320e:	4643      	mov	r3, r8
    3210:	2b00      	cmp	r3, #0
    3212:	d03a      	beq.n	328a <AJ_ASN1DecodeElement+0xba>
    3214:	4663      	mov	r3, ip
    3216:	2b00      	cmp	r3, #0
    3218:	d037      	beq.n	328a <AJ_ASN1DecodeElement+0xba>
	{
        return AJ_ERR_INVALID;
    }

    len = *(der->data)++;
    321a:	1ca3      	adds	r3, r4, #2
    321c:	6043      	str	r3, [r0, #4]
    321e:	7863      	ldrb	r3, [r4, #1]
    der->size--;
    3220:	3d02      	subs	r5, #2
    3222:	6005      	str	r5, [r0, #0]
    if (0x80 & len) 
    3224:	09d9      	lsrs	r1, r3, #7
    3226:	d016      	beq.n	3256 <AJ_ASN1DecodeElement+0x86>
	{
        n = len & 0x7F;
    3228:	247f      	movs	r4, #127	; 0x7f
    322a:	401c      	ands	r4, r3
        if (n > sizeof (size_t)) 
    322c:	2c04      	cmp	r4, #4
    322e:	d82c      	bhi.n	328a <AJ_ASN1DecodeElement+0xba>
		{
            return AJ_ERR_INVALID;
        }
        len = 0;
        while (n && der->size) 
    3230:	2c00      	cmp	r4, #0
    3232:	d014      	beq.n	325e <AJ_ASN1DecodeElement+0x8e>
    3234:	2d00      	cmp	r5, #0
    3236:	d014      	beq.n	3262 <AJ_ASN1DecodeElement+0x92>
    3238:	1c29      	adds	r1, r5, #0
    323a:	2300      	movs	r3, #0
		{
            len = (len << 8) + *(der->data)++;
    323c:	021b      	lsls	r3, r3, #8
    323e:	6846      	ldr	r6, [r0, #4]
    3240:	1c77      	adds	r7, r6, #1
    3242:	6047      	str	r7, [r0, #4]
    3244:	7836      	ldrb	r6, [r6, #0]
    3246:	18f3      	adds	r3, r6, r3
            n--;
            der->size--;
    3248:	3901      	subs	r1, #1
    324a:	6001      	str	r1, [r0, #0]
    324c:	1a6e      	subs	r6, r5, r1
        if (n > sizeof (size_t)) 
		{
            return AJ_ERR_INVALID;
        }
        len = 0;
        while (n && der->size) 
    324e:	42a6      	cmp	r6, r4
    3250:	d001      	beq.n	3256 <AJ_ASN1DecodeElement+0x86>
    3252:	2900      	cmp	r1, #0
    3254:	d1f2      	bne.n	323c <AJ_ASN1DecodeElement+0x6c>
            len = (len << 8) + *(der->data)++;
            n--;
            der->size--;
        }
    }
    if (len > der->size) 
    3256:	6801      	ldr	r1, [r0, #0]
    3258:	4299      	cmp	r1, r3
    325a:	d316      	bcc.n	328a <AJ_ASN1DecodeElement+0xba>
    325c:	e002      	b.n	3264 <AJ_ASN1DecodeElement+0x94>
        if (n > sizeof (size_t)) 
		{
            return AJ_ERR_INVALID;
        }
        len = 0;
        while (n && der->size) 
    325e:	2300      	movs	r3, #0
    3260:	e000      	b.n	3264 <AJ_ASN1DecodeElement+0x94>
    3262:	2300      	movs	r3, #0
    }
    if (len > der->size) 
	{
        return AJ_ERR_INVALID;
    }
    out->size = len;
    3264:	6013      	str	r3, [r2, #0]
    out->data = der->data;
    3266:	6841      	ldr	r1, [r0, #4]
    3268:	6051      	str	r1, [r2, #4]
    if (AJ_OK != ASN1DecodeLength(der, out)) 
	{
        AJ_InfoPrintf(("AJ_ASN1DecodeElement(der=%p, tag=%x, out=%p): Length error\n", der, tag, out));
        return AJ_ERR_INVALID;
    }
    der->data += out->size;
    326a:	6841      	ldr	r1, [r0, #4]
    326c:	468c      	mov	ip, r1
    326e:	4463      	add	r3, ip
    3270:	6043      	str	r3, [r0, #4]
    der->size -= out->size;
    3272:	6813      	ldr	r3, [r2, #0]
    3274:	6802      	ldr	r2, [r0, #0]
    3276:	1ad3      	subs	r3, r2, r3
    3278:	6003      	str	r3, [r0, #0]

    return AJ_OK;
    327a:	2300      	movs	r3, #0
    327c:	e006      	b.n	328c <AJ_ASN1DecodeElement+0xbc>
{
    uint8_t tmp;

    if ((NULL == der) || (NULL == out)) 
	{
        return AJ_ERR_INVALID;
    327e:	2303      	movs	r3, #3
    3280:	e004      	b.n	328c <AJ_ASN1DecodeElement+0xbc>
    3282:	2303      	movs	r3, #3
    3284:	e002      	b.n	328c <AJ_ASN1DecodeElement+0xbc>
    }
    if ((NULL == der->data) || (0 == der->size)) 
	{
        return AJ_ERR_INVALID;
    3286:	2303      	movs	r3, #3
    3288:	e000      	b.n	328c <AJ_ASN1DecodeElement+0xbc>
    }
    // Decode size
    if (AJ_OK != ASN1DecodeLength(der, out)) 
	{
        AJ_InfoPrintf(("AJ_ASN1DecodeElement(der=%p, tag=%x, out=%p): Length error\n", der, tag, out));
        return AJ_ERR_INVALID;
    328a:	2303      	movs	r3, #3
    }
    der->data += out->size;
    der->size -= out->size;

    return AJ_OK;
}
    328c:	1c18      	adds	r0, r3, #0
    328e:	bc04      	pop	{r2}
    3290:	4690      	mov	r8, r2
    3292:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003294 <AJ_ASN1DecodeElements>:

AJ_Status AJ_ASN1DecodeElements(DER_Element* der, const uint8_t* tags, size_t len, ...)
{
    3294:	b40c      	push	{r2, r3}
    3296:	b5f0      	push	{r4, r5, r6, r7, lr}
    3298:	4647      	mov	r7, r8
    329a:	b480      	push	{r7}
    329c:	b082      	sub	sp, #8
    uint8_t tag;
    uint32_t tmp;

    AJ_InfoPrintf(("AJ_ASN1DecodeElements(der=%p, tags=%p, len=%zu)\n", der, tags, len));

    if ((NULL == der) || (NULL == tags)) 
    329e:	2800      	cmp	r0, #0
    32a0:	d02e      	beq.n	3300 <AJ_ASN1DecodeElements+0x6c>
	{
        return AJ_ERR_INVALID;
    32a2:	2303      	movs	r3, #3
    uint8_t tag;
    uint32_t tmp;

    AJ_InfoPrintf(("AJ_ASN1DecodeElements(der=%p, tags=%p, len=%zu)\n", der, tags, len));

    if ((NULL == der) || (NULL == tags)) 
    32a4:	2900      	cmp	r1, #0
    32a6:	d031      	beq.n	330c <AJ_ASN1DecodeElements+0x78>
	{
        return AJ_ERR_INVALID;
    }

    va_start(argp, len);
    32a8:	ab09      	add	r3, sp, #36	; 0x24
    32aa:	9301      	str	r3, [sp, #4]
    while ((AJ_OK == status) && len && (der->size)) 
    32ac:	9b08      	ldr	r3, [sp, #32]
    32ae:	2b00      	cmp	r3, #0
    32b0:	d02a      	beq.n	3308 <AJ_ASN1DecodeElements+0x74>
    32b2:	6803      	ldr	r3, [r0, #0]
    32b4:	2b00      	cmp	r3, #0
    32b6:	d025      	beq.n	3304 <AJ_ASN1DecodeElements+0x70>
    32b8:	1c05      	adds	r5, r0, #0
    32ba:	1c0c      	adds	r4, r1, #0
    32bc:	9b08      	ldr	r3, [sp, #32]
    32be:	1e5e      	subs	r6, r3, #1
    32c0:	198e      	adds	r6, r1, r6
	{
        tag = *tags++;
        if (ASN_CONTEXT_SPECIFIC == tag) 
		{
            tmp = va_arg(argp, uint32_t);
            tag = (ASN_CONTEXT_SPECIFIC | tmp);
    32c2:	2360      	movs	r3, #96	; 0x60
    32c4:	425b      	negs	r3, r3
    32c6:	4698      	mov	r8, r3
        }
        out = va_arg(argp, DER_Element*);
        len--;
        status = AJ_ASN1DecodeElement(der, tag, out);
    32c8:	4f14      	ldr	r7, [pc, #80]	; (331c <AJ_ASN1DecodeElements+0x88>)
    }

    va_start(argp, len);
    while ((AJ_OK == status) && len && (der->size)) 
	{
        tag = *tags++;
    32ca:	7821      	ldrb	r1, [r4, #0]
        if (ASN_CONTEXT_SPECIFIC == tag) 
    32cc:	29a0      	cmp	r1, #160	; 0xa0
    32ce:	d106      	bne.n	32de <AJ_ASN1DecodeElements+0x4a>
		{
            tmp = va_arg(argp, uint32_t);
    32d0:	9b01      	ldr	r3, [sp, #4]
    32d2:	1d1a      	adds	r2, r3, #4
    32d4:	9201      	str	r2, [sp, #4]
            tag = (ASN_CONTEXT_SPECIFIC | tmp);
    32d6:	6819      	ldr	r1, [r3, #0]
    32d8:	4643      	mov	r3, r8
    32da:	4319      	orrs	r1, r3
    32dc:	b2c9      	uxtb	r1, r1
        }
        out = va_arg(argp, DER_Element*);
    32de:	9b01      	ldr	r3, [sp, #4]
    32e0:	1d1a      	adds	r2, r3, #4
    32e2:	9201      	str	r2, [sp, #4]
        len--;
        status = AJ_ASN1DecodeElement(der, tag, out);
    32e4:	681a      	ldr	r2, [r3, #0]
    32e6:	1c28      	adds	r0, r5, #0
    32e8:	47b8      	blx	r7
	{
        return AJ_ERR_INVALID;
    }

    va_start(argp, len);
    while ((AJ_OK == status) && len && (der->size)) 
    32ea:	2800      	cmp	r0, #0
    32ec:	d106      	bne.n	32fc <AJ_ASN1DecodeElements+0x68>
    32ee:	42b4      	cmp	r4, r6
    32f0:	d00a      	beq.n	3308 <AJ_ASN1DecodeElements+0x74>
    32f2:	3401      	adds	r4, #1
    32f4:	682b      	ldr	r3, [r5, #0]
    32f6:	2b00      	cmp	r3, #0
    32f8:	d1e7      	bne.n	32ca <AJ_ASN1DecodeElements+0x36>
    32fa:	e003      	b.n	3304 <AJ_ASN1DecodeElements+0x70>
            status = AJ_ERR_INVALID;
        }
    }
    va_end(argp);

    return status;
    32fc:	1c03      	adds	r3, r0, #0
    32fe:	e005      	b.n	330c <AJ_ASN1DecodeElements+0x78>

    AJ_InfoPrintf(("AJ_ASN1DecodeElements(der=%p, tags=%p, len=%zu)\n", der, tags, len));

    if ((NULL == der) || (NULL == tags)) 
	{
        return AJ_ERR_INVALID;
    3300:	2303      	movs	r3, #3
    3302:	e003      	b.n	330c <AJ_ASN1DecodeElements+0x78>
	{
        // If unset elements, fail
        if (len) 
		{
            AJ_InfoPrintf(("AJ_ASN1DecodeElements(der=%p, tags=%p, len=%zu): Uninitialized elements\n", der, tags, len));
            status = AJ_ERR_INVALID;
    3304:	2003      	movs	r0, #3
    3306:	e7f9      	b.n	32fc <AJ_ASN1DecodeElements+0x68>

    return AJ_OK;
}

AJ_Status AJ_ASN1DecodeElements(DER_Element* der, const uint8_t* tags, size_t len, ...)
{
    3308:	2000      	movs	r0, #0
    330a:	e7f7      	b.n	32fc <AJ_ASN1DecodeElements+0x68>
        }
    }
    va_end(argp);

    return status;
}
    330c:	1c18      	adds	r0, r3, #0
    330e:	b002      	add	sp, #8
    3310:	bc04      	pop	{r2}
    3312:	4690      	mov	r8, r2
    3314:	bcf0      	pop	{r4, r5, r6, r7}
    3316:	bc08      	pop	{r3}
    3318:	b002      	add	sp, #8
    331a:	4718      	bx	r3
    331c:	000031d1 	.word	0x000031d1

00003320 <CompareOID>:
const uint8_t OID_DN_CN[]             = { 0x55, 0x04, 0x03 };
// 2.5.29.19
const uint8_t OID_BASIC_CONSTRAINTS[] = { 0x55, 0x1D, 0x13 };

uint8_t CompareOID(DER_Element* der, const uint8_t* oid, size_t len)
{
    3320:	b510      	push	{r4, lr}
    if (der->size != len)
    3322:	6804      	ldr	r4, [r0, #0]
	{
        return 0;
    3324:	2300      	movs	r3, #0
// 2.5.29.19
const uint8_t OID_BASIC_CONSTRAINTS[] = { 0x55, 0x1D, 0x13 };

uint8_t CompareOID(DER_Element* der, const uint8_t* oid, size_t len)
{
    if (der->size != len)
    3326:	4294      	cmp	r4, r2
    3328:	d106      	bne.n	3338 <CompareOID+0x18>
	{
        return 0;
    }
    return (0 == memcmp(der->data, oid, len));
    332a:	6840      	ldr	r0, [r0, #4]
    332c:	1c22      	adds	r2, r4, #0
    332e:	4b03      	ldr	r3, [pc, #12]	; (333c <CompareOID+0x1c>)
    3330:	4798      	blx	r3
    3332:	4243      	negs	r3, r0
    3334:	4143      	adcs	r3, r0
    3336:	b2db      	uxtb	r3, r3
}
    3338:	1c18      	adds	r0, r3, #0
    333a:	bd10      	pop	{r4, pc}
    333c:	0001671b 	.word	0x0001671b

00003340 <DecodeCertificateName>:

    return status;
}

static AJ_Status DecodeCertificateName(X509DistinguishedName* dn, DER_Element* der)
{
    3340:	b5f0      	push	{r4, r5, r6, r7, lr}
    3342:	b089      	sub	sp, #36	; 0x24
    3344:	1c06      	adds	r6, r0, #0
    3346:	1c0d      	adds	r5, r1, #0
    DER_Element set;
    DER_Element seq;
    DER_Element oid;
    DER_Element tmp;

    memset(dn, 0, sizeof (X509DistinguishedName));
    3348:	2100      	movs	r1, #0
    334a:	2210      	movs	r2, #16
    334c:	4b21      	ldr	r3, [pc, #132]	; (33d4 <DecodeCertificateName+0x94>)
    334e:	4798      	blx	r3

    while ((AJ_OK == status) && (der->size)) 
	{
        status = AJ_ASN1DecodeElement(der, ASN_SET_OF, &set);
    3350:	2411      	movs	r4, #17
    3352:	4f21      	ldr	r7, [pc, #132]	; (33d8 <DecodeCertificateName+0x98>)
    3354:	e038      	b.n	33c8 <DecodeCertificateName+0x88>
    3356:	1c28      	adds	r0, r5, #0
    3358:	1c21      	adds	r1, r4, #0
    335a:	aa06      	add	r2, sp, #24
    335c:	47b8      	blx	r7
        if (AJ_OK != status) 
    335e:	2800      	cmp	r0, #0
    3360:	d136      	bne.n	33d0 <DecodeCertificateName+0x90>
		{
            return status;
        }
        status = AJ_ASN1DecodeElement(&set, ASN_SEQ, &seq);
    3362:	a806      	add	r0, sp, #24
    3364:	2110      	movs	r1, #16
    3366:	aa04      	add	r2, sp, #16
    3368:	4b1b      	ldr	r3, [pc, #108]	; (33d8 <DecodeCertificateName+0x98>)
    336a:	4798      	blx	r3
        if (AJ_OK != status) 
    336c:	2800      	cmp	r0, #0
    336e:	d12f      	bne.n	33d0 <DecodeCertificateName+0x90>
		{
            return status;
        }
        status = AJ_ASN1DecodeElement(&seq, ASN_OID, &oid);
    3370:	a804      	add	r0, sp, #16
    3372:	2106      	movs	r1, #6
    3374:	aa02      	add	r2, sp, #8
    3376:	4b18      	ldr	r3, [pc, #96]	; (33d8 <DecodeCertificateName+0x98>)
    3378:	4798      	blx	r3
        if (AJ_OK != status) 
    337a:	2800      	cmp	r0, #0
    337c:	d128      	bne.n	33d0 <DecodeCertificateName+0x90>
		{
            return status;
        }
        if (CompareOID(&oid, OID_DN_OU, sizeof (OID_DN_OU)))
    337e:	a802      	add	r0, sp, #8
    3380:	4916      	ldr	r1, [pc, #88]	; (33dc <DecodeCertificateName+0x9c>)
    3382:	2203      	movs	r2, #3
    3384:	4b16      	ldr	r3, [pc, #88]	; (33e0 <DecodeCertificateName+0xa0>)
    3386:	4798      	blx	r3
    3388:	2800      	cmp	r0, #0
    338a:	d00b      	beq.n	33a4 <DecodeCertificateName+0x64>
		{
            // Only accept UTF8 strings
            status = AJ_ASN1DecodeElement(&seq, ASN_UTF8, &tmp);
    338c:	a804      	add	r0, sp, #16
    338e:	210c      	movs	r1, #12
    3390:	466a      	mov	r2, sp
    3392:	4b11      	ldr	r3, [pc, #68]	; (33d8 <DecodeCertificateName+0x98>)
    3394:	4798      	blx	r3
            if (AJ_OK != status) 
    3396:	2800      	cmp	r0, #0
    3398:	d11a      	bne.n	33d0 <DecodeCertificateName+0x90>
			{
                return status;
            }
            dn->ou.data = tmp.data;
    339a:	9b01      	ldr	r3, [sp, #4]
    339c:	6073      	str	r3, [r6, #4]
            dn->ou.size = tmp.size;
    339e:	9b00      	ldr	r3, [sp, #0]
    33a0:	6033      	str	r3, [r6, #0]
    33a2:	e011      	b.n	33c8 <DecodeCertificateName+0x88>
        } 
		else if (CompareOID(&oid, OID_DN_CN, sizeof (OID_DN_CN))) 
    33a4:	a802      	add	r0, sp, #8
    33a6:	490f      	ldr	r1, [pc, #60]	; (33e4 <DecodeCertificateName+0xa4>)
    33a8:	2203      	movs	r2, #3
    33aa:	4b0d      	ldr	r3, [pc, #52]	; (33e0 <DecodeCertificateName+0xa0>)
    33ac:	4798      	blx	r3
    33ae:	2800      	cmp	r0, #0
    33b0:	d00a      	beq.n	33c8 <DecodeCertificateName+0x88>
		{
            // Only accept UTF8 strings
            status = AJ_ASN1DecodeElement(&seq, ASN_UTF8, &tmp);
    33b2:	a804      	add	r0, sp, #16
    33b4:	210c      	movs	r1, #12
    33b6:	466a      	mov	r2, sp
    33b8:	4b07      	ldr	r3, [pc, #28]	; (33d8 <DecodeCertificateName+0x98>)
    33ba:	4798      	blx	r3
            if (AJ_OK != status) 
    33bc:	2800      	cmp	r0, #0
    33be:	d107      	bne.n	33d0 <DecodeCertificateName+0x90>
			{
                return status;
            }
            dn->cn.data = tmp.data;
    33c0:	9b01      	ldr	r3, [sp, #4]
    33c2:	60f3      	str	r3, [r6, #12]
            dn->cn.size = tmp.size;
    33c4:	9b00      	ldr	r3, [sp, #0]
    33c6:	60b3      	str	r3, [r6, #8]
    DER_Element oid;
    DER_Element tmp;

    memset(dn, 0, sizeof (X509DistinguishedName));

    while ((AJ_OK == status) && (der->size)) 
    33c8:	682b      	ldr	r3, [r5, #0]
    33ca:	2b00      	cmp	r3, #0
    33cc:	d1c3      	bne.n	3356 <DecodeCertificateName+0x16>
    33ce:	2000      	movs	r0, #0
            dn->cn.size = tmp.size;
        }
    }

    return status;
}
    33d0:	b009      	add	sp, #36	; 0x24
    33d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    33d4:	00016773 	.word	0x00016773
    33d8:	000031d1 	.word	0x000031d1
    33dc:	0001b1b4 	.word	0x0001b1b4
    33e0:	00003321 	.word	0x00003321
    33e4:	0001b1a8 	.word	0x0001b1a8

000033e8 <AJ_X509DecodeCertificateDER>:

    return status;
}

AJ_Status AJ_X509DecodeCertificateDER(X509Certificate* certificate, DER_Element* der)
{
    33e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    33ea:	b0bd      	sub	sp, #244	; 0xf4
    33ec:	1c05      	adds	r5, r0, #0
    33ee:	1c0e      	adds	r6, r1, #0
    DER_Element seq;
    DER_Element tbs;
    DER_Element tmp;
    DER_Element oid;
    DER_Element sig;
    const uint8_t tags1[] = { ASN_SEQ };
    33f0:	2210      	movs	r2, #16
    33f2:	ab31      	add	r3, sp, #196	; 0xc4
    33f4:	701a      	strb	r2, [r3, #0]
    const uint8_t tags2[] = { ASN_SEQ, ASN_SEQ, ASN_BITS };
    33f6:	a830      	add	r0, sp, #192	; 0xc0
    33f8:	49ab      	ldr	r1, [pc, #684]	; (36a8 <AJ_X509DecodeCertificateDER+0x2c0>)
    33fa:	3104      	adds	r1, #4
    33fc:	3a0d      	subs	r2, #13
    33fe:	4bab      	ldr	r3, [pc, #684]	; (36ac <AJ_X509DecodeCertificateDER+0x2c4>)
    3400:	4798      	blx	r3

    AJ_InfoPrintf(("AJ_X509DecodeCertificateDER(certificate=%p, der=%p)\n", certificate, der));

    if ((NULL == certificate) || (NULL == der)) 
    3402:	2d00      	cmp	r5, #0
    3404:	d100      	bne.n	3408 <AJ_X509DecodeCertificateDER+0x20>
    3406:	e21b      	b.n	3840 <AJ_X509DecodeCertificateDER+0x458>
	{
        return AJ_ERR_INVALID;
    3408:	2403      	movs	r4, #3
    const uint8_t tags1[] = { ASN_SEQ };
    const uint8_t tags2[] = { ASN_SEQ, ASN_SEQ, ASN_BITS };

    AJ_InfoPrintf(("AJ_X509DecodeCertificateDER(certificate=%p, der=%p)\n", certificate, der));

    if ((NULL == certificate) || (NULL == der)) 
    340a:	2e00      	cmp	r6, #0
    340c:	d100      	bne.n	3410 <AJ_X509DecodeCertificateDER+0x28>
    340e:	e229      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return AJ_ERR_INVALID;
    }

    status = AJ_ASN1DecodeElements(der, tags1, sizeof (tags1), &seq);
    3410:	1c30      	adds	r0, r6, #0
    3412:	a931      	add	r1, sp, #196	; 0xc4
    3414:	2201      	movs	r2, #1
    3416:	ab3a      	add	r3, sp, #232	; 0xe8
    3418:	4ca5      	ldr	r4, [pc, #660]	; (36b0 <AJ_X509DecodeCertificateDER+0x2c8>)
    341a:	47a0      	blx	r4
    if (AJ_OK != status) 
	{
        return status;
    341c:	1e04      	subs	r4, r0, #0
	{
        return AJ_ERR_INVALID;
    }

    status = AJ_ASN1DecodeElements(der, tags1, sizeof (tags1), &seq);
    if (AJ_OK != status) 
    341e:	d000      	beq.n	3422 <AJ_X509DecodeCertificateDER+0x3a>
    3420:	e220      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }
    status = AJ_ASN1DecodeElements(&seq, tags2, sizeof (tags2), &tbs, &tmp, &sig);
    3422:	ab36      	add	r3, sp, #216	; 0xd8
    3424:	9300      	str	r3, [sp, #0]
    3426:	ab32      	add	r3, sp, #200	; 0xc8
    3428:	9301      	str	r3, [sp, #4]
    342a:	a83a      	add	r0, sp, #232	; 0xe8
    342c:	a930      	add	r1, sp, #192	; 0xc0
    342e:	2203      	movs	r2, #3
    3430:	ab38      	add	r3, sp, #224	; 0xe0
    3432:	4c9f      	ldr	r4, [pc, #636]	; (36b0 <AJ_X509DecodeCertificateDER+0x2c8>)
    3434:	47a0      	blx	r4
    if (AJ_OK != status) 
	{
        return status;
    3436:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) 
	{
        return status;
    }
    status = AJ_ASN1DecodeElements(&seq, tags2, sizeof (tags2), &tbs, &tmp, &sig);
    if (AJ_OK != status) 
    3438:	d000      	beq.n	343c <AJ_X509DecodeCertificateDER+0x54>
    343a:	e213      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }

    // The signed TBS includes the sequence and length fields.
    certificate->raw.data = tbs.data - 4;
    343c:	9b39      	ldr	r3, [sp, #228]	; 0xe4
    343e:	930b      	str	r3, [sp, #44]	; 0x2c
    3440:	3b04      	subs	r3, #4
    3442:	60eb      	str	r3, [r5, #12]
    certificate->raw.size = tbs.size + 4;
    3444:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    3446:	3304      	adds	r3, #4
    3448:	60ab      	str	r3, [r5, #8]

    status = DecodeCertificateTBS(&certificate->tbs, &tbs);
    344a:	1c2c      	adds	r4, r5, #0
    344c:	3410      	adds	r4, #16
    DER_Element utc;
    DER_Element sub;
    DER_Element pub;
    DER_Element ext;
    DER_Element tmp;
    const uint8_t tags[] = { ASN_CONTEXT_SPECIFIC, ASN_INTEGER, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_CONTEXT_SPECIFIC };
    344e:	a820      	add	r0, sp, #128	; 0x80
    3450:	4995      	ldr	r1, [pc, #596]	; (36a8 <AJ_X509DecodeCertificateDER+0x2c0>)
    3452:	3108      	adds	r1, #8
    3454:	2208      	movs	r2, #8
    3456:	4b95      	ldr	r3, [pc, #596]	; (36ac <AJ_X509DecodeCertificateDER+0x2c4>)
    3458:	4798      	blx	r3

    memset(tbs, 0, sizeof (X509TbsCertificate));
    345a:	1c20      	adds	r0, r4, #0
    345c:	2100      	movs	r1, #0
    345e:	2288      	movs	r2, #136	; 0x88
    3460:	4b94      	ldr	r3, [pc, #592]	; (36b4 <AJ_X509DecodeCertificateDER+0x2cc>)
    3462:	4798      	blx	r3

    status = AJ_ASN1DecodeElements(der, tags, sizeof (tags), 0, &ver, &tbs->serial, &oid, &iss, &utc, &sub, &pub, 3, &ext);
    3464:	ab10      	add	r3, sp, #64	; 0x40
    3466:	9300      	str	r3, [sp, #0]
    3468:	9401      	str	r4, [sp, #4]
    346a:	ab12      	add	r3, sp, #72	; 0x48
    346c:	9302      	str	r3, [sp, #8]
    346e:	ab14      	add	r3, sp, #80	; 0x50
    3470:	9303      	str	r3, [sp, #12]
    3472:	ab16      	add	r3, sp, #88	; 0x58
    3474:	9304      	str	r3, [sp, #16]
    3476:	ab18      	add	r3, sp, #96	; 0x60
    3478:	9305      	str	r3, [sp, #20]
    347a:	ab1a      	add	r3, sp, #104	; 0x68
    347c:	9306      	str	r3, [sp, #24]
    347e:	2303      	movs	r3, #3
    3480:	9307      	str	r3, [sp, #28]
    3482:	ab1c      	add	r3, sp, #112	; 0x70
    3484:	9308      	str	r3, [sp, #32]
    3486:	a838      	add	r0, sp, #224	; 0xe0
    3488:	a920      	add	r1, sp, #128	; 0x80
    348a:	2208      	movs	r2, #8
    348c:	2300      	movs	r3, #0
    348e:	4c88      	ldr	r4, [pc, #544]	; (36b0 <AJ_X509DecodeCertificateDER+0x2c8>)
    3490:	47a0      	blx	r4
    if (AJ_OK != status) 
	{
        return status;
    3492:	1e04      	subs	r4, r0, #0
    const uint8_t tags[] = { ASN_CONTEXT_SPECIFIC, ASN_INTEGER, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_SEQ, ASN_CONTEXT_SPECIFIC };

    memset(tbs, 0, sizeof (X509TbsCertificate));

    status = AJ_ASN1DecodeElements(der, tags, sizeof (tags), 0, &ver, &tbs->serial, &oid, &iss, &utc, &sub, &pub, 3, &ext);
    if (AJ_OK != status) 
    3494:	d000      	beq.n	3498 <AJ_X509DecodeCertificateDER+0xb0>
    3496:	e1e5      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }

    // We only accept X.509v3 certificates.
    status = AJ_ASN1DecodeElement(&ver, ASN_INTEGER, &tmp);
    3498:	a810      	add	r0, sp, #64	; 0x40
    349a:	2102      	movs	r1, #2
    349c:	aa1e      	add	r2, sp, #120	; 0x78
    349e:	4b86      	ldr	r3, [pc, #536]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    34a0:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    34a2:	1e04      	subs	r4, r0, #0
        return status;
    }

    // We only accept X.509v3 certificates.
    status = AJ_ASN1DecodeElement(&ver, ASN_INTEGER, &tmp);
    if (AJ_OK != status) 
    34a4:	d000      	beq.n	34a8 <AJ_X509DecodeCertificateDER+0xc0>
    34a6:	e1dd      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }
    if ((0x1 != tmp.size) || (0x2 != *tmp.data)) 
	{
        return AJ_ERR_INVALID;
    34a8:	2403      	movs	r4, #3
    status = AJ_ASN1DecodeElement(&ver, ASN_INTEGER, &tmp);
    if (AJ_OK != status) 
	{
        return status;
    }
    if ((0x1 != tmp.size) || (0x2 != *tmp.data)) 
    34aa:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    34ac:	2b01      	cmp	r3, #1
    34ae:	d000      	beq.n	34b2 <AJ_X509DecodeCertificateDER+0xca>
    34b0:	e1d8      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    34b2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    34b4:	781b      	ldrb	r3, [r3, #0]
    34b6:	2b02      	cmp	r3, #2
    34b8:	d000      	beq.n	34bc <AJ_X509DecodeCertificateDER+0xd4>
    34ba:	e1d3      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return AJ_ERR_INVALID;
    }

    // We only accept ECDSA-SHA256 signed certificates at the moment.
    status = AJ_ASN1DecodeElement(&oid, ASN_OID, &tmp);
    34bc:	a812      	add	r0, sp, #72	; 0x48
    34be:	2106      	movs	r1, #6
    34c0:	aa1e      	add	r2, sp, #120	; 0x78
    34c2:	4b7d      	ldr	r3, [pc, #500]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    34c4:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    34c6:	1e04      	subs	r4, r0, #0
        return AJ_ERR_INVALID;
    }

    // We only accept ECDSA-SHA256 signed certificates at the moment.
    status = AJ_ASN1DecodeElement(&oid, ASN_OID, &tmp);
    if (AJ_OK != status) 
    34c8:	d000      	beq.n	34cc <AJ_X509DecodeCertificateDER+0xe4>
    34ca:	e1cb      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }
    if (!CompareOID(&tmp, OID_SIG_ECDSA_SHA256, sizeof (OID_SIG_ECDSA_SHA256)))
    34cc:	a81e      	add	r0, sp, #120	; 0x78
    34ce:	497b      	ldr	r1, [pc, #492]	; (36bc <AJ_X509DecodeCertificateDER+0x2d4>)
    34d0:	2208      	movs	r2, #8
    34d2:	4b7b      	ldr	r3, [pc, #492]	; (36c0 <AJ_X509DecodeCertificateDER+0x2d8>)
    34d4:	4798      	blx	r3
	{
        return AJ_ERR_INVALID;
    34d6:	2403      	movs	r4, #3
    status = AJ_ASN1DecodeElement(&oid, ASN_OID, &tmp);
    if (AJ_OK != status) 
	{
        return status;
    }
    if (!CompareOID(&tmp, OID_SIG_ECDSA_SHA256, sizeof (OID_SIG_ECDSA_SHA256)))
    34d8:	2800      	cmp	r0, #0
    34da:	d100      	bne.n	34de <AJ_X509DecodeCertificateDER+0xf6>
    34dc:	e1c2      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return AJ_ERR_INVALID;
    }

    status = DecodeCertificateName(&tbs->issuer, &iss);
    34de:	1c28      	adds	r0, r5, #0
    34e0:	3018      	adds	r0, #24
    34e2:	a914      	add	r1, sp, #80	; 0x50
    34e4:	4b77      	ldr	r3, [pc, #476]	; (36c4 <AJ_X509DecodeCertificateDER+0x2dc>)
    34e6:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    34e8:	1e04      	subs	r4, r0, #0
	{
        return AJ_ERR_INVALID;
    }

    status = DecodeCertificateName(&tbs->issuer, &iss);
    if (AJ_OK != status) 
    34ea:	d000      	beq.n	34ee <AJ_X509DecodeCertificateDER+0x106>
    34ec:	e1ba      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
{
    AJ_Status status;
    DER_Element time;
    uint8_t fmt;

    memset(validity, 0, sizeof (X509Validity));
    34ee:	1c28      	adds	r0, r5, #0
    34f0:	3028      	adds	r0, #40	; 0x28
    34f2:	2100      	movs	r1, #0
    34f4:	2210      	movs	r2, #16
    34f6:	4b6f      	ldr	r3, [pc, #444]	; (36b4 <AJ_X509DecodeCertificateDER+0x2cc>)
    34f8:	4798      	blx	r3

    if (!der->size) 
	{
        return AJ_ERR_SECURITY;
    34fa:	240d      	movs	r4, #13
    DER_Element time;
    uint8_t fmt;

    memset(validity, 0, sizeof (X509Validity));

    if (!der->size) 
    34fc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    34fe:	2b00      	cmp	r3, #0
    3500:	d100      	bne.n	3504 <AJ_X509DecodeCertificateDER+0x11c>
    3502:	e13f      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return AJ_ERR_SECURITY;
    }
    fmt = *der->data;
    switch (fmt)
    3504:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    3506:	781b      	ldrb	r3, [r3, #0]
    3508:	2b17      	cmp	r3, #23
    350a:	d002      	beq.n	3512 <AJ_X509DecodeCertificateDER+0x12a>
    350c:	2b18      	cmp	r3, #24
    350e:	d00f      	beq.n	3530 <AJ_X509DecodeCertificateDER+0x148>
    3510:	e046      	b.n	35a0 <AJ_X509DecodeCertificateDER+0x1b8>
	{
    case ASN_UTC_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_UTC_TIME, &time);
    3512:	a816      	add	r0, sp, #88	; 0x58
    3514:	2117      	movs	r1, #23
    3516:	aa2e      	add	r2, sp, #184	; 0xb8
    3518:	4b67      	ldr	r3, [pc, #412]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    351a:	4798      	blx	r3
        if (AJ_OK != status) 
		{
            return status;
    351c:	1e04      	subs	r4, r0, #0
    fmt = *der->data;
    switch (fmt)
	{
    case ASN_UTC_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_UTC_TIME, &time);
        if (AJ_OK != status) 
    351e:	d000      	beq.n	3522 <AJ_X509DecodeCertificateDER+0x13a>
    3520:	e130      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
		{
            return status;
        }
        validity->from = AJ_DecodeTime((char*) time.data, "%y%m%d%H%M%SZ");
    3522:	982f      	ldr	r0, [sp, #188]	; 0xbc
    3524:	4968      	ldr	r1, [pc, #416]	; (36c8 <AJ_X509DecodeCertificateDER+0x2e0>)
    3526:	4b69      	ldr	r3, [pc, #420]	; (36cc <AJ_X509DecodeCertificateDER+0x2e4>)
    3528:	4798      	blx	r3
    352a:	62a8      	str	r0, [r5, #40]	; 0x28
    352c:	62e9      	str	r1, [r5, #44]	; 0x2c
    352e:	e00d      	b.n	354c <AJ_X509DecodeCertificateDER+0x164>
        break;

    case ASN_GEN_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_GEN_TIME, &time);
    3530:	a816      	add	r0, sp, #88	; 0x58
    3532:	2118      	movs	r1, #24
    3534:	aa2e      	add	r2, sp, #184	; 0xb8
    3536:	4b60      	ldr	r3, [pc, #384]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    3538:	4798      	blx	r3
        if (AJ_OK != status) 
		{
            return status;
    353a:	1e04      	subs	r4, r0, #0
        validity->from = AJ_DecodeTime((char*) time.data, "%y%m%d%H%M%SZ");
        break;

    case ASN_GEN_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_GEN_TIME, &time);
        if (AJ_OK != status) 
    353c:	d000      	beq.n	3540 <AJ_X509DecodeCertificateDER+0x158>
    353e:	e121      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
		{
            return status;
        }
        validity->from = AJ_DecodeTime((char*) time.data, "%Y%m%d%H%M%SZ");
    3540:	982f      	ldr	r0, [sp, #188]	; 0xbc
    3542:	4963      	ldr	r1, [pc, #396]	; (36d0 <AJ_X509DecodeCertificateDER+0x2e8>)
    3544:	4b61      	ldr	r3, [pc, #388]	; (36cc <AJ_X509DecodeCertificateDER+0x2e4>)
    3546:	4798      	blx	r3
    3548:	62a8      	str	r0, [r5, #40]	; 0x28
    354a:	62e9      	str	r1, [r5, #44]	; 0x2c
        return AJ_ERR_INVALID;
    }

    if (!der->size) 
	{
        return AJ_ERR_SECURITY;
    354c:	240d      	movs	r4, #13

    default:
        return AJ_ERR_INVALID;
    }

    if (!der->size) 
    354e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    3550:	2b00      	cmp	r3, #0
    3552:	d100      	bne.n	3556 <AJ_X509DecodeCertificateDER+0x16e>
    3554:	e116      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return AJ_ERR_SECURITY;
    }
    fmt = *der->data;
    switch (fmt) 
    3556:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    3558:	781b      	ldrb	r3, [r3, #0]
    355a:	2b17      	cmp	r3, #23
    355c:	d002      	beq.n	3564 <AJ_X509DecodeCertificateDER+0x17c>
    355e:	2b18      	cmp	r3, #24
    3560:	d00f      	beq.n	3582 <AJ_X509DecodeCertificateDER+0x19a>
    3562:	e01d      	b.n	35a0 <AJ_X509DecodeCertificateDER+0x1b8>
	{
    case ASN_UTC_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_UTC_TIME, &time);
    3564:	a816      	add	r0, sp, #88	; 0x58
    3566:	2117      	movs	r1, #23
    3568:	aa2e      	add	r2, sp, #184	; 0xb8
    356a:	4b53      	ldr	r3, [pc, #332]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    356c:	4798      	blx	r3
        if (AJ_OK != status) 
		{
            return status;
    356e:	1e04      	subs	r4, r0, #0
    fmt = *der->data;
    switch (fmt) 
	{
    case ASN_UTC_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_UTC_TIME, &time);
        if (AJ_OK != status) 
    3570:	d000      	beq.n	3574 <AJ_X509DecodeCertificateDER+0x18c>
    3572:	e107      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
		{
            return status;
        }
        validity->to = AJ_DecodeTime((char*) time.data, "%y%m%d%H%M%SZ");
    3574:	982f      	ldr	r0, [sp, #188]	; 0xbc
    3576:	4954      	ldr	r1, [pc, #336]	; (36c8 <AJ_X509DecodeCertificateDER+0x2e0>)
    3578:	4b54      	ldr	r3, [pc, #336]	; (36cc <AJ_X509DecodeCertificateDER+0x2e4>)
    357a:	4798      	blx	r3
    357c:	6328      	str	r0, [r5, #48]	; 0x30
    357e:	6369      	str	r1, [r5, #52]	; 0x34
    3580:	e168      	b.n	3854 <AJ_X509DecodeCertificateDER+0x46c>
        break;

    case ASN_GEN_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_GEN_TIME, &time);
    3582:	a816      	add	r0, sp, #88	; 0x58
    3584:	2118      	movs	r1, #24
    3586:	aa2e      	add	r2, sp, #184	; 0xb8
    3588:	4b4b      	ldr	r3, [pc, #300]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    358a:	4798      	blx	r3
        if (AJ_OK != status) 
		{
            return status;
    358c:	1e04      	subs	r4, r0, #0
        validity->to = AJ_DecodeTime((char*) time.data, "%y%m%d%H%M%SZ");
        break;

    case ASN_GEN_TIME:
        status = AJ_ASN1DecodeElement(der, ASN_GEN_TIME, &time);
        if (AJ_OK != status) 
    358e:	d000      	beq.n	3592 <AJ_X509DecodeCertificateDER+0x1aa>
    3590:	e0f8      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
		{
            return status;
        }
        validity->to = AJ_DecodeTime((char*) time.data, "%Y%m%d%H%M%SZ");
    3592:	982f      	ldr	r0, [sp, #188]	; 0xbc
    3594:	494e      	ldr	r1, [pc, #312]	; (36d0 <AJ_X509DecodeCertificateDER+0x2e8>)
    3596:	4b4d      	ldr	r3, [pc, #308]	; (36cc <AJ_X509DecodeCertificateDER+0x2e4>)
    3598:	4798      	blx	r3
    359a:	6328      	str	r0, [r5, #48]	; 0x30
    359c:	6369      	str	r1, [r5, #52]	; 0x34
    359e:	e159      	b.n	3854 <AJ_X509DecodeCertificateDER+0x46c>
    35a0:	2403      	movs	r4, #3
    35a2:	e15f      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    status = DecodeCertificateName(&tbs->subject, &sub);
    if (AJ_OK != status) 
	{
        return status;
    }
    status = DecodeCertificatePub(&tbs->publickey, &pub);
    35a4:	1c2e      	adds	r6, r5, #0
    35a6:	3648      	adds	r6, #72	; 0x48
    AJ_Status status;
    DER_Element seq;
    DER_Element bit;
    DER_Element oid1;
    DER_Element oid2;
    const uint8_t tags1[] = { ASN_SEQ, ASN_BITS };
    35a8:	4c3f      	ldr	r4, [pc, #252]	; (36a8 <AJ_X509DecodeCertificateDER+0x2c0>)
    35aa:	1c21      	adds	r1, r4, #0
    35ac:	3110      	adds	r1, #16
    35ae:	a824      	add	r0, sp, #144	; 0x90
    35b0:	2202      	movs	r2, #2
    35b2:	4f3e      	ldr	r7, [pc, #248]	; (36ac <AJ_X509DecodeCertificateDER+0x2c4>)
    35b4:	47b8      	blx	r7
    const uint8_t tags2[] = { ASN_OID, ASN_OID };
    35b6:	1c21      	adds	r1, r4, #0
    35b8:	3114      	adds	r1, #20
    35ba:	a826      	add	r0, sp, #152	; 0x98
    35bc:	2202      	movs	r2, #2
    35be:	47b8      	blx	r7

    memset(pub, 0, sizeof (ecc_publickey));
    35c0:	1c30      	adds	r0, r6, #0
    35c2:	2100      	movs	r1, #0
    35c4:	224c      	movs	r2, #76	; 0x4c
    35c6:	4b3b      	ldr	r3, [pc, #236]	; (36b4 <AJ_X509DecodeCertificateDER+0x2cc>)
    35c8:	4798      	blx	r3

    status = AJ_ASN1DecodeElements(der, tags1, sizeof (tags1), &seq, &bit);
    35ca:	ab2a      	add	r3, sp, #168	; 0xa8
    35cc:	9300      	str	r3, [sp, #0]
    35ce:	a81a      	add	r0, sp, #104	; 0x68
    35d0:	a924      	add	r1, sp, #144	; 0x90
    35d2:	2202      	movs	r2, #2
    35d4:	ab28      	add	r3, sp, #160	; 0xa0
    35d6:	4c36      	ldr	r4, [pc, #216]	; (36b0 <AJ_X509DecodeCertificateDER+0x2c8>)
    35d8:	47a0      	blx	r4
    if (AJ_OK != status) 
	{
        return status;
    35da:	1e04      	subs	r4, r0, #0
    const uint8_t tags2[] = { ASN_OID, ASN_OID };

    memset(pub, 0, sizeof (ecc_publickey));

    status = AJ_ASN1DecodeElements(der, tags1, sizeof (tags1), &seq, &bit);
    if (AJ_OK != status) 
    35dc:	d000      	beq.n	35e0 <AJ_X509DecodeCertificateDER+0x1f8>
    35de:	e0d1      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return status;
    }

    // We only accept NISTP256 ECC keys at the moment.
    status = AJ_ASN1DecodeElements(&seq, tags2, sizeof (tags2), &oid1, &oid2);
    35e0:	ab2e      	add	r3, sp, #184	; 0xb8
    35e2:	9300      	str	r3, [sp, #0]
    35e4:	a828      	add	r0, sp, #160	; 0xa0
    35e6:	a926      	add	r1, sp, #152	; 0x98
    35e8:	2202      	movs	r2, #2
    35ea:	ab2c      	add	r3, sp, #176	; 0xb0
    35ec:	4c30      	ldr	r4, [pc, #192]	; (36b0 <AJ_X509DecodeCertificateDER+0x2c8>)
    35ee:	47a0      	blx	r4
    if (AJ_OK != status) 
	{
        return status;
    35f0:	1e04      	subs	r4, r0, #0
        return status;
    }

    // We only accept NISTP256 ECC keys at the moment.
    status = AJ_ASN1DecodeElements(&seq, tags2, sizeof (tags2), &oid1, &oid2);
    if (AJ_OK != status) 
    35f2:	d000      	beq.n	35f6 <AJ_X509DecodeCertificateDER+0x20e>
    35f4:	e0c6      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return status;
    }
    if (!CompareOID(&oid1, OID_KEY_ECC, sizeof (OID_KEY_ECC)))
    35f6:	a82c      	add	r0, sp, #176	; 0xb0
    35f8:	4936      	ldr	r1, [pc, #216]	; (36d4 <AJ_X509DecodeCertificateDER+0x2ec>)
    35fa:	2207      	movs	r2, #7
    35fc:	4b30      	ldr	r3, [pc, #192]	; (36c0 <AJ_X509DecodeCertificateDER+0x2d8>)
    35fe:	4798      	blx	r3
	 {
        return AJ_ERR_INVALID;
    3600:	2403      	movs	r4, #3
    status = AJ_ASN1DecodeElements(&seq, tags2, sizeof (tags2), &oid1, &oid2);
    if (AJ_OK != status) 
	{
        return status;
    }
    if (!CompareOID(&oid1, OID_KEY_ECC, sizeof (OID_KEY_ECC)))
    3602:	2800      	cmp	r0, #0
    3604:	d100      	bne.n	3608 <AJ_X509DecodeCertificateDER+0x220>
    3606:	e0bd      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	 {
        return AJ_ERR_INVALID;
    }
    if (!CompareOID(&oid2, OID_CRV_PRIME256V1, sizeof (OID_CRV_PRIME256V1)))
    3608:	a82e      	add	r0, sp, #184	; 0xb8
    360a:	4933      	ldr	r1, [pc, #204]	; (36d8 <AJ_X509DecodeCertificateDER+0x2f0>)
    360c:	2208      	movs	r2, #8
    360e:	4b2c      	ldr	r3, [pc, #176]	; (36c0 <AJ_X509DecodeCertificateDER+0x2d8>)
    3610:	4798      	blx	r3
    3612:	2800      	cmp	r0, #0
    3614:	d100      	bne.n	3618 <AJ_X509DecodeCertificateDER+0x230>
    3616:	e0b5      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	 {
        return AJ_ERR_INVALID;
    }

    // We only accept uncompressed ECC points.
    if ((2 + KEY_ECC_PUB_SZ) != bit.size) 
    3618:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
    361a:	2b42      	cmp	r3, #66	; 0x42
    361c:	d000      	beq.n	3620 <AJ_X509DecodeCertificateDER+0x238>
    361e:	e0b1      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return AJ_ERR_INVALID;
    }
    if ((0x00 != bit.data[0]) || (0x04 != bit.data[1]))
    3620:	982b      	ldr	r0, [sp, #172]	; 0xac
    3622:	7803      	ldrb	r3, [r0, #0]
    3624:	2b00      	cmp	r3, #0
    3626:	d000      	beq.n	362a <AJ_X509DecodeCertificateDER+0x242>
    3628:	e0ac      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
    362a:	7843      	ldrb	r3, [r0, #1]
    362c:	2b04      	cmp	r3, #4
    362e:	d000      	beq.n	3632 <AJ_X509DecodeCertificateDER+0x24a>
    3630:	e0a8      	b.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return AJ_ERR_INVALID;
    }
    bit.data += 2;
    3632:	3002      	adds	r0, #2
    3634:	902b      	str	r0, [sp, #172]	; 0xac
    bit.size -= 2;
    3636:	333c      	adds	r3, #60	; 0x3c
    3638:	932a      	str	r3, [sp, #168]	; 0xa8
    AJ_BigvalDecode(bit.data, &pub->x, KEY_ECC_SZ);
    363a:	1c31      	adds	r1, r6, #0
    363c:	2220      	movs	r2, #32
    363e:	4c27      	ldr	r4, [pc, #156]	; (36dc <AJ_X509DecodeCertificateDER+0x2f4>)
    3640:	47a0      	blx	r4
    bit.data += KEY_ECC_SZ;
    3642:	9b2b      	ldr	r3, [sp, #172]	; 0xac
    3644:	930b      	str	r3, [sp, #44]	; 0x2c
    3646:	1c18      	adds	r0, r3, #0
    3648:	3020      	adds	r0, #32
    364a:	902b      	str	r0, [sp, #172]	; 0xac
    bit.size -= KEY_ECC_SZ;
    364c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
    364e:	3b20      	subs	r3, #32
    3650:	932a      	str	r3, [sp, #168]	; 0xa8
    AJ_BigvalDecode(bit.data, &pub->y, KEY_ECC_SZ);
    3652:	1c29      	adds	r1, r5, #0
    3654:	316c      	adds	r1, #108	; 0x6c
    3656:	2220      	movs	r2, #32
    3658:	47a0      	blx	r4
    DER_Element savedSeq;
    DER_Element boolVal;
    DER_Element intVal;
    DER_Element oid;
    DER_Element oct;
    const uint8_t tags[] = { ASN_OID, ASN_OCTETS };
    365a:	4c13      	ldr	r4, [pc, #76]	; (36a8 <AJ_X509DecodeCertificateDER+0x2c0>)
    365c:	1c21      	adds	r1, r4, #0
    365e:	3118      	adds	r1, #24
    3660:	2602      	movs	r6, #2
    3662:	a80d      	add	r0, sp, #52	; 0x34
    3664:	1c32      	adds	r2, r6, #0
    3666:	4f11      	ldr	r7, [pc, #68]	; (36ac <AJ_X509DecodeCertificateDER+0x2c4>)
    3668:	47b8      	blx	r7
    const uint8_t tagsWithCritical[] = { ASN_OID, ASN_BOOLEAN, ASN_OCTETS };
    366a:	1c21      	adds	r1, r4, #0
    366c:	311c      	adds	r1, #28
    366e:	a80f      	add	r0, sp, #60	; 0x3c
    3670:	2203      	movs	r2, #3
    3672:	47b8      	blx	r7
    const uint8_t tagsCAPathLen[] = { ASN_BOOLEAN, ASN_INTEGER };
    3674:	1c21      	adds	r1, r4, #0
    3676:	3120      	adds	r1, #32
    3678:	a80e      	add	r0, sp, #56	; 0x38
    367a:	1c32      	adds	r2, r6, #0
    367c:	47b8      	blx	r7

    memset(extensions, 0, sizeof (X509Extensions));
    367e:	1c28      	adds	r0, r5, #0
    3680:	3094      	adds	r0, #148	; 0x94
    3682:	2100      	movs	r1, #0
    3684:	2204      	movs	r2, #4
    3686:	4b0b      	ldr	r3, [pc, #44]	; (36b4 <AJ_X509DecodeCertificateDER+0x2cc>)
    3688:	4798      	blx	r3

    status = AJ_ASN1DecodeElement(der, ASN_SEQ, &tmp);
    368a:	a81c      	add	r0, sp, #112	; 0x70
    368c:	2110      	movs	r1, #16
    368e:	aa22      	add	r2, sp, #136	; 0x88
    3690:	4b09      	ldr	r3, [pc, #36]	; (36b8 <AJ_X509DecodeCertificateDER+0x2d0>)
    3692:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    3694:	1e04      	subs	r4, r0, #0
    const uint8_t tagsCAPathLen[] = { ASN_BOOLEAN, ASN_INTEGER };

    memset(extensions, 0, sizeof (X509Extensions));

    status = AJ_ASN1DecodeElement(der, ASN_SEQ, &tmp);
    if (AJ_OK != status) 
    3696:	d175      	bne.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
	{
        return status;
    }
    der->size = tmp.size;
    3698:	9b22      	ldr	r3, [sp, #136]	; 0x88
    369a:	931c      	str	r3, [sp, #112]	; 0x70
    der->data = tmp.data;
    369c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    369e:	931d      	str	r3, [sp, #116]	; 0x74
    while ((AJ_OK == status) && (der->size)) 
	{
        status = AJ_ASN1DecodeElement(der, ASN_SEQ, &seq);
    36a0:	360e      	adds	r6, #14
                        return status;
                    }
                }
                if (tmp.size) 
				{
                    extensions->ca = *tmp.data;
    36a2:	2794      	movs	r7, #148	; 0x94
    36a4:	e06a      	b.n	377c <AJ_X509DecodeCertificateDER+0x394>
    36a6:	46c0      	nop			; (mov r8, r8)
    36a8:	0001b178 	.word	0x0001b178
    36ac:	00016739 	.word	0x00016739
    36b0:	00003295 	.word	0x00003295
    36b4:	00016773 	.word	0x00016773
    36b8:	000031d1 	.word	0x000031d1
    36bc:	0001b1a0 	.word	0x0001b1a0
    36c0:	00003321 	.word	0x00003321
    36c4:	00003341 	.word	0x00003341
    36c8:	0001b1f8 	.word	0x0001b1f8
    36cc:	0000d731 	.word	0x0000d731
    36d0:	0001b208 	.word	0x0001b208
    36d4:	0001b1ac 	.word	0x0001b1ac
    36d8:	0001b254 	.word	0x0001b254
    36dc:	00005ee5 	.word	0x00005ee5
    }
    der->size = tmp.size;
    der->data = tmp.data;
    while ((AJ_OK == status) && (der->size)) 
	{
        status = AJ_ASN1DecodeElement(der, ASN_SEQ, &seq);
    36e0:	a81c      	add	r0, sp, #112	; 0x70
    36e2:	1c31      	adds	r1, r6, #0
    36e4:	aa24      	add	r2, sp, #144	; 0x90
    36e6:	4b61      	ldr	r3, [pc, #388]	; (386c <AJ_X509DecodeCertificateDER+0x484>)
    36e8:	4798      	blx	r3
    36ea:	1e04      	subs	r4, r0, #0
        if (AJ_OK != status)
    36ec:	d14a      	bne.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
		{
            return status;
        }
        savedSeq.size = seq.size;
    36ee:	9b24      	ldr	r3, [sp, #144]	; 0x90
    36f0:	9326      	str	r3, [sp, #152]	; 0x98
        savedSeq.data = seq.data;
    36f2:	9b25      	ldr	r3, [sp, #148]	; 0x94
    36f4:	930b      	str	r3, [sp, #44]	; 0x2c
    36f6:	9327      	str	r3, [sp, #156]	; 0x9c

        status = AJ_ASN1DecodeElements(&seq, tagsWithCritical, sizeof (tagsWithCritical), &oid, &boolVal, &oct);
    36f8:	ab28      	add	r3, sp, #160	; 0xa0
    36fa:	9300      	str	r3, [sp, #0]
    36fc:	ab2e      	add	r3, sp, #184	; 0xb8
    36fe:	9301      	str	r3, [sp, #4]
    3700:	a824      	add	r0, sp, #144	; 0x90
    3702:	a90f      	add	r1, sp, #60	; 0x3c
    3704:	2203      	movs	r2, #3
    3706:	ab2c      	add	r3, sp, #176	; 0xb0
    3708:	4c59      	ldr	r4, [pc, #356]	; (3870 <AJ_X509DecodeCertificateDER+0x488>)
    370a:	47a0      	blx	r4
        if (AJ_OK != status) 
    370c:	2800      	cmp	r0, #0
    370e:	d009      	beq.n	3724 <AJ_X509DecodeCertificateDER+0x33c>
		{
            status = AJ_ASN1DecodeElements(&savedSeq, tags, sizeof (tags), &oid, &oct);
    3710:	ab2e      	add	r3, sp, #184	; 0xb8
    3712:	9300      	str	r3, [sp, #0]
    3714:	a826      	add	r0, sp, #152	; 0x98
    3716:	a90d      	add	r1, sp, #52	; 0x34
    3718:	2202      	movs	r2, #2
    371a:	ab2c      	add	r3, sp, #176	; 0xb0
    371c:	4c54      	ldr	r4, [pc, #336]	; (3870 <AJ_X509DecodeCertificateDER+0x488>)
    371e:	47a0      	blx	r4
    3720:	1e04      	subs	r4, r0, #0
            if (AJ_OK != status) 
    3722:	d12f      	bne.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
			{
                return status;
            }
        }
        if (CompareOID(&oid, OID_BASIC_CONSTRAINTS, sizeof (OID_BASIC_CONSTRAINTS))) 
    3724:	a82c      	add	r0, sp, #176	; 0xb0
    3726:	4953      	ldr	r1, [pc, #332]	; (3874 <AJ_X509DecodeCertificateDER+0x48c>)
    3728:	2203      	movs	r2, #3
    372a:	4b53      	ldr	r3, [pc, #332]	; (3878 <AJ_X509DecodeCertificateDER+0x490>)
    372c:	4798      	blx	r3
    372e:	2800      	cmp	r0, #0
    3730:	d024      	beq.n	377c <AJ_X509DecodeCertificateDER+0x394>
		{
            status = AJ_ASN1DecodeElement(&oct, ASN_SEQ, &seq);
    3732:	a82e      	add	r0, sp, #184	; 0xb8
    3734:	1c31      	adds	r1, r6, #0
    3736:	aa24      	add	r2, sp, #144	; 0x90
    3738:	4b4c      	ldr	r3, [pc, #304]	; (386c <AJ_X509DecodeCertificateDER+0x484>)
    373a:	4798      	blx	r3
    373c:	1e04      	subs	r4, r0, #0
            if (AJ_OK != status) 
    373e:	d121      	bne.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
			{
                return status;
            }
            // Explicit boolean (non-empty sequence)
            if (seq.size) 
    3740:	9b24      	ldr	r3, [sp, #144]	; 0x90
    3742:	2b00      	cmp	r3, #0
    3744:	d01a      	beq.n	377c <AJ_X509DecodeCertificateDER+0x394>
			{
                savedSeq.size = seq.size;
    3746:	9326      	str	r3, [sp, #152]	; 0x98
                savedSeq.data = seq.data;
    3748:	9b25      	ldr	r3, [sp, #148]	; 0x94
    374a:	930b      	str	r3, [sp, #44]	; 0x2c
    374c:	9327      	str	r3, [sp, #156]	; 0x9c
                status = AJ_ASN1DecodeElements(&seq, tagsCAPathLen, sizeof (tagsCAPathLen), &tmp, &intVal);
    374e:	ab2a      	add	r3, sp, #168	; 0xa8
    3750:	9300      	str	r3, [sp, #0]
    3752:	a824      	add	r0, sp, #144	; 0x90
    3754:	a90e      	add	r1, sp, #56	; 0x38
    3756:	2202      	movs	r2, #2
    3758:	ab22      	add	r3, sp, #136	; 0x88
    375a:	4c45      	ldr	r4, [pc, #276]	; (3870 <AJ_X509DecodeCertificateDER+0x488>)
    375c:	47a0      	blx	r4
                if (AJ_OK != status) 
    375e:	2800      	cmp	r0, #0
    3760:	d006      	beq.n	3770 <AJ_X509DecodeCertificateDER+0x388>
				{
                    status = AJ_ASN1DecodeElement(&savedSeq, ASN_BOOLEAN, &tmp);
    3762:	a826      	add	r0, sp, #152	; 0x98
    3764:	2101      	movs	r1, #1
    3766:	aa22      	add	r2, sp, #136	; 0x88
    3768:	4b40      	ldr	r3, [pc, #256]	; (386c <AJ_X509DecodeCertificateDER+0x484>)
    376a:	4798      	blx	r3
    376c:	1e04      	subs	r4, r0, #0
                    if (AJ_OK != status) 
    376e:	d109      	bne.n	3784 <AJ_X509DecodeCertificateDER+0x39c>
					{
                        return status;
                    }
                }
                if (tmp.size) 
    3770:	9b22      	ldr	r3, [sp, #136]	; 0x88
    3772:	2b00      	cmp	r3, #0
    3774:	d002      	beq.n	377c <AJ_X509DecodeCertificateDER+0x394>
				{
                    extensions->ca = *tmp.data;
    3776:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    3778:	781b      	ldrb	r3, [r3, #0]
    377a:	51eb      	str	r3, [r5, r7]
	{
        return status;
    }
    der->size = tmp.size;
    der->data = tmp.data;
    while ((AJ_OK == status) && (der->size)) 
    377c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    377e:	2b00      	cmp	r3, #0
    3780:	d1ae      	bne.n	36e0 <AJ_X509DecodeCertificateDER+0x2f8>
    3782:	2400      	movs	r4, #0
    // The signed TBS includes the sequence and length fields.
    certificate->raw.data = tbs.data - 4;
    certificate->raw.size = tbs.size + 4;

    status = DecodeCertificateTBS(&certificate->tbs, &tbs);
    if (AJ_OK != status) 
    3784:	2c00      	cmp	r4, #0
    3786:	d16d      	bne.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
	{
        return status;
    }

    // We only accept ECDSA-SHA256 signed certificates at the moment.
    status = AJ_ASN1DecodeElement(&tmp, ASN_OID, &oid);
    3788:	a836      	add	r0, sp, #216	; 0xd8
    378a:	2106      	movs	r1, #6
    378c:	aa34      	add	r2, sp, #208	; 0xd0
    378e:	4b37      	ldr	r3, [pc, #220]	; (386c <AJ_X509DecodeCertificateDER+0x484>)
    3790:	4798      	blx	r3
    if (AJ_OK != status) 
    3792:	2800      	cmp	r0, #0
    3794:	d156      	bne.n	3844 <AJ_X509DecodeCertificateDER+0x45c>
	{
        return status;
    }
    if (!CompareOID(&oid, OID_SIG_ECDSA_SHA256, sizeof (OID_SIG_ECDSA_SHA256))) 
    3796:	a834      	add	r0, sp, #208	; 0xd0
    3798:	4938      	ldr	r1, [pc, #224]	; (387c <AJ_X509DecodeCertificateDER+0x494>)
    379a:	2208      	movs	r2, #8
    379c:	4b36      	ldr	r3, [pc, #216]	; (3878 <AJ_X509DecodeCertificateDER+0x490>)
    379e:	4798      	blx	r3
    37a0:	2800      	cmp	r0, #0
    37a2:	d051      	beq.n	3848 <AJ_X509DecodeCertificateDER+0x460>
	{
        return AJ_ERR_INVALID;
    }

    // Remove the byte specifying unused bits, this should always be zero.
    if ((0 == sig.size) || (0 != *sig.data)) 
    37a4:	9b32      	ldr	r3, [sp, #200]	; 0xc8
    37a6:	2b00      	cmp	r3, #0
    37a8:	d050      	beq.n	384c <AJ_X509DecodeCertificateDER+0x464>
    37aa:	9a33      	ldr	r2, [sp, #204]	; 0xcc
    37ac:	7811      	ldrb	r1, [r2, #0]
    37ae:	2900      	cmp	r1, #0
    37b0:	d14e      	bne.n	3850 <AJ_X509DecodeCertificateDER+0x468>
	{
        return AJ_ERR_INVALID;
    }
    sig.data++;
    37b2:	3201      	adds	r2, #1
    37b4:	9233      	str	r2, [sp, #204]	; 0xcc
    sig.size--;
    37b6:	3b01      	subs	r3, #1
    37b8:	9332      	str	r3, [sp, #200]	; 0xc8
{
    AJ_Status status;
    DER_Element seq;
    DER_Element int1;
    DER_Element int2;
    const uint8_t tags[] = { ASN_INTEGER, ASN_INTEGER };
    37ba:	a828      	add	r0, sp, #160	; 0xa0
    37bc:	4930      	ldr	r1, [pc, #192]	; (3880 <AJ_X509DecodeCertificateDER+0x498>)
    37be:	3124      	adds	r1, #36	; 0x24
    37c0:	2202      	movs	r2, #2
    37c2:	4b30      	ldr	r3, [pc, #192]	; (3884 <AJ_X509DecodeCertificateDER+0x49c>)
    37c4:	4798      	blx	r3

    status = AJ_ASN1DecodeElement(der, ASN_SEQ, &seq);
    37c6:	a832      	add	r0, sp, #200	; 0xc8
    37c8:	2110      	movs	r1, #16
    37ca:	aa2a      	add	r2, sp, #168	; 0xa8
    37cc:	4b27      	ldr	r3, [pc, #156]	; (386c <AJ_X509DecodeCertificateDER+0x484>)
    37ce:	4798      	blx	r3
    if (AJ_OK != status) 
    37d0:	2800      	cmp	r0, #0
    37d2:	d131      	bne.n	3838 <AJ_X509DecodeCertificateDER+0x450>
	{
        return status;
    }
    status = AJ_ASN1DecodeElements(&seq, tags, sizeof (tags), &int1, &int2);
    37d4:	ab2e      	add	r3, sp, #184	; 0xb8
    37d6:	9300      	str	r3, [sp, #0]
    37d8:	a82a      	add	r0, sp, #168	; 0xa8
    37da:	a928      	add	r1, sp, #160	; 0xa0
    37dc:	2202      	movs	r2, #2
    37de:	ab2c      	add	r3, sp, #176	; 0xb0
    37e0:	4e23      	ldr	r6, [pc, #140]	; (3870 <AJ_X509DecodeCertificateDER+0x488>)
    37e2:	47b0      	blx	r6
    if (AJ_OK != status)
    37e4:	2800      	cmp	r0, #0
    37e6:	d129      	bne.n	383c <AJ_X509DecodeCertificateDER+0x454>
	{
        return status;
    }

    // Skip over unused bits.
    if ((0 < int1.size) && (0 == *int1.data)) 
    37e8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    37ea:	2b00      	cmp	r3, #0
    37ec:	d007      	beq.n	37fe <AJ_X509DecodeCertificateDER+0x416>
    37ee:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    37f0:	7811      	ldrb	r1, [r2, #0]
    37f2:	2900      	cmp	r1, #0
    37f4:	d103      	bne.n	37fe <AJ_X509DecodeCertificateDER+0x416>
	{
        int1.data++;
    37f6:	3201      	adds	r2, #1
    37f8:	922d      	str	r2, [sp, #180]	; 0xb4
        int1.size--;
    37fa:	3b01      	subs	r3, #1
    37fc:	932c      	str	r3, [sp, #176]	; 0xb0
    }
    if ((0 < int2.size) && (0 == *int2.data)) 
    37fe:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
    3800:	2b00      	cmp	r3, #0
    3802:	d007      	beq.n	3814 <AJ_X509DecodeCertificateDER+0x42c>
    3804:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    3806:	7811      	ldrb	r1, [r2, #0]
    3808:	2900      	cmp	r1, #0
    380a:	d103      	bne.n	3814 <AJ_X509DecodeCertificateDER+0x42c>
	{
        int2.data++;
    380c:	3201      	adds	r2, #1
    380e:	922f      	str	r2, [sp, #188]	; 0xbc
        int2.size--;
    3810:	3b01      	subs	r3, #1
    3812:	932e      	str	r3, [sp, #184]	; 0xb8
	{
        return AJ_ERR_INVALID;
    }
    sig.data++;
    sig.size--;
    status = DecodeCertificateSig(&certificate->signature, &sig);
    3814:	1c2e      	adds	r6, r5, #0
    3816:	3698      	adds	r6, #152	; 0x98
	{
        int2.data++;
        int2.size--;
    }

    memset(signature, 0, sizeof (ecc_signature));
    3818:	1c30      	adds	r0, r6, #0
    381a:	2100      	movs	r1, #0
    381c:	2248      	movs	r2, #72	; 0x48
    381e:	4b1a      	ldr	r3, [pc, #104]	; (3888 <AJ_X509DecodeCertificateDER+0x4a0>)
    3820:	4798      	blx	r3
    AJ_BigvalDecode(int1.data, &signature->r, int1.size);
    3822:	982d      	ldr	r0, [sp, #180]	; 0xb4
    3824:	1c31      	adds	r1, r6, #0
    3826:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    3828:	4e18      	ldr	r6, [pc, #96]	; (388c <AJ_X509DecodeCertificateDER+0x4a4>)
    382a:	47b0      	blx	r6
    AJ_BigvalDecode(int2.data, &signature->s, int2.size);
    382c:	1c29      	adds	r1, r5, #0
    382e:	31bc      	adds	r1, #188	; 0xbc
    3830:	982f      	ldr	r0, [sp, #188]	; 0xbc
    3832:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    3834:	47b0      	blx	r6
    3836:	e015      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    const uint8_t tags[] = { ASN_INTEGER, ASN_INTEGER };

    status = AJ_ASN1DecodeElement(der, ASN_SEQ, &seq);
    if (AJ_OK != status) 
	{
        return status;
    3838:	1c04      	adds	r4, r0, #0
    383a:	e013      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    }
    status = AJ_ASN1DecodeElements(&seq, tags, sizeof (tags), &int1, &int2);
    if (AJ_OK != status)
	{
        return status;
    383c:	1c04      	adds	r4, r0, #0
    }
    sig.data++;
    sig.size--;
    status = DecodeCertificateSig(&certificate->signature, &sig);

    return status;
    383e:	e011      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>

    AJ_InfoPrintf(("AJ_X509DecodeCertificateDER(certificate=%p, der=%p)\n", certificate, der));

    if ((NULL == certificate) || (NULL == der)) 
	{
        return AJ_ERR_INVALID;
    3840:	2403      	movs	r4, #3
    3842:	e00f      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>

    // We only accept ECDSA-SHA256 signed certificates at the moment.
    status = AJ_ASN1DecodeElement(&tmp, ASN_OID, &oid);
    if (AJ_OK != status) 
	{
        return status;
    3844:	1c04      	adds	r4, r0, #0
    3846:	e00d      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    }
    if (!CompareOID(&oid, OID_SIG_ECDSA_SHA256, sizeof (OID_SIG_ECDSA_SHA256))) 
	{
        return AJ_ERR_INVALID;
    3848:	2403      	movs	r4, #3
    384a:	e00b      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    }

    // Remove the byte specifying unused bits, this should always be zero.
    if ((0 == sig.size) || (0 != *sig.data)) 
	{
        return AJ_ERR_INVALID;
    384c:	2403      	movs	r4, #3
    384e:	e009      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    3850:	2403      	movs	r4, #3
    3852:	e007      	b.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    status = DecodeCertificateTime(&tbs->validity, &utc);
    if (AJ_OK != status) 
	{
        return status;
    }
    status = DecodeCertificateName(&tbs->subject, &sub);
    3854:	1c28      	adds	r0, r5, #0
    3856:	3038      	adds	r0, #56	; 0x38
    3858:	a918      	add	r1, sp, #96	; 0x60
    385a:	4b0d      	ldr	r3, [pc, #52]	; (3890 <AJ_X509DecodeCertificateDER+0x4a8>)
    385c:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    385e:	1e04      	subs	r4, r0, #0
    if (AJ_OK != status) 
	{
        return status;
    }
    status = DecodeCertificateName(&tbs->subject, &sub);
    if (AJ_OK != status) 
    3860:	d100      	bne.n	3864 <AJ_X509DecodeCertificateDER+0x47c>
    3862:	e69f      	b.n	35a4 <AJ_X509DecodeCertificateDER+0x1bc>
    sig.data++;
    sig.size--;
    status = DecodeCertificateSig(&certificate->signature, &sig);

    return status;
}
    3864:	1c20      	adds	r0, r4, #0
    3866:	b03d      	add	sp, #244	; 0xf4
    3868:	bdf0      	pop	{r4, r5, r6, r7, pc}
    386a:	46c0      	nop			; (mov r8, r8)
    386c:	000031d1 	.word	0x000031d1
    3870:	00003295 	.word	0x00003295
    3874:	0001b250 	.word	0x0001b250
    3878:	00003321 	.word	0x00003321
    387c:	0001b1a0 	.word	0x0001b1a0
    3880:	0001b178 	.word	0x0001b178
    3884:	00016739 	.word	0x00016739
    3888:	00016773 	.word	0x00016773
    388c:	00005ee5 	.word	0x00005ee5
    3890:	00003341 	.word	0x00003341

00003894 <AJ_X509Verify>:
    AJ_InfoPrintf(("AJ_X509SelfVerify(certificate=%p)\n", certificate));
    return AJ_DSAVerify(certificate->raw.data, certificate->raw.size, &certificate->signature, &certificate->tbs.publickey);
}

AJ_Status AJ_X509Verify(const X509Certificate* certificate, const ecc_publickey* key)
{
    3894:	b510      	push	{r4, lr}
    3896:	1c02      	adds	r2, r0, #0
    3898:	1c0b      	adds	r3, r1, #0
    AJ_InfoPrintf(("AJ_X509Verify(certificate=%p, key=%p)\n", certificate, key));
    return AJ_DSAVerify(certificate->raw.data, certificate->raw.size, &certificate->signature, key);
    389a:	68c0      	ldr	r0, [r0, #12]
    389c:	8911      	ldrh	r1, [r2, #8]
    389e:	3298      	adds	r2, #152	; 0x98
    38a0:	4c01      	ldr	r4, [pc, #4]	; (38a8 <AJ_X509Verify+0x14>)
    38a2:	47a0      	blx	r4
}
    38a4:	bd10      	pop	{r4, pc}
    38a6:	46c0      	nop			; (mov r8, r8)
    38a8:	000060e9 	.word	0x000060e9

000038ac <AJ_X509VerifyChain>:

AJ_Status AJ_X509VerifyChain(const X509CertificateChain* chain, const ecc_publickey* key)
{
    38ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    38ae:	464f      	mov	r7, r9
    38b0:	4646      	mov	r6, r8
    38b2:	b4c0      	push	{r6, r7}
    38b4:	1e05      	subs	r5, r0, #0
    AJ_Status status;

    AJ_InfoPrintf(("AJ_X509VerifyChain(chain=%p, key=%p)\n", chain, key));

    while (chain) 
    38b6:	d025      	beq.n	3904 <AJ_X509VerifyChain+0x58>
	{
        if (key) 
    38b8:	2900      	cmp	r1, #0
    38ba:	d004      	beq.n	38c6 <AJ_X509VerifyChain+0x1a>
		{
            status = AJ_X509Verify(&chain->certificate, key);
    38bc:	1c28      	adds	r0, r5, #0
    38be:	4b1a      	ldr	r3, [pc, #104]	; (3928 <AJ_X509VerifyChain+0x7c>)
    38c0:	4798      	blx	r3
            if (AJ_OK != status)
    38c2:	2800      	cmp	r0, #0
    38c4:	d12c      	bne.n	3920 <AJ_X509VerifyChain+0x74>
            }
        }
        /* The subject field of the current certificate must equal the issuer field of the next certificate
         * in the chain.
         */
        if (NULL != chain->next) 
    38c6:	23e0      	movs	r3, #224	; 0xe0
    38c8:	58ec      	ldr	r4, [r5, r3]
    38ca:	2c00      	cmp	r4, #0
    38cc:	d01c      	beq.n	3908 <AJ_X509VerifyChain+0x5c>
    38ce:	6baa      	ldr	r2, [r5, #56]	; 0x38
    38d0:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    38d2:	6c2e      	ldr	r6, [r5, #64]	; 0x40
    38d4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    38d6:	4698      	mov	r8, r3
    38d8:	69e1      	ldr	r1, [r4, #28]
    38da:	6a23      	ldr	r3, [r4, #32]
    38dc:	6a67      	ldr	r7, [r4, #36]	; 0x24
    38de:	46b9      	mov	r9, r7
   . See RFC 5280 section 7.1 and RFC 4518 for equivalence between different string types.
 */
static uint32_t AJ_X509CompareNames(const X509DistinguishedName a, const X509DistinguishedName b)
{
    /* Only OU and CN are supported as elements in a DN in AllJoyn */
    if (a.ou.size != b.ou.size || a.cn.size != b.cn.size) 
    38e0:	69a7      	ldr	r7, [r4, #24]
    38e2:	42ba      	cmp	r2, r7
    38e4:	d112      	bne.n	390c <AJ_X509VerifyChain+0x60>
    38e6:	429e      	cmp	r6, r3
    38e8:	d112      	bne.n	3910 <AJ_X509VerifyChain+0x64>
	{
        return FALSE;
    }

    if (0 != memcmp(a.ou.data, b.ou.data, a.ou.size) || 0 != memcmp(a.cn.data, b.cn.data, a.cn.size)) 
    38ea:	4b10      	ldr	r3, [pc, #64]	; (392c <AJ_X509VerifyChain+0x80>)
    38ec:	4798      	blx	r3
    38ee:	2800      	cmp	r0, #0
    38f0:	d110      	bne.n	3914 <AJ_X509VerifyChain+0x68>
    38f2:	4640      	mov	r0, r8
    38f4:	4649      	mov	r1, r9
    38f6:	1c32      	adds	r2, r6, #0
    38f8:	4b0c      	ldr	r3, [pc, #48]	; (392c <AJ_X509VerifyChain+0x80>)
    38fa:	4798      	blx	r3
        /* The subject field of the current certificate must equal the issuer field of the next certificate
         * in the chain.
         */
        if (NULL != chain->next) 
		{
            if (!AJ_X509CompareNames(chain->certificate.tbs.subject, chain->next->certificate.tbs.issuer)) 
    38fc:	2800      	cmp	r0, #0
    38fe:	d00b      	beq.n	3918 <AJ_X509VerifyChain+0x6c>
			{
                return AJ_ERR_SECURITY;
    3900:	200d      	movs	r0, #13
    3902:	e00d      	b.n	3920 <AJ_X509VerifyChain+0x74>
        }
        key = &chain->certificate.tbs.publickey;
        chain = chain->next;
    }

    return AJ_OK;
    3904:	2000      	movs	r0, #0
    3906:	e00b      	b.n	3920 <AJ_X509VerifyChain+0x74>
    3908:	2000      	movs	r0, #0
    390a:	e009      	b.n	3920 <AJ_X509VerifyChain+0x74>
         */
        if (NULL != chain->next) 
		{
            if (!AJ_X509CompareNames(chain->certificate.tbs.subject, chain->next->certificate.tbs.issuer)) 
			{
                return AJ_ERR_SECURITY;
    390c:	200d      	movs	r0, #13
    390e:	e007      	b.n	3920 <AJ_X509VerifyChain+0x74>
    3910:	200d      	movs	r0, #13
    3912:	e005      	b.n	3920 <AJ_X509VerifyChain+0x74>
    3914:	200d      	movs	r0, #13
    3916:	e003      	b.n	3920 <AJ_X509VerifyChain+0x74>
            }
        }
        key = &chain->certificate.tbs.publickey;
    3918:	1c29      	adds	r1, r5, #0
    391a:	3148      	adds	r1, #72	; 0x48
        chain = chain->next;
    391c:	1c25      	adds	r5, r4, #0
    391e:	e7cb      	b.n	38b8 <AJ_X509VerifyChain+0xc>
    }

    return AJ_OK;
}
    3920:	bc0c      	pop	{r2, r3}
    3922:	4690      	mov	r8, r2
    3924:	4699      	mov	r9, r3
    3926:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3928:	00003895 	.word	0x00003895
    392c:	0001671b 	.word	0x0001671b

00003930 <WriteLine>:
//    }*/
    return status;
}

static AJ_Status WriteLine(AJ_IOBuffer* txBuf, char* line) 
{
    3930:	b538      	push	{r3, r4, r5, lr}
    3932:	1c04      	adds	r4, r0, #0
    3934:	1c0d      	adds	r5, r1, #0
    strcpy((char*) txBuf->writePtr, line);
    3936:	68c0      	ldr	r0, [r0, #12]
    3938:	4b07      	ldr	r3, [pc, #28]	; (3958 <WriteLine+0x28>)
    393a:	4798      	blx	r3
    txBuf->writePtr += strlen(line);
    393c:	1c28      	adds	r0, r5, #0
    393e:	4b07      	ldr	r3, [pc, #28]	; (395c <WriteLine+0x2c>)
    3940:	4798      	blx	r3
    3942:	68e3      	ldr	r3, [r4, #12]
    3944:	469c      	mov	ip, r3
    3946:	4460      	add	r0, ip
    3948:	60e0      	str	r0, [r4, #12]
	printf("WriteLine: ioBuf->send(ioBuf) \n");
    394a:	4805      	ldr	r0, [pc, #20]	; (3960 <WriteLine+0x30>)
    394c:	4b05      	ldr	r3, [pc, #20]	; (3964 <WriteLine+0x34>)
    394e:	4798      	blx	r3
    return txBuf->send(txBuf);
    3950:	6923      	ldr	r3, [r4, #16]
    3952:	1c20      	adds	r0, r4, #0
    3954:	4798      	blx	r3
}
    3956:	bd38      	pop	{r3, r4, r5, pc}
    3958:	0001714b 	.word	0x0001714b
    395c:	0001715b 	.word	0x0001715b
    3960:	0001b270 	.word	0x0001b270
    3964:	00016f5d 	.word	0x00016f5d

00003968 <SetSignalRules>:
    }
    return status;
}

static AJ_Status SetSignalRules(AJ_BusAttachment* bus)
{
    3968:	b5f0      	push	{r4, r5, r6, r7, lr}
    396a:	4647      	mov	r7, r8
    396c:	b480      	push	{r7}
    396e:	b094      	sub	sp, #80	; 0x50
    return txBuf->send(txBuf);
}

uint8_t AJ_GetRoutingProtoVersion(void)
{
    return routingProtoVersion;
    3970:	4b18      	ldr	r3, [pc, #96]	; (39d4 <SetSignalRules+0x6c>)
     * version 10 the router supports the arg[0,1,...] key in match
     * rules, allowing us to set a signal rule for just the
     * NameOwnerChanged signals of entries in the map.  See aj_guid.c
     * for usage of the arg key.
     */
    if (AJ_GetRoutingProtoVersion() < 11) 
    3972:	781b      	ldrb	r3, [r3, #0]
    return status;
}

static AJ_Status SetSignalRules(AJ_BusAttachment* bus)
{
    AJ_Status status = AJ_OK;
    3974:	2400      	movs	r4, #0
     * version 10 the router supports the arg[0,1,...] key in match
     * rules, allowing us to set a signal rule for just the
     * NameOwnerChanged signals of entries in the map.  See aj_guid.c
     * for usage of the arg key.
     */
    if (AJ_GetRoutingProtoVersion() < 11) 
    3976:	2b0a      	cmp	r3, #10
    3978:	d827      	bhi.n	39ca <SetSignalRules+0x62>
    397a:	9001      	str	r0, [sp, #4]
	{
        status = AJ_BusSetSignalRule(bus, "type='signal',member='NameOwnerChanged',interface='org.freedesktop.DBus'", AJ_BUS_SIGNAL_ALLOW);
    397c:	4916      	ldr	r1, [pc, #88]	; (39d8 <SetSignalRules+0x70>)
    397e:	2200      	movs	r2, #0
    3980:	4b16      	ldr	r3, [pc, #88]	; (39dc <SetSignalRules+0x74>)
    3982:	4798      	blx	r3
    3984:	1e04      	subs	r4, r0, #0
        if (status == AJ_OK) 
    3986:	d120      	bne.n	39ca <SetSignalRules+0x62>
		{
            uint8_t found_reply = FALSE;
            AJ_Message msg;
            AJ_Time timer;
            AJ_InitTimer(&timer);
    3988:	a802      	add	r0, sp, #8
    398a:	4b15      	ldr	r3, [pc, #84]	; (39e0 <SetSignalRules+0x78>)
    398c:	4798      	blx	r3

            while (found_reply == FALSE && AJ_GetElapsedTime(&timer, TRUE) < 3000) 
    398e:	4e15      	ldr	r6, [pc, #84]	; (39e4 <SetSignalRules+0x7c>)
			{
                status = AJ_UnmarshalMsg(bus, &msg, 3000);
    3990:	4f15      	ldr	r7, [pc, #84]	; (39e8 <SetSignalRules+0x80>)
                        // ignore everything else
                        AJ_BusHandleBusMessage(&msg);
                        break;
                    }

                    AJ_CloseMsg(&msg);
    3992:	4b16      	ldr	r3, [pc, #88]	; (39ec <SetSignalRules+0x84>)
    3994:	4698      	mov	r8, r3
    3996:	e012      	b.n	39be <SetSignalRules+0x56>
            AJ_Time timer;
            AJ_InitTimer(&timer);

            while (found_reply == FALSE && AJ_GetElapsedTime(&timer, TRUE) < 3000) 
			{
                status = AJ_UnmarshalMsg(bus, &msg, 3000);
    3998:	9801      	ldr	r0, [sp, #4]
    399a:	a904      	add	r1, sp, #16
    399c:	4a14      	ldr	r2, [pc, #80]	; (39f0 <SetSignalRules+0x88>)
    399e:	47b8      	blx	r7
    39a0:	1e04      	subs	r4, r0, #0
                if (status == AJ_OK) 
    39a2:	d10c      	bne.n	39be <SetSignalRules+0x56>
				{
                    switch (msg.msgId) 
					{
                    case AJ_REPLY_ID(AJ_METHOD_ADD_MATCH):
                        found_reply = TRUE;
    39a4:	2501      	movs	r5, #1
            while (found_reply == FALSE && AJ_GetElapsedTime(&timer, TRUE) < 3000) 
			{
                status = AJ_UnmarshalMsg(bus, &msg, 3000);
                if (status == AJ_OK) 
				{
                    switch (msg.msgId) 
    39a6:	4b13      	ldr	r3, [pc, #76]	; (39f4 <SetSignalRules+0x8c>)
    39a8:	9a04      	ldr	r2, [sp, #16]
    39aa:	429a      	cmp	r2, r3
    39ac:	d003      	beq.n	39b6 <SetSignalRules+0x4e>
                        found_reply = TRUE;
                        break;

                    default:
                        // ignore everything else
                        AJ_BusHandleBusMessage(&msg);
    39ae:	a804      	add	r0, sp, #16
    39b0:	4b11      	ldr	r3, [pc, #68]	; (39f8 <SetSignalRules+0x90>)
    39b2:	4798      	blx	r3
                        break;
    39b4:	2500      	movs	r5, #0
                    }

                    AJ_CloseMsg(&msg);
    39b6:	a804      	add	r0, sp, #16
    39b8:	47c0      	blx	r8
            uint8_t found_reply = FALSE;
            AJ_Message msg;
            AJ_Time timer;
            AJ_InitTimer(&timer);

            while (found_reply == FALSE && AJ_GetElapsedTime(&timer, TRUE) < 3000) 
    39ba:	2d00      	cmp	r5, #0
    39bc:	d105      	bne.n	39ca <SetSignalRules+0x62>
    39be:	a802      	add	r0, sp, #8
    39c0:	2101      	movs	r1, #1
    39c2:	47b0      	blx	r6
    39c4:	4b0d      	ldr	r3, [pc, #52]	; (39fc <SetSignalRules+0x94>)
    39c6:	4298      	cmp	r0, r3
    39c8:	d9e6      	bls.n	3998 <SetSignalRules+0x30>
            }
        }
    }

    return status;
}
    39ca:	1c20      	adds	r0, r4, #0
    39cc:	b014      	add	sp, #80	; 0x50
    39ce:	bc04      	pop	{r2}
    39d0:	4690      	mov	r8, r2
    39d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    39d4:	200006cc 	.word	0x200006cc
    39d8:	0001b290 	.word	0x0001b290
    39dc:	00002b99 	.word	0x00002b99
    39e0:	0000d7ad 	.word	0x0000d7ad
    39e4:	0000d769 	.word	0x0000d769
    39e8:	0000acb5 	.word	0x0000acb5
    39ec:	0000a77d 	.word	0x0000a77d
    39f0:	00000bb8 	.word	0x00000bb8
    39f4:	80000006 	.word	0x80000006
    39f8:	00002bf1 	.word	0x00002bf1
    39fc:	00000bb7 	.word	0x00000bb7

00003a00 <AJ_GetMinProtoVersion>:
//----------------------------------------------------------------------------------------------------
static void AddRoutingNodeToBlacklist(AJ_Service* service);
//----------------------------------------------------------------------------------------------------
uint8_t AJ_GetMinProtoVersion()
{
    return minProtoVersion;
    3a00:	4b01      	ldr	r3, [pc, #4]	; (3a08 <AJ_GetMinProtoVersion+0x8>)
    3a02:	7818      	ldrb	r0, [r3, #0]
}
    3a04:	4770      	bx	lr
    3a06:	46c0      	nop			; (mov r8, r8)
    3a08:	20000121 	.word	0x20000121

00003a0c <SetBusAuthPwdCallback>:
{
    /*
     * This functionality is no longer provided but the function is still defined for backwards
     * compatibility.
     */
}
    3a0c:	4770      	bx	lr
    3a0e:	46c0      	nop			; (mov r8, r8)

00003a10 <AJ_GetRoutingProtoVersion>:
    return txBuf->send(txBuf);
}

uint8_t AJ_GetRoutingProtoVersion(void)
{
    return routingProtoVersion;
    3a10:	4b01      	ldr	r3, [pc, #4]	; (3a18 <AJ_GetRoutingProtoVersion+0x8>)
    3a12:	7818      	ldrb	r0, [r3, #0]
}
    3a14:	4770      	bx	lr
    3a16:	46c0      	nop			; (mov r8, r8)
    3a18:	200006cc 	.word	0x200006cc

00003a1c <AJ_Authenticate>:

    return status;
}

AJ_Status AJ_Authenticate(AJ_BusAttachment* bus)
{
    3a1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a1e:	b0a9      	sub	sp, #164	; 0xa4
    3a20:	1c04      	adds	r4, r0, #0
    AJ_Status status = AJ_OK;
    AJ_Message helloResponse;

    if (bus->isAuthenticated)
    3a22:	2354      	movs	r3, #84	; 0x54
    3a24:	5cc3      	ldrb	r3, [r0, r3]
	{
        // ARDP does not do SASL and it sends BusHello as part of the SYN message.
        // Therefore, Hello has already been sent by the time AJ_Net_Connect() returns,
        // *before* AJ_Authenticate is called.
        return AJ_OK;
    3a26:	2000      	movs	r0, #0
AJ_Status AJ_Authenticate(AJ_BusAttachment* bus)
{
    AJ_Status status = AJ_OK;
    AJ_Message helloResponse;

    if (bus->isAuthenticated)
    3a28:	2b00      	cmp	r3, #0
    3a2a:	d000      	beq.n	3a2e <AJ_Authenticate+0x12>
    3a2c:	e0ca      	b.n	3bc4 <AJ_Authenticate+0x1a8>
        // *before* AJ_Authenticate is called.
        return AJ_OK;
    }

    // Send initial NUL byte
    bus->sock.tx.writePtr[0] = 0;
    3a2e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    3a30:	7013      	strb	r3, [r2, #0]
    bus->sock.tx.writePtr += 1;
    3a32:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3a34:	3301      	adds	r3, #1
    3a36:	6263      	str	r3, [r4, #36]	; 0x24
    status = bus->sock.tx.send(&bus->sock.tx);
    3a38:	1c25      	adds	r5, r4, #0
    3a3a:	3518      	adds	r5, #24
    3a3c:	1c28      	adds	r0, r5, #0
    3a3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    3a40:	4798      	blx	r3
    if (status != AJ_OK) 
    3a42:	2800      	cmp	r0, #0
    3a44:	d000      	beq.n	3a48 <AJ_Authenticate+0x2c>
    3a46:	e0bd      	b.n	3bc4 <AJ_Authenticate+0x1a8>
        goto ExitConnect;
    }

    /* Use SASL Anonymous to connect to routing node */
	//- , - ,   
    status = AnonymousAuthAdvance(&bus->sock.rx, &bus->sock.tx);
    3a48:	1c26      	adds	r6, r4, #0
    3a4a:	3630      	adds	r6, #48	; 0x30
    AJ_Status status = AJ_OK;
    AJ_GUID localGuid;
    char buf[40];
    uint32_t ret;
    //initiate the SASL exchange with AUTH ANONYMOUS 
    status = WriteLine(txBuf, "AUTH ANONYMOUS\n");
    3a4c:	1c28      	adds	r0, r5, #0
    3a4e:	495e      	ldr	r1, [pc, #376]	; (3bc8 <AJ_Authenticate+0x1ac>)
    3a50:	4b5e      	ldr	r3, [pc, #376]	; (3bcc <AJ_Authenticate+0x1b0>)
    3a52:	4798      	blx	r3
 //   ResetRead(rxBuf);

    if (status == AJ_OK) 
    3a54:	2800      	cmp	r0, #0
    3a56:	d113      	bne.n	3a80 <AJ_Authenticate+0x64>
{
    // All the authentication messages end in a CR/LF so read until we get a newline
    AJ_Status status = AJ_OK;
  //  while ((AJ_IO_BUF_AVAIL(rxBuf) == 0) || (*(rxBuf->writePtr - 1) != '\n')) 
//	{
        status = rxBuf->recv(rxBuf, AJ_IO_BUF_SPACE(rxBuf), 3500);
    3a58:	8e61      	ldrh	r1, [r4, #50]	; 0x32
    3a5a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    3a5c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    3a5e:	1a9b      	subs	r3, r3, r2
    3a60:	18c9      	adds	r1, r1, r3
    3a62:	1c30      	adds	r0, r6, #0
    3a64:	4a5a      	ldr	r2, [pc, #360]	; (3bd0 <AJ_Authenticate+0x1b4>)
    3a66:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3a68:	4798      	blx	r3

    if (status == AJ_OK) 
	{
        // expect server to send back OK GUID 
        status = ReadLine(rxBuf);
        if (status == AJ_OK) 
    3a6a:	2800      	cmp	r0, #0
    3a6c:	d108      	bne.n	3a80 <AJ_Authenticate+0x64>
		{
            if (memcmp(rxBuf->readPtr, "OK", 2) != 0)
    3a6e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    3a70:	4958      	ldr	r1, [pc, #352]	; (3bd4 <AJ_Authenticate+0x1b8>)
    3a72:	2202      	movs	r2, #2
    3a74:	4b58      	ldr	r3, [pc, #352]	; (3bd8 <AJ_Authenticate+0x1bc>)
    3a76:	4798      	blx	r3
			{
                return AJ_ERR_ACCESS_ROUTING_NODE;
    3a78:	2322      	movs	r3, #34	; 0x22
	{
        // expect server to send back OK GUID 
        status = ReadLine(rxBuf);
        if (status == AJ_OK) 
		{
            if (memcmp(rxBuf->readPtr, "OK", 2) != 0)
    3a7a:	2800      	cmp	r0, #0
    3a7c:	d138      	bne.n	3af0 <AJ_Authenticate+0xd4>
    3a7e:	e079      	b.n	3b74 <AJ_Authenticate+0x158>
	{
        status = WriteLine(txBuf, "INFORM_PROTO_VERSION 10\n");
 //       ResetRead(rxBuf);
    }

    if (status == AJ_OK) 
    3a80:	2800      	cmp	r0, #0
    3a82:	d120      	bne.n	3ac6 <AJ_Authenticate+0xaa>
{
    // All the authentication messages end in a CR/LF so read until we get a newline
    AJ_Status status = AJ_OK;
  //  while ((AJ_IO_BUF_AVAIL(rxBuf) == 0) || (*(rxBuf->writePtr - 1) != '\n')) 
//	{
        status = rxBuf->recv(rxBuf, AJ_IO_BUF_SPACE(rxBuf), 3500);
    3a84:	8e61      	ldrh	r1, [r4, #50]	; 0x32
    3a86:	6b63      	ldr	r3, [r4, #52]	; 0x34
    3a88:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    3a8a:	1a9b      	subs	r3, r3, r2
    3a8c:	18c9      	adds	r1, r1, r3
    3a8e:	1c30      	adds	r0, r6, #0
    3a90:	4a4f      	ldr	r2, [pc, #316]	; (3bd0 <AJ_Authenticate+0x1b4>)
    3a92:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3a94:	4798      	blx	r3

    if (status == AJ_OK) 
	{
        // expect server to send back INFORM_PROTO_VERSION version# 
        status = ReadLine(rxBuf);
        if (status == AJ_OK)
    3a96:	2800      	cmp	r0, #0
    3a98:	d115      	bne.n	3ac6 <AJ_Authenticate+0xaa>
		{
            if (memcmp(rxBuf->readPtr, "INFORM_PROTO_VERSION", strlen("INFORM_PROTO_VERSION")) != 0) 
    3a9a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
    3a9c:	1c30      	adds	r0, r6, #0
    3a9e:	494f      	ldr	r1, [pc, #316]	; (3bdc <AJ_Authenticate+0x1c0>)
    3aa0:	2214      	movs	r2, #20
    3aa2:	4b4d      	ldr	r3, [pc, #308]	; (3bd8 <AJ_Authenticate+0x1bc>)
    3aa4:	4798      	blx	r3
			{
                return AJ_ERR_ACCESS_ROUTING_NODE;
    3aa6:	2322      	movs	r3, #34	; 0x22
	{
        // expect server to send back INFORM_PROTO_VERSION version# 
        status = ReadLine(rxBuf);
        if (status == AJ_OK)
		{
            if (memcmp(rxBuf->readPtr, "INFORM_PROTO_VERSION", strlen("INFORM_PROTO_VERSION")) != 0) 
    3aa8:	2800      	cmp	r0, #0
    3aaa:	d121      	bne.n	3af0 <AJ_Authenticate+0xd4>
			{
                return AJ_ERR_ACCESS_ROUTING_NODE;
            }
            routingProtoVersion = atoi((const char*)(rxBuf->readPtr + strlen("INFORM_PROTO_VERSION") + 1));
    3aac:	1c30      	adds	r0, r6, #0
    3aae:	3015      	adds	r0, #21
    3ab0:	4b4b      	ldr	r3, [pc, #300]	; (3be0 <AJ_Authenticate+0x1c4>)
    3ab2:	4798      	blx	r3
    3ab4:	b2c0      	uxtb	r0, r0
    3ab6:	4b4b      	ldr	r3, [pc, #300]	; (3be4 <AJ_Authenticate+0x1c8>)
    3ab8:	7018      	strb	r0, [r3, #0]
//----------------------------------------------------------------------------------------------------
static void AddRoutingNodeToBlacklist(AJ_Service* service);
//----------------------------------------------------------------------------------------------------
uint8_t AJ_GetMinProtoVersion()
{
    return minProtoVersion;
    3aba:	4b4b      	ldr	r3, [pc, #300]	; (3be8 <AJ_Authenticate+0x1cc>)
            if (memcmp(rxBuf->readPtr, "INFORM_PROTO_VERSION", strlen("INFORM_PROTO_VERSION")) != 0) 
			{
                return AJ_ERR_ACCESS_ROUTING_NODE;
            }
            routingProtoVersion = atoi((const char*)(rxBuf->readPtr + strlen("INFORM_PROTO_VERSION") + 1));
            if (routingProtoVersion < AJ_GetMinProtoVersion()) 
    3abc:	781a      	ldrb	r2, [r3, #0]
			{
                AJ_InfoPrintf(("ERR_OLD_VERSION: Found version %u but minimum %u required", routingProtoVersion, AJ_GetMinProtoVersion()));
                return AJ_ERR_OLD_VERSION;
    3abe:	2327      	movs	r3, #39	; 0x27
            if (memcmp(rxBuf->readPtr, "INFORM_PROTO_VERSION", strlen("INFORM_PROTO_VERSION")) != 0) 
			{
                return AJ_ERR_ACCESS_ROUTING_NODE;
            }
            routingProtoVersion = atoi((const char*)(rxBuf->readPtr + strlen("INFORM_PROTO_VERSION") + 1));
            if (routingProtoVersion < AJ_GetMinProtoVersion()) 
    3ac0:	4282      	cmp	r2, r0
    3ac2:	d815      	bhi.n	3af0 <AJ_Authenticate+0xd4>
    3ac4:	e05b      	b.n	3b7e <AJ_Authenticate+0x162>
    }

    /* Use SASL Anonymous to connect to routing node */
	//- , - ,   
    status = AnonymousAuthAdvance(&bus->sock.rx, &bus->sock.tx);
    if (status == AJ_OK) 
    3ac6:	2800      	cmp	r0, #0
    3ac8:	d000      	beq.n	3acc <AJ_Authenticate+0xb0>
    3aca:	e07b      	b.n	3bc4 <AJ_Authenticate+0x1a8>
    AJ_Status status;
    AJ_Message msg;

    AJ_InfoPrintf(("SendHello(bus=0x%p)\n", bus));

    status = AJ_MarshalMethodCall(bus, &msg, AJ_METHOD_HELLO, AJ_DBusDestination, 0, AJ_FLAG_ALLOW_REMOTE_MSG, 5000);
    3acc:	2300      	movs	r3, #0
    3ace:	9300      	str	r3, [sp, #0]
    3ad0:	3304      	adds	r3, #4
    3ad2:	9301      	str	r3, [sp, #4]
    3ad4:	4b45      	ldr	r3, [pc, #276]	; (3bec <AJ_Authenticate+0x1d0>)
    3ad6:	9302      	str	r3, [sp, #8]
    3ad8:	1c20      	adds	r0, r4, #0
    3ada:	a908      	add	r1, sp, #32
    3adc:	2200      	movs	r2, #0
    3ade:	4b44      	ldr	r3, [pc, #272]	; (3bf0 <AJ_Authenticate+0x1d4>)
    3ae0:	4d44      	ldr	r5, [pc, #272]	; (3bf4 <AJ_Authenticate+0x1d8>)
    3ae2:	47a8      	blx	r5
    3ae4:	1e03      	subs	r3, r0, #0
    if (status == AJ_OK) 
    3ae6:	d103      	bne.n	3af0 <AJ_Authenticate+0xd4>
	{
        status = AJ_DeliverMsg(&msg);
    3ae8:	a808      	add	r0, sp, #32
    3aea:	4b43      	ldr	r3, [pc, #268]	; (3bf8 <AJ_Authenticate+0x1dc>)
    3aec:	4798      	blx	r3
    3aee:	1c03      	adds	r3, r0, #0
    3af0:	1e18      	subs	r0, r3, #0
    if (status == AJ_OK) 
	{
        status = SendHello(bus);
    }

    if (status == AJ_OK)
    3af2:	d167      	bne.n	3bc4 <AJ_Authenticate+0x1a8>
	{
        status = AJ_UnmarshalMsg(bus, &helloResponse, 5000);
    3af4:	1c20      	adds	r0, r4, #0
    3af6:	a918      	add	r1, sp, #96	; 0x60
    3af8:	4a3c      	ldr	r2, [pc, #240]	; (3bec <AJ_Authenticate+0x1d0>)
    3afa:	4b40      	ldr	r3, [pc, #256]	; (3bfc <AJ_Authenticate+0x1e0>)
    3afc:	4798      	blx	r3
    }

    if (status == AJ_OK) 
    3afe:	2800      	cmp	r0, #0
    3b00:	d160      	bne.n	3bc4 <AJ_Authenticate+0x1a8>
	{
        if (helloResponse.hdr->msgType == AJ_MSG_ERROR) 
    3b02:	9b19      	ldr	r3, [sp, #100]	; 0x64
    3b04:	785b      	ldrb	r3, [r3, #1]
    3b06:	2b03      	cmp	r3, #3
    3b08:	d10c      	bne.n	3b24 <AJ_Authenticate+0x108>
		{
            AJ_ErrPrintf(("AJ_Authenticate(): AJ_ERR_TIMEOUT\n"));
    3b0a:	3001      	adds	r0, #1
    3b0c:	493c      	ldr	r1, [pc, #240]	; (3c00 <AJ_Authenticate+0x1e4>)
    3b0e:	223e      	movs	r2, #62	; 0x3e
    3b10:	32ff      	adds	r2, #255	; 0xff
    3b12:	4b3c      	ldr	r3, [pc, #240]	; (3c04 <AJ_Authenticate+0x1e8>)
    3b14:	4798      	blx	r3
            status = AJ_ERR_TIMEOUT;
    3b16:	2507      	movs	r5, #7

    if (status == AJ_OK) 
	{
        if (helloResponse.hdr->msgType == AJ_MSG_ERROR) 
		{
            AJ_ErrPrintf(("AJ_Authenticate(): AJ_ERR_TIMEOUT\n"));
    3b18:	2800      	cmp	r0, #0
    3b1a:	d022      	beq.n	3b62 <AJ_Authenticate+0x146>
    3b1c:	483a      	ldr	r0, [pc, #232]	; (3c08 <AJ_Authenticate+0x1ec>)
    3b1e:	4b3b      	ldr	r3, [pc, #236]	; (3c0c <AJ_Authenticate+0x1f0>)
    3b20:	4798      	blx	r3
    3b22:	e01e      	b.n	3b62 <AJ_Authenticate+0x146>
            status = AJ_ERR_TIMEOUT;
        } 
		else 
		{
            AJ_Arg arg;
            status = AJ_UnmarshalArg(&helloResponse, &arg);
    3b24:	a818      	add	r0, sp, #96	; 0x60
    3b26:	a908      	add	r1, sp, #32
    3b28:	4b39      	ldr	r3, [pc, #228]	; (3c10 <AJ_Authenticate+0x1f4>)
    3b2a:	4798      	blx	r3
    3b2c:	1e05      	subs	r5, r0, #0
            if (status == AJ_OK)
    3b2e:	d118      	bne.n	3b62 <AJ_Authenticate+0x146>
			{
                if (arg.len >= (sizeof(bus->uniqueName) - 1)) 
    3b30:	ab08      	add	r3, sp, #32
    3b32:	885e      	ldrh	r6, [r3, #2]
    3b34:	2e13      	cmp	r6, #19
    3b36:	d90c      	bls.n	3b52 <AJ_Authenticate+0x136>
				{
                    AJ_ErrPrintf(("AJ_Authenticate(): AJ_ERR_RESOURCES\n"));
    3b38:	2001      	movs	r0, #1
    3b3a:	4931      	ldr	r1, [pc, #196]	; (3c00 <AJ_Authenticate+0x1e4>)
    3b3c:	22a4      	movs	r2, #164	; 0xa4
    3b3e:	0052      	lsls	r2, r2, #1
    3b40:	4b30      	ldr	r3, [pc, #192]	; (3c04 <AJ_Authenticate+0x1e8>)
    3b42:	4798      	blx	r3
                    status = AJ_ERR_RESOURCES;
    3b44:	350b      	adds	r5, #11
            status = AJ_UnmarshalArg(&helloResponse, &arg);
            if (status == AJ_OK)
			{
                if (arg.len >= (sizeof(bus->uniqueName) - 1)) 
				{
                    AJ_ErrPrintf(("AJ_Authenticate(): AJ_ERR_RESOURCES\n"));
    3b46:	2800      	cmp	r0, #0
    3b48:	d00b      	beq.n	3b62 <AJ_Authenticate+0x146>
    3b4a:	4832      	ldr	r0, [pc, #200]	; (3c14 <AJ_Authenticate+0x1f8>)
    3b4c:	4b2f      	ldr	r3, [pc, #188]	; (3c0c <AJ_Authenticate+0x1f0>)
    3b4e:	4798      	blx	r3
    3b50:	e007      	b.n	3b62 <AJ_Authenticate+0x146>
                    status = AJ_ERR_RESOURCES;
                } 
				else 
				{
                    memcpy(bus->uniqueName, arg.val.v_string, arg.len);
    3b52:	1ca0      	adds	r0, r4, #2
    3b54:	9909      	ldr	r1, [sp, #36]	; 0x24
    3b56:	1c32      	adds	r2, r6, #0
    3b58:	4b2f      	ldr	r3, [pc, #188]	; (3c18 <AJ_Authenticate+0x1fc>)
    3b5a:	4798      	blx	r3
                    bus->uniqueName[arg.len] = '\0';
    3b5c:	19a6      	adds	r6, r4, r6
    3b5e:	2300      	movs	r3, #0
    3b60:	70b3      	strb	r3, [r6, #2]
                }
            }
        }
        AJ_CloseMsg(&helloResponse);
    3b62:	a818      	add	r0, sp, #96	; 0x60
    3b64:	4b2d      	ldr	r3, [pc, #180]	; (3c1c <AJ_Authenticate+0x200>)
    3b66:	4798      	blx	r3
    3b68:	1e28      	subs	r0, r5, #0
    }

ExitConnect:

    if (status == AJ_OK) 
    3b6a:	d12b      	bne.n	3bc4 <AJ_Authenticate+0x1a8>
	{
        bus->isAuthenticated = TRUE;
    3b6c:	2201      	movs	r2, #1
    3b6e:	2354      	movs	r3, #84	; 0x54
    3b70:	54e2      	strb	r2, [r4, r3]
    3b72:	e027      	b.n	3bc4 <AJ_Authenticate+0x1a8>
        }
    }

    if (status == AJ_OK) 
	{
        status = WriteLine(txBuf, "INFORM_PROTO_VERSION 10\n");
    3b74:	1c28      	adds	r0, r5, #0
    3b76:	492a      	ldr	r1, [pc, #168]	; (3c20 <AJ_Authenticate+0x204>)
    3b78:	4b14      	ldr	r3, [pc, #80]	; (3bcc <AJ_Authenticate+0x1b0>)
    3b7a:	4798      	blx	r3
    3b7c:	e780      	b.n	3a80 <AJ_Authenticate+0x64>
    }

    if (status == AJ_OK)
	 {
        //send BEGIN LocalGUID to server 
        AJ_GetLocalGUID(&localGuid);
    3b7e:	a804      	add	r0, sp, #16
    3b80:	4b28      	ldr	r3, [pc, #160]	; (3c24 <AJ_Authenticate+0x208>)
    3b82:	4798      	blx	r3
        strcpy(buf, "BEGIN ");
    3b84:	ae08      	add	r6, sp, #32
    3b86:	4b28      	ldr	r3, [pc, #160]	; (3c28 <AJ_Authenticate+0x20c>)
    3b88:	681a      	ldr	r2, [r3, #0]
    3b8a:	9208      	str	r2, [sp, #32]
    3b8c:	889a      	ldrh	r2, [r3, #4]
    3b8e:	80b2      	strh	r2, [r6, #4]
    3b90:	799b      	ldrb	r3, [r3, #6]
    3b92:	71b3      	strb	r3, [r6, #6]
        status = AJ_GUID_ToString(&localGuid, buf + strlen(buf), 33);
    3b94:	1c30      	adds	r0, r6, #0
    3b96:	4f25      	ldr	r7, [pc, #148]	; (3c2c <AJ_Authenticate+0x210>)
    3b98:	47b8      	blx	r7
    3b9a:	1831      	adds	r1, r6, r0
    3b9c:	a804      	add	r0, sp, #16
    3b9e:	2221      	movs	r2, #33	; 0x21
    3ba0:	4b23      	ldr	r3, [pc, #140]	; (3c30 <AJ_Authenticate+0x214>)
    3ba2:	4798      	blx	r3
        strcat(buf, "\n");
    3ba4:	1c30      	adds	r0, r6, #0
    3ba6:	47b8      	blx	r7
    3ba8:	1830      	adds	r0, r6, r0
    3baa:	4922      	ldr	r1, [pc, #136]	; (3c34 <AJ_Authenticate+0x218>)
    3bac:	2202      	movs	r2, #2
    3bae:	4b1a      	ldr	r3, [pc, #104]	; (3c18 <AJ_Authenticate+0x1fc>)
    3bb0:	4798      	blx	r3
        status = WriteLine(txBuf, buf);
    3bb2:	1c28      	adds	r0, r5, #0
    3bb4:	1c31      	adds	r1, r6, #0
    3bb6:	4b05      	ldr	r3, [pc, #20]	; (3bcc <AJ_Authenticate+0x1b0>)
    3bb8:	4798      	blx	r3
    return status;
}

static void ResetRead(AJ_IOBuffer* rxBuf) 
{
    rxBuf->readPtr += AJ_IO_BUF_AVAIL(rxBuf);
    3bba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3bbc:	63a3      	str	r3, [r4, #56]	; 0x38
    *rxBuf->writePtr = '\0';
    3bbe:	2200      	movs	r2, #0
    3bc0:	701a      	strb	r2, [r3, #0]
    3bc2:	e780      	b.n	3ac6 <AJ_Authenticate+0xaa>
    if (status == AJ_OK) 
	{
        bus->isAuthenticated = TRUE;
    }
    return status;
}
    3bc4:	b029      	add	sp, #164	; 0xa4
    3bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3bc8:	0001b2dc 	.word	0x0001b2dc
    3bcc:	00003931 	.word	0x00003931
    3bd0:	00000dac 	.word	0x00000dac
    3bd4:	0001b2ec 	.word	0x0001b2ec
    3bd8:	0001671b 	.word	0x0001671b
    3bdc:	0001b2f0 	.word	0x0001b2f0
    3be0:	00016665 	.word	0x00016665
    3be4:	200006cc 	.word	0x200006cc
    3be8:	20000121 	.word	0x20000121
    3bec:	00001388 	.word	0x00001388
    3bf0:	0001e7b8 	.word	0x0001e7b8
    3bf4:	0000bca5 	.word	0x0000bca5
    3bf8:	0000a539 	.word	0x0000a539
    3bfc:	0000acb5 	.word	0x0000acb5
    3c00:	0001b308 	.word	0x0001b308
    3c04:	0000636d 	.word	0x0000636d
    3c08:	0001b334 	.word	0x0001b334
    3c0c:	00016f5d 	.word	0x00016f5d
    3c10:	0000a855 	.word	0x0000a855
    3c14:	0001b358 	.word	0x0001b358
    3c18:	00016739 	.word	0x00016739
    3c1c:	0000a77d 	.word	0x0000a77d
    3c20:	0001b37c 	.word	0x0001b37c
    3c24:	00004431 	.word	0x00004431
    3c28:	0001b398 	.word	0x0001b398
    3c2c:	0001715b 	.word	0x0001715b
    3c30:	00007a7d 	.word	0x00007a7d
    3c34:	000214dc 	.word	0x000214dc

00003c38 <AJ_Disconnect>:
}

#endif // AJ_ARDP

void AJ_Disconnect(AJ_BusAttachment* bus)
{
    3c38:	b510      	push	{r4, lr}
    3c3a:	1c04      	adds	r4, r0, #0
    // We won't be getting any more method replies.
    AJ_ReleaseReplyContexts();
    3c3c:	4b05      	ldr	r3, [pc, #20]	; (3c54 <AJ_Disconnect+0x1c>)
    3c3e:	4798      	blx	r3
    // Disconnect the network closing sockets etc.
    AJ_Net_Disconnect(&bus->sock);
    3c40:	1c20      	adds	r0, r4, #0
    3c42:	3018      	adds	r0, #24
    3c44:	4b04      	ldr	r3, [pc, #16]	; (3c58 <AJ_Disconnect+0x20>)
    3c46:	4798      	blx	r3

    // Clear auth context
    AJ_ClearAuthContext();
    3c48:	4b04      	ldr	r3, [pc, #16]	; (3c5c <AJ_Disconnect+0x24>)
    3c4a:	4798      	blx	r3

    // Set the routing nodes proto version to zero (not connected)
    routingProtoVersion = 0;
    3c4c:	2200      	movs	r2, #0
    3c4e:	4b04      	ldr	r3, [pc, #16]	; (3c60 <AJ_Disconnect+0x28>)
    3c50:	701a      	strb	r2, [r3, #0]
}
    3c52:	bd10      	pop	{r4, pc}
    3c54:	00008a95 	.word	0x00008a95
    3c58:	0000c2c9 	.word	0x0000c2c9
    3c5c:	0000c549 	.word	0x0000c549
    3c60:	200006cc 	.word	0x200006cc

00003c64 <AJ_IsRoutingNodeBlacklisted>:

uint8_t AJ_IsRoutingNodeBlacklisted(AJ_Service* service)
{
    3c64:	b570      	push	{r4, r5, r6, lr}
    uint8_t i = 0;
    for (; i < AJ_ROUTING_NODE_BLACKLIST_SIZE; ++i)
	{
        if (RoutingNodeIPBlacklist[i])
    3c66:	4b0f      	ldr	r3, [pc, #60]	; (3ca4 <AJ_IsRoutingNodeBlacklisted+0x40>)
    3c68:	681a      	ldr	r2, [r3, #0]
    3c6a:	2a00      	cmp	r2, #0
    3c6c:	d013      	beq.n	3c96 <AJ_IsRoutingNodeBlacklisted+0x32>
		{
            if ((RoutingNodeIPBlacklist[i] == service->ipv4) && (RoutingNodePortBlacklist[i] == service->ipv4port)) 
    3c6e:	6884      	ldr	r4, [r0, #8]
    3c70:	490d      	ldr	r1, [pc, #52]	; (3ca8 <AJ_IsRoutingNodeBlacklisted+0x44>)
    3c72:	1c1d      	adds	r5, r3, #0
    3c74:	353c      	adds	r5, #60	; 0x3c
    3c76:	e004      	b.n	3c82 <AJ_IsRoutingNodeBlacklisted+0x1e>
uint8_t AJ_IsRoutingNodeBlacklisted(AJ_Service* service)
{
    uint8_t i = 0;
    for (; i < AJ_ROUTING_NODE_BLACKLIST_SIZE; ++i)
	{
        if (RoutingNodeIPBlacklist[i])
    3c78:	685a      	ldr	r2, [r3, #4]
    3c7a:	3304      	adds	r3, #4
    3c7c:	3102      	adds	r1, #2
    3c7e:	2a00      	cmp	r2, #0
    3c80:	d00b      	beq.n	3c9a <AJ_IsRoutingNodeBlacklisted+0x36>
		{
            if ((RoutingNodeIPBlacklist[i] == service->ipv4) && (RoutingNodePortBlacklist[i] == service->ipv4port)) 
    3c82:	42a2      	cmp	r2, r4
    3c84:	d103      	bne.n	3c8e <AJ_IsRoutingNodeBlacklisted+0x2a>
    3c86:	880e      	ldrh	r6, [r1, #0]
    3c88:	8882      	ldrh	r2, [r0, #4]
    3c8a:	4296      	cmp	r6, r2
    3c8c:	d007      	beq.n	3c9e <AJ_IsRoutingNodeBlacklisted+0x3a>
}

uint8_t AJ_IsRoutingNodeBlacklisted(AJ_Service* service)
{
    uint8_t i = 0;
    for (; i < AJ_ROUTING_NODE_BLACKLIST_SIZE; ++i)
    3c8e:	42ab      	cmp	r3, r5
    3c90:	d1f2      	bne.n	3c78 <AJ_IsRoutingNodeBlacklisted+0x14>
            // break early if list isn't full
            break;
        }
    }

    return FALSE;
    3c92:	2000      	movs	r0, #0
    3c94:	e004      	b.n	3ca0 <AJ_IsRoutingNodeBlacklisted+0x3c>
    3c96:	2000      	movs	r0, #0
    3c98:	e002      	b.n	3ca0 <AJ_IsRoutingNodeBlacklisted+0x3c>
    3c9a:	2000      	movs	r0, #0
    3c9c:	e000      	b.n	3ca0 <AJ_IsRoutingNodeBlacklisted+0x3c>
	{
        if (RoutingNodeIPBlacklist[i])
		{
            if ((RoutingNodeIPBlacklist[i] == service->ipv4) && (RoutingNodePortBlacklist[i] == service->ipv4port)) 
			{
                return TRUE;
    3c9e:	2001      	movs	r0, #1
            break;
        }
    }

    return FALSE;
}
    3ca0:	bd70      	pop	{r4, r5, r6, pc}
    3ca2:	46c0      	nop			; (mov r8, r8)
    3ca4:	200005ac 	.word	0x200005ac
    3ca8:	200005f0 	.word	0x200005f0

00003cac <AJ_AddRoutingNodeToResponseList>:

void AJ_AddRoutingNodeToResponseList(AJ_Service* service)
{
    3cac:	b5f0      	push	{r4, r5, r6, r7, lr}
    3cae:	465f      	mov	r7, fp
    3cb0:	4656      	mov	r6, sl
    3cb2:	464d      	mov	r5, r9
    3cb4:	4644      	mov	r4, r8
    3cb6:	b4f0      	push	{r4, r5, r6, r7}
     * in such a situation.
     */
    int i = 0;
    uint8_t replace = 0;
    int RoutingNodeSlot = 0;
    if (RoutingNodeResponselist_idx == AJ_ROUTING_NODE_RESPONSELIST_SIZE) 
    3cb8:	4b6d      	ldr	r3, [pc, #436]	; (3e70 <AJ_AddRoutingNodeToResponseList+0x1c4>)
    3cba:	781c      	ldrb	r4, [r3, #0]
	{
        replace = 0;
        RoutingNodeSlot = 0;
    }
	else 
	   if (RoutingNodeResponselist_idx < AJ_ROUTING_NODE_RESPONSELIST_SIZE)
    3cbc:	2c02      	cmp	r4, #2
    3cbe:	d900      	bls.n	3cc2 <AJ_AddRoutingNodeToResponseList+0x16>
    3cc0:	e0ac      	b.n	3e1c <AJ_AddRoutingNodeToResponseList+0x170>
	   {
          replace = 1;
          RoutingNodeSlot = RoutingNodeResponselist_idx;
    3cc2:	1c27      	adds	r7, r4, #0
        RoutingNodeSlot = 0;
    }
	else 
	   if (RoutingNodeResponselist_idx < AJ_ROUTING_NODE_RESPONSELIST_SIZE)
	   {
          replace = 1;
    3cc4:	2301      	movs	r3, #1
    3cc6:	4699      	mov	r9, r3
    3cc8:	e0ab      	b.n	3e22 <AJ_AddRoutingNodeToResponseList+0x176>
    3cca:	4659      	mov	r1, fp
    3ccc:	1a89      	subs	r1, r1, r2
    3cce:	4688      	mov	r8, r1
    3cd0:	1c19      	adds	r1, r3, #0
          RoutingNodeSlot = RoutingNodeResponselist_idx;
       }
    for (i = 0; i  < AJ_ROUTING_NODE_RESPONSELIST_SIZE; ++i) 
	{
        if (RoutingNodeResponselist[i].ipv4 || RoutingNodeResponselist[i].ipv4Udp)
    3cd2:	689d      	ldr	r5, [r3, #8]
    3cd4:	2d00      	cmp	r5, #0
    3cd6:	d104      	bne.n	3ce2 <AJ_AddRoutingNodeToResponseList+0x36>
    3cd8:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    3cda:	2d00      	cmp	r5, #0
    3cdc:	d000      	beq.n	3ce0 <AJ_AddRoutingNodeToResponseList+0x34>
    3cde:	e0be      	b.n	3e5e <AJ_AddRoutingNodeToResponseList+0x1b2>
    3ce0:	e066      	b.n	3db0 <AJ_AddRoutingNodeToResponseList+0x104>
		{
            if ((RoutingNodeResponselist[i].ipv4 && RoutingNodeResponselist[i].ipv4 == service->ipv4 && RoutingNodeResponselist[i].ipv4port == service->ipv4port)
    3ce2:	6886      	ldr	r6, [r0, #8]
    3ce4:	42b5      	cmp	r5, r6
    3ce6:	d104      	bne.n	3cf2 <AJ_AddRoutingNodeToResponseList+0x46>
    3ce8:	889d      	ldrh	r5, [r3, #4]
    3cea:	46aa      	mov	sl, r5
    3cec:	8885      	ldrh	r5, [r0, #4]
    3cee:	45aa      	cmp	sl, r5
    3cf0:	d00a      	beq.n	3d08 <AJ_AddRoutingNodeToResponseList+0x5c>
                || (RoutingNodeResponselist[i].ipv4Udp && RoutingNodeResponselist[i].ipv4Udp == service->ipv4Udp && RoutingNodeResponselist[i].ipv4portUdp == service->ipv4portUdp)) {
    3cf2:	6a8d      	ldr	r5, [r1, #40]	; 0x28
    3cf4:	2d00      	cmp	r5, #0
    3cf6:	d039      	beq.n	3d6c <AJ_AddRoutingNodeToResponseList+0xc0>
    3cf8:	6a86      	ldr	r6, [r0, #40]	; 0x28
    3cfa:	42b5      	cmp	r5, r6
    3cfc:	d136      	bne.n	3d6c <AJ_AddRoutingNodeToResponseList+0xc0>
    3cfe:	8c8d      	ldrh	r5, [r1, #36]	; 0x24
    3d00:	46aa      	mov	sl, r5
    3d02:	8c85      	ldrh	r5, [r0, #36]	; 0x24
    3d04:	45aa      	cmp	sl, r5
    3d06:	d131      	bne.n	3d6c <AJ_AddRoutingNodeToResponseList+0xc0>
                // track only the highest protocol version per service
                if (RoutingNodeResponselist[i].pv < service->pv) 
    3d08:	4643      	mov	r3, r8
    3d0a:	011b      	lsls	r3, r3, #4
    3d0c:	4642      	mov	r2, r8
    3d0e:	1a9b      	subs	r3, r3, r2
    3d10:	009b      	lsls	r3, r3, #2
    3d12:	4a58      	ldr	r2, [pc, #352]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3d14:	18d3      	adds	r3, r2, r3
    3d16:	691a      	ldr	r2, [r3, #16]
    3d18:	6903      	ldr	r3, [r0, #16]
    3d1a:	429a      	cmp	r2, r3
    3d1c:	d20e      	bcs.n	3d3c <AJ_AddRoutingNodeToResponseList+0x90>
				{
                    RoutingNodeResponselist[i].pv = service->pv;
    3d1e:	4c55      	ldr	r4, [pc, #340]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3d20:	4642      	mov	r2, r8
    3d22:	0112      	lsls	r2, r2, #4
    3d24:	4641      	mov	r1, r8
    3d26:	1a51      	subs	r1, r2, r1
    3d28:	0089      	lsls	r1, r1, #2
    3d2a:	1861      	adds	r1, r4, r1
    3d2c:	610b      	str	r3, [r1, #16]
                    RoutingNodeResponselist[i].priority = service->priority;
    3d2e:	8981      	ldrh	r1, [r0, #12]
    3d30:	4643      	mov	r3, r8
    3d32:	1ad2      	subs	r2, r2, r3
    3d34:	0092      	lsls	r2, r2, #2
    3d36:	18a3      	adds	r3, r4, r2
    3d38:	8199      	strh	r1, [r3, #12]
    3d3a:	e092      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
                    AJ_InfoPrintf(("Updated routing node entry to 0x%x (pv = %d, port = %d, priority = %d) to response list with %d response(s) in list\n", service->ipv4, service->pv, service->ipv4port, service->priority, RoutingNodeResponselist_idx));
                }
				else 
				   if (RoutingNodeResponselist[i].pv == service->pv)
    3d3c:	429a      	cmp	r2, r3
    3d3e:	d000      	beq.n	3d42 <AJ_AddRoutingNodeToResponseList+0x96>
    3d40:	e08f      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
				   {
                    // update the priority if necessary
                    if (RoutingNodeResponselist[i].priority != service->priority)
    3d42:	8982      	ldrh	r2, [r0, #12]
    3d44:	4643      	mov	r3, r8
    3d46:	011b      	lsls	r3, r3, #4
    3d48:	4641      	mov	r1, r8
    3d4a:	1a5b      	subs	r3, r3, r1
    3d4c:	009b      	lsls	r3, r3, #2
    3d4e:	4949      	ldr	r1, [pc, #292]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3d50:	18cb      	adds	r3, r1, r3
    3d52:	899b      	ldrh	r3, [r3, #12]
    3d54:	4293      	cmp	r3, r2
    3d56:	d100      	bne.n	3d5a <AJ_AddRoutingNodeToResponseList+0xae>
    3d58:	e083      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
					{
                        RoutingNodeResponselist[i].priority = service->priority;
    3d5a:	4643      	mov	r3, r8
    3d5c:	011b      	lsls	r3, r3, #4
    3d5e:	4641      	mov	r1, r8
    3d60:	1a5b      	subs	r3, r3, r1
    3d62:	009b      	lsls	r3, r3, #2
    3d64:	4943      	ldr	r1, [pc, #268]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3d66:	18cb      	adds	r3, r1, r3
    3d68:	819a      	strh	r2, [r3, #12]
    3d6a:	e07a      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
                return;
            } 
			else
			{
                // if the list is full, find a tentative candidate for eviction, if possible
                if (RoutingNodeResponselist_idx == AJ_ROUTING_NODE_RESPONSELIST_SIZE) 
    3d6c:	2c03      	cmp	r4, #3
    3d6e:	d11b      	bne.n	3da8 <AJ_AddRoutingNodeToResponseList+0xfc>
				{
                    if (RoutingNodeResponselist[i].pv > RoutingNodeResponselist[RoutingNodeSlot].pv) 
    3d70:	690d      	ldr	r5, [r1, #16]
    3d72:	46aa      	mov	sl, r5
    3d74:	013d      	lsls	r5, r7, #4
    3d76:	1bed      	subs	r5, r5, r7
    3d78:	00ad      	lsls	r5, r5, #2
    3d7a:	4e3e      	ldr	r6, [pc, #248]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3d7c:	46b4      	mov	ip, r6
    3d7e:	4465      	add	r5, ip
    3d80:	692d      	ldr	r5, [r5, #16]
    3d82:	45aa      	cmp	sl, r5
    3d84:	d810      	bhi.n	3da8 <AJ_AddRoutingNodeToResponseList+0xfc>
					{
                        continue;
                    } 
					else 
					   if (RoutingNodeResponselist[i].pv < RoutingNodeResponselist[RoutingNodeSlot].pv)
    3d86:	d30c      	bcc.n	3da2 <AJ_AddRoutingNodeToResponseList+0xf6>
					   {
                          RoutingNodeSlot = i;
                          replace = 1;
                       }
					   else 
					      if (RoutingNodeResponselist[i].priority < RoutingNodeResponselist[RoutingNodeSlot].priority)
    3d88:	013d      	lsls	r5, r7, #4
    3d8a:	1bed      	subs	r5, r5, r7
    3d8c:	00ad      	lsls	r5, r5, #2
    3d8e:	4465      	add	r5, ip
						  {
                             continue;
						  }
						  else
						     if (RoutingNodeResponselist[i].priority > RoutingNodeResponselist[RoutingNodeSlot].priority) 
    3d90:	8989      	ldrh	r1, [r1, #12]
    3d92:	468a      	mov	sl, r1
    3d94:	89a9      	ldrh	r1, [r5, #12]
    3d96:	458a      	cmp	sl, r1
    3d98:	d906      	bls.n	3da8 <AJ_AddRoutingNodeToResponseList+0xfc>
    3d9a:	4647      	mov	r7, r8
							 {
                                RoutingNodeSlot = i;
                                replace = 1;
    3d9c:	2101      	movs	r1, #1
    3d9e:	4689      	mov	r9, r1
    3da0:	e002      	b.n	3da8 <AJ_AddRoutingNodeToResponseList+0xfc>
    3da2:	4647      	mov	r7, r8
                    } 
					else 
					   if (RoutingNodeResponselist[i].pv < RoutingNodeResponselist[RoutingNodeSlot].pv)
					   {
                          RoutingNodeSlot = i;
                          replace = 1;
    3da4:	2101      	movs	r1, #1
    3da6:	4689      	mov	r9, r1
    3da8:	3a01      	subs	r2, #1
    3daa:	333c      	adds	r3, #60	; 0x3c
	   if (RoutingNodeResponselist_idx < AJ_ROUTING_NODE_RESPONSELIST_SIZE)
	   {
          replace = 1;
          RoutingNodeSlot = RoutingNodeResponselist_idx;
       }
    for (i = 0; i  < AJ_ROUTING_NODE_RESPONSELIST_SIZE; ++i) 
    3dac:	2a00      	cmp	r2, #0
    3dae:	d18c      	bne.n	3cca <AJ_AddRoutingNodeToResponseList+0x1e>
		{
            // break early if list isn't full
            break;
        }
    }
    if (replace)
    3db0:	464b      	mov	r3, r9
    3db2:	2b00      	cmp	r3, #0
    3db4:	d055      	beq.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
	{
        if (RoutingNodeResponselist_idx == AJ_ROUTING_NODE_RESPONSELIST_SIZE)
    3db6:	2c03      	cmp	r4, #3
    3db8:	d112      	bne.n	3de0 <AJ_AddRoutingNodeToResponseList+0x134>
		{
            // Is current candidate for eviction of a lower ranking ?
            if (service->pv < RoutingNodeResponselist[RoutingNodeSlot].pv) 
    3dba:	6902      	ldr	r2, [r0, #16]
    3dbc:	013b      	lsls	r3, r7, #4
    3dbe:	1bdb      	subs	r3, r3, r7
    3dc0:	009b      	lsls	r3, r3, #2
    3dc2:	492c      	ldr	r1, [pc, #176]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3dc4:	18cb      	adds	r3, r1, r3
    3dc6:	691b      	ldr	r3, [r3, #16]
    3dc8:	429a      	cmp	r2, r3
    3dca:	d34a      	bcc.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
			{
                return;
            }
            if (service->pv == RoutingNodeResponselist[RoutingNodeSlot].pv && service->priority >= RoutingNodeResponselist[RoutingNodeSlot].priority)
    3dcc:	d12e      	bne.n	3e2c <AJ_AddRoutingNodeToResponseList+0x180>
    3dce:	013b      	lsls	r3, r7, #4
    3dd0:	1bdb      	subs	r3, r3, r7
    3dd2:	009b      	lsls	r3, r3, #2
    3dd4:	18cb      	adds	r3, r1, r3
    3dd6:	8982      	ldrh	r2, [r0, #12]
    3dd8:	899b      	ldrh	r3, [r3, #12]
    3dda:	429a      	cmp	r2, r3
    3ddc:	d326      	bcc.n	3e2c <AJ_AddRoutingNodeToResponseList+0x180>
    3dde:	e040      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
			{
                return;
            }
            AJ_InfoPrintf(("Evicting slot number %d\n", RoutingNodeSlot));
        }
        RoutingNodeResponselist[RoutingNodeSlot].ipv4 = service->ipv4;
    3de0:	4924      	ldr	r1, [pc, #144]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3de2:	013b      	lsls	r3, r7, #4
    3de4:	1bda      	subs	r2, r3, r7
    3de6:	0092      	lsls	r2, r2, #2
    3de8:	188a      	adds	r2, r1, r2
    3dea:	6885      	ldr	r5, [r0, #8]
    3dec:	6095      	str	r5, [r2, #8]
        RoutingNodeResponselist[RoutingNodeSlot].ipv4port = service->ipv4port;
    3dee:	8885      	ldrh	r5, [r0, #4]
    3df0:	8095      	strh	r5, [r2, #4]
        RoutingNodeResponselist[RoutingNodeSlot].ipv4Udp = service->ipv4Udp;
    3df2:	6a85      	ldr	r5, [r0, #40]	; 0x28
    3df4:	6295      	str	r5, [r2, #40]	; 0x28
        RoutingNodeResponselist[RoutingNodeSlot].ipv4portUdp = service->ipv4portUdp;
    3df6:	8c85      	ldrh	r5, [r0, #36]	; 0x24
    3df8:	8495      	strh	r5, [r2, #36]	; 0x24
        RoutingNodeResponselist[RoutingNodeSlot].addrTypes = service->addrTypes;
    3dfa:	7806      	ldrb	r6, [r0, #0]
    3dfc:	1bdd      	subs	r5, r3, r7
    3dfe:	00ad      	lsls	r5, r5, #2
    3e00:	546e      	strb	r6, [r5, r1]
        RoutingNodeResponselist[RoutingNodeSlot].pv = service->pv;
    3e02:	6905      	ldr	r5, [r0, #16]
    3e04:	6115      	str	r5, [r2, #16]
        RoutingNodeResponselist[RoutingNodeSlot].priority = service->priority;
    3e06:	8982      	ldrh	r2, [r0, #12]
    3e08:	1bdf      	subs	r7, r3, r7
    3e0a:	00bf      	lsls	r7, r7, #2
    3e0c:	19cf      	adds	r7, r1, r7
    3e0e:	81ba      	strh	r2, [r7, #12]
        if (RoutingNodeResponselist_idx < AJ_ROUTING_NODE_RESPONSELIST_SIZE)
    3e10:	2c02      	cmp	r4, #2
    3e12:	d826      	bhi.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
		{
            RoutingNodeResponselist_idx++;
    3e14:	3401      	adds	r4, #1
    3e16:	4b16      	ldr	r3, [pc, #88]	; (3e70 <AJ_AddRoutingNodeToResponseList+0x1c4>)
    3e18:	701c      	strb	r4, [r3, #0]
    3e1a:	e022      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
     * to randomly select which responses will get added to the list
     * in such a situation.
     */
    int i = 0;
    uint8_t replace = 0;
    int RoutingNodeSlot = 0;
    3e1c:	2700      	movs	r7, #0
     * allowing some responses to be considered. An alternative is
     * to randomly select which responses will get added to the list
     * in such a situation.
     */
    int i = 0;
    uint8_t replace = 0;
    3e1e:	2300      	movs	r3, #0
    3e20:	4699      	mov	r9, r3
    3e22:	4b14      	ldr	r3, [pc, #80]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)

    return FALSE;
}

void AJ_AddRoutingNodeToResponseList(AJ_Service* service)
{
    3e24:	2203      	movs	r2, #3
    3e26:	2103      	movs	r1, #3
    3e28:	468b      	mov	fp, r1
    3e2a:	e74e      	b.n	3cca <AJ_AddRoutingNodeToResponseList+0x1e>
			{
                return;
            }
            AJ_InfoPrintf(("Evicting slot number %d\n", RoutingNodeSlot));
        }
        RoutingNodeResponselist[RoutingNodeSlot].ipv4 = service->ipv4;
    3e2c:	4911      	ldr	r1, [pc, #68]	; (3e74 <AJ_AddRoutingNodeToResponseList+0x1c8>)
    3e2e:	013b      	lsls	r3, r7, #4
    3e30:	1bda      	subs	r2, r3, r7
    3e32:	0092      	lsls	r2, r2, #2
    3e34:	188a      	adds	r2, r1, r2
    3e36:	6884      	ldr	r4, [r0, #8]
    3e38:	6094      	str	r4, [r2, #8]
        RoutingNodeResponselist[RoutingNodeSlot].ipv4port = service->ipv4port;
    3e3a:	8884      	ldrh	r4, [r0, #4]
    3e3c:	8094      	strh	r4, [r2, #4]
        RoutingNodeResponselist[RoutingNodeSlot].ipv4Udp = service->ipv4Udp;
    3e3e:	6a84      	ldr	r4, [r0, #40]	; 0x28
    3e40:	6294      	str	r4, [r2, #40]	; 0x28
        RoutingNodeResponselist[RoutingNodeSlot].ipv4portUdp = service->ipv4portUdp;
    3e42:	8c84      	ldrh	r4, [r0, #36]	; 0x24
    3e44:	8494      	strh	r4, [r2, #36]	; 0x24
        RoutingNodeResponselist[RoutingNodeSlot].addrTypes = service->addrTypes;
    3e46:	7805      	ldrb	r5, [r0, #0]
    3e48:	1bdc      	subs	r4, r3, r7
    3e4a:	00a4      	lsls	r4, r4, #2
    3e4c:	5465      	strb	r5, [r4, r1]
        RoutingNodeResponselist[RoutingNodeSlot].pv = service->pv;
    3e4e:	6904      	ldr	r4, [r0, #16]
    3e50:	6114      	str	r4, [r2, #16]
        RoutingNodeResponselist[RoutingNodeSlot].priority = service->priority;
    3e52:	8982      	ldrh	r2, [r0, #12]
    3e54:	1bdb      	subs	r3, r3, r7
    3e56:	009f      	lsls	r7, r3, #2
    3e58:	19cb      	adds	r3, r1, r7
    3e5a:	819a      	strh	r2, [r3, #12]
    3e5c:	e001      	b.n	3e62 <AJ_AddRoutingNodeToResponseList+0x1b6>
    for (i = 0; i  < AJ_ROUTING_NODE_RESPONSELIST_SIZE; ++i) 
	{
        if (RoutingNodeResponselist[i].ipv4 || RoutingNodeResponselist[i].ipv4Udp)
		{
            if ((RoutingNodeResponselist[i].ipv4 && RoutingNodeResponselist[i].ipv4 == service->ipv4 && RoutingNodeResponselist[i].ipv4port == service->ipv4port)
                || (RoutingNodeResponselist[i].ipv4Udp && RoutingNodeResponselist[i].ipv4Udp == service->ipv4Udp && RoutingNodeResponselist[i].ipv4portUdp == service->ipv4portUdp)) {
    3e5e:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    3e60:	e74a      	b.n	3cf8 <AJ_AddRoutingNodeToResponseList+0x4c>
		{
            RoutingNodeResponselist_idx++;
        }
        AJ_InfoPrintf(("Added routing node 0x%x (pv = %d, port = %d, priority = %d) to response list with %d response(s) in list\n", service->ipv4, service->pv, service->ipv4port, service->priority, RoutingNodeResponselist_idx));
    }
}
    3e62:	bc3c      	pop	{r2, r3, r4, r5}
    3e64:	4690      	mov	r8, r2
    3e66:	4699      	mov	r9, r3
    3e68:	46a2      	mov	sl, r4
    3e6a:	46ab      	mov	fp, r5
    3e6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3e6e:	46c0      	nop			; (mov r8, r8)
    3e70:	200006cd 	.word	0x200006cd
    3e74:	20000618 	.word	0x20000618

00003e78 <AJ_GetRoutingNodeResponseListSize>:
    return AJ_OK;
}

uint8_t AJ_GetRoutingNodeResponseListSize()
{
    return RoutingNodeResponselist_idx;
    3e78:	4b01      	ldr	r3, [pc, #4]	; (3e80 <AJ_GetRoutingNodeResponseListSize+0x8>)
    3e7a:	7818      	ldrb	r0, [r3, #0]
}
    3e7c:	4770      	bx	lr
    3e7e:	46c0      	nop			; (mov r8, r8)
    3e80:	200006cd 	.word	0x200006cd

00003e84 <AJ_InitRoutingNodeResponselist>:
    RoutingNodePortBlacklist[RoutingNodeBlacklist_idx] = service->ipv4portUdp;
    RoutingNodeBlacklist_idx = (RoutingNodeBlacklist_idx + 1) % AJ_ROUTING_NODE_BLACKLIST_SIZE;
}

void AJ_InitRoutingNodeResponselist()
{
    3e84:	b508      	push	{r3, lr}
    memset(RoutingNodeResponselist, 0, sizeof(RoutingNodeResponselist));
    3e86:	4806      	ldr	r0, [pc, #24]	; (3ea0 <AJ_InitRoutingNodeResponselist+0x1c>)
    3e88:	2100      	movs	r1, #0
    3e8a:	22b4      	movs	r2, #180	; 0xb4
    3e8c:	4b05      	ldr	r3, [pc, #20]	; (3ea4 <AJ_InitRoutingNodeResponselist+0x20>)
    3e8e:	4798      	blx	r3
    memset(RoutingNodeAttemptsResponselist, 0, sizeof(RoutingNodeAttemptsResponselist));
    3e90:	4b05      	ldr	r3, [pc, #20]	; (3ea8 <AJ_InitRoutingNodeResponselist+0x24>)
    3e92:	2200      	movs	r2, #0
    3e94:	601a      	str	r2, [r3, #0]
    3e96:	809a      	strh	r2, [r3, #4]
    RoutingNodeResponselist_idx = 0;
    3e98:	4b04      	ldr	r3, [pc, #16]	; (3eac <AJ_InitRoutingNodeResponselist+0x28>)
    3e9a:	701a      	strb	r2, [r3, #0]
}
    3e9c:	bd08      	pop	{r3, pc}
    3e9e:	46c0      	nop			; (mov r8, r8)
    3ea0:	20000618 	.word	0x20000618
    3ea4:	00016773 	.word	0x00016773
    3ea8:	20000610 	.word	0x20000610
    3eac:	200006cd 	.word	0x200006cd

00003eb0 <AJ_SelectRoutingNodeFromResponseList>:
        AJ_InfoPrintf(("Added routing node 0x%x (pv = %d, port = %d, priority = %d) to response list with %d response(s) in list\n", service->ipv4, service->pv, service->ipv4port, service->priority, RoutingNodeResponselist_idx));
    }
}

AJ_Status AJ_SelectRoutingNodeFromResponseList(AJ_Service* service)
{
    3eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    3eb2:	465f      	mov	r7, fp
    3eb4:	4656      	mov	r6, sl
    3eb6:	464d      	mov	r5, r9
    3eb8:	4644      	mov	r4, r8
    3eba:	b4f0      	push	{r4, r5, r6, r7}
    3ebc:	b085      	sub	sp, #20
    3ebe:	1c05      	adds	r5, r0, #0
    uint8_t selectedIndex = 0;
    uint32_t runningSum = 0;
    uint8_t skip = 0;
    uint32_t priority_idx = 0;
    uint32_t priority_srv = 0;
    uint32_t random = 0;
    3ec0:	2300      	movs	r3, #0
    3ec2:	9303      	str	r3, [sp, #12]
    if (RoutingNodeResponselist[0].ipv4 || RoutingNodeResponselist[0].ipv4Udp) 
    3ec4:	4b5c      	ldr	r3, [pc, #368]	; (4038 <AJ_SelectRoutingNodeFromResponseList+0x188>)
    3ec6:	689b      	ldr	r3, [r3, #8]
    3ec8:	2b00      	cmp	r3, #0
    3eca:	d104      	bne.n	3ed6 <AJ_SelectRoutingNodeFromResponseList+0x26>
    3ecc:	4a5a      	ldr	r2, [pc, #360]	; (4038 <AJ_SelectRoutingNodeFromResponseList+0x188>)
    3ece:	6a92      	ldr	r2, [r2, #40]	; 0x28
    3ed0:	2a00      	cmp	r2, #0
    3ed2:	d100      	bne.n	3ed6 <AJ_SelectRoutingNodeFromResponseList+0x26>
    3ed4:	e09b      	b.n	400e <AJ_SelectRoutingNodeFromResponseList+0x15e>
	{
        service->ipv4 = RoutingNodeResponselist[0].ipv4;
    3ed6:	60ab      	str	r3, [r5, #8]
        service->ipv4port = RoutingNodeResponselist[0].ipv4port;
    3ed8:	4c57      	ldr	r4, [pc, #348]	; (4038 <AJ_SelectRoutingNodeFromResponseList+0x188>)
    3eda:	88a3      	ldrh	r3, [r4, #4]
    3edc:	80ab      	strh	r3, [r5, #4]
        service->ipv4Udp = RoutingNodeResponselist[0].ipv4Udp;
    3ede:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    3ee0:	62ab      	str	r3, [r5, #40]	; 0x28
        service->ipv4portUdp = RoutingNodeResponselist[0].ipv4portUdp;
    3ee2:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
    3ee4:	84ab      	strh	r3, [r5, #36]	; 0x24
        service->pv = RoutingNodeResponselist[0].pv;
    3ee6:	6923      	ldr	r3, [r4, #16]
    3ee8:	612b      	str	r3, [r5, #16]
        service->addrTypes = RoutingNodeResponselist[0].addrTypes;
    3eea:	7823      	ldrb	r3, [r4, #0]
    3eec:	702b      	strb	r3, [r5, #0]
        service->priority = RoutingNodeResponselist[0].priority;
    3eee:	89a3      	ldrh	r3, [r4, #12]
    3ef0:	81ab      	strh	r3, [r5, #12]
        runningSum = service->priority;
    3ef2:	9301      	str	r3, [sp, #4]
        skip = RoutingNodeAttemptsResponselist[0];
    3ef4:	4b51      	ldr	r3, [pc, #324]	; (403c <AJ_SelectRoutingNodeFromResponseList+0x18c>)
    3ef6:	781a      	ldrb	r2, [r3, #0]
    3ef8:	4693      	mov	fp, r2
    3efa:	1c1f      	adds	r7, r3, #0
    3efc:	343c      	adds	r4, #60	; 0x3c
     * The selection involves choosing the router with the
     * highest protocol version and the lowest service priority
     * (inverse of static rank/score).
     */
    uint8_t i = 1;
    uint8_t selectedIndex = 0;
    3efe:	2300      	movs	r3, #0
    3f00:	469a      	mov	sl, r3
    /*
     * The selection involves choosing the router with the
     * highest protocol version and the lowest service priority
     * (inverse of static rank/score).
     */
    uint8_t i = 1;
    3f02:	2601      	movs	r6, #1
    3f04:	46a1      	mov	r9, r4
		{
            AJ_InfoPrintf(("Index 0 was previously selected\n"));
        }
        for (; i  < AJ_ROUTING_NODE_RESPONSELIST_SIZE; ++i)
		{
            if (RoutingNodeResponselist[i].ipv4 || RoutingNodeResponselist[i].ipv4Udp) 
    3f06:	68a3      	ldr	r3, [r4, #8]
    3f08:	2b00      	cmp	r3, #0
    3f0a:	d103      	bne.n	3f14 <AJ_SelectRoutingNodeFromResponseList+0x64>
    3f0c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3f0e:	2a00      	cmp	r2, #0
    3f10:	d100      	bne.n	3f14 <AJ_SelectRoutingNodeFromResponseList+0x64>
    3f12:	e080      	b.n	4016 <AJ_SelectRoutingNodeFromResponseList+0x166>
			{
                if (RoutingNodeAttemptsResponselist[i]) 
    3f14:	887a      	ldrh	r2, [r7, #2]
    3f16:	2a00      	cmp	r2, #0
    3f18:	d000      	beq.n	3f1c <AJ_SelectRoutingNodeFromResponseList+0x6c>
    3f1a:	e070      	b.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
				{
                    AJ_InfoPrintf(("Index %d was previously selected\n", i));
                    continue;
                }
                if (skip)
    3f1c:	465a      	mov	r2, fp
    3f1e:	2a00      	cmp	r2, #0
    3f20:	d017      	beq.n	3f52 <AJ_SelectRoutingNodeFromResponseList+0xa2>
				{
                    service->ipv4 = RoutingNodeResponselist[i].ipv4;
    3f22:	60ab      	str	r3, [r5, #8]
                    service->ipv4port = RoutingNodeResponselist[i].ipv4port;
    3f24:	464b      	mov	r3, r9
    3f26:	889b      	ldrh	r3, [r3, #4]
    3f28:	80ab      	strh	r3, [r5, #4]
                    service->ipv4Udp = RoutingNodeResponselist[i].ipv4Udp;
    3f2a:	464b      	mov	r3, r9
    3f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3f2e:	62ab      	str	r3, [r5, #40]	; 0x28
                    service->ipv4portUdp = RoutingNodeResponselist[i].ipv4portUdp;
    3f30:	464b      	mov	r3, r9
    3f32:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    3f34:	84ab      	strh	r3, [r5, #36]	; 0x24
                    service->pv = RoutingNodeResponselist[i].pv;
    3f36:	464b      	mov	r3, r9
    3f38:	691b      	ldr	r3, [r3, #16]
    3f3a:	612b      	str	r3, [r5, #16]
                    service->addrTypes = RoutingNodeResponselist[i].addrTypes;
    3f3c:	464b      	mov	r3, r9
    3f3e:	781b      	ldrb	r3, [r3, #0]
    3f40:	702b      	strb	r3, [r5, #0]
                    service->priority = RoutingNodeResponselist[i].priority;
    3f42:	464b      	mov	r3, r9
    3f44:	899b      	ldrh	r3, [r3, #12]
    3f46:	81ab      	strh	r3, [r5, #12]
                    selectedIndex = i;
                    runningSum = service->priority;
    3f48:	9301      	str	r3, [sp, #4]
                    skip = 0;
                    continue;
    3f4a:	46b2      	mov	sl, r6
                    service->pv = RoutingNodeResponselist[i].pv;
                    service->addrTypes = RoutingNodeResponselist[i].addrTypes;
                    service->priority = RoutingNodeResponselist[i].priority;
                    selectedIndex = i;
                    runningSum = service->priority;
                    skip = 0;
    3f4c:	2300      	movs	r3, #0
    3f4e:	469b      	mov	fp, r3
                    continue;
    3f50:	e055      	b.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
                }
                if (RoutingNodeResponselist[i].pv < service->pv)
    3f52:	464a      	mov	r2, r9
    3f54:	6911      	ldr	r1, [r2, #16]
    3f56:	692a      	ldr	r2, [r5, #16]
    3f58:	4291      	cmp	r1, r2
    3f5a:	d350      	bcc.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
				{
                    continue;
                }
                if (RoutingNodeResponselist[i].pv > service->pv || (RoutingNodeResponselist[i].pv == service->pv && RoutingNodeResponselist[i].priority < service->priority)) 
    3f5c:	d805      	bhi.n	3f6a <AJ_SelectRoutingNodeFromResponseList+0xba>
    3f5e:	d11a      	bne.n	3f96 <AJ_SelectRoutingNodeFromResponseList+0xe6>
    3f60:	464a      	mov	r2, r9
    3f62:	8991      	ldrh	r1, [r2, #12]
    3f64:	89aa      	ldrh	r2, [r5, #12]
    3f66:	4291      	cmp	r1, r2
    3f68:	d215      	bcs.n	3f96 <AJ_SelectRoutingNodeFromResponseList+0xe6>
				{
                    service->ipv4 = RoutingNodeResponselist[i].ipv4;
    3f6a:	60ab      	str	r3, [r5, #8]
                    service->ipv4port = RoutingNodeResponselist[i].ipv4port;
    3f6c:	464b      	mov	r3, r9
    3f6e:	889b      	ldrh	r3, [r3, #4]
    3f70:	80ab      	strh	r3, [r5, #4]
                    service->ipv4Udp = RoutingNodeResponselist[i].ipv4Udp;
    3f72:	464b      	mov	r3, r9
    3f74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3f76:	62ab      	str	r3, [r5, #40]	; 0x28
                    service->ipv4portUdp = RoutingNodeResponselist[i].ipv4portUdp;
    3f78:	464b      	mov	r3, r9
    3f7a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    3f7c:	84ab      	strh	r3, [r5, #36]	; 0x24
                    service->pv = RoutingNodeResponselist[i].pv;
    3f7e:	464b      	mov	r3, r9
    3f80:	691b      	ldr	r3, [r3, #16]
    3f82:	612b      	str	r3, [r5, #16]
                    service->addrTypes = RoutingNodeResponselist[i].addrTypes;
    3f84:	464b      	mov	r3, r9
    3f86:	781b      	ldrb	r3, [r3, #0]
    3f88:	702b      	strb	r3, [r5, #0]
                    service->priority = RoutingNodeResponselist[i].priority;
    3f8a:	464b      	mov	r3, r9
    3f8c:	899b      	ldrh	r3, [r3, #12]
    3f8e:	81ab      	strh	r3, [r5, #12]
                    runningSum = service->priority;
    3f90:	9301      	str	r3, [sp, #4]
                    selectedIndex = i;
    3f92:	46b2      	mov	sl, r6
    3f94:	e033      	b.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
                    AJ_InfoPrintf(("Tentatively selecting routing node %x (pv = %d, port = %d, priority = %d).\n", service->ipv4, service->pv, service->ipv4port, service->priority));
                } 
				else 
				   if (RoutingNodeResponselist[i].priority == service->priority) 
    3f96:	464b      	mov	r3, r9
    3f98:	899a      	ldrh	r2, [r3, #12]
    3f9a:	89ab      	ldrh	r3, [r5, #12]
    3f9c:	429a      	cmp	r2, r3
    3f9e:	d12e      	bne.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
					   * priorities under consideration is used as the second node's
                       * associated sum. A uniform random number up to the sum of the two
                       * priorities (inclusive) is chosen and the first node whose associated
                       * sum is greater than or equal to the random number is selected.
                     */
                    random = 0;
    3fa0:	2300      	movs	r3, #0
    3fa2:	9303      	str	r3, [sp, #12]
					// -   
                    AJ_RandBytes((uint8_t*)&random, sizeof(random));
    3fa4:	a803      	add	r0, sp, #12
    3fa6:	2104      	movs	r1, #4
    3fa8:	4b25      	ldr	r3, [pc, #148]	; (4040 <AJ_SelectRoutingNodeFromResponseList+0x190>)
    3faa:	4798      	blx	r3
                    priority_idx = RoutingNodeResponselist[i].priority + runningSum;
    3fac:	464b      	mov	r3, r9
    3fae:	899b      	ldrh	r3, [r3, #12]
    3fb0:	9a01      	ldr	r2, [sp, #4]
    3fb2:	4690      	mov	r8, r2
    3fb4:	4498      	add	r8, r3
                    priority_srv = runningSum;
                    runningSum = priority_idx;
                    random %= (runningSum + 1);
    3fb6:	4643      	mov	r3, r8
    3fb8:	1c59      	adds	r1, r3, #1
    3fba:	9803      	ldr	r0, [sp, #12]
    3fbc:	4b21      	ldr	r3, [pc, #132]	; (4044 <AJ_SelectRoutingNodeFromResponseList+0x194>)
    3fbe:	4798      	blx	r3
    3fc0:	9103      	str	r1, [sp, #12]
                    AJ_InfoPrintf(("P_idx is %u and P_srv is %u and random is %u\n", priority_idx, priority_srv, random));
                    if (random > priority_srv) 
    3fc2:	9a01      	ldr	r2, [sp, #4]
    3fc4:	4291      	cmp	r1, r2
    3fc6:	d918      	bls.n	3ffa <AJ_SelectRoutingNodeFromResponseList+0x14a>
					{
                        AJ_InfoPrintf(("Picking index %d on this round\n", i));
                        service->ipv4 = RoutingNodeResponselist[i].ipv4;
    3fc8:	464b      	mov	r3, r9
    3fca:	689b      	ldr	r3, [r3, #8]
    3fcc:	60ab      	str	r3, [r5, #8]
                        service->ipv4port = RoutingNodeResponselist[i].ipv4port;
    3fce:	464b      	mov	r3, r9
    3fd0:	889b      	ldrh	r3, [r3, #4]
    3fd2:	80ab      	strh	r3, [r5, #4]
                        service->ipv4Udp = RoutingNodeResponselist[i].ipv4Udp;
    3fd4:	464b      	mov	r3, r9
    3fd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3fd8:	62ab      	str	r3, [r5, #40]	; 0x28
                        service->ipv4portUdp = RoutingNodeResponselist[i].ipv4portUdp;
    3fda:	464b      	mov	r3, r9
    3fdc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    3fde:	84ab      	strh	r3, [r5, #36]	; 0x24
                        service->pv = RoutingNodeResponselist[i].pv;
    3fe0:	464b      	mov	r3, r9
    3fe2:	691b      	ldr	r3, [r3, #16]
    3fe4:	612b      	str	r3, [r5, #16]
                        service->addrTypes = RoutingNodeResponselist[i].addrTypes;
    3fe6:	464b      	mov	r3, r9
    3fe8:	781b      	ldrb	r3, [r3, #0]
    3fea:	702b      	strb	r3, [r5, #0]
                        service->priority = RoutingNodeResponselist[i].priority;
    3fec:	464b      	mov	r3, r9
    3fee:	899b      	ldrh	r3, [r3, #12]
    3ff0:	81ab      	strh	r3, [r5, #12]
                    random = 0;
					// -   
                    AJ_RandBytes((uint8_t*)&random, sizeof(random));
                    priority_idx = RoutingNodeResponselist[i].priority + runningSum;
                    priority_srv = runningSum;
                    runningSum = priority_idx;
    3ff2:	4643      	mov	r3, r8
    3ff4:	9301      	str	r3, [sp, #4]
                        service->ipv4port = RoutingNodeResponselist[i].ipv4port;
                        service->ipv4Udp = RoutingNodeResponselist[i].ipv4Udp;
                        service->ipv4portUdp = RoutingNodeResponselist[i].ipv4portUdp;
                        service->pv = RoutingNodeResponselist[i].pv;
                        service->addrTypes = RoutingNodeResponselist[i].addrTypes;
                        service->priority = RoutingNodeResponselist[i].priority;
    3ff6:	46b2      	mov	sl, r6
    3ff8:	e001      	b.n	3ffe <AJ_SelectRoutingNodeFromResponseList+0x14e>
                    random = 0;
					// -   
                    AJ_RandBytes((uint8_t*)&random, sizeof(random));
                    priority_idx = RoutingNodeResponselist[i].priority + runningSum;
                    priority_srv = runningSum;
                    runningSum = priority_idx;
    3ffa:	4643      	mov	r3, r8
    3ffc:	9301      	str	r3, [sp, #4]
        skip = RoutingNodeAttemptsResponselist[0];
        if (skip)
		{
            AJ_InfoPrintf(("Index 0 was previously selected\n"));
        }
        for (; i  < AJ_ROUTING_NODE_RESPONSELIST_SIZE; ++i)
    3ffe:	3601      	adds	r6, #1
    4000:	b2f6      	uxtb	r6, r6
    4002:	3702      	adds	r7, #2
    4004:	343c      	adds	r4, #60	; 0x3c
    4006:	2e03      	cmp	r6, #3
    4008:	d000      	beq.n	400c <AJ_SelectRoutingNodeFromResponseList+0x15c>
    400a:	e77b      	b.n	3f04 <AJ_SelectRoutingNodeFromResponseList+0x54>
    400c:	e003      	b.n	4016 <AJ_SelectRoutingNodeFromResponseList+0x166>
            }
        }
    } 
	else
	{
        AJ_InitRoutingNodeResponselist();
    400e:	4b0e      	ldr	r3, [pc, #56]	; (4048 <AJ_SelectRoutingNodeFromResponseList+0x198>)
    4010:	4798      	blx	r3
        return AJ_ERR_TIMEOUT;
    4012:	2007      	movs	r0, #7
    4014:	e009      	b.n	402a <AJ_SelectRoutingNodeFromResponseList+0x17a>
    }

    if (skip)
	{
        AJ_InfoPrintf(("All entries in the response list have been previously selected\n"));
        return AJ_ERR_END_OF_DATA;
    4016:	200a      	movs	r0, #10
	{
        AJ_InitRoutingNodeResponselist();
        return AJ_ERR_TIMEOUT;
    }

    if (skip)
    4018:	465b      	mov	r3, fp
    401a:	2b00      	cmp	r3, #0
    401c:	d105      	bne.n	402a <AJ_SelectRoutingNodeFromResponseList+0x17a>
	{
        AJ_InfoPrintf(("All entries in the response list have been previously selected\n"));
        return AJ_ERR_END_OF_DATA;
    }
    RoutingNodeAttemptsResponselist[selectedIndex] = 1;
    401e:	4653      	mov	r3, sl
    4020:	005b      	lsls	r3, r3, #1
    4022:	2101      	movs	r1, #1
    4024:	4a05      	ldr	r2, [pc, #20]	; (403c <AJ_SelectRoutingNodeFromResponseList+0x18c>)
    4026:	5299      	strh	r1, [r3, r2]
    AJ_InfoPrintf(("Selected routing node 0x%x (pv = %d, port = %d, priority = %d) out of %d responses in the list.\n", service->ipv4, service->pv, service->ipv4port, service->priority, RoutingNodeResponselist_idx));
    return AJ_OK;
    4028:	2000      	movs	r0, #0
}
    402a:	b005      	add	sp, #20
    402c:	bc3c      	pop	{r2, r3, r4, r5}
    402e:	4690      	mov	r8, r2
    4030:	4699      	mov	r9, r3
    4032:	46a2      	mov	sl, r4
    4034:	46ab      	mov	fp, r5
    4036:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4038:	20000618 	.word	0x20000618
    403c:	20000610 	.word	0x20000610
    4040:	0000d6a9 	.word	0x0000d6a9
    4044:	00014fa9 	.word	0x00014fa9
    4048:	00003e85 	.word	0x00003e85

0000404c <AJ_FindBusAndConnect>:
    AJ_InitRoutingNodeResponselist();
    return status;
}

AJ_Status AJ_FindBusAndConnect(AJ_BusAttachment* bus, const char* serviceName, uint32_t timeout)
{
    404c:	b5f0      	push	{r4, r5, r6, r7, lr}
    404e:	464f      	mov	r7, r9
    4050:	4646      	mov	r6, r8
    4052:	b4c0      	push	{r6, r7}
    4054:	b095      	sub	sp, #84	; 0x54
    4056:	9001      	str	r0, [sp, #4]
    4058:	1c0c      	adds	r4, r1, #0
    405a:	1c16      	adds	r6, r2, #0
    bus->isProbeRequired = TRUE;

    AJ_InfoPrintf(("AJ_FindBusAndConnect(bus=0x%p, serviceName=\"%s\", timeout=%d, selection timeout=%d.)\n", bus, serviceName, timeout, selectionTimeout));

    // Clear the bus struct
    memset(bus, 0, sizeof(AJ_BusAttachment));
    405c:	2100      	movs	r1, #0
    405e:	2260      	movs	r2, #96	; 0x60
    4060:	4b55      	ldr	r3, [pc, #340]	; (41b8 <AJ_FindBusAndConnect+0x16c>)
    4062:	4798      	blx	r3
    // Clear stale name->GUID mappings
    AJ_GUID_ClearNameMap();
    4064:	4b55      	ldr	r3, [pc, #340]	; (41bc <AJ_FindBusAndConnect+0x170>)
    4066:	4798      	blx	r3

    // Discover a daemon or service to connect to
    if (!serviceName) 
    4068:	2c00      	cmp	r4, #0
    406a:	d100      	bne.n	406e <AJ_FindBusAndConnect+0x22>
	{
        serviceName = daemonService;
    406c:	4c54      	ldr	r4, [pc, #336]	; (41c0 <AJ_FindBusAndConnect+0x174>)
			service.ipv4 = 0x7f000001; // 127.0.0.1
		#endif
        service.addrTypes = AJ_ADDR_TCP4;
		
#else
        AJ_InitTimer(&connectionTimer);
    406e:	a803      	add	r0, sp, #12
    4070:	4b54      	ldr	r3, [pc, #336]	; (41c4 <AJ_FindBusAndConnect+0x178>)
    4072:	4798      	blx	r3
        printf("AJ_FindBusAndConnect(): Connection timer started\n");
    4074:	4854      	ldr	r0, [pc, #336]	; (41c8 <AJ_FindBusAndConnect+0x17c>)
    4076:	4b55      	ldr	r3, [pc, #340]	; (41cc <AJ_FindBusAndConnect+0x180>)
    4078:	4798      	blx	r3
        status = AJ_Discover(serviceName, &service, timeout, selectionTimeout);//aj_disco.c
    407a:	4b55      	ldr	r3, [pc, #340]	; (41d0 <AJ_FindBusAndConnect+0x184>)
    407c:	681b      	ldr	r3, [r3, #0]
    407e:	1c20      	adds	r0, r4, #0
    4080:	a905      	add	r1, sp, #20
    4082:	1c32      	adds	r2, r6, #0
    4084:	4c53      	ldr	r4, [pc, #332]	; (41d4 <AJ_FindBusAndConnect+0x188>)
    4086:	47a0      	blx	r4
    4088:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    408a:	d006      	beq.n	409a <AJ_FindBusAndConnect+0x4e>
		{
            printf("AJ_FindBusAndConnect(): AJ_Discover status=%s\n", AJ_StatusText(status));
    408c:	4b52      	ldr	r3, [pc, #328]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    408e:	4798      	blx	r3
    4090:	1c01      	adds	r1, r0, #0
    4092:	4852      	ldr	r0, [pc, #328]	; (41dc <AJ_FindBusAndConnect+0x190>)
    4094:	4b52      	ldr	r3, [pc, #328]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    4096:	4798      	blx	r3
            goto ExitConnect;
    4098:	e07b      	b.n	4192 <AJ_FindBusAndConnect+0x146>
        }
#endif

        // this calls into platform code that will decide whether to use UDP or TCP, based on what is available
		printf("TCP connection started \n");
    409a:	4852      	ldr	r0, [pc, #328]	; (41e4 <AJ_FindBusAndConnect+0x198>)
    409c:	4b4b      	ldr	r3, [pc, #300]	; (41cc <AJ_FindBusAndConnect+0x180>)
    409e:	4798      	blx	r3
        status = AJ_Net_Connect(bus, &service);
    40a0:	9801      	ldr	r0, [sp, #4]
    40a2:	a905      	add	r1, sp, #20
    40a4:	4b50      	ldr	r3, [pc, #320]	; (41e8 <AJ_FindBusAndConnect+0x19c>)
    40a6:	4798      	blx	r3
    40a8:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    40aa:	d006      	beq.n	40ba <AJ_FindBusAndConnect+0x6e>
		 {
            printf("AJ_FindBusAndConnect(): AJ_Net_Connect status=%s\n", AJ_StatusText(status));
    40ac:	4b4a      	ldr	r3, [pc, #296]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    40ae:	4798      	blx	r3
    40b0:	1c01      	adds	r1, r0, #0
    40b2:	484e      	ldr	r0, [pc, #312]	; (41ec <AJ_FindBusAndConnect+0x1a0>)
    40b4:	4b4a      	ldr	r3, [pc, #296]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    40b6:	4798      	blx	r3
            goto ExitConnect;
    40b8:	e06b      	b.n	4192 <AJ_FindBusAndConnect+0x146>
        }
		
        status = AJ_Authenticate(bus);
    40ba:	9801      	ldr	r0, [sp, #4]
    40bc:	4b4c      	ldr	r3, [pc, #304]	; (41f0 <AJ_FindBusAndConnect+0x1a4>)
    40be:	4798      	blx	r3
    40c0:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    40c2:	d060      	beq.n	4186 <AJ_FindBusAndConnect+0x13a>
		{
             printf("AJ_FindBusAndConnect(): AJ_Authenticate status=%s\n", AJ_StatusText(status));
    40c4:	4b44      	ldr	r3, [pc, #272]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    40c6:	4798      	blx	r3
    40c8:	1c01      	adds	r1, r0, #0
    40ca:	484a      	ldr	r0, [pc, #296]	; (41f4 <AJ_FindBusAndConnect+0x1a8>)
    40cc:	4b44      	ldr	r3, [pc, #272]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    40ce:	4798      	blx	r3

#if ((!AJ_CONNECT_LOCALHOST) && (!defined(ARDUINO)) && (!defined(AJ_SERIAL_CONNECTION)))
             printf("AJ_FindBusAndConnect(): Blacklisting routing node\n");
    40d0:	4849      	ldr	r0, [pc, #292]	; (41f8 <AJ_FindBusAndConnect+0x1ac>)
    40d2:	4b3e      	ldr	r3, [pc, #248]	; (41cc <AJ_FindBusAndConnect+0x180>)
    40d4:	4798      	blx	r3
    return RoutingNodeResponselist_idx;
}

static void AddRoutingNodeToBlacklist(AJ_Service* service)
{
    RoutingNodeIPBlacklist[RoutingNodeBlacklist_idx] = service->ipv4;
    40d6:	4b49      	ldr	r3, [pc, #292]	; (41fc <AJ_FindBusAndConnect+0x1b0>)
    40d8:	469c      	mov	ip, r3
    40da:	781b      	ldrb	r3, [r3, #0]
    40dc:	4d48      	ldr	r5, [pc, #288]	; (4200 <AJ_FindBusAndConnect+0x1b4>)
    40de:	0098      	lsls	r0, r3, #2
    40e0:	aa05      	add	r2, sp, #20
    40e2:	9f07      	ldr	r7, [sp, #28]
    40e4:	5147      	str	r7, [r0, r5]
    RoutingNodePortBlacklist[RoutingNodeBlacklist_idx] = service->ipv4port;
    40e6:	4f47      	ldr	r7, [pc, #284]	; (4204 <AJ_FindBusAndConnect+0x1b8>)
    40e8:	0058      	lsls	r0, r3, #1
    40ea:	8891      	ldrh	r1, [r2, #4]
    40ec:	53c1      	strh	r1, [r0, r7]
    RoutingNodeBlacklist_idx = (RoutingNodeBlacklist_idx + 1) % AJ_ROUTING_NODE_BLACKLIST_SIZE;
    40ee:	3301      	adds	r3, #1
    40f0:	210f      	movs	r1, #15
    40f2:	4689      	mov	r9, r1

    RoutingNodeIPBlacklist[RoutingNodeBlacklist_idx] = service->ipv4Udp;
    40f4:	400b      	ands	r3, r1
    40f6:	0099      	lsls	r1, r3, #2
    40f8:	980f      	ldr	r0, [sp, #60]	; 0x3c
    40fa:	5148      	str	r0, [r1, r5]
    RoutingNodePortBlacklist[RoutingNodeBlacklist_idx] = service->ipv4portUdp;
    40fc:	005d      	lsls	r5, r3, #1
    40fe:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    4100:	53ea      	strh	r2, [r5, r7]
    RoutingNodeBlacklist_idx = (RoutingNodeBlacklist_idx + 1) % AJ_ROUTING_NODE_BLACKLIST_SIZE;
    4102:	3301      	adds	r3, #1
    4104:	464a      	mov	r2, r9
    4106:	4013      	ands	r3, r2
    4108:	4662      	mov	r2, ip
    410a:	7013      	strb	r3, [r2, #0]
             printf("AJ_FindBusAndConnect(): Blacklisting routing node\n");
			// -    
            AddRoutingNodeToBlacklist(&service);
            // try again
            finished = FALSE;
            connectionTime -= AJ_GetElapsedTime(&connectionTimer, FALSE);
    410c:	a803      	add	r0, sp, #12
    410e:	2100      	movs	r1, #0
    4110:	4b3d      	ldr	r3, [pc, #244]	; (4208 <AJ_FindBusAndConnect+0x1bc>)
    4112:	4798      	blx	r3
    4114:	1a36      	subs	r6, r6, r0
            // select a new node from the response list
            while (connectionTime > 0) 
    4116:	2e00      	cmp	r6, #0
    4118:	dd2d      	ble.n	4176 <AJ_FindBusAndConnect+0x12a>
			{
				//   
                status = AJ_SelectRoutingNodeFromResponseList(&service);
    411a:	4f3c      	ldr	r7, [pc, #240]	; (420c <AJ_FindBusAndConnect+0x1c0>)
                    status = AJ_ERR_TIMEOUT;
                    //AJ_InfoPrintf(("Exhausted all the retries from the response list\n"));
                    finished = FALSE;
                    break;
                }
                 printf("Retrying with a new selection from the routing node response list\n");
    411c:	4d2b      	ldr	r5, [pc, #172]	; (41cc <AJ_FindBusAndConnect+0x180>)
            connectionTime -= AJ_GetElapsedTime(&connectionTimer, FALSE);
            // select a new node from the response list
            while (connectionTime > 0) 
			{
				//   
                status = AJ_SelectRoutingNodeFromResponseList(&service);
    411e:	a805      	add	r0, sp, #20
    4120:	47b8      	blx	r7
                if (status == AJ_ERR_END_OF_DATA) 
    4122:	280a      	cmp	r0, #10
    4124:	d026      	beq.n	4174 <AJ_FindBusAndConnect+0x128>
                    status = AJ_ERR_TIMEOUT;
                    //AJ_InfoPrintf(("Exhausted all the retries from the response list\n"));
                    finished = FALSE;
                    break;
                }
                 printf("Retrying with a new selection from the routing node response list\n");
    4126:	483a      	ldr	r0, [pc, #232]	; (4210 <AJ_FindBusAndConnect+0x1c4>)
    4128:	47a8      	blx	r5
                status = AJ_Net_Connect(bus, &service);
    412a:	9801      	ldr	r0, [sp, #4]
    412c:	a905      	add	r1, sp, #20
    412e:	4b2e      	ldr	r3, [pc, #184]	; (41e8 <AJ_FindBusAndConnect+0x19c>)
    4130:	4798      	blx	r3
    4132:	1e04      	subs	r4, r0, #0
                if (status != AJ_OK) 
    4134:	d006      	beq.n	4144 <AJ_FindBusAndConnect+0xf8>
				{
                     printf("AJ_FindBusAndConnect(): AJ_Net_Connect status=%s\n", AJ_StatusText(status));
    4136:	4b28      	ldr	r3, [pc, #160]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    4138:	4798      	blx	r3
    413a:	1c01      	adds	r1, r0, #0
    413c:	482b      	ldr	r0, [pc, #172]	; (41ec <AJ_FindBusAndConnect+0x1a0>)
    413e:	4b28      	ldr	r3, [pc, #160]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    4140:	4798      	blx	r3
                    goto ExitConnect;
    4142:	e026      	b.n	4192 <AJ_FindBusAndConnect+0x146>
                }
                status = AJ_Authenticate(bus);
    4144:	9801      	ldr	r0, [sp, #4]
    4146:	4b2a      	ldr	r3, [pc, #168]	; (41f0 <AJ_FindBusAndConnect+0x1a4>)
    4148:	4798      	blx	r3
    414a:	1e04      	subs	r4, r0, #0
                if (status == AJ_OK) 
    414c:	d01b      	beq.n	4186 <AJ_FindBusAndConnect+0x13a>
                    finished = TRUE;
                    break;
                } 
				else
				{
                    connectionTime -= AJ_GetElapsedTime(&connectionTimer, FALSE);
    414e:	a803      	add	r0, sp, #12
    4150:	2100      	movs	r1, #0
    4152:	4b2d      	ldr	r3, [pc, #180]	; (4208 <AJ_FindBusAndConnect+0x1bc>)
    4154:	4798      	blx	r3
    4156:	1a36      	subs	r6, r6, r0
            AddRoutingNodeToBlacklist(&service);
            // try again
            finished = FALSE;
            connectionTime -= AJ_GetElapsedTime(&connectionTimer, FALSE);
            // select a new node from the response list
            while (connectionTime > 0) 
    4158:	2e00      	cmp	r6, #0
    415a:	dce0      	bgt.n	411e <AJ_FindBusAndConnect+0xd2>
    415c:	e00b      	b.n	4176 <AJ_FindBusAndConnect+0x12a>
        }

        status = SetSignalRules(bus);
        if (status != AJ_OK)
		{
             printf("AJ_FindBusAndConnect(): SetSignalRules status=%s\n", AJ_StatusText(status));
    415e:	4b1e      	ldr	r3, [pc, #120]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    4160:	4798      	blx	r3
    4162:	1c01      	adds	r1, r0, #0
    4164:	482b      	ldr	r0, [pc, #172]	; (4214 <AJ_FindBusAndConnect+0x1c8>)
    4166:	4b1e      	ldr	r3, [pc, #120]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    4168:	4798      	blx	r3
            goto ExitConnect;
    416a:	e012      	b.n	4192 <AJ_FindBusAndConnect+0x146>
        }

        AJ_InitRoutingNodeResponselist();
    416c:	4d2a      	ldr	r5, [pc, #168]	; (4218 <AJ_FindBusAndConnect+0x1cc>)
    416e:	47a8      	blx	r5
    }

ExitConnect:

    AJ_InitRoutingNodeResponselist();
    4170:	47a8      	blx	r5
    4172:	e01a      	b.n	41aa <AJ_FindBusAndConnect+0x15e>
			{
				//   
                status = AJ_SelectRoutingNodeFromResponseList(&service);
                if (status == AJ_ERR_END_OF_DATA) 
				{
                    status = AJ_ERR_TIMEOUT;
    4174:	2407      	movs	r4, #7
#endif
        }

        if (status != AJ_OK) 
		{
             printf("AJ_FindBusAndConnect(): AJ_Authenticate status=%s\n", AJ_StatusText(status));
    4176:	1c20      	adds	r0, r4, #0
    4178:	4b17      	ldr	r3, [pc, #92]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    417a:	4798      	blx	r3
    417c:	1c01      	adds	r1, r0, #0
    417e:	481d      	ldr	r0, [pc, #116]	; (41f4 <AJ_FindBusAndConnect+0x1a8>)
    4180:	4b17      	ldr	r3, [pc, #92]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    4182:	4798      	blx	r3
            goto ExitConnect;
    4184:	e005      	b.n	4192 <AJ_FindBusAndConnect+0x146>
        }

        status = SetSignalRules(bus);
    4186:	9801      	ldr	r0, [sp, #4]
    4188:	4b24      	ldr	r3, [pc, #144]	; (421c <AJ_FindBusAndConnect+0x1d0>)
    418a:	4798      	blx	r3
    418c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    418e:	d0ed      	beq.n	416c <AJ_FindBusAndConnect+0x120>
    4190:	e7e5      	b.n	415e <AJ_FindBusAndConnect+0x112>
        AJ_InitRoutingNodeResponselist();
    }

ExitConnect:

    AJ_InitRoutingNodeResponselist();
    4192:	4b21      	ldr	r3, [pc, #132]	; (4218 <AJ_FindBusAndConnect+0x1cc>)
    4194:	4798      	blx	r3
    if (status != AJ_OK) 
	{
         printf("AJ_FindBusAndConnect(): status=%s\n", AJ_StatusText(status));
    4196:	1c20      	adds	r0, r4, #0
    4198:	4b0f      	ldr	r3, [pc, #60]	; (41d8 <AJ_FindBusAndConnect+0x18c>)
    419a:	4798      	blx	r3
    419c:	1c01      	adds	r1, r0, #0
    419e:	4820      	ldr	r0, [pc, #128]	; (4220 <AJ_FindBusAndConnect+0x1d4>)
    41a0:	4b0f      	ldr	r3, [pc, #60]	; (41e0 <AJ_FindBusAndConnect+0x194>)
    41a2:	4798      	blx	r3
		// 
        AJ_Disconnect(bus);
    41a4:	9801      	ldr	r0, [sp, #4]
    41a6:	4b1f      	ldr	r3, [pc, #124]	; (4224 <AJ_FindBusAndConnect+0x1d8>)
    41a8:	4798      	blx	r3
    }

    return status;
}
    41aa:	1c20      	adds	r0, r4, #0
    41ac:	b015      	add	sp, #84	; 0x54
    41ae:	bc0c      	pop	{r2, r3}
    41b0:	4690      	mov	r8, r2
    41b2:	4699      	mov	r9, r3
    41b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    41b6:	46c0      	nop			; (mov r8, r8)
    41b8:	00016773 	.word	0x00016773
    41bc:	00007bf5 	.word	0x00007bf5
    41c0:	0001b25c 	.word	0x0001b25c
    41c4:	0000d7ad 	.word	0x0000d7ad
    41c8:	0001b3a0 	.word	0x0001b3a0
    41cc:	00016f5d 	.word	0x00016f5d
    41d0:	20000124 	.word	0x20000124
    41d4:	0000716d 	.word	0x0000716d
    41d8:	000063c5 	.word	0x000063c5
    41dc:	0001b3d4 	.word	0x0001b3d4
    41e0:	00016e3d 	.word	0x00016e3d
    41e4:	0001b404 	.word	0x0001b404
    41e8:	0000c1c1 	.word	0x0000c1c1
    41ec:	0001b41c 	.word	0x0001b41c
    41f0:	00003a1d 	.word	0x00003a1d
    41f4:	0001b450 	.word	0x0001b450
    41f8:	0001b484 	.word	0x0001b484
    41fc:	200005ec 	.word	0x200005ec
    4200:	200005ac 	.word	0x200005ac
    4204:	200005f0 	.word	0x200005f0
    4208:	0000d769 	.word	0x0000d769
    420c:	00003eb1 	.word	0x00003eb1
    4210:	0001b4b8 	.word	0x0001b4b8
    4214:	0001b4fc 	.word	0x0001b4fc
    4218:	00003e85 	.word	0x00003e85
    421c:	00003969 	.word	0x00003969
    4220:	0001b530 	.word	0x0001b530
    4224:	00003c39 	.word	0x00003c39

00004228 <AJ_InitRoutingNodeBlacklist>:
    memset(RoutingNodeAttemptsResponselist, 0, sizeof(RoutingNodeAttemptsResponselist));
    RoutingNodeResponselist_idx = 0;
}

void AJ_InitRoutingNodeBlacklist()
{
    4228:	b508      	push	{r3, lr}
    memset(RoutingNodeIPBlacklist, 0, sizeof(RoutingNodeIPBlacklist));
    422a:	4809      	ldr	r0, [pc, #36]	; (4250 <AJ_InitRoutingNodeBlacklist+0x28>)
    422c:	2100      	movs	r1, #0
    422e:	2240      	movs	r2, #64	; 0x40
    4230:	4b08      	ldr	r3, [pc, #32]	; (4254 <AJ_InitRoutingNodeBlacklist+0x2c>)
    4232:	4798      	blx	r3
    memset(RoutingNodePortBlacklist, 0, sizeof(RoutingNodePortBlacklist));
    4234:	4a08      	ldr	r2, [pc, #32]	; (4258 <AJ_InitRoutingNodeBlacklist+0x30>)
    4236:	2300      	movs	r3, #0
    4238:	6013      	str	r3, [r2, #0]
    423a:	6053      	str	r3, [r2, #4]
    423c:	6093      	str	r3, [r2, #8]
    423e:	60d3      	str	r3, [r2, #12]
    4240:	6113      	str	r3, [r2, #16]
    4242:	6153      	str	r3, [r2, #20]
    4244:	6193      	str	r3, [r2, #24]
    4246:	61d3      	str	r3, [r2, #28]
    RoutingNodeBlacklist_idx = 0;
    4248:	4a04      	ldr	r2, [pc, #16]	; (425c <AJ_InitRoutingNodeBlacklist+0x34>)
    424a:	7013      	strb	r3, [r2, #0]
}
    424c:	bd08      	pop	{r3, pc}
    424e:	46c0      	nop			; (mov r8, r8)
    4250:	200005ac 	.word	0x200005ac
    4254:	00016773 	.word	0x00016773
    4258:	200005f0 	.word	0x200005f0
    425c:	200005ec 	.word	0x200005ec

00004260 <FindCredential>:
    }
    return AJ_OK;
}
*/
static uint16_t FindCredential(const uint16_t credType, const uint8_t* credId, uint8_t credIdLen, AJ_PeerCred** credHolder)
{
    4260:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4262:	1c07      	adds	r7, r0, #0
    4264:	1c0e      	adds	r6, r1, #0
    4266:	1c15      	adds	r5, r2, #0
    4268:	1c1c      	adds	r4, r3, #0
    uint8_t localCredIdLen;
    uint8_t* localCredId;
    AJ_PeerCred* cred;
    int32_t idMatch;

    printf("FindCredential(type=0x%04X, id=0x%p, len=%d)\n", credType, credId, credIdLen);
    426a:	480a      	ldr	r0, [pc, #40]	; (4294 <FindCredential+0x34>)
    426c:	1c39      	adds	r1, r7, #0
    426e:	1c32      	adds	r2, r6, #0
    4270:	1c2b      	adds	r3, r5, #0
    4272:	4d09      	ldr	r5, [pc, #36]	; (4298 <FindCredential+0x38>)
    4274:	47a8      	blx	r5
                AJ_Free(localCredId);
                AJ_NVRAM_Close(handle);
                return slot;  // short query 
            }
            // full query 
       */     cred = (AJ_PeerCred*) AJ_Malloc(sizeof(AJ_PeerCred));
    4276:	201c      	movs	r0, #28
    4278:	4b08      	ldr	r3, [pc, #32]	; (429c <FindCredential+0x3c>)
    427a:	4798      	blx	r3
			localCredId[12]=0xb0;
			localCredId[13]=0x0a;
			localCredId[14]=0x68;
			localCredId[15]=0x11;
			
	        cred->type = localCredType;
    427c:	2301      	movs	r3, #1
    427e:	8003      	strh	r3, [r0, #0]
            cred->idLen = localCredIdLen;
    4280:	330f      	adds	r3, #15
    4282:	7083      	strb	r3, [r0, #2]
            cred->id = localCredId;
    4284:	2300      	movs	r3, #0
    4286:	6043      	str	r3, [r0, #4]
            cred->dataLen = 0;
    4288:	8283      	strh	r3, [r0, #20]
            cred->associationLen = 0;
    428a:	7303      	strb	r3, [r0, #12]
            {
                AJ_ErrPrintf(("FindCredential(): AJ_ERR_FAILURE on read failure \n"));
                AJ_FreeCredential(cred);
                return 0;
            }
         */ *credHolder = cred;
    428c:	6020      	str	r0, [r4, #0]
			slot=1;
            return slot;  // found
 /*       }
    }*/
    return 0; /* not found */
}
    428e:	2001      	movs	r0, #1
    4290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4292:	46c0      	nop			; (mov r8, r8)
    4294:	0001b554 	.word	0x0001b554
    4298:	00016e3d 	.word	0x00016e3d
    429c:	0000d7dd 	.word	0x0000d7dd

000042a0 <AJ_GetCredential>:

AJ_Status AJ_GetCredential(const uint16_t credType, const uint8_t* id, uint8_t idLen, AJ_PeerCred** customCredHolder)
{
    42a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    42a2:	1c06      	adds	r6, r0, #0
    42a4:	1c0d      	adds	r5, r1, #0
    42a6:	1c14      	adds	r4, r2, #0
    uint16_t slot = FindCredential(credType, id, idLen, customCredHolder);
    42a8:	4f07      	ldr	r7, [pc, #28]	; (42c8 <AJ_GetCredential+0x28>)
    42aa:	47b8      	blx	r7
    42ac:	1c07      	adds	r7, r0, #0

    printf("AJ_GetCredential(type=0x%04X, id=0x%p, len=%d)\n", credType, id, idLen);
    42ae:	4807      	ldr	r0, [pc, #28]	; (42cc <AJ_GetCredential+0x2c>)
    42b0:	1c31      	adds	r1, r6, #0
    42b2:	1c2a      	adds	r2, r5, #0
    42b4:	1c23      	adds	r3, r4, #0
    42b6:	4c06      	ldr	r4, [pc, #24]	; (42d0 <AJ_GetCredential+0x30>)
    42b8:	47a0      	blx	r4

    if (slot) 
    42ba:	2f00      	cmp	r7, #0
    42bc:	d101      	bne.n	42c2 <AJ_GetCredential+0x22>
    {
        return AJ_OK;
    }

    return AJ_ERR_FAILURE;
    42be:	2013      	movs	r0, #19
    42c0:	e000      	b.n	42c4 <AJ_GetCredential+0x24>

    printf("AJ_GetCredential(type=0x%04X, id=0x%p, len=%d)\n", credType, id, idLen);

    if (slot) 
    {
        return AJ_OK;
    42c2:	2000      	movs	r0, #0
    }

    return AJ_ERR_FAILURE;
}
    42c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    42c6:	46c0      	nop			; (mov r8, r8)
    42c8:	00004261 	.word	0x00004261
    42cc:	0001b584 	.word	0x0001b584
    42d0:	00016e3d 	.word	0x00016e3d

000042d4 <AJ_StoreCredential>:
    *deleteSlot = oldestslot;
    return AJ_OK;
}

AJ_Status AJ_StoreCredential(AJ_PeerCred* aCred)
{
    42d4:	b538      	push	{r3, r4, r5, lr}
    42d6:	1c04      	adds	r4, r0, #0
    AJ_Status status = AJ_OK;
    uint16_t slot;
    uint32_t len;

    printf("AJ_StoreCredential(aCred=0x%p)\n", aCred);
    42d8:	481e      	ldr	r0, [pc, #120]	; (4354 <AJ_StoreCredential+0x80>)
    42da:	1c21      	adds	r1, r4, #0
    42dc:	4b1e      	ldr	r3, [pc, #120]	; (4358 <AJ_StoreCredential+0x84>)
    42de:	4798      	blx	r3

    slot = FindCredential(aCred->type, aCred->id, aCred->idLen, NULL);
    42e0:	8820      	ldrh	r0, [r4, #0]
    42e2:	78a2      	ldrb	r2, [r4, #2]
    42e4:	6861      	ldr	r1, [r4, #4]
    42e6:	2300      	movs	r3, #0
    42e8:	4d1c      	ldr	r5, [pc, #112]	; (435c <AJ_StoreCredential+0x88>)
    42ea:	47a8      	blx	r5
    42ec:	1e02      	subs	r2, r0, #0
            AJ_InfoPrintf(("AJ_StoreCredential(aCred=0x%p): Remaining %d Required %d Slot %d\n", aCred, AJ_NVRAM_GetSizeRemaining(), len, slot));
            status = AJ_DeleteOldestCredential(&slot);
        }*/
    }

    if (slot) 
    42ee:	d021      	beq.n	4334 <AJ_StoreCredential+0x60>
    AJ_Status status = AJ_OK;
    //AJ_NV_DATASET* handle;
    size_t len;
    size_t size, toWrite;

    printf("UpdateCred(aCred=0x%p, slot=%d)\n", aCred, slot);
    42f0:	481b      	ldr	r0, [pc, #108]	; (4360 <AJ_StoreCredential+0x8c>)
    42f2:	1c21      	adds	r1, r4, #0
    42f4:	4b18      	ldr	r3, [pc, #96]	; (4358 <AJ_StoreCredential+0x84>)
    42f6:	4798      	blx	r3

    if (!aCred) 
    42f8:	2c00      	cmp	r4, #0
    42fa:	d10d      	bne.n	4318 <AJ_StoreCredential+0x44>
    {
        AJ_ErrPrintf(("UpdateCred(): AJ_ERR_FAILURE on null credential\n"));
    42fc:	2001      	movs	r0, #1
    42fe:	4919      	ldr	r1, [pc, #100]	; (4364 <AJ_StoreCredential+0x90>)
    4300:	2244      	movs	r2, #68	; 0x44
    4302:	32ff      	adds	r2, #255	; 0xff
    4304:	4b18      	ldr	r3, [pc, #96]	; (4368 <AJ_StoreCredential+0x94>)
    4306:	4798      	blx	r3
        return AJ_ERR_FAILURE;
    4308:	2313      	movs	r3, #19

    printf("UpdateCred(aCred=0x%p, slot=%d)\n", aCred, slot);

    if (!aCred) 
    {
        AJ_ErrPrintf(("UpdateCred(): AJ_ERR_FAILURE on null credential\n"));
    430a:	2800      	cmp	r0, #0
    430c:	d020      	beq.n	4350 <AJ_StoreCredential+0x7c>
    430e:	4817      	ldr	r0, [pc, #92]	; (436c <AJ_StoreCredential+0x98>)
    4310:	4b17      	ldr	r3, [pc, #92]	; (4370 <AJ_StoreCredential+0x9c>)
    4312:	4798      	blx	r3
        return AJ_ERR_FAILURE;
    4314:	2313      	movs	r3, #19
    4316:	e01b      	b.n	4350 <AJ_StoreCredential+0x7c>
    // Write type 
    toWrite = sizeof(aCred->type);
    //size = AJ_NVRAM_Write(&aCred->type, toWrite, handle);
    if (toWrite != size) 
    {
        AJ_ErrPrintf(("UpdateCred(): AJ_ERR_FAILURE on write failure on type field\n"));
    4318:	2001      	movs	r0, #1
    431a:	4912      	ldr	r1, [pc, #72]	; (4364 <AJ_StoreCredential+0x90>)
    431c:	2254      	movs	r2, #84	; 0x54
    431e:	32ff      	adds	r2, #255	; 0xff
    4320:	4b11      	ldr	r3, [pc, #68]	; (4368 <AJ_StoreCredential+0x94>)
    4322:	4798      	blx	r3

Exit:
    status = AJ_NVRAM_Close(handle);
    status = AJ_ERR_FAILURE;
*/
    return status;
    4324:	2300      	movs	r3, #0
    // Write type 
    toWrite = sizeof(aCred->type);
    //size = AJ_NVRAM_Write(&aCred->type, toWrite, handle);
    if (toWrite != size) 
    {
        AJ_ErrPrintf(("UpdateCred(): AJ_ERR_FAILURE on write failure on type field\n"));
    4326:	2800      	cmp	r0, #0
    4328:	d012      	beq.n	4350 <AJ_StoreCredential+0x7c>
    432a:	4812      	ldr	r0, [pc, #72]	; (4374 <AJ_StoreCredential+0xa0>)
    432c:	4b10      	ldr	r3, [pc, #64]	; (4370 <AJ_StoreCredential+0x9c>)
    432e:	4798      	blx	r3

Exit:
    status = AJ_NVRAM_Close(handle);
    status = AJ_ERR_FAILURE;
*/
    return status;
    4330:	2300      	movs	r3, #0
    4332:	e00d      	b.n	4350 <AJ_StoreCredential+0x7c>
        status = UpdateCred(aCred, slot);
    } 
    else 
    {
        status = AJ_ERR_FAILURE;
        AJ_ErrPrintf(("AJ_StoreCredential(aCred=0x%p): AJ_ERR_FAILURE\n", aCred));
    4334:	2001      	movs	r0, #1
    4336:	490b      	ldr	r1, [pc, #44]	; (4364 <AJ_StoreCredential+0x90>)
    4338:	228b      	movs	r2, #139	; 0x8b
    433a:	0092      	lsls	r2, r2, #2
    433c:	4b0a      	ldr	r3, [pc, #40]	; (4368 <AJ_StoreCredential+0x94>)
    433e:	4798      	blx	r3
    {
        status = UpdateCred(aCred, slot);
    } 
    else 
    {
        status = AJ_ERR_FAILURE;
    4340:	2313      	movs	r3, #19
        AJ_ErrPrintf(("AJ_StoreCredential(aCred=0x%p): AJ_ERR_FAILURE\n", aCred));
    4342:	2800      	cmp	r0, #0
    4344:	d004      	beq.n	4350 <AJ_StoreCredential+0x7c>
    4346:	480c      	ldr	r0, [pc, #48]	; (4378 <AJ_StoreCredential+0xa4>)
    4348:	1c21      	adds	r1, r4, #0
    434a:	4b03      	ldr	r3, [pc, #12]	; (4358 <AJ_StoreCredential+0x84>)
    434c:	4798      	blx	r3
    {
        status = UpdateCred(aCred, slot);
    } 
    else 
    {
        status = AJ_ERR_FAILURE;
    434e:	2313      	movs	r3, #19
        AJ_ErrPrintf(("AJ_StoreCredential(aCred=0x%p): AJ_ERR_FAILURE\n", aCred));
    }

    return status;
}
    4350:	1c18      	adds	r0, r3, #0
    4352:	bd38      	pop	{r3, r4, r5, pc}
    4354:	0001b5b4 	.word	0x0001b5b4
    4358:	00016e3d 	.word	0x00016e3d
    435c:	00004261 	.word	0x00004261
    4360:	0001b5d4 	.word	0x0001b5d4
    4364:	0001b5f8 	.word	0x0001b5f8
    4368:	0000636d 	.word	0x0000636d
    436c:	0001b620 	.word	0x0001b620
    4370:	00016f5d 	.word	0x00016f5d
    4374:	0001b650 	.word	0x0001b650
    4378:	0001b68c 	.word	0x0001b68c

0000437c <AJ_StorePeerSecret>:

AJ_Status AJ_StorePeerSecret(const AJ_GUID* peerGuid, const uint8_t* secret,
                             const uint8_t len, uint32_t expiration)
{
    437c:	b5f0      	push	{r4, r5, r6, r7, lr}
    437e:	b08d      	sub	sp, #52	; 0x34
    4380:	1c06      	adds	r6, r0, #0
    4382:	1c0c      	adds	r4, r1, #0
    4384:	1c15      	adds	r5, r2, #0
    4386:	1c1f      	adds	r7, r3, #0
    AJ_PeerCred cred;
    AJ_Status status;

    printf("AJ_StorePeerSecret(peerGuid=0x%p, secret=0x%p, len=%d, expiration=0x%08X)\n", peerGuid, secret, len, expiration);
    4388:	9300      	str	r3, [sp, #0]
    438a:	480c      	ldr	r0, [pc, #48]	; (43bc <AJ_StorePeerSecret+0x40>)
    438c:	1c31      	adds	r1, r6, #0
    438e:	9403      	str	r4, [sp, #12]
    4390:	1c22      	adds	r2, r4, #0
    4392:	1c2b      	adds	r3, r5, #0
    4394:	4c0a      	ldr	r4, [pc, #40]	; (43c0 <AJ_StorePeerSecret+0x44>)
    4396:	47a0      	blx	r4

    cred.type = AJ_CRED_TYPE_GENERIC;
    4398:	a805      	add	r0, sp, #20
    439a:	2301      	movs	r3, #1
    439c:	8003      	strh	r3, [r0, #0]
    cred.idLen = sizeof(AJ_GUID);
    439e:	330f      	adds	r3, #15
    43a0:	7083      	strb	r3, [r0, #2]
    cred.id = (uint8_t*) peerGuid;
    43a2:	6046      	str	r6, [r0, #4]
    cred.expiration = expiration;
    43a4:	6087      	str	r7, [r0, #8]
    cred.associationLen = 0;
    43a6:	2300      	movs	r3, #0
    43a8:	7303      	strb	r3, [r0, #12]
    cred.association = NULL;
    43aa:	6103      	str	r3, [r0, #16]
    cred.dataLen = len;
    43ac:	8285      	strh	r5, [r0, #20]
    cred.data = (uint8_t*) secret;
    43ae:	9b03      	ldr	r3, [sp, #12]
    43b0:	6183      	str	r3, [r0, #24]
    status = AJ_StoreCredential(&cred);
    43b2:	4b04      	ldr	r3, [pc, #16]	; (43c4 <AJ_StorePeerSecret+0x48>)
    43b4:	4798      	blx	r3

    return status;
}
    43b6:	b00d      	add	sp, #52	; 0x34
    43b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    43ba:	46c0      	nop			; (mov r8, r8)
    43bc:	0001b6bc 	.word	0x0001b6bc
    43c0:	00016e3d 	.word	0x00016e3d
    43c4:	000042d5 	.word	0x000042d5

000043c8 <AJ_DeleteCredential>:

AJ_Status AJ_DeleteCredential(const uint16_t credType, const uint8_t* id, uint8_t idLen)
{
    43c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    43ca:	1c06      	adds	r6, r0, #0
    43cc:	1c0d      	adds	r5, r1, #0
    43ce:	1c14      	adds	r4, r2, #0
    AJ_Status status = AJ_ERR_FAILURE;
    uint16_t slot = FindCredential(credType, id, idLen, NULL);
    43d0:	2300      	movs	r3, #0
    43d2:	4f05      	ldr	r7, [pc, #20]	; (43e8 <AJ_DeleteCredential+0x20>)
    43d4:	47b8      	blx	r7

    printf("AJ_DeleteCredential(type=0x%04X, id=0x%p, len=%d\n", credType, id, idLen);
    43d6:	4805      	ldr	r0, [pc, #20]	; (43ec <AJ_DeleteCredential+0x24>)
    43d8:	1c31      	adds	r1, r6, #0
    43da:	1c2a      	adds	r2, r5, #0
    43dc:	1c23      	adds	r3, r4, #0
    43de:	4c04      	ldr	r4, [pc, #16]	; (43f0 <AJ_DeleteCredential+0x28>)
    43e0:	47a0      	blx	r4
    {
        //status = AJ_NVRAM_Delete(slot);
    }

    return status;
}
    43e2:	2013      	movs	r0, #19
    43e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    43e6:	46c0      	nop			; (mov r8, r8)
    43e8:	00004261 	.word	0x00004261
    43ec:	0001b708 	.word	0x0001b708
    43f0:	00016e3d 	.word	0x00016e3d

000043f4 <AJ_DeletePeerCredential>:

AJ_Status AJ_DeletePeerCredential(const AJ_GUID* peerGuid)
{
    43f4:	b508      	push	{r3, lr}
    43f6:	1c01      	adds	r1, r0, #0
    return AJ_DeleteCredential(AJ_CRED_TYPE_GENERIC, peerGuid->val, sizeof(AJ_GUID));
    43f8:	2001      	movs	r0, #1
    43fa:	2210      	movs	r2, #16
    43fc:	4b01      	ldr	r3, [pc, #4]	; (4404 <AJ_DeletePeerCredential+0x10>)
    43fe:	4798      	blx	r3
}
    4400:	bd08      	pop	{r3, pc}
    4402:	46c0      	nop			; (mov r8, r8)
    4404:	000043c9 	.word	0x000043c9

00004408 <AJ_ClearCredentials>:

AJ_Status AJ_ClearCredentials(void)
{
    4408:	2328      	movs	r3, #40	; 0x28
    440a:	3b01      	subs	r3, #1
    440c:	b29b      	uxth	r3, r3
    AJ_Status status = AJ_OK;
    uint16_t id = AJ_CREDS_NV_ID_BEGIN;

    AJ_InfoPrintf(("AJ_ClearCredentials()\n"));

    for (; id < AJ_CREDS_NV_ID_END; ++id) 
    440e:	2b00      	cmp	r3, #0
    4410:	d1fb      	bne.n	440a <AJ_ClearCredentials+0x2>
            AJ_NVRAM_Delete(id);
        }*/
    }

    return status;
}
    4412:	2000      	movs	r0, #0
    4414:	4770      	bx	lr
    4416:	46c0      	nop			; (mov r8, r8)

00004418 <AJ_GetPeerCredential>:

AJ_Status AJ_GetPeerCredential(const AJ_GUID* peerGuid, AJ_PeerCred** peerCredHolder)
{
    4418:	b510      	push	{r4, lr}
    441a:	1c02      	adds	r2, r0, #0
    441c:	1c0b      	adds	r3, r1, #0
    return AJ_GetCredential(AJ_CRED_TYPE_GENERIC, peerGuid->val, sizeof(peerGuid->val), peerCredHolder);
    441e:	2001      	movs	r0, #1
    4420:	1c11      	adds	r1, r2, #0
    4422:	2210      	movs	r2, #16
    4424:	4c01      	ldr	r4, [pc, #4]	; (442c <AJ_GetPeerCredential+0x14>)
    4426:	47a0      	blx	r4
}
    4428:	bd10      	pop	{r4, pc}
    442a:	46c0      	nop			; (mov r8, r8)
    442c:	000042a1 	.word	0x000042a1

00004430 <AJ_GetLocalGUID>:
    AJ_Status status =AJ_OK;
	// AJ_ERR_FAILURE;
    //AJ_NV_DATASET* handle;

    AJ_InfoPrintf(("AJ_GetLocalGUID(localGuid=0x%p)\n", localGuid));
    localGuid->val[0]=0xbf;
    4430:	23bf      	movs	r3, #191	; 0xbf
    4432:	7003      	strb	r3, [r0, #0]
    localGuid->val[1]=0xa9;
    4434:	3b16      	subs	r3, #22
    4436:	7043      	strb	r3, [r0, #1]
    localGuid->val[2]=0xaa;
    4438:	3301      	adds	r3, #1
    443a:	7083      	strb	r3, [r0, #2]
    localGuid->val[3]=0x3f;
    443c:	3b6b      	subs	r3, #107	; 0x6b
    443e:	70c3      	strb	r3, [r0, #3]
   
    localGuid->val[4]=0x2e;
    4440:	3b11      	subs	r3, #17
    4442:	7103      	strb	r3, [r0, #4]
    localGuid->val[5]=0xce;
    4444:	22ce      	movs	r2, #206	; 0xce
    4446:	7142      	strb	r2, [r0, #5]
    localGuid->val[6]=0x2e;
    4448:	7183      	strb	r3, [r0, #6]
    localGuid->val[7]=0xfd;
    444a:	33cf      	adds	r3, #207	; 0xcf
    444c:	71c3      	strb	r3, [r0, #7]
   
    localGuid->val[8]=0xa2;
    444e:	3b5b      	subs	r3, #91	; 0x5b
    4450:	7203      	strb	r3, [r0, #8]
    localGuid->val[9]=0x1b;
    4452:	3b87      	subs	r3, #135	; 0x87
    4454:	7243      	strb	r3, [r0, #9]
    localGuid->val[10]=0xb5;
    4456:	339a      	adds	r3, #154	; 0x9a
    4458:	7283      	strb	r3, [r0, #10]
    localGuid->val[11]=0xb1;
    445a:	3b04      	subs	r3, #4
    445c:	72c3      	strb	r3, [r0, #11]
   
    localGuid->val[12]=0x63;
    445e:	3b4e      	subs	r3, #78	; 0x4e
    4460:	7303      	strb	r3, [r0, #12]
    localGuid->val[13]=0x2b;
    4462:	3b38      	subs	r3, #56	; 0x38
    4464:	7343      	strb	r3, [r0, #13]
    localGuid->val[14]=0x4f;
    4466:	3324      	adds	r3, #36	; 0x24
    4468:	7383      	strb	r3, [r0, #14]
    localGuid->val[15]=0x77;
    446a:	3328      	adds	r3, #40	; 0x28
    446c:	73c3      	strb	r3, [r0, #15]
            status = AJ_NVRAM_Close(handle);
        }
    }
*/
    return status;
}
    446e:	2000      	movs	r0, #0
    4470:	4770      	bx	lr
    4472:	46c0      	nop			; (mov r8, r8)

00004474 <AJ_FreeCredential>:

AJ_Status AJ_FreeCredential(AJ_PeerCred* cred)
{
    4474:	b510      	push	{r4, lr}
    if (!cred) 
    4476:	2800      	cmp	r0, #0
    4478:	d02a      	beq.n	44d0 <AJ_FreeCredential+0x5c>
    447a:	1c04      	adds	r4, r0, #0
{
    if (!cred) 
    {
        return AJ_OK;
    }
    if ((cred->idLen > 0) && cred->id) 
    447c:	7881      	ldrb	r1, [r0, #2]
    447e:	2900      	cmp	r1, #0
    4480:	d009      	beq.n	4496 <AJ_FreeCredential+0x22>
    4482:	6840      	ldr	r0, [r0, #4]
    4484:	2800      	cmp	r0, #0
    4486:	d006      	beq.n	4496 <AJ_FreeCredential+0x22>
    {
        AJ_MemZeroSecure(cred->id, cred->idLen);
    4488:	4b12      	ldr	r3, [pc, #72]	; (44d4 <AJ_FreeCredential+0x60>)
    448a:	4798      	blx	r3
        AJ_Free(cred->id);
    448c:	6860      	ldr	r0, [r4, #4]
    448e:	4b12      	ldr	r3, [pc, #72]	; (44d8 <AJ_FreeCredential+0x64>)
    4490:	4798      	blx	r3
        cred->idLen = 0;
    4492:	2300      	movs	r3, #0
    4494:	70a3      	strb	r3, [r4, #2]
    }
    if ((cred->associationLen > 0) && cred->association) 
    4496:	7b21      	ldrb	r1, [r4, #12]
    4498:	2900      	cmp	r1, #0
    449a:	d009      	beq.n	44b0 <AJ_FreeCredential+0x3c>
    449c:	6920      	ldr	r0, [r4, #16]
    449e:	2800      	cmp	r0, #0
    44a0:	d006      	beq.n	44b0 <AJ_FreeCredential+0x3c>
    {
        AJ_MemZeroSecure(cred->association, cred->associationLen);
    44a2:	4b0c      	ldr	r3, [pc, #48]	; (44d4 <AJ_FreeCredential+0x60>)
    44a4:	4798      	blx	r3
        AJ_Free(cred->association);
    44a6:	6920      	ldr	r0, [r4, #16]
    44a8:	4b0b      	ldr	r3, [pc, #44]	; (44d8 <AJ_FreeCredential+0x64>)
    44aa:	4798      	blx	r3
        cred->associationLen = 0;
    44ac:	2300      	movs	r3, #0
    44ae:	7323      	strb	r3, [r4, #12]
    }
    if ((cred->dataLen > 0) && cred->data) 
    44b0:	8aa1      	ldrh	r1, [r4, #20]
    44b2:	2900      	cmp	r1, #0
    44b4:	d009      	beq.n	44ca <AJ_FreeCredential+0x56>
    44b6:	69a0      	ldr	r0, [r4, #24]
    44b8:	2800      	cmp	r0, #0
    44ba:	d006      	beq.n	44ca <AJ_FreeCredential+0x56>
    {
        AJ_MemZeroSecure(cred->data, cred->dataLen);
    44bc:	4b05      	ldr	r3, [pc, #20]	; (44d4 <AJ_FreeCredential+0x60>)
    44be:	4798      	blx	r3
        AJ_Free(cred->data);
    44c0:	69a0      	ldr	r0, [r4, #24]
    44c2:	4b05      	ldr	r3, [pc, #20]	; (44d8 <AJ_FreeCredential+0x64>)
    44c4:	4798      	blx	r3
        cred->dataLen = 0;
    44c6:	2300      	movs	r3, #0
    44c8:	82a3      	strh	r3, [r4, #20]
    if (!cred) 
    {
        return AJ_OK;
    }
    FreeCredentialContent(cred);
    AJ_Free(cred);
    44ca:	1c20      	adds	r0, r4, #0
    44cc:	4b02      	ldr	r3, [pc, #8]	; (44d8 <AJ_FreeCredential+0x64>)
    44ce:	4798      	blx	r3

    return AJ_OK;
}
    44d0:	2000      	movs	r0, #0
    44d2:	bd10      	pop	{r4, pc}
    44d4:	0000d71d 	.word	0x0000d71d
    44d8:	0000d7e9 	.word	0x0000d7e9

000044dc <AJ_CredentialExpired>:
{
    return AJ_DeleteCredential(credType, (const uint8_t*) &id, sizeof(id));
}

AJ_Status AJ_CredentialExpired(AJ_PeerCred* cred)
{
    44dc:	b510      	push	{r4, lr}
    44de:	b082      	sub	sp, #8
    44e0:	1c04      	adds	r4, r0, #0
    AJ_Time now;

    AJ_InitTimer(&now);
    44e2:	4668      	mov	r0, sp
    44e4:	4b06      	ldr	r3, [pc, #24]	; (4500 <AJ_CredentialExpired+0x24>)
    44e6:	4798      	blx	r3
    if (now.seconds == 0) 
    44e8:	9b01      	ldr	r3, [sp, #4]
    {
        // don't know the current time so can't check the credential expriy 
        return AJ_ERR_INVALID;
    44ea:	2003      	movs	r0, #3
AJ_Status AJ_CredentialExpired(AJ_PeerCred* cred)
{
    AJ_Time now;

    AJ_InitTimer(&now);
    if (now.seconds == 0) 
    44ec:	2b00      	cmp	r3, #0
    44ee:	d005      	beq.n	44fc <AJ_CredentialExpired+0x20>
    {
        // don't know the current time so can't check the credential expriy 
        return AJ_ERR_INVALID;
    }

    if (cred->expiration > now.seconds) 
    44f0:	68a2      	ldr	r2, [r4, #8]
    44f2:	4293      	cmp	r3, r2
    44f4:	d301      	bcc.n	44fa <AJ_CredentialExpired+0x1e>
    {
        return AJ_OK;
    }

    return AJ_ERR_KEY_EXPIRED; /* expires */
    44f6:	3020      	adds	r0, #32
    44f8:	e000      	b.n	44fc <AJ_CredentialExpired+0x20>
        return AJ_ERR_INVALID;
    }

    if (cred->expiration > now.seconds) 
    {
        return AJ_OK;
    44fa:	2000      	movs	r0, #0
    }

    return AJ_ERR_KEY_EXPIRED; /* expires */
}
    44fc:	b002      	add	sp, #8
    44fe:	bd10      	pop	{r4, pc}
    4500:	0000d7ad 	.word	0x0000d7ad

00004504 <AES_CTR_DRBG_Increment>:
 * NIST SP 800-90A standard, which can be found at
 * http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf
 */

static void AES_CTR_DRBG_Increment(uint8_t* data, size_t size)
{
    4504:	3901      	subs	r1, #1
    4506:	1841      	adds	r1, r0, r1
    4508:	3801      	subs	r0, #1
    while (size--) 
    450a:	e006      	b.n	451a <AES_CTR_DRBG_Increment+0x16>
	{
        data[size]++;
    450c:	780b      	ldrb	r3, [r1, #0]
    450e:	3301      	adds	r3, #1
    4510:	b2db      	uxtb	r3, r3
    4512:	700b      	strb	r3, [r1, #0]
    4514:	3901      	subs	r1, #1
        if (data[size]) 
    4516:	2b00      	cmp	r3, #0
    4518:	d101      	bne.n	451e <AES_CTR_DRBG_Increment+0x1a>
 * http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf
 */

static void AES_CTR_DRBG_Increment(uint8_t* data, size_t size)
{
    while (size--) 
    451a:	4281      	cmp	r1, r0
    451c:	d1f6      	bne.n	450c <AES_CTR_DRBG_Increment+0x8>
        if (data[size]) 
		{
            break;
        }
    }
}
    451e:	4770      	bx	lr

00004520 <InitCCMContext>:
    }
    Trace("CBC-MAC", context->T.data, context->M);
}

static CCM_Context* InitCCMContext(const uint8_t* nonce, uint32_t nLen, uint32_t hdrLen, uint32_t msgLen, uint8_t M)
{
    4520:	b5f0      	push	{r4, r5, r6, r7, lr}
    4522:	4657      	mov	r7, sl
    4524:	4646      	mov	r6, r8
    4526:	b4c0      	push	{r6, r7}
    4528:	b083      	sub	sp, #12
    452a:	9001      	str	r0, [sp, #4]
    452c:	1c0d      	adds	r5, r1, #0
    452e:	1c14      	adds	r4, r2, #0
    4530:	4698      	mov	r8, r3
    4532:	ab0a      	add	r3, sp, #40	; 0x28
    4534:	781a      	ldrb	r2, [r3, #0]
    int i;
    int l;
    uint8_t L  = 15 - max(nLen, 11);
    4536:	1e0f      	subs	r7, r1, #0
    4538:	2f0b      	cmp	r7, #11
    453a:	d200      	bcs.n	453e <InitCCMContext+0x1e>
    453c:	270b      	movs	r7, #11
    uint8_t flags = ((hdrLen) ? 0x40 : 0) | (((M - 2) / 2) << 3) | (L - 1);
    453e:	1c23      	adds	r3, r4, #0
    4540:	1e59      	subs	r1, r3, #1
    4542:	418b      	sbcs	r3, r1
    4544:	0199      	lsls	r1, r3, #6
    4546:	230e      	movs	r3, #14
    4548:	1bdf      	subs	r7, r3, r7
    454a:	b2ff      	uxtb	r7, r7
    454c:	1e93      	subs	r3, r2, #2
    454e:	0fda      	lsrs	r2, r3, #31
    4550:	18d3      	adds	r3, r2, r3
    4552:	105b      	asrs	r3, r3, #1
    4554:	00db      	lsls	r3, r3, #3
    4556:	433b      	orrs	r3, r7
    4558:	430b      	orrs	r3, r1
    455a:	b2db      	uxtb	r3, r3
    455c:	469a      	mov	sl, r3
    CCM_Context* context;

    AJ_ASSERT(nLen <= 15);
    455e:	2d0f      	cmp	r5, #15
    4560:	d905      	bls.n	456e <InitCCMContext+0x4e>
    4562:	4817      	ldr	r0, [pc, #92]	; (45c0 <InitCCMContext+0xa0>)
    4564:	2192      	movs	r1, #146	; 0x92
    4566:	4a17      	ldr	r2, [pc, #92]	; (45c4 <InitCCMContext+0xa4>)
    4568:	4b17      	ldr	r3, [pc, #92]	; (45c8 <InitCCMContext+0xa8>)
    456a:	4c18      	ldr	r4, [pc, #96]	; (45cc <InitCCMContext+0xac>)
    456c:	47a0      	blx	r4

    context = (CCM_Context*)AJ_Malloc(sizeof(CCM_Context));
    456e:	2040      	movs	r0, #64	; 0x40
    4570:	4b17      	ldr	r3, [pc, #92]	; (45d0 <InitCCMContext+0xb0>)
    4572:	4798      	blx	r3
    4574:	1e06      	subs	r6, r0, #0
    if (context) 
    4576:	d01d      	beq.n	45b4 <InitCCMContext+0x94>
	{
        memset(context, 0, sizeof(CCM_Context));
    4578:	2100      	movs	r1, #0
    457a:	2240      	movs	r2, #64	; 0x40
    457c:	4b15      	ldr	r3, [pc, #84]	; (45d4 <InitCCMContext+0xb4>)
    457e:	4798      	blx	r3
        // Set ivec and other initial args.
        context->ivec.data[0] = L - 1;
    4580:	2320      	movs	r3, #32
    4582:	54f7      	strb	r7, [r6, r3]
        memcpy(&context->ivec.data[1], nonce, nLen);
    4584:	1c30      	adds	r0, r6, #0
    4586:	3021      	adds	r0, #33	; 0x21
    4588:	9901      	ldr	r1, [sp, #4]
    458a:	1c2a      	adds	r2, r5, #0
    458c:	4f12      	ldr	r7, [pc, #72]	; (45d8 <InitCCMContext+0xb8>)
    458e:	47b8      	blx	r7
        // Compute the B_0 block. This encodes the flags, the nonce, and the message length.
        context->B_0.data[0] = flags;
    4590:	2330      	movs	r3, #48	; 0x30
    4592:	4652      	mov	r2, sl
    4594:	54f2      	strb	r2, [r6, r3]
        memcpy(&context->B_0.data[1], nonce, nLen);
    4596:	1c30      	adds	r0, r6, #0
    4598:	3031      	adds	r0, #49	; 0x31
    459a:	9901      	ldr	r1, [sp, #4]
    459c:	1c2a      	adds	r2, r5, #0
    459e:	47b8      	blx	r7
        for (i = 15, l = msgLen - hdrLen; l != 0; i--) 
    45a0:	4643      	mov	r3, r8
    45a2:	1b1b      	subs	r3, r3, r4
    45a4:	d006      	beq.n	45b4 <InitCCMContext+0x94>
    45a6:	1c32      	adds	r2, r6, #0
    45a8:	323f      	adds	r2, #63	; 0x3f
		{
            context->B_0.data[i] = (uint8_t)l;
    45aa:	7013      	strb	r3, [r2, #0]
            l >>= 8;
    45ac:	121b      	asrs	r3, r3, #8
    45ae:	3a01      	subs	r2, #1
        context->ivec.data[0] = L - 1;
        memcpy(&context->ivec.data[1], nonce, nLen);
        // Compute the B_0 block. This encodes the flags, the nonce, and the message length.
        context->B_0.data[0] = flags;
        memcpy(&context->B_0.data[1], nonce, nLen);
        for (i = 15, l = msgLen - hdrLen; l != 0; i--) 
    45b0:	2b00      	cmp	r3, #0
    45b2:	d1fa      	bne.n	45aa <InitCCMContext+0x8a>
            context->B_0.data[i] = (uint8_t)l;
            l >>= 8;
        }
    }
    return context;
}
    45b4:	1c30      	adds	r0, r6, #0
    45b6:	b003      	add	sp, #12
    45b8:	bc0c      	pop	{r2, r3}
    45ba:	4690      	mov	r8, r2
    45bc:	469a      	mov	sl, r3
    45be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    45c0:	0001b7b8 	.word	0x0001b7b8
    45c4:	0001b794 	.word	0x0001b794
    45c8:	0001b7e4 	.word	0x0001b7e4
    45cc:	00016629 	.word	0x00016629
    45d0:	0000d7dd 	.word	0x0000d7dd
    45d4:	00016773 	.word	0x00016773
    45d8:	00016739 	.word	0x00016739

000045dc <CBC_MAC>:
/**
 * Compute the CBC MAC over some data
 */

static void CBC_MAC(const uint8_t* key, const uint8_t* in, uint32_t len, CCM_Context* context)
{
    45dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    45de:	4657      	mov	r7, sl
    45e0:	4646      	mov	r6, r8
    45e2:	b4c0      	push	{r6, r7}
    45e4:	b085      	sub	sp, #20
    45e6:	9002      	str	r0, [sp, #8]
    45e8:	468a      	mov	sl, r1
    45ea:	4690      	mov	r8, r2
    45ec:	9303      	str	r3, [sp, #12]
    while (len >= AJ_BLOCKSZ) 
    45ee:	2a0f      	cmp	r2, #15
    45f0:	d918      	bls.n	4624 <CBC_MAC+0x48>
    45f2:	4645      	mov	r5, r8
    45f4:	1c0c      	adds	r4, r1, #0
	{
        AJ_AES_CBC_128_ENCRYPT(key, in, context->T.data, AJ_BLOCKSZ, context->ivec0.data);
    45f6:	1c1f      	adds	r7, r3, #0
    45f8:	3710      	adds	r7, #16
    45fa:	4e19      	ldr	r6, [pc, #100]	; (4660 <CBC_MAC+0x84>)
    45fc:	9700      	str	r7, [sp, #0]
    45fe:	9802      	ldr	r0, [sp, #8]
    4600:	1c21      	adds	r1, r4, #0
    4602:	9a03      	ldr	r2, [sp, #12]
    4604:	2310      	movs	r3, #16
    4606:	47b0      	blx	r6
        Trace("After AES", context->T.data, AJ_BLOCKSZ);
        in += AJ_BLOCKSZ;
    4608:	3410      	adds	r4, #16
        len -= AJ_BLOCKSZ;
    460a:	3d10      	subs	r5, #16
 * Compute the CBC MAC over some data
 */

static void CBC_MAC(const uint8_t* key, const uint8_t* in, uint32_t len, CCM_Context* context)
{
    while (len >= AJ_BLOCKSZ) 
    460c:	2d0f      	cmp	r5, #15
    460e:	d8f5      	bhi.n	45fc <CBC_MAC+0x20>
    4610:	4643      	mov	r3, r8
    4612:	3b10      	subs	r3, #16
    4614:	091b      	lsrs	r3, r3, #4
    4616:	3301      	adds	r3, #1
    4618:	011b      	lsls	r3, r3, #4
    461a:	449a      	add	sl, r3
    461c:	230f      	movs	r3, #15
    461e:	4642      	mov	r2, r8
    4620:	401a      	ands	r2, r3
    4622:	4690      	mov	r8, r2
        AJ_AES_CBC_128_ENCRYPT(key, in, context->T.data, AJ_BLOCKSZ, context->ivec0.data);
        Trace("After AES", context->T.data, AJ_BLOCKSZ);
        in += AJ_BLOCKSZ;
        len -= AJ_BLOCKSZ;
    }
    if (len)
    4624:	4643      	mov	r3, r8
    4626:	2b00      	cmp	r3, #0
    4628:	d015      	beq.n	4656 <CBC_MAC+0x7a>
	{
        ZERO(context->A);
    462a:	9d03      	ldr	r5, [sp, #12]
    462c:	1c2c      	adds	r4, r5, #0
    462e:	3430      	adds	r4, #48	; 0x30
    4630:	1c20      	adds	r0, r4, #0
    4632:	2100      	movs	r1, #0
    4634:	2210      	movs	r2, #16
    4636:	4b0b      	ldr	r3, [pc, #44]	; (4664 <CBC_MAC+0x88>)
    4638:	4798      	blx	r3
        memcpy(context->A.data, in, len);
    463a:	1c20      	adds	r0, r4, #0
    463c:	4651      	mov	r1, sl
    463e:	4642      	mov	r2, r8
    4640:	4b09      	ldr	r3, [pc, #36]	; (4668 <CBC_MAC+0x8c>)
    4642:	4798      	blx	r3
        AJ_AES_CBC_128_ENCRYPT(key, context->A.data, context->T.data, AJ_BLOCKSZ, context->ivec0.data);
    4644:	1c2b      	adds	r3, r5, #0
    4646:	3310      	adds	r3, #16
    4648:	9300      	str	r3, [sp, #0]
    464a:	9802      	ldr	r0, [sp, #8]
    464c:	1c21      	adds	r1, r4, #0
    464e:	1c2a      	adds	r2, r5, #0
    4650:	2310      	movs	r3, #16
    4652:	4c03      	ldr	r4, [pc, #12]	; (4660 <CBC_MAC+0x84>)
    4654:	47a0      	blx	r4
        Trace("After AES", context->T.data, AJ_BLOCKSZ);
    }
}
    4656:	b005      	add	sp, #20
    4658:	bc0c      	pop	{r2, r3}
    465a:	4690      	mov	r8, r2
    465c:	469a      	mov	sl, r3
    465e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4660:	0000d599 	.word	0x0000d599
    4664:	00016773 	.word	0x00016773
    4668:	00016739 	.word	0x00016739

0000466c <Compute_CCM_AuthTag>:
static void Compute_CCM_AuthTag(const uint8_t* key,
                                CCM_Context* context,
                                const uint8_t* msg,
                                uint32_t mLen,
                                uint32_t hdrLen)
{
    466c:	b5f0      	push	{r4, r5, r6, r7, lr}
    466e:	4657      	mov	r7, sl
    4670:	464e      	mov	r6, r9
    4672:	4645      	mov	r5, r8
    4674:	b4e0      	push	{r5, r6, r7}
    4676:	b084      	sub	sp, #16
    4678:	9002      	str	r0, [sp, #8]
    467a:	1c0c      	adds	r4, r1, #0
    467c:	9203      	str	r2, [sp, #12]
    467e:	1c1f      	adds	r7, r3, #0
    // Initialize CBC-MAC with B_0 initialization vector is 0.
    Trace("CBC IV in", context->B_0.data, AJ_BLOCKSZ);
    AJ_AES_CBC_128_ENCRYPT(key, context->B_0.data, context->T.data, AJ_BLOCKSZ, context->ivec0.data);
    4680:	1c0e      	adds	r6, r1, #0
    4682:	3630      	adds	r6, #48	; 0x30
    4684:	2310      	movs	r3, #16
    4686:	4699      	mov	r9, r3
    4688:	4489      	add	r9, r1
    468a:	464b      	mov	r3, r9
    468c:	9300      	str	r3, [sp, #0]
    468e:	1c31      	adds	r1, r6, #0
    4690:	1c22      	adds	r2, r4, #0
    4692:	2310      	movs	r3, #16
    4694:	4d21      	ldr	r5, [pc, #132]	; (471c <Compute_CCM_AuthTag+0xb0>)
    4696:	47a8      	blx	r5
    Trace("CBC IV out", context->T.data, AJ_BLOCKSZ);
    // Compute CBC-MAC for the add data.
   if (hdrLen) 
    4698:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    469a:	2b00      	cmp	r3, #0
    469c:	d02f      	beq.n	46fe <Compute_CCM_AuthTag+0x92>
   {
        uint32_t firstFew;
        // This encodes the header data length and the first few bytes of the header data
        ZERO(context->A);
    469e:	1c30      	adds	r0, r6, #0
    46a0:	2100      	movs	r1, #0
    46a2:	2210      	movs	r2, #16
    46a4:	4b1e      	ldr	r3, [pc, #120]	; (4720 <Compute_CCM_AuthTag+0xb4>)
    46a6:	4798      	blx	r3
        context->A.data[0] = (uint8_t)(hdrLen >> 8);
    46a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    46aa:	0a1a      	lsrs	r2, r3, #8
    46ac:	2330      	movs	r3, #48	; 0x30
    46ae:	54e2      	strb	r2, [r4, r3]
        context->A.data[1] = (uint8_t)(hdrLen >> 0);
    46b0:	3301      	adds	r3, #1
    46b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    46b4:	54e2      	strb	r2, [r4, r3]
        firstFew = min(hdrLen, 14);
    46b6:	4692      	mov	sl, r2
    46b8:	2a0e      	cmp	r2, #14
    46ba:	d901      	bls.n	46c0 <Compute_CCM_AuthTag+0x54>
    46bc:	230e      	movs	r3, #14
    46be:	469a      	mov	sl, r3
        memcpy(&context->A.data[2], msg, firstFew);
    46c0:	1c20      	adds	r0, r4, #0
    46c2:	3032      	adds	r0, #50	; 0x32
    46c4:	9d03      	ldr	r5, [sp, #12]
    46c6:	1c29      	adds	r1, r5, #0
    46c8:	4652      	mov	r2, sl
    46ca:	4b16      	ldr	r3, [pc, #88]	; (4724 <Compute_CCM_AuthTag+0xb8>)
    46cc:	4798      	blx	r3
        // Adjust for the hdr data bytes that were encoded in the length block
        msg += firstFew;
    46ce:	1c2b      	adds	r3, r5, #0
    46d0:	4453      	add	r3, sl
    46d2:	1c1d      	adds	r5, r3, #0
        hdrLen -= firstFew;
    46d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    46d6:	4652      	mov	r2, sl
    46d8:	1a9b      	subs	r3, r3, r2
    46da:	4698      	mov	r8, r3
        // Continue the MAC by encrypting the length block
        Trace("Before AES", context->A.data, AJ_BLOCKSZ);
        AJ_AES_CBC_128_ENCRYPT(key, context->A.data, context->T.data, AJ_BLOCKSZ, context->ivec0.data);
    46dc:	464b      	mov	r3, r9
    46de:	9300      	str	r3, [sp, #0]
    46e0:	9802      	ldr	r0, [sp, #8]
    46e2:	1c31      	adds	r1, r6, #0
    46e4:	1c22      	adds	r2, r4, #0
    46e6:	2310      	movs	r3, #16
    46e8:	4e0c      	ldr	r6, [pc, #48]	; (471c <Compute_CCM_AuthTag+0xb0>)
    46ea:	47b0      	blx	r6
        Trace("After AES", context->T.data, AJ_BLOCKSZ);
        // Continue computing the CBC-MAC
        CBC_MAC(key, msg, hdrLen, context);
    46ec:	9802      	ldr	r0, [sp, #8]
    46ee:	1c29      	adds	r1, r5, #0
    46f0:	4642      	mov	r2, r8
    46f2:	1c23      	adds	r3, r4, #0
    46f4:	4e0c      	ldr	r6, [pc, #48]	; (4728 <Compute_CCM_AuthTag+0xbc>)
    46f6:	47b0      	blx	r6
        msg += hdrLen;
    46f8:	1c2b      	adds	r3, r5, #0
    46fa:	4443      	add	r3, r8
    46fc:	9303      	str	r3, [sp, #12]
    }
    // Continue computing CBC-MAC over the message data.
    if (mLen) 
    46fe:	2f00      	cmp	r7, #0
    4700:	d005      	beq.n	470e <Compute_CCM_AuthTag+0xa2>
	{
        CBC_MAC(key, msg, mLen, context);
    4702:	9802      	ldr	r0, [sp, #8]
    4704:	9903      	ldr	r1, [sp, #12]
    4706:	1c3a      	adds	r2, r7, #0
    4708:	1c23      	adds	r3, r4, #0
    470a:	4c07      	ldr	r4, [pc, #28]	; (4728 <Compute_CCM_AuthTag+0xbc>)
    470c:	47a0      	blx	r4
    }
    Trace("CBC-MAC", context->T.data, context->M);
}
    470e:	b004      	add	sp, #16
    4710:	bc1c      	pop	{r2, r3, r4}
    4712:	4690      	mov	r8, r2
    4714:	4699      	mov	r9, r3
    4716:	46a2      	mov	sl, r4
    4718:	bdf0      	pop	{r4, r5, r6, r7, pc}
    471a:	46c0      	nop			; (mov r8, r8)
    471c:	0000d599 	.word	0x0000d599
    4720:	00016773 	.word	0x00016773
    4724:	00016739 	.word	0x00016739
    4728:	000045dd 	.word	0x000045dd

0000472c <AES_CTR_DRBG_BCC>:
    memcpy(ctx->k, tmp, KEYLEN);
    memcpy(ctx->v, tmp + KEYLEN, OUTLEN);
}

static void AES_CTR_DRBG_BCC(uint8_t* k, uint8_t* data, size_t size, uint8_t* out)
{
    472c:	b5f0      	push	{r4, r5, r6, r7, lr}
    472e:	4647      	mov	r7, r8
    4730:	b480      	push	{r7}
    4732:	b082      	sub	sp, #8
    4734:	9001      	str	r0, [sp, #4]
    4736:	1c0e      	adds	r6, r1, #0
    4738:	4690      	mov	r8, r2
    473a:	1c1c      	adds	r4, r3, #0
    size_t i;
    size_t j;

    AJ_ASSERT(0 == (size % OUTLEN));
    473c:	1c13      	adds	r3, r2, #0
    473e:	071b      	lsls	r3, r3, #28
    4740:	d006      	beq.n	4750 <AES_CTR_DRBG_BCC+0x24>
    4742:	4815      	ldr	r0, [pc, #84]	; (4798 <AES_CTR_DRBG_BCC+0x6c>)
    4744:	2170      	movs	r1, #112	; 0x70
    4746:	31ff      	adds	r1, #255	; 0xff
    4748:	4a14      	ldr	r2, [pc, #80]	; (479c <AES_CTR_DRBG_BCC+0x70>)
    474a:	4b15      	ldr	r3, [pc, #84]	; (47a0 <AES_CTR_DRBG_BCC+0x74>)
    474c:	4c15      	ldr	r4, [pc, #84]	; (47a4 <AES_CTR_DRBG_BCC+0x78>)
    474e:	47a0      	blx	r4
    memset(out, 0, OUTLEN);
    4750:	1c20      	adds	r0, r4, #0
    4752:	2100      	movs	r1, #0
    4754:	2210      	movs	r2, #16
    4756:	4b14      	ldr	r3, [pc, #80]	; (47a8 <AES_CTR_DRBG_BCC+0x7c>)
    4758:	4798      	blx	r3

    AJ_AES_Enable(k);
    475a:	9801      	ldr	r0, [sp, #4]
    475c:	4b13      	ldr	r3, [pc, #76]	; (47ac <AES_CTR_DRBG_BCC+0x80>)
    475e:	4798      	blx	r3
    for (i = 0; i < size; i += OUTLEN) 
    4760:	1c37      	adds	r7, r6, #0
    4762:	4643      	mov	r3, r8
    4764:	2b00      	cmp	r3, #0
    4766:	d110      	bne.n	478a <AES_CTR_DRBG_BCC+0x5e>
    4768:	e012      	b.n	4790 <AES_CTR_DRBG_BCC+0x64>
	{
        for (j = 0; j < OUTLEN; j++) 
		{
            out[j] ^= data[j];
    476a:	5cf9      	ldrb	r1, [r7, r3]
    476c:	5ce2      	ldrb	r2, [r4, r3]
    476e:	404a      	eors	r2, r1
    4770:	54e2      	strb	r2, [r4, r3]
    memset(out, 0, OUTLEN);

    AJ_AES_Enable(k);
    for (i = 0; i < size; i += OUTLEN) 
	{
        for (j = 0; j < OUTLEN; j++) 
    4772:	3301      	adds	r3, #1
    4774:	2b10      	cmp	r3, #16
    4776:	d1f8      	bne.n	476a <AES_CTR_DRBG_BCC+0x3e>
		{
            out[j] ^= data[j];
        }
        AJ_AES_ECB_128_ENCRYPT(k, out, out);
    4778:	9801      	ldr	r0, [sp, #4]
    477a:	1c21      	adds	r1, r4, #0
    477c:	1c22      	adds	r2, r4, #0
    477e:	47a8      	blx	r5
        data += OUTLEN;
    4780:	3710      	adds	r7, #16
    4782:	1bbb      	subs	r3, r7, r6

    AJ_ASSERT(0 == (size % OUTLEN));
    memset(out, 0, OUTLEN);

    AJ_AES_Enable(k);
    for (i = 0; i < size; i += OUTLEN) 
    4784:	4598      	cmp	r8, r3
    4786:	d801      	bhi.n	478c <AES_CTR_DRBG_BCC+0x60>
    4788:	e002      	b.n	4790 <AES_CTR_DRBG_BCC+0x64>
	{
        for (j = 0; j < OUTLEN; j++) 
		{
            out[j] ^= data[j];
        }
        AJ_AES_ECB_128_ENCRYPT(k, out, out);
    478a:	4d09      	ldr	r5, [pc, #36]	; (47b0 <AES_CTR_DRBG_BCC+0x84>)
    memcpy(ctx->k, tmp, KEYLEN);
    memcpy(ctx->v, tmp + KEYLEN, OUTLEN);
}

static void AES_CTR_DRBG_BCC(uint8_t* k, uint8_t* data, size_t size, uint8_t* out)
{
    478c:	2300      	movs	r3, #0
    478e:	e7ec      	b.n	476a <AES_CTR_DRBG_BCC+0x3e>
            out[j] ^= data[j];
        }
        AJ_AES_ECB_128_ENCRYPT(k, out, out);
        data += OUTLEN;
    }
}
    4790:	b002      	add	sp, #8
    4792:	bc04      	pop	{r2}
    4794:	4690      	mov	r8, r2
    4796:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4798:	0001b7b8 	.word	0x0001b7b8
    479c:	0001b918 	.word	0x0001b918
    47a0:	0001b7f0 	.word	0x0001b7f0
    47a4:	00016629 	.word	0x00016629
    47a8:	00016773 	.word	0x00016773
    47ac:	0000d44d 	.word	0x0000d44d
    47b0:	0000d63d 	.word	0x0000d63d

000047b4 <AES_CTR_DRBG_Update>:
        }
    }
}

static void AES_CTR_DRBG_Update(CTR_DRBG_CTX* ctx, uint8_t data[SEEDLEN])
{
    47b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    47b6:	4647      	mov	r7, r8
    47b8:	b480      	push	{r7}
    47ba:	b088      	sub	sp, #32
    47bc:	1c04      	adds	r4, r0, #0
    47be:	1c0e      	adds	r6, r1, #0
    size_t i = 0;
    uint8_t tmp[SEEDLEN];
    uint8_t* t = tmp;

    AJ_AES_Enable(ctx->k);
    47c0:	1c05      	adds	r5, r0, #0
    47c2:	3511      	adds	r5, #17
    47c4:	1c28      	adds	r0, r5, #0
    47c6:	4b15      	ldr	r3, [pc, #84]	; (481c <AES_CTR_DRBG_Update+0x68>)
    47c8:	4798      	blx	r3
    for (i = 0; i < SEEDLEN; i += OUTLEN) 
	{
        AES_CTR_DRBG_Increment(ctx->v, OUTLEN);
    47ca:	3401      	adds	r4, #1
    47cc:	1c20      	adds	r0, r4, #0
    47ce:	2110      	movs	r1, #16
    47d0:	4b13      	ldr	r3, [pc, #76]	; (4820 <AES_CTR_DRBG_Update+0x6c>)
    47d2:	4698      	mov	r8, r3
    47d4:	4798      	blx	r3
        AJ_AES_ECB_128_ENCRYPT(ctx->k, ctx->v, t);
    47d6:	1c28      	adds	r0, r5, #0
    47d8:	1c21      	adds	r1, r4, #0
    47da:	466a      	mov	r2, sp
    47dc:	4f11      	ldr	r7, [pc, #68]	; (4824 <AES_CTR_DRBG_Update+0x70>)
    47de:	47b8      	blx	r7
    uint8_t* t = tmp;

    AJ_AES_Enable(ctx->k);
    for (i = 0; i < SEEDLEN; i += OUTLEN) 
	{
        AES_CTR_DRBG_Increment(ctx->v, OUTLEN);
    47e0:	1c20      	adds	r0, r4, #0
    47e2:	2110      	movs	r1, #16
    47e4:	47c0      	blx	r8
        AJ_AES_ECB_128_ENCRYPT(ctx->k, ctx->v, t);
    47e6:	1c28      	adds	r0, r5, #0
    47e8:	1c21      	adds	r1, r4, #0
    47ea:	aa04      	add	r2, sp, #16
    47ec:	47b8      	blx	r7
    47ee:	2300      	movs	r3, #0
        t += OUTLEN;
    }

    for (i = 0; i < SEEDLEN; i++)
	{
        tmp[i] ^= data[i];
    47f0:	5cf1      	ldrb	r1, [r6, r3]
    47f2:	466a      	mov	r2, sp
    47f4:	5c9a      	ldrb	r2, [r3, r2]
    47f6:	404a      	eors	r2, r1
    47f8:	4669      	mov	r1, sp
    47fa:	545a      	strb	r2, [r3, r1]
        AES_CTR_DRBG_Increment(ctx->v, OUTLEN);
        AJ_AES_ECB_128_ENCRYPT(ctx->k, ctx->v, t);
        t += OUTLEN;
    }

    for (i = 0; i < SEEDLEN; i++)
    47fc:	3301      	adds	r3, #1
    47fe:	2b20      	cmp	r3, #32
    4800:	d1f6      	bne.n	47f0 <AES_CTR_DRBG_Update+0x3c>
	{
        tmp[i] ^= data[i];
    }

    memcpy(ctx->k, tmp, KEYLEN);
    4802:	1c28      	adds	r0, r5, #0
    4804:	2210      	movs	r2, #16
    4806:	4d08      	ldr	r5, [pc, #32]	; (4828 <AES_CTR_DRBG_Update+0x74>)
    4808:	47a8      	blx	r5
    memcpy(ctx->v, tmp + KEYLEN, OUTLEN);
    480a:	1c20      	adds	r0, r4, #0
    480c:	a904      	add	r1, sp, #16
    480e:	2210      	movs	r2, #16
    4810:	47a8      	blx	r5
}
    4812:	b008      	add	sp, #32
    4814:	bc04      	pop	{r2}
    4816:	4690      	mov	r8, r2
    4818:	bdf0      	pop	{r4, r5, r6, r7, pc}
    481a:	46c0      	nop			; (mov r8, r8)
    481c:	0000d44d 	.word	0x0000d44d
    4820:	00004505 	.word	0x00004505
    4824:	0000d63d 	.word	0x0000d63d
    4828:	00016739 	.word	0x00016739

0000482c <AJ_Encrypt_CCM>:
                         uint32_t msgLen,
                         uint32_t hdrLen,
                         uint8_t tagLen,
                         const uint8_t* nonce,
                         uint32_t nLen)
{
    482c:	b5f0      	push	{r4, r5, r6, r7, lr}
    482e:	465f      	mov	r7, fp
    4830:	4646      	mov	r6, r8
    4832:	b4c0      	push	{r6, r7}
    4834:	b087      	sub	sp, #28
    4836:	9003      	str	r0, [sp, #12]
    4838:	9104      	str	r1, [sp, #16]
    483a:	4690      	mov	r8, r2
    483c:	1c1f      	adds	r7, r3, #0
    483e:	ab0e      	add	r3, sp, #56	; 0x38
    4840:	781b      	ldrb	r3, [r3, #0]
    4842:	469b      	mov	fp, r3
    AJ_Status status = AJ_OK;
    CCM_Context* context;

    if (!(context = InitCCMContext(nonce, nLen, hdrLen, msgLen, tagLen))) 
    4844:	9300      	str	r3, [sp, #0]
    4846:	980f      	ldr	r0, [sp, #60]	; 0x3c
    4848:	9910      	ldr	r1, [sp, #64]	; 0x40
    484a:	1c3a      	adds	r2, r7, #0
    484c:	4643      	mov	r3, r8
    484e:	4c21      	ldr	r4, [pc, #132]	; (48d4 <AJ_Encrypt_CCM+0xa8>)
    4850:	47a0      	blx	r4
    4852:	1e04      	subs	r4, r0, #0
    4854:	d10d      	bne.n	4872 <AJ_Encrypt_CCM+0x46>
	{
        AJ_ErrPrintf(("AJ_Encrypt_CCM(): AJ_ERR_RESOURCES\n"));
    4856:	2001      	movs	r0, #1
    4858:	491f      	ldr	r1, [pc, #124]	; (48d8 <AJ_Encrypt_CCM+0xac>)
    485a:	22b8      	movs	r2, #184	; 0xb8
    485c:	4b1f      	ldr	r3, [pc, #124]	; (48dc <AJ_Encrypt_CCM+0xb0>)
    485e:	4798      	blx	r3
    4860:	1c03      	adds	r3, r0, #0
        return AJ_ERR_RESOURCES;
    4862:	200b      	movs	r0, #11
    AJ_Status status = AJ_OK;
    CCM_Context* context;

    if (!(context = InitCCMContext(nonce, nLen, hdrLen, msgLen, tagLen))) 
	{
        AJ_ErrPrintf(("AJ_Encrypt_CCM(): AJ_ERR_RESOURCES\n"));
    4864:	2b00      	cmp	r3, #0
    4866:	d02f      	beq.n	48c8 <AJ_Encrypt_CCM+0x9c>
    4868:	481d      	ldr	r0, [pc, #116]	; (48e0 <AJ_Encrypt_CCM+0xb4>)
    486a:	4b1e      	ldr	r3, [pc, #120]	; (48e4 <AJ_Encrypt_CCM+0xb8>)
    486c:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    486e:	200b      	movs	r0, #11
    4870:	e02a      	b.n	48c8 <AJ_Encrypt_CCM+0x9c>
    }
    // Do any platform specific operations to enable AES
    AJ_AES_Enable(key);
    4872:	9d03      	ldr	r5, [sp, #12]
    4874:	1c28      	adds	r0, r5, #0
    4876:	4b1c      	ldr	r3, [pc, #112]	; (48e8 <AJ_Encrypt_CCM+0xbc>)
    4878:	4798      	blx	r3
    // Compute the authentication tag
    Compute_CCM_AuthTag(key, context, msg, msgLen - hdrLen, hdrLen);
    487a:	4643      	mov	r3, r8
    487c:	1bdb      	subs	r3, r3, r7
    487e:	9700      	str	r7, [sp, #0]
    4880:	9503      	str	r5, [sp, #12]
    4882:	1c28      	adds	r0, r5, #0
    4884:	1c21      	adds	r1, r4, #0
    4886:	9e04      	ldr	r6, [sp, #16]
    4888:	1c32      	adds	r2, r6, #0
    488a:	9305      	str	r3, [sp, #20]
    488c:	4d17      	ldr	r5, [pc, #92]	; (48ec <AJ_Encrypt_CCM+0xc0>)
    488e:	47a8      	blx	r5
    // Encrypt the authentication tag
    AJ_AES_CTR_128(key, context->T.data, msg + msgLen, tagLen, context->ivec.data);
    4890:	1c21      	adds	r1, r4, #0
    4892:	3120      	adds	r1, #32
    4894:	1c0d      	adds	r5, r1, #0
    4896:	9604      	str	r6, [sp, #16]
    4898:	1c32      	adds	r2, r6, #0
    489a:	4442      	add	r2, r8
    489c:	9100      	str	r1, [sp, #0]
    489e:	9803      	ldr	r0, [sp, #12]
    48a0:	1c21      	adds	r1, r4, #0
    48a2:	465b      	mov	r3, fp
    48a4:	4e12      	ldr	r6, [pc, #72]	; (48f0 <AJ_Encrypt_CCM+0xc4>)
    48a6:	47b0      	blx	r6
    Trace("CTR Start", context->ivec.data, AJ_BLOCKSZ);
    // Encrypt the message
    if (msgLen != hdrLen) 
    48a8:	45b8      	cmp	r8, r7
    48aa:	d007      	beq.n	48bc <AJ_Encrypt_CCM+0x90>
	{
        AJ_AES_CTR_128(key, msg + hdrLen, msg + hdrLen, msgLen - hdrLen, context->ivec.data);
    48ac:	9a04      	ldr	r2, [sp, #16]
    48ae:	19d2      	adds	r2, r2, r7
    48b0:	9500      	str	r5, [sp, #0]
    48b2:	9803      	ldr	r0, [sp, #12]
    48b4:	1c11      	adds	r1, r2, #0
    48b6:	9b05      	ldr	r3, [sp, #20]
    48b8:	4d0d      	ldr	r5, [pc, #52]	; (48f0 <AJ_Encrypt_CCM+0xc4>)
    48ba:	47a8      	blx	r5
    }
    // Balance the enable call above
    AJ_AES_Disable();
    48bc:	4b0d      	ldr	r3, [pc, #52]	; (48f4 <AJ_Encrypt_CCM+0xc8>)
    48be:	4798      	blx	r3
    // Done with the context
    AJ_Free(context);
    48c0:	1c20      	adds	r0, r4, #0
    48c2:	4b0d      	ldr	r3, [pc, #52]	; (48f8 <AJ_Encrypt_CCM+0xcc>)
    48c4:	4798      	blx	r3
    return status;
    48c6:	2000      	movs	r0, #0
}
    48c8:	b007      	add	sp, #28
    48ca:	bc0c      	pop	{r2, r3}
    48cc:	4690      	mov	r8, r2
    48ce:	469b      	mov	fp, r3
    48d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    48d2:	46c0      	nop			; (mov r8, r8)
    48d4:	00004521 	.word	0x00004521
    48d8:	0001b7b8 	.word	0x0001b7b8
    48dc:	0000636d 	.word	0x0000636d
    48e0:	0001b804 	.word	0x0001b804
    48e4:	00016f5d 	.word	0x00016f5d
    48e8:	0000d44d 	.word	0x0000d44d
    48ec:	0000466d 	.word	0x0000466d
    48f0:	0000d4f1 	.word	0x0000d4f1
    48f4:	0000d4d9 	.word	0x0000d4d9
    48f8:	0000d7e9 	.word	0x0000d7e9

000048fc <AJ_Decrypt_CCM>:
                         uint32_t msgLen,
                         uint32_t hdrLen,
                         uint8_t tagLen,
                         const uint8_t* nonce,
                         uint32_t nLen)
{
    48fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    48fe:	465f      	mov	r7, fp
    4900:	4646      	mov	r6, r8
    4902:	b4c0      	push	{r6, r7}
    4904:	b087      	sub	sp, #28
    4906:	9003      	str	r0, [sp, #12]
    4908:	9104      	str	r1, [sp, #16]
    490a:	1c16      	adds	r6, r2, #0
    490c:	1c1d      	adds	r5, r3, #0
    490e:	ab0e      	add	r3, sp, #56	; 0x38
    4910:	781b      	ldrb	r3, [r3, #0]
    4912:	4698      	mov	r8, r3
    AJ_Status status = AJ_OK;
    CCM_Context* context;

    if (!(context = InitCCMContext(nonce, nLen, hdrLen, msgLen, tagLen))) 
    4914:	9300      	str	r3, [sp, #0]
    4916:	980f      	ldr	r0, [sp, #60]	; 0x3c
    4918:	9910      	ldr	r1, [sp, #64]	; 0x40
    491a:	1c2a      	adds	r2, r5, #0
    491c:	1c33      	adds	r3, r6, #0
    491e:	4c37      	ldr	r4, [pc, #220]	; (49fc <AJ_Decrypt_CCM+0x100>)
    4920:	47a0      	blx	r4
    4922:	1e04      	subs	r4, r0, #0
    4924:	d10d      	bne.n	4942 <AJ_Decrypt_CCM+0x46>
	{
        AJ_ErrPrintf(("AJ_Decrypt_CCM(): AJ_ERR_RESOURCES\n"));
    4926:	2001      	movs	r0, #1
    4928:	4935      	ldr	r1, [pc, #212]	; (4a00 <AJ_Decrypt_CCM+0x104>)
    492a:	22de      	movs	r2, #222	; 0xde
    492c:	4b35      	ldr	r3, [pc, #212]	; (4a04 <AJ_Decrypt_CCM+0x108>)
    492e:	4798      	blx	r3
    4930:	1c03      	adds	r3, r0, #0
        return AJ_ERR_RESOURCES;
    4932:	200b      	movs	r0, #11
    AJ_Status status = AJ_OK;
    CCM_Context* context;

    if (!(context = InitCCMContext(nonce, nLen, hdrLen, msgLen, tagLen))) 
	{
        AJ_ErrPrintf(("AJ_Decrypt_CCM(): AJ_ERR_RESOURCES\n"));
    4934:	2b00      	cmp	r3, #0
    4936:	d05c      	beq.n	49f2 <AJ_Decrypt_CCM+0xf6>
    4938:	4833      	ldr	r0, [pc, #204]	; (4a08 <AJ_Decrypt_CCM+0x10c>)
    493a:	4b34      	ldr	r3, [pc, #208]	; (4a0c <AJ_Decrypt_CCM+0x110>)
    493c:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    493e:	200b      	movs	r0, #11
    4940:	e057      	b.n	49f2 <AJ_Decrypt_CCM+0xf6>
    }
    // Do any platform specific operations to enable AES
    AJ_AES_Enable(key);
    4942:	9f03      	ldr	r7, [sp, #12]
    4944:	1c38      	adds	r0, r7, #0
    4946:	4b32      	ldr	r3, [pc, #200]	; (4a10 <AJ_Decrypt_CCM+0x114>)
    4948:	4798      	blx	r3
    // Decrypt the authentication field
    AJ_AES_CTR_128(key, msg + msgLen, msg + msgLen, tagLen, context->ivec.data);
    494a:	9b04      	ldr	r3, [sp, #16]
    494c:	469c      	mov	ip, r3
    494e:	44b4      	add	ip, r6
    4950:	4663      	mov	r3, ip
    4952:	9305      	str	r3, [sp, #20]
    4954:	2220      	movs	r2, #32
    4956:	4693      	mov	fp, r2
    4958:	44a3      	add	fp, r4
    495a:	465a      	mov	r2, fp
    495c:	9200      	str	r2, [sp, #0]
    495e:	9703      	str	r7, [sp, #12]
    4960:	1c38      	adds	r0, r7, #0
    4962:	4661      	mov	r1, ip
    4964:	4662      	mov	r2, ip
    4966:	4643      	mov	r3, r8
    4968:	4f2a      	ldr	r7, [pc, #168]	; (4a14 <AJ_Decrypt_CCM+0x118>)
    496a:	47b8      	blx	r7
    // Decrypt message.
    if (msgLen != hdrLen) 
    496c:	42ae      	cmp	r6, r5
    496e:	d008      	beq.n	4982 <AJ_Decrypt_CCM+0x86>
	{
        AJ_AES_CTR_128(key, msg + hdrLen, msg + hdrLen, msgLen - hdrLen, context->ivec.data);
    4970:	9b04      	ldr	r3, [sp, #16]
    4972:	195a      	adds	r2, r3, r5
    4974:	1b73      	subs	r3, r6, r5
    4976:	4659      	mov	r1, fp
    4978:	9100      	str	r1, [sp, #0]
    497a:	9803      	ldr	r0, [sp, #12]
    497c:	1c11      	adds	r1, r2, #0
    497e:	4f25      	ldr	r7, [pc, #148]	; (4a14 <AJ_Decrypt_CCM+0x118>)
    4980:	47b8      	blx	r7
    }
    // Compute and verify the authentication tag T.
    Compute_CCM_AuthTag(key, context, msg, msgLen - hdrLen, hdrLen);
    4982:	1b73      	subs	r3, r6, r5
    4984:	9500      	str	r5, [sp, #0]
    4986:	9803      	ldr	r0, [sp, #12]
    4988:	1c21      	adds	r1, r4, #0
    498a:	9a04      	ldr	r2, [sp, #16]
    498c:	4d22      	ldr	r5, [pc, #136]	; (4a18 <AJ_Decrypt_CCM+0x11c>)
    498e:	47a8      	blx	r5
    // Balance the enable call above
    AJ_AES_Disable();
    4990:	4b22      	ldr	r3, [pc, #136]	; (4a1c <AJ_Decrypt_CCM+0x120>)
    4992:	4798      	blx	r3
    if (memcmp(context->T.data, msg + msgLen, tagLen) != 0) 
    4994:	1c20      	adds	r0, r4, #0
    4996:	9905      	ldr	r1, [sp, #20]
    4998:	4642      	mov	r2, r8
    499a:	4b21      	ldr	r3, [pc, #132]	; (4a20 <AJ_Decrypt_CCM+0x124>)
    499c:	4798      	blx	r3
                         uint32_t hdrLen,
                         uint8_t tagLen,
                         const uint8_t* nonce,
                         uint32_t nLen)
{
    AJ_Status status = AJ_OK;
    499e:	2500      	movs	r5, #0
    }
    // Compute and verify the authentication tag T.
    Compute_CCM_AuthTag(key, context, msg, msgLen - hdrLen, hdrLen);
    // Balance the enable call above
    AJ_AES_Disable();
    if (memcmp(context->T.data, msg + msgLen, tagLen) != 0) 
    49a0:	2800      	cmp	r0, #0
    49a2:	d022      	beq.n	49ea <AJ_Decrypt_CCM+0xee>
	{
	//	printf("context->T.data = %p, msg + msgLen=%p tagLen= %d\n",context->T.data, msg + msgLen, tagLen );
		printf("context->T.data[0]=0x%x 0x%x 0x%x 0x%x ", *(context->T.data), *(context->T.data+1), *(context->T.data+2), *(context->T.data+3));
    49a4:	7821      	ldrb	r1, [r4, #0]
    49a6:	7862      	ldrb	r2, [r4, #1]
    49a8:	78a3      	ldrb	r3, [r4, #2]
    49aa:	78e0      	ldrb	r0, [r4, #3]
    49ac:	9000      	str	r0, [sp, #0]
    49ae:	481d      	ldr	r0, [pc, #116]	; (4a24 <AJ_Decrypt_CCM+0x128>)
    49b0:	4d1d      	ldr	r5, [pc, #116]	; (4a28 <AJ_Decrypt_CCM+0x12c>)
    49b2:	47a8      	blx	r5
		printf("msg + msgLen[0]=0x%x =0x%x =0x%x =0x%x \n", *(msg + msgLen), *(msg + msgLen+1), *(msg + msgLen+2), *(msg + msgLen+3));
    49b4:	9b05      	ldr	r3, [sp, #20]
    49b6:	7819      	ldrb	r1, [r3, #0]
    49b8:	9f04      	ldr	r7, [sp, #16]
    49ba:	19b8      	adds	r0, r7, r6
    49bc:	7842      	ldrb	r2, [r0, #1]
    49be:	7883      	ldrb	r3, [r0, #2]
    49c0:	78c0      	ldrb	r0, [r0, #3]
    49c2:	9000      	str	r0, [sp, #0]
    49c4:	4819      	ldr	r0, [pc, #100]	; (4a2c <AJ_Decrypt_CCM+0x130>)
    49c6:	47a8      	blx	r5
        // Authentication failed Clear the decrypted data
        memset(msg, 0, msgLen + tagLen);
    49c8:	1c32      	adds	r2, r6, #0
    49ca:	4442      	add	r2, r8
    49cc:	1c38      	adds	r0, r7, #0
    49ce:	2100      	movs	r1, #0
    49d0:	4b17      	ldr	r3, [pc, #92]	; (4a30 <AJ_Decrypt_CCM+0x134>)
    49d2:	4798      	blx	r3
        AJ_ErrPrintf(("AJ_Decrypt_CCM(): AJ_ERR_SECURITY\n"));
    49d4:	2001      	movs	r0, #1
    49d6:	490a      	ldr	r1, [pc, #40]	; (4a00 <AJ_Decrypt_CCM+0x104>)
    49d8:	22f5      	movs	r2, #245	; 0xf5
    49da:	4b0a      	ldr	r3, [pc, #40]	; (4a04 <AJ_Decrypt_CCM+0x108>)
    49dc:	4798      	blx	r3
        status = AJ_ERR_SECURITY;
    49de:	250d      	movs	r5, #13
	//	printf("context->T.data = %p, msg + msgLen=%p tagLen= %d\n",context->T.data, msg + msgLen, tagLen );
		printf("context->T.data[0]=0x%x 0x%x 0x%x 0x%x ", *(context->T.data), *(context->T.data+1), *(context->T.data+2), *(context->T.data+3));
		printf("msg + msgLen[0]=0x%x =0x%x =0x%x =0x%x \n", *(msg + msgLen), *(msg + msgLen+1), *(msg + msgLen+2), *(msg + msgLen+3));
        // Authentication failed Clear the decrypted data
        memset(msg, 0, msgLen + tagLen);
        AJ_ErrPrintf(("AJ_Decrypt_CCM(): AJ_ERR_SECURITY\n"));
    49e0:	2800      	cmp	r0, #0
    49e2:	d002      	beq.n	49ea <AJ_Decrypt_CCM+0xee>
    49e4:	4813      	ldr	r0, [pc, #76]	; (4a34 <AJ_Decrypt_CCM+0x138>)
    49e6:	4b09      	ldr	r3, [pc, #36]	; (4a0c <AJ_Decrypt_CCM+0x110>)
    49e8:	4798      	blx	r3
        status = AJ_ERR_SECURITY;
    }
    // Done with the context
    AJ_Free(context);
    49ea:	1c20      	adds	r0, r4, #0
    49ec:	4b12      	ldr	r3, [pc, #72]	; (4a38 <AJ_Decrypt_CCM+0x13c>)
    49ee:	4798      	blx	r3
    return status;
    49f0:	1c28      	adds	r0, r5, #0
}
    49f2:	b007      	add	sp, #28
    49f4:	bc0c      	pop	{r2, r3}
    49f6:	4690      	mov	r8, r2
    49f8:	469b      	mov	fp, r3
    49fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    49fc:	00004521 	.word	0x00004521
    4a00:	0001b7b8 	.word	0x0001b7b8
    4a04:	0000636d 	.word	0x0000636d
    4a08:	0001b828 	.word	0x0001b828
    4a0c:	00016f5d 	.word	0x00016f5d
    4a10:	0000d44d 	.word	0x0000d44d
    4a14:	0000d4f1 	.word	0x0000d4f1
    4a18:	0000466d 	.word	0x0000466d
    4a1c:	0000d4d9 	.word	0x0000d4d9
    4a20:	0001671b 	.word	0x0001671b
    4a24:	0001b84c 	.word	0x0001b84c
    4a28:	00016e3d 	.word	0x00016e3d
    4a2c:	0001b874 	.word	0x0001b874
    4a30:	00016773 	.word	0x00016773
    4a34:	0001b8a0 	.word	0x0001b8a0
    4a38:	0000d7e9 	.word	0x0000d7e9

00004a3c <AJ_RandHex>:
    AJ_Free(inBuf);
    return status;
}

AJ_Status AJ_RandHex(char* rand, uint32_t bufLen, uint32_t len)
{
    4a3c:	b570      	push	{r4, r5, r6, lr}
    4a3e:	b082      	sub	sp, #8
    4a40:	1c04      	adds	r4, r0, #0
    4a42:	1c0e      	adds	r6, r1, #0
    4a44:	1c15      	adds	r5, r2, #0
    AJ_RandBytes((uint8_t*)rand, len);
    4a46:	1c11      	adds	r1, r2, #0
    4a48:	4b05      	ldr	r3, [pc, #20]	; (4a60 <AJ_RandHex+0x24>)
    4a4a:	4798      	blx	r3
    return AJ_RawToHex((const uint8_t*) rand, len, rand, bufLen, FALSE);
    4a4c:	2300      	movs	r3, #0
    4a4e:	9300      	str	r3, [sp, #0]
    4a50:	1c20      	adds	r0, r4, #0
    4a52:	1c29      	adds	r1, r5, #0
    4a54:	1c22      	adds	r2, r4, #0
    4a56:	1c33      	adds	r3, r6, #0
    4a58:	4c02      	ldr	r4, [pc, #8]	; (4a64 <AJ_RandHex+0x28>)
    4a5a:	47a0      	blx	r4
}
    4a5c:	b002      	add	sp, #8
    4a5e:	bd70      	pop	{r4, r5, r6, pc}
    4a60:	0000d6a9 	.word	0x0000d6a9
    4a64:	0000d86d 	.word	0x0000d86d

00004a68 <AES_CTR_DRBG_Reseed>:

    AJ_Free(S);
}

void AES_CTR_DRBG_Reseed(CTR_DRBG_CTX* ctx, uint8_t* seed, size_t size)
{
    4a68:	b5f0      	push	{r4, r5, r6, r7, lr}
    4a6a:	b097      	sub	sp, #92	; 0x5c
    4a6c:	1c04      	adds	r4, r0, #0
    4a6e:	9100      	str	r1, [sp, #0]
    4a70:	1c15      	adds	r5, r2, #0
    uint8_t data[SEEDLEN];
    if (ctx->df) 
    4a72:	7803      	ldrb	r3, [r0, #0]
    4a74:	2b00      	cmp	r3, #0
    4a76:	d057      	beq.n	4b28 <AES_CTR_DRBG_Reseed+0xc0>
{
    // Variable names reflect NIST SP 800-90A
    uint32_t i = 0;
    uint32_t L = size;
    uint32_t N = SEEDLEN;
    uint32_t n = OUTLEN + sizeof (L) + sizeof (N) + size + sizeof (0x80);
    4a78:	1c16      	adds	r6, r2, #0
    4a7a:	361c      	adds	r6, #28
    uint8_t* s;
    uint8_t k[KEYLEN];
    uint8_t K[KEYLEN];
    uint8_t X[KEYLEN];

    n += (OUTLEN - (n % OUTLEN));
    4a7c:	230f      	movs	r3, #15
    4a7e:	439e      	bics	r6, r3
    4a80:	3610      	adds	r6, #16
    AJ_ASSERT(0 == (n % OUTLEN));
    S = AJ_Malloc(n);
    4a82:	1c30      	adds	r0, r6, #0
    4a84:	4b30      	ldr	r3, [pc, #192]	; (4b48 <AES_CTR_DRBG_Reseed+0xe0>)
    4a86:	4798      	blx	r3
    4a88:	1e07      	subs	r7, r0, #0
    if (NULL == S) 
    4a8a:	d048      	beq.n	4b1e <AES_CTR_DRBG_Reseed+0xb6>
	{
        // Errors are not propagated up
        return;
    }

    memset(S, 0, n);
    4a8c:	2100      	movs	r1, #0
    4a8e:	1c32      	adds	r2, r6, #0
    4a90:	4b2e      	ldr	r3, [pc, #184]	; (4b4c <AES_CTR_DRBG_Reseed+0xe4>)
    4a92:	4798      	blx	r3
    s = S + OUTLEN;
    *s++ = (L >> 24) & 0xFF;
    4a94:	0e2b      	lsrs	r3, r5, #24
    4a96:	743b      	strb	r3, [r7, #16]
    *s++ = (L >> 16) & 0xFF;
    4a98:	0c2b      	lsrs	r3, r5, #16
    4a9a:	747b      	strb	r3, [r7, #17]
    *s++ = (L >>  8) & 0xFF;
    4a9c:	0a2b      	lsrs	r3, r5, #8
    4a9e:	74bb      	strb	r3, [r7, #18]
    *s++ = (L >>  0) & 0xFF;
    4aa0:	74fd      	strb	r5, [r7, #19]
    *s++ = (N >> 24) & 0xFF;
    4aa2:	2300      	movs	r3, #0
    4aa4:	753b      	strb	r3, [r7, #20]
    *s++ = (N >> 16) & 0xFF;
    4aa6:	757b      	strb	r3, [r7, #21]
    *s++ = (N >>  8) & 0xFF;
    4aa8:	75bb      	strb	r3, [r7, #22]
    *s++ = (N >>  0) & 0xFF;
    4aaa:	1c3a      	adds	r2, r7, #0
    4aac:	3218      	adds	r2, #24
    4aae:	3320      	adds	r3, #32
    4ab0:	75fb      	strb	r3, [r7, #23]
    memcpy(s, seed, size);
    4ab2:	9201      	str	r2, [sp, #4]
    4ab4:	1c10      	adds	r0, r2, #0
    4ab6:	9900      	ldr	r1, [sp, #0]
    4ab8:	1c2a      	adds	r2, r5, #0
    4aba:	4b25      	ldr	r3, [pc, #148]	; (4b50 <AES_CTR_DRBG_Reseed+0xe8>)
    4abc:	4798      	blx	r3
    s += size;
    *s++ = 0x80;
    4abe:	2380      	movs	r3, #128	; 0x80
    4ac0:	9a01      	ldr	r2, [sp, #4]
    4ac2:	5553      	strb	r3, [r2, r5]

    for (i = 0; i < KEYLEN; i++) 
    4ac4:	2300      	movs	r3, #0
	{
        k[i] = i;
    4ac6:	aa02      	add	r2, sp, #8
    4ac8:	549b      	strb	r3, [r3, r2]
    *s++ = (N >>  0) & 0xFF;
    memcpy(s, seed, size);
    s += size;
    *s++ = 0x80;

    for (i = 0; i < KEYLEN; i++) 
    4aca:	3301      	adds	r3, #1
    4acc:	2b10      	cmp	r3, #16
    4ace:	d1fa      	bne.n	4ac6 <AES_CTR_DRBG_Reseed+0x5e>
	{
        k[i] = i;
    }

    AES_CTR_DRBG_BCC(k, S, n, K);
    4ad0:	1c10      	adds	r0, r2, #0
    4ad2:	1c39      	adds	r1, r7, #0
    4ad4:	1c32      	adds	r2, r6, #0
    4ad6:	ab06      	add	r3, sp, #24
    4ad8:	4d1e      	ldr	r5, [pc, #120]	; (4b54 <AES_CTR_DRBG_Reseed+0xec>)
    4ada:	47a8      	blx	r5
    AES_CTR_DRBG_Increment(S, 4);
    4adc:	1c38      	adds	r0, r7, #0
    4ade:	2104      	movs	r1, #4
    4ae0:	4b1d      	ldr	r3, [pc, #116]	; (4b58 <AES_CTR_DRBG_Reseed+0xf0>)
    4ae2:	4798      	blx	r3
    AES_CTR_DRBG_BCC(k, S, n, X);
    4ae4:	a802      	add	r0, sp, #8
    4ae6:	1c39      	adds	r1, r7, #0
    4ae8:	1c32      	adds	r2, r6, #0
    4aea:	ab0a      	add	r3, sp, #40	; 0x28
    4aec:	47a8      	blx	r5

    AJ_AES_Enable(K);
    4aee:	a806      	add	r0, sp, #24
    4af0:	4b1a      	ldr	r3, [pc, #104]	; (4b5c <AES_CTR_DRBG_Reseed+0xf4>)
    4af2:	4798      	blx	r3
    AJ_AES_ECB_128_ENCRYPT(K, X, X);
    4af4:	a806      	add	r0, sp, #24
    4af6:	a90a      	add	r1, sp, #40	; 0x28
    4af8:	1c0a      	adds	r2, r1, #0
    4afa:	4e19      	ldr	r6, [pc, #100]	; (4b60 <AES_CTR_DRBG_Reseed+0xf8>)
    4afc:	47b0      	blx	r6
    memcpy(data, X, OUTLEN);
    4afe:	a80e      	add	r0, sp, #56	; 0x38
    4b00:	a90a      	add	r1, sp, #40	; 0x28
    4b02:	2210      	movs	r2, #16
    4b04:	4d12      	ldr	r5, [pc, #72]	; (4b50 <AES_CTR_DRBG_Reseed+0xe8>)
    4b06:	47a8      	blx	r5
    data += OUTLEN;
    AJ_AES_ECB_128_ENCRYPT(K, X, X);
    4b08:	a806      	add	r0, sp, #24
    4b0a:	a90a      	add	r1, sp, #40	; 0x28
    4b0c:	1c0a      	adds	r2, r1, #0
    4b0e:	47b0      	blx	r6
    memcpy(data, X, OUTLEN);
    4b10:	a812      	add	r0, sp, #72	; 0x48
    4b12:	a90a      	add	r1, sp, #40	; 0x28
    4b14:	2210      	movs	r2, #16
    4b16:	47a8      	blx	r5

    AJ_Free(S);
    4b18:	1c38      	adds	r0, r7, #0
    4b1a:	4b12      	ldr	r3, [pc, #72]	; (4b64 <AES_CTR_DRBG_Reseed+0xfc>)
    4b1c:	4798      	blx	r3
{
    uint8_t data[SEEDLEN];
    if (ctx->df) 
	{
        AES_CTR_DRBG_DF(seed, size, data);
        AES_CTR_DRBG_Update(ctx, data);
    4b1e:	1c20      	adds	r0, r4, #0
    4b20:	a90e      	add	r1, sp, #56	; 0x38
    4b22:	4b11      	ldr	r3, [pc, #68]	; (4b68 <AES_CTR_DRBG_Reseed+0x100>)
    4b24:	4798      	blx	r3
    4b26:	e00b      	b.n	4b40 <AES_CTR_DRBG_Reseed+0xd8>
    } 
	else 
	{
        AJ_ASSERT(SEEDLEN == size);
    4b28:	2a20      	cmp	r2, #32
    4b2a:	d006      	beq.n	4b3a <AES_CTR_DRBG_Reseed+0xd2>
    4b2c:	480f      	ldr	r0, [pc, #60]	; (4b6c <AES_CTR_DRBG_Reseed+0x104>)
    4b2e:	21c0      	movs	r1, #192	; 0xc0
    4b30:	31ff      	adds	r1, #255	; 0xff
    4b32:	4a0f      	ldr	r2, [pc, #60]	; (4b70 <AES_CTR_DRBG_Reseed+0x108>)
    4b34:	4b0f      	ldr	r3, [pc, #60]	; (4b74 <AES_CTR_DRBG_Reseed+0x10c>)
    4b36:	4c10      	ldr	r4, [pc, #64]	; (4b78 <AES_CTR_DRBG_Reseed+0x110>)
    4b38:	47a0      	blx	r4
        AES_CTR_DRBG_Update(ctx, seed);
    4b3a:	9900      	ldr	r1, [sp, #0]
    4b3c:	4b0a      	ldr	r3, [pc, #40]	; (4b68 <AES_CTR_DRBG_Reseed+0x100>)
    4b3e:	4798      	blx	r3
    }
    ctx->c = 1;
    4b40:	2301      	movs	r3, #1
    4b42:	6263      	str	r3, [r4, #36]	; 0x24
}
    4b44:	b017      	add	sp, #92	; 0x5c
    4b46:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4b48:	0000d7dd 	.word	0x0000d7dd
    4b4c:	00016773 	.word	0x00016773
    4b50:	00016739 	.word	0x00016739
    4b54:	0000472d 	.word	0x0000472d
    4b58:	00004505 	.word	0x00004505
    4b5c:	0000d44d 	.word	0x0000d44d
    4b60:	0000d63d 	.word	0x0000d63d
    4b64:	0000d7e9 	.word	0x0000d7e9
    4b68:	000047b5 	.word	0x000047b5
    4b6c:	0001b7b8 	.word	0x0001b7b8
    4b70:	0001b7a4 	.word	0x0001b7a4
    4b74:	0001b908 	.word	0x0001b908
    4b78:	00016629 	.word	0x00016629

00004b7c <AES_CTR_DRBG_Instantiate>:


void AES_CTR_DRBG_Instantiate(CTR_DRBG_CTX* ctx, uint8_t* seed, size_t size, uint8_t df)
{
    4b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b7e:	b083      	sub	sp, #12
    4b80:	1c04      	adds	r4, r0, #0
    4b82:	1c0f      	adds	r7, r1, #0
    4b84:	9201      	str	r2, [sp, #4]
    4b86:	1c1e      	adds	r6, r3, #0
    memset(ctx->k, 0, KEYLEN);
    4b88:	3011      	adds	r0, #17
    4b8a:	2100      	movs	r1, #0
    4b8c:	2210      	movs	r2, #16
    4b8e:	4d07      	ldr	r5, [pc, #28]	; (4bac <AES_CTR_DRBG_Instantiate+0x30>)
    4b90:	47a8      	blx	r5
    memset(ctx->v, 0, OUTLEN);
    4b92:	1c60      	adds	r0, r4, #1
    4b94:	2100      	movs	r1, #0
    4b96:	2210      	movs	r2, #16
    4b98:	47a8      	blx	r5
    ctx->df = df;
    4b9a:	7026      	strb	r6, [r4, #0]
    AES_CTR_DRBG_Reseed(ctx, seed, size);
    4b9c:	1c20      	adds	r0, r4, #0
    4b9e:	1c39      	adds	r1, r7, #0
    4ba0:	9a01      	ldr	r2, [sp, #4]
    4ba2:	4b03      	ldr	r3, [pc, #12]	; (4bb0 <AES_CTR_DRBG_Instantiate+0x34>)
    4ba4:	4798      	blx	r3
}
    4ba6:	b003      	add	sp, #12
    4ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4baa:	46c0      	nop			; (mov r8, r8)
    4bac:	00016773 	.word	0x00016773
    4bb0:	00004a69 	.word	0x00004a69

00004bb4 <AES_CTR_DRBG_Generate>:


AJ_Status AES_CTR_DRBG_Generate(CTR_DRBG_CTX* ctx, uint8_t* rand, size_t size)
{
    4bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4bb6:	465f      	mov	r7, fp
    4bb8:	4656      	mov	r6, sl
    4bba:	464d      	mov	r5, r9
    4bbc:	b4e0      	push	{r5, r6, r7}
    4bbe:	b08a      	sub	sp, #40	; 0x28
    4bc0:	1c07      	adds	r7, r0, #0
    4bc2:	1c0d      	adds	r5, r1, #0
    4bc4:	1c14      	adds	r4, r2, #0
    size_t copy;

    // Reseed interval 2^32 (counter wraps to zero)
    if (0 == ctx->c) 
	{
        return AJ_ERR_SECURITY;
    4bc6:	200d      	movs	r0, #13
{
    uint8_t data[SEEDLEN];
    size_t copy;

    // Reseed interval 2^32 (counter wraps to zero)
    if (0 == ctx->c) 
    4bc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4bca:	2b00      	cmp	r3, #0
    4bcc:	d033      	beq.n	4c36 <AES_CTR_DRBG_Generate+0x82>
	{
        return AJ_ERR_SECURITY;
    }
    AJ_AES_Enable(ctx->k);
    4bce:	2311      	movs	r3, #17
    4bd0:	469c      	mov	ip, r3
    4bd2:	44bc      	add	ip, r7
    4bd4:	4663      	mov	r3, ip
    4bd6:	9301      	str	r3, [sp, #4]
    4bd8:	4660      	mov	r0, ip
    4bda:	4b1a      	ldr	r3, [pc, #104]	; (4c44 <AES_CTR_DRBG_Generate+0x90>)
    4bdc:	4798      	blx	r3
    while (size) 
    4bde:	2c00      	cmp	r4, #0
    4be0:	d018      	beq.n	4c14 <AES_CTR_DRBG_Generate+0x60>
	{
        AES_CTR_DRBG_Increment(ctx->v, OUTLEN);
    4be2:	4b19      	ldr	r3, [pc, #100]	; (4c48 <AES_CTR_DRBG_Generate+0x94>)
    4be4:	469b      	mov	fp, r3
        AJ_AES_ECB_128_ENCRYPT(ctx->k, ctx->v, data);
    4be6:	4b19      	ldr	r3, [pc, #100]	; (4c4c <AES_CTR_DRBG_Generate+0x98>)
    4be8:	469a      	mov	sl, r3
        copy = (size < OUTLEN) ? size : OUTLEN;
        memcpy(rand, data, copy);
    4bea:	4b19      	ldr	r3, [pc, #100]	; (4c50 <AES_CTR_DRBG_Generate+0x9c>)
    4bec:	4699      	mov	r9, r3
        return AJ_ERR_SECURITY;
    }
    AJ_AES_Enable(ctx->k);
    while (size) 
	{
        AES_CTR_DRBG_Increment(ctx->v, OUTLEN);
    4bee:	1c7e      	adds	r6, r7, #1
    4bf0:	1c30      	adds	r0, r6, #0
    4bf2:	2110      	movs	r1, #16
    4bf4:	47d8      	blx	fp
        AJ_AES_ECB_128_ENCRYPT(ctx->k, ctx->v, data);
    4bf6:	9801      	ldr	r0, [sp, #4]
    4bf8:	1c31      	adds	r1, r6, #0
    4bfa:	aa02      	add	r2, sp, #8
    4bfc:	47d0      	blx	sl
        copy = (size < OUTLEN) ? size : OUTLEN;
    4bfe:	1e26      	subs	r6, r4, #0
    4c00:	2e10      	cmp	r6, #16
    4c02:	d900      	bls.n	4c06 <AES_CTR_DRBG_Generate+0x52>
    4c04:	2610      	movs	r6, #16
        memcpy(rand, data, copy);
    4c06:	1c28      	adds	r0, r5, #0
    4c08:	a902      	add	r1, sp, #8
    4c0a:	1c32      	adds	r2, r6, #0
    4c0c:	47c8      	blx	r9
        rand += copy;
    4c0e:	19ad      	adds	r5, r5, r6
        size -= copy;
    4c10:	1ba4      	subs	r4, r4, r6
    if (0 == ctx->c) 
	{
        return AJ_ERR_SECURITY;
    }
    AJ_AES_Enable(ctx->k);
    while (size) 
    4c12:	d1ec      	bne.n	4bee <AES_CTR_DRBG_Generate+0x3a>
        copy = (size < OUTLEN) ? size : OUTLEN;
        memcpy(rand, data, copy);
        rand += copy;
        size -= copy;
    }
    memset(data, 0, SEEDLEN);
    4c14:	2300      	movs	r3, #0
    4c16:	9302      	str	r3, [sp, #8]
    4c18:	9303      	str	r3, [sp, #12]
    4c1a:	9304      	str	r3, [sp, #16]
    4c1c:	9305      	str	r3, [sp, #20]
    4c1e:	9306      	str	r3, [sp, #24]
    4c20:	9307      	str	r3, [sp, #28]
    4c22:	9308      	str	r3, [sp, #32]
    4c24:	9309      	str	r3, [sp, #36]	; 0x24
    AES_CTR_DRBG_Update(ctx, data);
    4c26:	1c38      	adds	r0, r7, #0
    4c28:	a902      	add	r1, sp, #8
    4c2a:	4b0a      	ldr	r3, [pc, #40]	; (4c54 <AES_CTR_DRBG_Generate+0xa0>)
    4c2c:	4798      	blx	r3
    ctx->c++;
    4c2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4c30:	3301      	adds	r3, #1
    4c32:	627b      	str	r3, [r7, #36]	; 0x24

    return AJ_OK;
    4c34:	2000      	movs	r0, #0
}
    4c36:	b00a      	add	sp, #40	; 0x28
    4c38:	bc1c      	pop	{r2, r3, r4}
    4c3a:	4691      	mov	r9, r2
    4c3c:	469a      	mov	sl, r3
    4c3e:	46a3      	mov	fp, r4
    4c40:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4c42:	46c0      	nop			; (mov r8, r8)
    4c44:	0000d44d 	.word	0x0000d44d
    4c48:	00004505 	.word	0x00004505
    4c4c:	0000d63d 	.word	0x0000d63d
    4c50:	00016739 	.word	0x00016739
    4c54:	000047b5 	.word	0x000047b5

00004c58 <mpy_accum>:

#else /* ARM7_ASM, below is platform independent */

/* (sum, carry) += a * b */
static void mpy_accum(int* cumcarry, uint64_t* sum, uint32_t a, uint32_t b)
{
    4c58:	b570      	push	{r4, r5, r6, lr}
    4c5a:	1c05      	adds	r5, r0, #0
    4c5c:	1c0c      	adds	r4, r1, #0
    uint64_t product = (uint64_t)a * (uint64_t)b;
    4c5e:	1c10      	adds	r0, r2, #0
    4c60:	2100      	movs	r1, #0
    4c62:	1c1a      	adds	r2, r3, #0
    4c64:	2300      	movs	r3, #0
    4c66:	4e08      	ldr	r6, [pc, #32]	; (4c88 <mpy_accum+0x30>)
    4c68:	47b0      	blx	r6
    uint64_t lsum = *sum;

    lsum += product;
    4c6a:	6822      	ldr	r2, [r4, #0]
    4c6c:	6863      	ldr	r3, [r4, #4]
    4c6e:	1812      	adds	r2, r2, r0
    4c70:	414b      	adcs	r3, r1
    if (lsum < product) 
    4c72:	4299      	cmp	r1, r3
    4c74:	d802      	bhi.n	4c7c <mpy_accum+0x24>
    4c76:	d104      	bne.n	4c82 <mpy_accum+0x2a>
    4c78:	4290      	cmp	r0, r2
    4c7a:	d902      	bls.n	4c82 <mpy_accum+0x2a>
	{
        *cumcarry += 1;
    4c7c:	6829      	ldr	r1, [r5, #0]
    4c7e:	3101      	adds	r1, #1
    4c80:	6029      	str	r1, [r5, #0]
    }
    *sum = lsum;
    4c82:	6022      	str	r2, [r4, #0]
    4c84:	6063      	str	r3, [r4, #4]
}
    4c86:	bd70      	pop	{r4, r5, r6, pc}
    4c88:	000151a1 	.word	0x000151a1

00004c8c <mpy_accum_dbl>:
#ifdef SPECIAL_SQUARE

/* (sum, carry += 2 * a * b.  Attempts to reduce writes to memory and
   branches caused slowdown on windows machines. */
static void mpy_accum_dbl(int* cumcarry, uint64_t* sum, uint32_t a, uint32_t b)
{
    4c8c:	b570      	push	{r4, r5, r6, lr}
    4c8e:	1c04      	adds	r4, r0, #0
    4c90:	1c0d      	adds	r5, r1, #0
    uint64_t product = (uint64_t)a * (uint64_t)b;
    4c92:	1c10      	adds	r0, r2, #0
    4c94:	2100      	movs	r1, #0
    4c96:	1c1a      	adds	r2, r3, #0
    4c98:	2300      	movs	r3, #0
    4c9a:	4e0d      	ldr	r6, [pc, #52]	; (4cd0 <mpy_accum_dbl+0x44>)
    4c9c:	47b0      	blx	r6
    uint64_t lsum = *sum;
    lsum += product;
    4c9e:	682a      	ldr	r2, [r5, #0]
    4ca0:	686b      	ldr	r3, [r5, #4]
    4ca2:	1812      	adds	r2, r2, r0
    4ca4:	414b      	adcs	r3, r1
    if (lsum < product) 
    4ca6:	4299      	cmp	r1, r3
    4ca8:	d802      	bhi.n	4cb0 <mpy_accum_dbl+0x24>
    4caa:	d104      	bne.n	4cb6 <mpy_accum_dbl+0x2a>
    4cac:	4290      	cmp	r0, r2
    4cae:	d902      	bls.n	4cb6 <mpy_accum_dbl+0x2a>
	{
        *cumcarry += 1;
    4cb0:	6826      	ldr	r6, [r4, #0]
    4cb2:	3601      	adds	r6, #1
    4cb4:	6026      	str	r6, [r4, #0]
    }
    lsum += product;
    4cb6:	1812      	adds	r2, r2, r0
    4cb8:	414b      	adcs	r3, r1
    if (lsum < product) 
    4cba:	4299      	cmp	r1, r3
    4cbc:	d802      	bhi.n	4cc4 <mpy_accum_dbl+0x38>
    4cbe:	d104      	bne.n	4cca <mpy_accum_dbl+0x3e>
    4cc0:	4290      	cmp	r0, r2
    4cc2:	d902      	bls.n	4cca <mpy_accum_dbl+0x3e>
	{
        *cumcarry += 1;
    4cc4:	6821      	ldr	r1, [r4, #0]
    4cc6:	3101      	adds	r1, #1
    4cc8:	6021      	str	r1, [r4, #0]
    }
    *sum = lsum;
    4cca:	602a      	str	r2, [r5, #0]
    4ccc:	606b      	str	r3, [r5, #4]
}
    4cce:	bd70      	pop	{r4, r5, r6, pc}
    4cd0:	000151a1 	.word	0x000151a1

00004cd4 <big_adjustP>:
/*
 * Adds k * modulusP to a and stores into target.  -2^62 <= k <= 2^62 .
 * (This is conservative.)
 */
static void big_adjustP(bigval_t* tgt, bigval_t const* a, int64_t k)
{
    4cd4:	b5f0      	push	{r4, r5, r6, r7, lr}
    tgt->data[i] = (uint32_t)(int32_t)w;     \
    w >>= 32;

    /* add k * modulus */

    if (k != 0) 
    4cd6:	1c14      	adds	r4, r2, #0
    4cd8:	431c      	orrs	r4, r3
    4cda:	d045      	beq.n	4d68 <big_adjustP+0x94>
	{
        int64_t w = 0;
        RDCSTEP(0, -k);
    4cdc:	680c      	ldr	r4, [r1, #0]
    4cde:	2500      	movs	r5, #0
    4ce0:	1aa4      	subs	r4, r4, r2
    4ce2:	419d      	sbcs	r5, r3
    4ce4:	6004      	str	r4, [r0, #0]
    4ce6:	1c2e      	adds	r6, r5, #0
    4ce8:	17ef      	asrs	r7, r5, #31
        RDCSTEP(1, 0);
    4cea:	684c      	ldr	r4, [r1, #4]
    4cec:	2500      	movs	r5, #0
    4cee:	19a4      	adds	r4, r4, r6
    4cf0:	417d      	adcs	r5, r7
    4cf2:	6044      	str	r4, [r0, #4]
    4cf4:	1c2e      	adds	r6, r5, #0
    4cf6:	17ef      	asrs	r7, r5, #31
        RDCSTEP(2, 0);
    4cf8:	688c      	ldr	r4, [r1, #8]
    4cfa:	2500      	movs	r5, #0
    4cfc:	19a4      	adds	r4, r4, r6
    4cfe:	417d      	adcs	r5, r7
    4d00:	6084      	str	r4, [r0, #8]
    4d02:	1c2e      	adds	r6, r5, #0
    4d04:	17ef      	asrs	r7, r5, #31
        RDCSTEP(3, k);
    4d06:	68cc      	ldr	r4, [r1, #12]
    4d08:	2500      	movs	r5, #0
    4d0a:	19a4      	adds	r4, r4, r6
    4d0c:	417d      	adcs	r5, r7
    4d0e:	18a4      	adds	r4, r4, r2
    4d10:	415d      	adcs	r5, r3
    4d12:	60c4      	str	r4, [r0, #12]
    4d14:	1c2e      	adds	r6, r5, #0
    4d16:	17ef      	asrs	r7, r5, #31
        RDCSTEP(4, 0);
    4d18:	690c      	ldr	r4, [r1, #16]
    4d1a:	2500      	movs	r5, #0
    4d1c:	19a4      	adds	r4, r4, r6
    4d1e:	417d      	adcs	r5, r7
    4d20:	6104      	str	r4, [r0, #16]
    4d22:	1c2e      	adds	r6, r5, #0
    4d24:	17ef      	asrs	r7, r5, #31
        RDCSTEP(5, 0);
    4d26:	694c      	ldr	r4, [r1, #20]
    4d28:	2500      	movs	r5, #0
    4d2a:	19a4      	adds	r4, r4, r6
    4d2c:	417d      	adcs	r5, r7
    4d2e:	6144      	str	r4, [r0, #20]
    4d30:	1c2e      	adds	r6, r5, #0
    4d32:	17ef      	asrs	r7, r5, #31
        RDCSTEP(6, k);
    4d34:	698c      	ldr	r4, [r1, #24]
    4d36:	2500      	movs	r5, #0
    4d38:	19a4      	adds	r4, r4, r6
    4d3a:	417d      	adcs	r5, r7
    4d3c:	18a4      	adds	r4, r4, r2
    4d3e:	415d      	adcs	r5, r3
    4d40:	6184      	str	r4, [r0, #24]
    4d42:	1c2e      	adds	r6, r5, #0
    4d44:	17ef      	asrs	r7, r5, #31
        RDCSTEP(7, -k);
    4d46:	69cc      	ldr	r4, [r1, #28]
    4d48:	2500      	movs	r5, #0
    4d4a:	19a4      	adds	r4, r4, r6
    4d4c:	417d      	adcs	r5, r7
    4d4e:	1aa4      	subs	r4, r4, r2
    4d50:	419d      	sbcs	r5, r3
    4d52:	61c4      	str	r4, [r0, #28]
    4d54:	1c2e      	adds	r6, r5, #0
    4d56:	17ef      	asrs	r7, r5, #31
        RDCSTEP(8, k);
    4d58:	6a0c      	ldr	r4, [r1, #32]
    4d5a:	2500      	movs	r5, #0
    4d5c:	1936      	adds	r6, r6, r4
    4d5e:	416f      	adcs	r7, r5
    4d60:	1992      	adds	r2, r2, r6
    4d62:	417b      	adcs	r3, r7
    4d64:	6202      	str	r2, [r0, #32]
    4d66:	e008      	b.n	4d7a <big_adjustP+0xa6>
    } 
	else if (tgt != a)
    4d68:	4288      	cmp	r0, r1
    4d6a:	d006      	beq.n	4d7a <big_adjustP+0xa6>
	{
        *tgt = *a;
    4d6c:	1c03      	adds	r3, r0, #0
    4d6e:	c915      	ldmia	r1!, {r0, r2, r4}
    4d70:	c315      	stmia	r3!, {r0, r2, r4}
    4d72:	c915      	ldmia	r1!, {r0, r2, r4}
    4d74:	c315      	stmia	r3!, {r0, r2, r4}
    4d76:	c915      	ldmia	r1!, {r0, r2, r4}
    4d78:	c315      	stmia	r3!, {r0, r2, r4}
    }
}
    4d7a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004d7c <big_add>:
/*
 * Adds a to b as signed (2's complement) numbers.  Ok to use for
 * modular values if you don't let the sum overflow.
 */
COND_STATIC void big_add(bigval_t* tgt, bigval_t const* a, bigval_t const* b)
{
    4d7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d7e:	4657      	mov	r7, sl
    4d80:	464e      	mov	r6, r9
    4d82:	b4c0      	push	{r6, r7}
    4d84:	b085      	sub	sp, #20
    4d86:	4682      	mov	sl, r0
    4d88:	4689      	mov	r9, r1
    4d8a:	1c10      	adds	r0, r2, #0
    4d8c:	2100      	movs	r1, #0
    uint64_t v;
    int i;

    v = 0;
    4d8e:	2300      	movs	r3, #0
    4d90:	2400      	movs	r4, #0
    4d92:	9300      	str	r3, [sp, #0]
    4d94:	9401      	str	r4, [sp, #4]
    for (i = 0; i < BIGLEN; ++i) 
	{
        v += a->data[i];
        v += b->data[i];
    4d96:	5843      	ldr	r3, [r0, r1]
    4d98:	9302      	str	r3, [sp, #8]
    4d9a:	2300      	movs	r3, #0
    4d9c:	9303      	str	r3, [sp, #12]
    int i;

    v = 0;
    for (i = 0; i < BIGLEN; ++i) 
	{
        v += a->data[i];
    4d9e:	464b      	mov	r3, r9
    4da0:	585e      	ldr	r6, [r3, r1]
    4da2:	2700      	movs	r7, #0
    4da4:	9a02      	ldr	r2, [sp, #8]
    4da6:	9b03      	ldr	r3, [sp, #12]
    4da8:	1992      	adds	r2, r2, r6
    4daa:	417b      	adcs	r3, r7
        v += b->data[i];
    4dac:	9c00      	ldr	r4, [sp, #0]
    4dae:	9d01      	ldr	r5, [sp, #4]
    4db0:	1912      	adds	r2, r2, r4
    4db2:	416b      	adcs	r3, r5
        tgt->data[i] = (uint32_t)v;
    4db4:	4654      	mov	r4, sl
    4db6:	5062      	str	r2, [r4, r1]
        v >>= 32;
    4db8:	9300      	str	r3, [sp, #0]
    4dba:	2300      	movs	r3, #0
    4dbc:	9301      	str	r3, [sp, #4]
    4dbe:	3104      	adds	r1, #4
{
    uint64_t v;
    int i;

    v = 0;
    for (i = 0; i < BIGLEN; ++i) 
    4dc0:	2924      	cmp	r1, #36	; 0x24
    4dc2:	d1e8      	bne.n	4d96 <big_add+0x1a>
        v += a->data[i];
        v += b->data[i];
        tgt->data[i] = (uint32_t)v;
        v >>= 32;
    }
}
    4dc4:	b005      	add	sp, #20
    4dc6:	bc0c      	pop	{r2, r3}
    4dc8:	4691      	mov	r9, r2
    4dca:	469a      	mov	sl, r3
    4dcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4dce:	46c0      	nop			; (mov r8, r8)

00004dd0 <big_addP>:

/*
 * modulo modulusP addition with approximate reduction.
 */
static void big_addP(bigval_t* tgt, bigval_t const* a, bigval_t const* b)
{
    4dd0:	b510      	push	{r4, lr}
    4dd2:	1c04      	adds	r4, r0, #0
    big_add(tgt, a, b);
    4dd4:	4b05      	ldr	r3, [pc, #20]	; (4dec <big_addP+0x1c>)
    4dd6:	4798      	blx	r3
    big_approx_reduceP(tgt, tgt);
    4dd8:	6a20      	ldr	r0, [r4, #32]
    4dda:	17c1      	asrs	r1, r0, #31
    4ddc:	2300      	movs	r3, #0
    4dde:	4242      	negs	r2, r0
    4de0:	418b      	sbcs	r3, r1
    4de2:	1c20      	adds	r0, r4, #0
    4de4:	1c21      	adds	r1, r4, #0
    4de6:	4c02      	ldr	r4, [pc, #8]	; (4df0 <big_addP+0x20>)
    4de8:	47a0      	blx	r4
}
    4dea:	bd10      	pop	{r4, pc}
    4dec:	00004d7d 	.word	0x00004d7d
    4df0:	00004cd5 	.word	0x00004cd5

00004df4 <big_sub>:


/* 2's complement subtraction */
static void big_sub(bigval_t* tgt, bigval_t const* a, bigval_t const* b)
{
    4df4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4df6:	4657      	mov	r7, sl
    4df8:	464e      	mov	r6, r9
    4dfa:	b4c0      	push	{r6, r7}
    4dfc:	b085      	sub	sp, #20
    4dfe:	4682      	mov	sl, r0
    4e00:	4689      	mov	r9, r1
    4e02:	1c10      	adds	r0, r2, #0
    4e04:	2100      	movs	r1, #0
    uint64_t v;
    int i;
    /* negation is equivalent to 1's complement and increment */

    v = 1; /* increment */
    4e06:	2301      	movs	r3, #1
    4e08:	2400      	movs	r4, #0
    4e0a:	9300      	str	r3, [sp, #0]
    4e0c:	9401      	str	r4, [sp, #4]
    for (i = 0; i < BIGLEN; ++i)
	{
        v += a->data[i];
        v += ~b->data[i]; /* 1's complement */
    4e0e:	5843      	ldr	r3, [r0, r1]
    4e10:	43db      	mvns	r3, r3
    4e12:	9302      	str	r3, [sp, #8]
    4e14:	2300      	movs	r3, #0
    4e16:	9303      	str	r3, [sp, #12]
    /* negation is equivalent to 1's complement and increment */

    v = 1; /* increment */
    for (i = 0; i < BIGLEN; ++i)
	{
        v += a->data[i];
    4e18:	464b      	mov	r3, r9
    4e1a:	585e      	ldr	r6, [r3, r1]
    4e1c:	2700      	movs	r7, #0
    4e1e:	9a02      	ldr	r2, [sp, #8]
    4e20:	9b03      	ldr	r3, [sp, #12]
    4e22:	1992      	adds	r2, r2, r6
    4e24:	417b      	adcs	r3, r7
        v += ~b->data[i]; /* 1's complement */
    4e26:	9c00      	ldr	r4, [sp, #0]
    4e28:	9d01      	ldr	r5, [sp, #4]
    4e2a:	1912      	adds	r2, r2, r4
    4e2c:	416b      	adcs	r3, r5
        tgt->data[i] = (uint32_t)v;
    4e2e:	4654      	mov	r4, sl
    4e30:	5062      	str	r2, [r4, r1]
        v >>= 32;
    4e32:	9300      	str	r3, [sp, #0]
    4e34:	2300      	movs	r3, #0
    4e36:	9301      	str	r3, [sp, #4]
    4e38:	3104      	adds	r1, #4
    uint64_t v;
    int i;
    /* negation is equivalent to 1's complement and increment */

    v = 1; /* increment */
    for (i = 0; i < BIGLEN; ++i)
    4e3a:	2924      	cmp	r1, #36	; 0x24
    4e3c:	d1e7      	bne.n	4e0e <big_sub+0x1a>
        v += a->data[i];
        v += ~b->data[i]; /* 1's complement */
        tgt->data[i] = (uint32_t)v;
        v >>= 32;
    }
}
    4e3e:	b005      	add	sp, #20
    4e40:	bc0c      	pop	{r2, r3}
    4e42:	4691      	mov	r9, r2
    4e44:	469a      	mov	sl, r3
    4e46:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004e48 <big_mpyP>:
 * Computes a * b, approximately reduced mod modulusP or orderP,
 * depending on the modselect flag.
 */
static void big_mpyP(bigval_t* tgt, bigval_t const* a, bigval_t const* b,
                     modulus_val_t modselect)
{
    4e48:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e4a:	465f      	mov	r7, fp
    4e4c:	4656      	mov	r6, sl
    4e4e:	464d      	mov	r5, r9
    4e50:	4644      	mov	r4, r8
    4e52:	b4f0      	push	{r4, r5, r6, r7}
    4e54:	b0cb      	sub	sp, #300	; 0x12c
    4e56:	9011      	str	r0, [sp, #68]	; 0x44
    4e58:	468b      	mov	fp, r1
    4e5a:	920b      	str	r2, [sp, #44]	; 0x2c
    4e5c:	9310      	str	r3, [sp, #64]	; 0x40
#define MODSELECT MOD_MODULUS
#endif


    a_words = BIGLEN;
    while (a_words > 0 && a->data[a_words - 1] == 0) 
    4e5e:	6a0b      	ldr	r3, [r1, #32]
    4e60:	2b00      	cmp	r3, #0
    4e62:	d000      	beq.n	4e66 <big_mpyP+0x1e>
    4e64:	e2da      	b.n	541c <big_mpyP+0x5d4>
    4e66:	1c0b      	adds	r3, r1, #0
    4e68:	331c      	adds	r3, #28
    4e6a:	2208      	movs	r2, #8
    4e6c:	1e56      	subs	r6, r2, #1
    4e6e:	6819      	ldr	r1, [r3, #0]
    4e70:	2900      	cmp	r1, #0
    4e72:	d000      	beq.n	4e76 <big_mpyP+0x2e>
    4e74:	e2a4      	b.n	53c0 <big_mpyP+0x578>
    4e76:	3b04      	subs	r3, #4
    4e78:	1e32      	subs	r2, r6, #0
    4e7a:	d1f7      	bne.n	4e6c <big_mpyP+0x24>
    4e7c:	e2db      	b.n	5436 <big_mpyP+0x5ee>

#ifdef SPECIAL_SQUARE

        /* a[i] * a[j] + a[j] * a[i] == 2 * (a[i] * a[j]), so
           we can cut the number of multiplies nearly in half. */
        for (i = 0; i < 2 * a_words - 1; ++i) 
    4e7e:	0052      	lsls	r2, r2, #1
    4e80:	1e53      	subs	r3, r2, #1
    4e82:	2b00      	cmp	r3, #0
    4e84:	dd00      	ble.n	4e88 <big_mpyP+0x40>
    4e86:	e0a8      	b.n	4fda <big_mpyP+0x192>
    4e88:	2300      	movs	r3, #0
    4e8a:	469a      	mov	sl, r3
    4e8c:	e14f      	b.n	512e <big_mpyP+0x2e6>
    4e8e:	9208      	str	r2, [sp, #32]
    4e90:	e001      	b.n	4e96 <big_mpyP+0x4e>

        /* normal multiply */

        /* compute length of b */
        b_words = BIGLEN;
        while (b_words > 0 && b->data[b_words - 1] == 0)
    4e92:	2309      	movs	r3, #9
    4e94:	9308      	str	r3, [sp, #32]
		{
            --b_words;
        }

        /* iterate over words of output */
        for (i = 0; i < a_words + b_words - 1; ++i) 
    4e96:	9b08      	ldr	r3, [sp, #32]
    4e98:	18f3      	adds	r3, r6, r3
    4e9a:	1e5a      	subs	r2, r3, #1
    4e9c:	4692      	mov	sl, r2
    4e9e:	2700      	movs	r7, #0
    4ea0:	2a00      	cmp	r2, #0
    4ea2:	dc0b      	bgt.n	4ebc <big_mpyP+0x74>
    4ea4:	2300      	movs	r3, #0
    4ea6:	469a      	mov	sl, r3
    4ea8:	e141      	b.n	512e <big_mpyP+0x2e6>

        /* normal multiply */

        /* compute length of b */
        b_words = BIGLEN;
        while (b_words > 0 && b->data[b_words - 1] == 0)
    4eaa:	1e51      	subs	r1, r2, #1
    4eac:	6818      	ldr	r0, [r3, #0]
    4eae:	2800      	cmp	r0, #0
    4eb0:	d1ed      	bne.n	4e8e <big_mpyP+0x46>
    4eb2:	3b04      	subs	r3, #4
    4eb4:	1e0a      	subs	r2, r1, #0
    4eb6:	d1f8      	bne.n	4eaa <big_mpyP+0x62>
    4eb8:	9108      	str	r1, [sp, #32]
    4eba:	e7ec      	b.n	4e96 <big_mpyP+0x4e>
    4ebc:	2301      	movs	r3, #1
    4ebe:	1b9b      	subs	r3, r3, r6
    4ec0:	930a      	str	r3, [sp, #40]	; 0x28

            case 6: ACCUM(ap - 2, bp + 2);

            case 7: ACCUM(ap - 1, bp + 1);

            case 8: ACCUM(ap - 0, bp + 0); /* j = 0 */
    4ec2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4ec4:	4699      	mov	r9, r3
    4ec6:	9706      	str	r7, [sp, #24]
    4ec8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4eca:	19dc      	adds	r4, r3, r7
               j < b_words and j <= i

               (j exists only in the mind of the reader.)
             */
            maxj = MIN(b_words - 1, i);
            minj = MAX(0, i - a_words + 1);
    4ecc:	43e3      	mvns	r3, r4
    4ece:	17db      	asrs	r3, r3, #31
    4ed0:	401c      	ands	r4, r3
       * are intended to coax the compiler into emitting a jump
       * table. Here j runs from maxj to minj, but addition is
       * commutative, so it doesn't matter.
       */

            ap = &a->data[i - minj];
    4ed2:	1b3b      	subs	r3, r7, r4
    4ed4:	4698      	mov	r8, r3
    4ed6:	009d      	lsls	r5, r3, #2
    4ed8:	1c2b      	adds	r3, r5, #0
    4eda:	445b      	add	r3, fp
    4edc:	9300      	str	r3, [sp, #0]
            bp = &b->data[minj];
    4ede:	00a6      	lsls	r6, r4, #2
    4ee0:	444e      	add	r6, r9
               j >= 0 and j > i - a_words and
               j < b_words and j <= i

               (j exists only in the mind of the reader.)
             */
            maxj = MIN(b_words - 1, i);
    4ee2:	9b08      	ldr	r3, [sp, #32]
    4ee4:	1e5a      	subs	r2, r3, #1
    4ee6:	1e3b      	subs	r3, r7, #0
    4ee8:	4293      	cmp	r3, r2
    4eea:	dd00      	ble.n	4eee <big_mpyP+0xa6>
    4eec:	1c13      	adds	r3, r2, #0

            ap = &a->data[i - minj];
            bp = &b->data[minj];

            /* the order is opposite the loop, but addition is commutative */
            switch (8 - (maxj - minj)) {
    4eee:	1ae3      	subs	r3, r4, r3
    4ef0:	3308      	adds	r3, #8
    4ef2:	2b08      	cmp	r3, #8
    4ef4:	d84e      	bhi.n	4f94 <big_mpyP+0x14c>
    4ef6:	009b      	lsls	r3, r3, #2
    4ef8:	4ae0      	ldr	r2, [pc, #896]	; (527c <big_mpyP+0x434>)
    4efa:	58d3      	ldr	r3, [r2, r3]
    4efc:	469f      	mov	pc, r3
            case 0: ACCUM(ap - 8, bp + 8); /* j = 8 */
    4efe:	9b00      	ldr	r3, [sp, #0]
    4f00:	3b20      	subs	r3, #32
    4f02:	681a      	ldr	r2, [r3, #0]
    4f04:	a825      	add	r0, sp, #148	; 0x94
    4f06:	a922      	add	r1, sp, #136	; 0x88
    4f08:	6a33      	ldr	r3, [r6, #32]
    4f0a:	4ddd      	ldr	r5, [pc, #884]	; (5280 <big_mpyP+0x438>)
    4f0c:	47a8      	blx	r5

            case 1: ACCUM(ap - 7, bp + 7);
    4f0e:	9b00      	ldr	r3, [sp, #0]
    4f10:	3b1c      	subs	r3, #28
    4f12:	681a      	ldr	r2, [r3, #0]
    4f14:	a825      	add	r0, sp, #148	; 0x94
    4f16:	a922      	add	r1, sp, #136	; 0x88
    4f18:	69f3      	ldr	r3, [r6, #28]
    4f1a:	4dd9      	ldr	r5, [pc, #868]	; (5280 <big_mpyP+0x438>)
    4f1c:	47a8      	blx	r5

            case 2: ACCUM(ap - 6, bp + 6);
    4f1e:	9b00      	ldr	r3, [sp, #0]
    4f20:	3b18      	subs	r3, #24
    4f22:	681a      	ldr	r2, [r3, #0]
    4f24:	a825      	add	r0, sp, #148	; 0x94
    4f26:	a922      	add	r1, sp, #136	; 0x88
    4f28:	69b3      	ldr	r3, [r6, #24]
    4f2a:	4dd5      	ldr	r5, [pc, #852]	; (5280 <big_mpyP+0x438>)
    4f2c:	47a8      	blx	r5

            case 3: ACCUM(ap - 5, bp + 5);
    4f2e:	9b00      	ldr	r3, [sp, #0]
    4f30:	3b14      	subs	r3, #20
    4f32:	681a      	ldr	r2, [r3, #0]
    4f34:	a825      	add	r0, sp, #148	; 0x94
    4f36:	a922      	add	r1, sp, #136	; 0x88
    4f38:	6973      	ldr	r3, [r6, #20]
    4f3a:	4dd1      	ldr	r5, [pc, #836]	; (5280 <big_mpyP+0x438>)
    4f3c:	47a8      	blx	r5

            case 4: ACCUM(ap - 4, bp + 4);
    4f3e:	9b00      	ldr	r3, [sp, #0]
    4f40:	3b10      	subs	r3, #16
    4f42:	681a      	ldr	r2, [r3, #0]
    4f44:	a825      	add	r0, sp, #148	; 0x94
    4f46:	a922      	add	r1, sp, #136	; 0x88
    4f48:	6933      	ldr	r3, [r6, #16]
    4f4a:	4dcd      	ldr	r5, [pc, #820]	; (5280 <big_mpyP+0x438>)
    4f4c:	47a8      	blx	r5

            case 5: ACCUM(ap - 3, bp + 3);
    4f4e:	9b00      	ldr	r3, [sp, #0]
    4f50:	3b0c      	subs	r3, #12
    4f52:	681a      	ldr	r2, [r3, #0]
    4f54:	a825      	add	r0, sp, #148	; 0x94
    4f56:	a922      	add	r1, sp, #136	; 0x88
    4f58:	68f3      	ldr	r3, [r6, #12]
    4f5a:	4dc9      	ldr	r5, [pc, #804]	; (5280 <big_mpyP+0x438>)
    4f5c:	47a8      	blx	r5

            case 6: ACCUM(ap - 2, bp + 2);
    4f5e:	9b00      	ldr	r3, [sp, #0]
    4f60:	3b08      	subs	r3, #8
    4f62:	681a      	ldr	r2, [r3, #0]
    4f64:	a825      	add	r0, sp, #148	; 0x94
    4f66:	a922      	add	r1, sp, #136	; 0x88
    4f68:	68b3      	ldr	r3, [r6, #8]
    4f6a:	4dc5      	ldr	r5, [pc, #788]	; (5280 <big_mpyP+0x438>)
    4f6c:	47a8      	blx	r5

            case 7: ACCUM(ap - 1, bp + 1);
    4f6e:	9d00      	ldr	r5, [sp, #0]
    4f70:	3d04      	subs	r5, #4
    4f72:	682a      	ldr	r2, [r5, #0]
    4f74:	6873      	ldr	r3, [r6, #4]
    4f76:	a825      	add	r0, sp, #148	; 0x94
    4f78:	a922      	add	r1, sp, #136	; 0x88
    4f7a:	4dc1      	ldr	r5, [pc, #772]	; (5280 <big_mpyP+0x438>)
    4f7c:	47a8      	blx	r5

            case 8: ACCUM(ap - 0, bp + 0); /* j = 0 */
    4f7e:	4643      	mov	r3, r8
    4f80:	009b      	lsls	r3, r3, #2
    4f82:	465a      	mov	r2, fp
    4f84:	589a      	ldr	r2, [r3, r2]
    4f86:	00a4      	lsls	r4, r4, #2
    4f88:	464b      	mov	r3, r9
    4f8a:	58e3      	ldr	r3, [r4, r3]
    4f8c:	a825      	add	r0, sp, #148	; 0x94
    4f8e:	a922      	add	r1, sp, #136	; 0x88
    4f90:	4cbb      	ldr	r4, [pc, #748]	; (5280 <big_mpyP+0x438>)
    4f92:	47a0      	blx	r4
    4f94:	9b06      	ldr	r3, [sp, #24]
    4f96:	00db      	lsls	r3, r3, #3
    4f98:	aa26      	add	r2, sp, #152	; 0x98
    4f9a:	4694      	mov	ip, r2
    4f9c:	4463      	add	r3, ip
            w[i] = sum0;
            sum0 = sum1;
            sum1 = cum_carry;
            cum_carry = 0;
#else
            w[i] = u_accum & 0xffffffffULL;
    4f9e:	2200      	movs	r2, #0
    4fa0:	9922      	ldr	r1, [sp, #136]	; 0x88
    4fa2:	6019      	str	r1, [r3, #0]
    4fa4:	605a      	str	r2, [r3, #4]
            u_accum = (u_accum >> 32) + ((uint64_t)cum_carry << 32);
    4fa6:	9b25      	ldr	r3, [sp, #148]	; 0x94
    4fa8:	9303      	str	r3, [sp, #12]
    4faa:	2300      	movs	r3, #0
    4fac:	9302      	str	r3, [sp, #8]
    4fae:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4fb0:	9304      	str	r3, [sp, #16]
    4fb2:	2300      	movs	r3, #0
    4fb4:	9305      	str	r3, [sp, #20]
    4fb6:	9802      	ldr	r0, [sp, #8]
    4fb8:	9903      	ldr	r1, [sp, #12]
    4fba:	9b04      	ldr	r3, [sp, #16]
    4fbc:	9c05      	ldr	r4, [sp, #20]
    4fbe:	18c0      	adds	r0, r0, r3
    4fc0:	4161      	adcs	r1, r4
    4fc2:	9022      	str	r0, [sp, #136]	; 0x88
    4fc4:	9123      	str	r1, [sp, #140]	; 0x8c
            cum_carry = 0;
    4fc6:	9225      	str	r2, [sp, #148]	; 0x94
		{
            --b_words;
        }

        /* iterate over words of output */
        for (i = 0; i < a_words + b_words - 1; ++i) 
    4fc8:	3701      	adds	r7, #1
    4fca:	4557      	cmp	r7, sl
    4fcc:	d000      	beq.n	4fd0 <big_mpyP+0x188>
    4fce:	e77a      	b.n	4ec6 <big_mpyP+0x7e>

    /* The total value as indicated above is maintained invariant
       down to the approximate reduction code below. */

    /* propagate any residual to next to end of array */
    for (; i < 2 * BIGLEN - 1; ++i) 
    4fd0:	4653      	mov	r3, sl
    4fd2:	2b10      	cmp	r3, #16
    4fd4:	dc00      	bgt.n	4fd8 <big_mpyP+0x190>
    4fd6:	e0aa      	b.n	512e <big_mpyP+0x2e6>
    4fd8:	e1fd      	b.n	53d6 <big_mpyP+0x58e>
    4fda:	ab26      	add	r3, sp, #152	; 0x98
    4fdc:	4698      	mov	r8, r3
    4fde:	1e53      	subs	r3, r2, #1
    4fe0:	469a      	mov	sl, r3
#else
#define MODSELECT MOD_MODULUS
#endif


    a_words = BIGLEN;
    4fe2:	2300      	movs	r3, #0
    4fe4:	4699      	mov	r9, r3
    4fe6:	3301      	adds	r3, #1
    4fe8:	1b9b      	subs	r3, r3, r6
    4fea:	9304      	str	r3, [sp, #16]

            case 6: ACCUMDBL(ap - 2, bp + 2);

            case 7: ACCUMDBL(ap - 1, bp + 1);

            case 8: ACCUMDBL(ap - 0, bp + 0); /* j = 0 */
    4fec:	464d      	mov	r5, r9
    4fee:	4653      	mov	r3, sl
    4ff0:	9302      	str	r3, [sp, #8]
    4ff2:	960a      	str	r6, [sp, #40]	; 0x28
               0 <= j < a_words && 0 <= i-j < a_words && j < i-j
               Hence
               j >= 0 and j > i - a_words and
               j < a_words and 2*j < i
             */
            maxj = MIN(a_words - 1, i);
    4ff4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4ff6:	3b01      	subs	r3, #1
    4ff8:	1e2f      	subs	r7, r5, #0
    4ffa:	429f      	cmp	r7, r3
    4ffc:	dd00      	ble.n	5000 <big_mpyP+0x1b8>
    4ffe:	1c1f      	adds	r7, r3, #0
    5000:	1c2c      	adds	r4, r5, #0
    5002:	1e6b      	subs	r3, r5, #1
            /* Only go half way.  Must use (i-1)>> 1, not (i-1)/ 2 */
            maxj = MIN(maxj, (i - 1) >> 1);
    5004:	105b      	asrs	r3, r3, #1
    5006:	46b9      	mov	r9, r7
    5008:	429f      	cmp	r7, r3
    500a:	dd00      	ble.n	500e <big_mpyP+0x1c6>
    500c:	4699      	mov	r9, r3
    500e:	9b04      	ldr	r3, [sp, #16]
    5010:	469c      	mov	ip, r3
    5012:	4464      	add	r4, ip
            minj = MAX(0, i - a_words + 1);
    5014:	43e3      	mvns	r3, r4
    5016:	17db      	asrs	r3, r3, #31
    5018:	401c      	ands	r4, r3
            if ((i & 1) == 0) 
			{
                ACCUM(a->data + j, a->data + j);
            }
#else /* SMALL_CODE not defined */
            ap = &a->data[i - minj];
    501a:	1b2b      	subs	r3, r5, r4
    501c:	469a      	mov	sl, r3
    501e:	009e      	lsls	r6, r3, #2
    5020:	1c33      	adds	r3, r6, #0
    5022:	445b      	add	r3, fp
    5024:	9300      	str	r3, [sp, #0]
            bp = &a->data[minj];
    5026:	00a3      	lsls	r3, r4, #2
    5028:	445b      	add	r3, fp
    502a:	1c1f      	adds	r7, r3, #0
            switch (8 - (maxj - minj)) 
    502c:	464b      	mov	r3, r9
    502e:	1ae3      	subs	r3, r4, r3
    5030:	3308      	adds	r3, #8
    5032:	2b08      	cmp	r3, #8
    5034:	d84e      	bhi.n	50d4 <big_mpyP+0x28c>
    5036:	009b      	lsls	r3, r3, #2
    5038:	4a92      	ldr	r2, [pc, #584]	; (5284 <big_mpyP+0x43c>)
    503a:	58d3      	ldr	r3, [r2, r3]
    503c:	469f      	mov	pc, r3
			{
            case 0: ACCUMDBL(ap - 8, bp + 8); /* j = 8 */
    503e:	9b00      	ldr	r3, [sp, #0]
    5040:	3b20      	subs	r3, #32
    5042:	681a      	ldr	r2, [r3, #0]
    5044:	a825      	add	r0, sp, #148	; 0x94
    5046:	a922      	add	r1, sp, #136	; 0x88
    5048:	6a3b      	ldr	r3, [r7, #32]
    504a:	4e8f      	ldr	r6, [pc, #572]	; (5288 <big_mpyP+0x440>)
    504c:	47b0      	blx	r6

            case 1: ACCUMDBL(ap - 7, bp + 7);
    504e:	9b00      	ldr	r3, [sp, #0]
    5050:	3b1c      	subs	r3, #28
    5052:	681a      	ldr	r2, [r3, #0]
    5054:	a825      	add	r0, sp, #148	; 0x94
    5056:	a922      	add	r1, sp, #136	; 0x88
    5058:	69fb      	ldr	r3, [r7, #28]
    505a:	4e8b      	ldr	r6, [pc, #556]	; (5288 <big_mpyP+0x440>)
    505c:	47b0      	blx	r6

            case 2: ACCUMDBL(ap - 6, bp + 6);
    505e:	9b00      	ldr	r3, [sp, #0]
    5060:	3b18      	subs	r3, #24
    5062:	681a      	ldr	r2, [r3, #0]
    5064:	a825      	add	r0, sp, #148	; 0x94
    5066:	a922      	add	r1, sp, #136	; 0x88
    5068:	69bb      	ldr	r3, [r7, #24]
    506a:	4e87      	ldr	r6, [pc, #540]	; (5288 <big_mpyP+0x440>)
    506c:	47b0      	blx	r6

            case 3: ACCUMDBL(ap - 5, bp + 5);
    506e:	9b00      	ldr	r3, [sp, #0]
    5070:	3b14      	subs	r3, #20
    5072:	681a      	ldr	r2, [r3, #0]
    5074:	a825      	add	r0, sp, #148	; 0x94
    5076:	a922      	add	r1, sp, #136	; 0x88
    5078:	697b      	ldr	r3, [r7, #20]
    507a:	4e83      	ldr	r6, [pc, #524]	; (5288 <big_mpyP+0x440>)
    507c:	47b0      	blx	r6

            case 4: ACCUMDBL(ap - 4, bp + 4);
    507e:	9b00      	ldr	r3, [sp, #0]
    5080:	3b10      	subs	r3, #16
    5082:	681a      	ldr	r2, [r3, #0]
    5084:	a825      	add	r0, sp, #148	; 0x94
    5086:	a922      	add	r1, sp, #136	; 0x88
    5088:	693b      	ldr	r3, [r7, #16]
    508a:	4e7f      	ldr	r6, [pc, #508]	; (5288 <big_mpyP+0x440>)
    508c:	47b0      	blx	r6

            case 5: ACCUMDBL(ap - 3, bp + 3);
    508e:	9b00      	ldr	r3, [sp, #0]
    5090:	3b0c      	subs	r3, #12
    5092:	681a      	ldr	r2, [r3, #0]
    5094:	a825      	add	r0, sp, #148	; 0x94
    5096:	a922      	add	r1, sp, #136	; 0x88
    5098:	68fb      	ldr	r3, [r7, #12]
    509a:	4e7b      	ldr	r6, [pc, #492]	; (5288 <big_mpyP+0x440>)
    509c:	47b0      	blx	r6

            case 6: ACCUMDBL(ap - 2, bp + 2);
    509e:	9b00      	ldr	r3, [sp, #0]
    50a0:	3b08      	subs	r3, #8
    50a2:	681a      	ldr	r2, [r3, #0]
    50a4:	a825      	add	r0, sp, #148	; 0x94
    50a6:	a922      	add	r1, sp, #136	; 0x88
    50a8:	68bb      	ldr	r3, [r7, #8]
    50aa:	4e77      	ldr	r6, [pc, #476]	; (5288 <big_mpyP+0x440>)
    50ac:	47b0      	blx	r6

            case 7: ACCUMDBL(ap - 1, bp + 1);
    50ae:	9e00      	ldr	r6, [sp, #0]
    50b0:	3e04      	subs	r6, #4
    50b2:	6832      	ldr	r2, [r6, #0]
    50b4:	687b      	ldr	r3, [r7, #4]
    50b6:	a825      	add	r0, sp, #148	; 0x94
    50b8:	a922      	add	r1, sp, #136	; 0x88
    50ba:	4e73      	ldr	r6, [pc, #460]	; (5288 <big_mpyP+0x440>)
    50bc:	47b0      	blx	r6

            case 8: ACCUMDBL(ap - 0, bp + 0); /* j = 0 */
    50be:	4653      	mov	r3, sl
    50c0:	009b      	lsls	r3, r3, #2
    50c2:	465a      	mov	r2, fp
    50c4:	589a      	ldr	r2, [r3, r2]
    50c6:	00a4      	lsls	r4, r4, #2
    50c8:	465b      	mov	r3, fp
    50ca:	58e3      	ldr	r3, [r4, r3]
    50cc:	a825      	add	r0, sp, #148	; 0x94
    50ce:	a922      	add	r1, sp, #136	; 0x88
    50d0:	4c6d      	ldr	r4, [pc, #436]	; (5288 <big_mpyP+0x440>)
    50d2:	47a0      	blx	r4
            }

            /* Even numbered columns (zero based) have a middle element. */
            if ((i & 1) == 0) 
    50d4:	2301      	movs	r3, #1
    50d6:	422b      	tst	r3, r5
    50d8:	d109      	bne.n	50ee <big_mpyP+0x2a6>
			{
                ACCUM(a->data + maxj + 1, a->data + maxj + 1);
    50da:	464f      	mov	r7, r9
    50dc:	3701      	adds	r7, #1
    50de:	00bf      	lsls	r7, r7, #2
    50e0:	465b      	mov	r3, fp
    50e2:	58fb      	ldr	r3, [r7, r3]
    50e4:	a825      	add	r0, sp, #148	; 0x94
    50e6:	a922      	add	r1, sp, #136	; 0x88
    50e8:	1c1a      	adds	r2, r3, #0
    50ea:	4c65      	ldr	r4, [pc, #404]	; (5280 <big_mpyP+0x438>)
    50ec:	47a0      	blx	r4
            w[i] = sum0;
            sum0 = sum1;
            sum1 = cum_carry;
            cum_carry = 0;
#else /* ARM7_ASM not defined */
            w[i] = u_accum & 0xffffffffULL;
    50ee:	2300      	movs	r3, #0
    50f0:	4642      	mov	r2, r8
    50f2:	9922      	ldr	r1, [sp, #136]	; 0x88
    50f4:	6011      	str	r1, [r2, #0]
    50f6:	6053      	str	r3, [r2, #4]
            u_accum = (u_accum >> 32) + ((uint64_t)cum_carry << 32);
    50f8:	9a25      	ldr	r2, [sp, #148]	; 0x94
    50fa:	9207      	str	r2, [sp, #28]
    50fc:	2200      	movs	r2, #0
    50fe:	9206      	str	r2, [sp, #24]
    5100:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    5102:	9208      	str	r2, [sp, #32]
    5104:	2200      	movs	r2, #0
    5106:	9209      	str	r2, [sp, #36]	; 0x24
    5108:	9806      	ldr	r0, [sp, #24]
    510a:	9907      	ldr	r1, [sp, #28]
    510c:	9e08      	ldr	r6, [sp, #32]
    510e:	9f09      	ldr	r7, [sp, #36]	; 0x24
    5110:	1980      	adds	r0, r0, r6
    5112:	4179      	adcs	r1, r7
    5114:	9022      	str	r0, [sp, #136]	; 0x88
    5116:	9123      	str	r1, [sp, #140]	; 0x8c
            cum_carry = 0;
    5118:	9325      	str	r3, [sp, #148]	; 0x94

#ifdef SPECIAL_SQUARE

        /* a[i] * a[j] + a[j] * a[i] == 2 * (a[i] * a[j]), so
           we can cut the number of multiplies nearly in half. */
        for (i = 0; i < 2 * a_words - 1; ++i) 
    511a:	3501      	adds	r5, #1
    511c:	3308      	adds	r3, #8
    511e:	469c      	mov	ip, r3
    5120:	44e0      	add	r8, ip
    5122:	9b02      	ldr	r3, [sp, #8]
    5124:	429d      	cmp	r5, r3
    5126:	d000      	beq.n	512a <big_mpyP+0x2e2>
    5128:	e764      	b.n	4ff4 <big_mpyP+0x1ac>
    512a:	469a      	mov	sl, r3
    512c:	e750      	b.n	4fd0 <big_mpyP+0x188>
    512e:	9922      	ldr	r1, [sp, #136]	; 0x88
    5130:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    5132:	4653      	mov	r3, sl
    5134:	00db      	lsls	r3, r3, #3
    5136:	a826      	add	r0, sp, #152	; 0x98
    5138:	4684      	mov	ip, r0
    513a:	4463      	add	r3, ip
#ifdef ARM7_ASM
        w[i] = sum0;
        sum0 = sum1;
        sum1 = 0;
#else
        w[i] = u_accum & 0xffffffffULL;
    513c:	2000      	movs	r0, #0
    513e:	4654      	mov	r4, sl
    5140:	6019      	str	r1, [r3, #0]
    5142:	6058      	str	r0, [r3, #4]
        u_accum >>= 32;
    5144:	1c11      	adds	r1, r2, #0
    5146:	1c02      	adds	r2, r0, #0

    /* The total value as indicated above is maintained invariant
       down to the approximate reduction code below. */

    /* propagate any residual to next to end of array */
    for (; i < 2 * BIGLEN - 1; ++i) 
    5148:	3401      	adds	r4, #1
    514a:	3308      	adds	r3, #8
    514c:	2c10      	cmp	r4, #16
    514e:	ddf7      	ble.n	5140 <big_mpyP+0x2f8>
    5150:	46a2      	mov	sl, r4
    5152:	9122      	str	r1, [sp, #136]	; 0x88
    5154:	9023      	str	r0, [sp, #140]	; 0x8c
    5156:	e13e      	b.n	53d6 <big_mpyP+0x58e>

    if (big_is_negative(a)) 
	{
        for (i = 0; i < BIGLEN; ++i) 
		{
            w[i + BIGLEN] -= b->data[i];
    5158:	ca40      	ldmia	r2!, {r6}
    515a:	2700      	movs	r7, #0
    515c:	6818      	ldr	r0, [r3, #0]
    515e:	6859      	ldr	r1, [r3, #4]
    5160:	1b80      	subs	r0, r0, r6
    5162:	41b9      	sbcs	r1, r7
    5164:	c303      	stmia	r3!, {r0, r1}
     * the "correction" only adds in zero.
     */

    if (big_is_negative(a)) 
	{
        for (i = 0; i < BIGLEN; ++i) 
    5166:	42a3      	cmp	r3, r4
    5168:	d1f6      	bne.n	5158 <big_mpyP+0x310>
    516a:	e146      	b.n	53fa <big_mpyP+0x5b2>
		{
            w[i + BIGLEN] -= b->data[i];
        }
    }
    if (big_is_negative(b)) 
    516c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    516e:	6a1b      	ldr	r3, [r3, #32]
    5170:	2b00      	cmp	r3, #0
    5172:	db00      	blt.n	5176 <big_mpyP+0x32e>
    5174:	e147      	b.n	5406 <big_mpyP+0x5be>
    5176:	a938      	add	r1, sp, #224	; 0xe0
    5178:	4658      	mov	r0, fp
    517a:	ac4a      	add	r4, sp, #296	; 0x128
	{
        for (i = 0; i < BIGLEN; ++i) 
		{
            w[i + BIGLEN] -= a->data[i];
    517c:	c840      	ldmia	r0!, {r6}
    517e:	2700      	movs	r7, #0
    5180:	680a      	ldr	r2, [r1, #0]
    5182:	684b      	ldr	r3, [r1, #4]
    5184:	1b92      	subs	r2, r2, r6
    5186:	41bb      	sbcs	r3, r7
    5188:	c10c      	stmia	r1!, {r2, r3}
            w[i + BIGLEN] -= b->data[i];
        }
    }
    if (big_is_negative(b)) 
	{
        for (i = 0; i < BIGLEN; ++i) 
    518a:	42a1      	cmp	r1, r4
    518c:	d1f6      	bne.n	517c <big_mpyP+0x334>
		{
            w[i + BIGLEN] -= a->data[i];
        }
        if (big_is_negative(a)) 
    518e:	2d00      	cmp	r5, #0
    5190:	db00      	blt.n	5194 <big_mpyP+0x34c>
    5192:	e138      	b.n	5406 <big_mpyP+0x5be>
		{
            /* both negative */
            w[2 * BIGLEN - 1] += 1ULL << 32;
    5194:	2200      	movs	r2, #0
    5196:	2301      	movs	r3, #1
    5198:	9848      	ldr	r0, [sp, #288]	; 0x120
    519a:	9949      	ldr	r1, [sp, #292]	; 0x124
    519c:	1812      	adds	r2, r2, r0
    519e:	414b      	adcs	r3, r1
    51a0:	9248      	str	r2, [sp, #288]	; 0x120
    51a2:	9349      	str	r3, [sp, #292]	; 0x124
    51a4:	e12f      	b.n	5406 <big_mpyP+0x5be>
     * The code from here to the end of the function maintains w mod
     * modulusP constant, even though it changes the value of w.
     */

    /* reduce (approximate) */
    if (MODSELECT == MOD_MODULUS) 
    51a6:	9b10      	ldr	r3, [sp, #64]	; 0x40
    51a8:	2b00      	cmp	r3, #0
    51aa:	d004      	beq.n	51b6 <big_mpyP+0x36e>
    51ac:	ac26      	add	r4, sp, #152	; 0x98
    51ae:	ad48      	add	r5, sp, #288	; 0x120
#else
#define NO_SPECIAL_SQUARE 0
#endif


    if (NO_SPECIAL_SQUARE || a != b) 
    51b0:	2000      	movs	r0, #0
    51b2:	2100      	movs	r1, #0
    51b4:	e028      	b.n	5208 <big_mpyP+0x3c0>
    51b6:	ab3e      	add	r3, sp, #248	; 0xf8
    51b8:	aa38      	add	r2, sp, #224	; 0xe0
    51ba:	ae2a      	add	r6, sp, #168	; 0xa8
    if (MODSELECT == MOD_MODULUS) 
	{
        for (i = 2 * BIGLEN - 1; i >= MSW; --i) 
		{
            int64_t v;
            v = w[i];
    51bc:	6a98      	ldr	r0, [r3, #40]	; 0x28
    51be:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
            if (v != 0) 
    51c0:	1c04      	adds	r4, r0, #0
    51c2:	430c      	orrs	r4, r1
    51c4:	d01b      	beq.n	51fe <big_mpyP+0x3b6>
			{
                w[i] = 0;
    51c6:	2400      	movs	r4, #0
    51c8:	2500      	movs	r5, #0
    51ca:	629c      	str	r4, [r3, #40]	; 0x28
    51cc:	62dd      	str	r5, [r3, #44]	; 0x2c
                w[i - 1] += v;
    51ce:	6a1c      	ldr	r4, [r3, #32]
    51d0:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    51d2:	1824      	adds	r4, r4, r0
    51d4:	414d      	adcs	r5, r1
    51d6:	621c      	str	r4, [r3, #32]
    51d8:	625d      	str	r5, [r3, #36]	; 0x24
                w[i - 2] -= v;
    51da:	699c      	ldr	r4, [r3, #24]
    51dc:	69dd      	ldr	r5, [r3, #28]
    51de:	1a24      	subs	r4, r4, r0
    51e0:	418d      	sbcs	r5, r1
    51e2:	619c      	str	r4, [r3, #24]
    51e4:	61dd      	str	r5, [r3, #28]
                w[i - 5] -= v;
    51e6:	681c      	ldr	r4, [r3, #0]
    51e8:	685d      	ldr	r5, [r3, #4]
    51ea:	1a24      	subs	r4, r4, r0
    51ec:	418d      	sbcs	r5, r1
    51ee:	601c      	str	r4, [r3, #0]
    51f0:	605d      	str	r5, [r3, #4]
                w[i - 8] += v;
    51f2:	6814      	ldr	r4, [r2, #0]
    51f4:	6855      	ldr	r5, [r2, #4]
    51f6:	1900      	adds	r0, r0, r4
    51f8:	4169      	adcs	r1, r5
    51fa:	6010      	str	r0, [r2, #0]
    51fc:	6051      	str	r1, [r2, #4]
    51fe:	3b08      	subs	r3, #8
    5200:	3a08      	subs	r2, #8
     */

    /* reduce (approximate) */
    if (MODSELECT == MOD_MODULUS) 
	{
        for (i = 2 * BIGLEN - 1; i >= MSW; --i) 
    5202:	42b3      	cmp	r3, r6
    5204:	d1da      	bne.n	51bc <big_mpyP+0x374>
    5206:	e103      	b.n	5410 <big_mpyP+0x5c8>

        /* convert to 32 bit values, except for most signifiant word */
        carry = 0;
        for (i = 0; i < 2 * BIGLEN - 1; ++i) 
		{
            w[i] += carry;
    5208:	6822      	ldr	r2, [r4, #0]
    520a:	6863      	ldr	r3, [r4, #4]
    520c:	1812      	adds	r2, r2, r0
    520e:	414b      	adcs	r3, r1
            carry =  w[i] >> 32;
    5210:	1c18      	adds	r0, r3, #0
    5212:	17d9      	asrs	r1, r3, #31
            w[i] -= carry << 32;
    5214:	1c1f      	adds	r7, r3, #0
    5216:	2600      	movs	r6, #0
    5218:	1b92      	subs	r2, r2, r6
    521a:	41bb      	sbcs	r3, r7
    521c:	c40c      	stmia	r4!, {r2, r3}

        int64_t carry;

        /* convert to 32 bit values, except for most signifiant word */
        carry = 0;
        for (i = 0; i < 2 * BIGLEN - 1; ++i) 
    521e:	42ac      	cmp	r4, r5
    5220:	d1f2      	bne.n	5208 <big_mpyP+0x3c0>
            w[i] += carry;
            carry =  w[i] >> 32;
            w[i] -= carry << 32;
        }
        /* i is live */
        w[i] += carry;
    5222:	9b48      	ldr	r3, [sp, #288]	; 0x120
    5224:	9c49      	ldr	r4, [sp, #292]	; 0x124
    5226:	18c0      	adds	r0, r0, r3
    5228:	4161      	adcs	r1, r4
    522a:	9048      	str	r0, [sp, #288]	; 0x120
    522c:	9149      	str	r1, [sp, #292]	; 0x124
    522e:	ab48      	add	r3, sp, #288	; 0x120
    5230:	469a      	mov	sl, r3
    5232:	2309      	movs	r3, #9
    5234:	9304      	str	r3, [sp, #16]
    5236:	4653      	mov	r3, sl
    5238:	930c      	str	r3, [sp, #48]	; 0x30
    523a:	9e12      	ldr	r6, [sp, #72]	; 0x48
    523c:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    523e:	e05f      	b.n	5300 <big_mpyP+0x4b8>

            for (k = 0; w[i] != 0 && k < 3; ++k) 
			{
                v = w[i];
                carry = 0;
                for (j = i - MSW; j < 2 * BIGLEN; ++j) 
    5240:	9a04      	ldr	r2, [sp, #16]
    5242:	4690      	mov	r8, r2
    5244:	2a11      	cmp	r2, #17
    5246:	dc47      	bgt.n	52d8 <big_mpyP+0x490>
    5248:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    524a:	4699      	mov	r9, r3
    524c:	4b0f      	ldr	r3, [pc, #60]	; (528c <big_mpyP+0x444>)
    524e:	469a      	mov	sl, r3
    5250:	2400      	movs	r4, #0
    5252:	2500      	movs	r5, #0
    5254:	9600      	str	r6, [sp, #0]
    5256:	9701      	str	r7, [sp, #4]
				{
                    if (j <= i) 
    5258:	45c3      	cmp	fp, r8
    525a:	db1b      	blt.n	5294 <big_mpyP+0x44c>
					{
                        tmp2 = -(v * orderDBL.data[j - i + MSW]);
    525c:	9806      	ldr	r0, [sp, #24]
    525e:	9908      	ldr	r1, [sp, #32]
    5260:	4653      	mov	r3, sl
    5262:	681a      	ldr	r2, [r3, #0]
    5264:	685b      	ldr	r3, [r3, #4]
    5266:	4e0a      	ldr	r6, [pc, #40]	; (5290 <big_mpyP+0x448>)
    5268:	47b0      	blx	r6
                        tmp = w[j] + tmp2 + carry;
    526a:	464b      	mov	r3, r9
    526c:	681a      	ldr	r2, [r3, #0]
    526e:	685b      	ldr	r3, [r3, #4]
    5270:	1a12      	subs	r2, r2, r0
    5272:	418b      	sbcs	r3, r1
    5274:	1912      	adds	r2, r2, r4
    5276:	416b      	adcs	r3, r5
    5278:	e011      	b.n	529e <big_mpyP+0x456>
    527a:	46c0      	nop			; (mov r8, r8)
    527c:	0001b92c 	.word	0x0001b92c
    5280:	00004c59 	.word	0x00004c59
    5284:	0001b950 	.word	0x0001b950
    5288:	00004c8d 	.word	0x00004c8d
    528c:	0001b9e8 	.word	0x0001b9e8
    5290:	000151a1 	.word	0x000151a1
                    } 
					else 
					{
                        tmp = w[j] + carry;
    5294:	464b      	mov	r3, r9
    5296:	681a      	ldr	r2, [r3, #0]
    5298:	685b      	ldr	r3, [r3, #4]
    529a:	1912      	adds	r2, r2, r4
    529c:	416b      	adcs	r3, r5
                    }
                    if (j < 2 * BIGLEN - 1) 
    529e:	4641      	mov	r1, r8
    52a0:	2910      	cmp	r1, #16
    52a2:	dc09      	bgt.n	52b8 <big_mpyP+0x470>
					{
                        carry = tmp >> 32;
    52a4:	1c1c      	adds	r4, r3, #0
    52a6:	17dd      	asrs	r5, r3, #31
                        tmp -= carry << 32;
    52a8:	9301      	str	r3, [sp, #4]
    52aa:	2100      	movs	r1, #0
    52ac:	9100      	str	r1, [sp, #0]
    52ae:	9800      	ldr	r0, [sp, #0]
    52b0:	9901      	ldr	r1, [sp, #4]
    52b2:	1a12      	subs	r2, r2, r0
    52b4:	418b      	sbcs	r3, r1
    52b6:	e001      	b.n	52bc <big_mpyP+0x474>
                    } 
					else 
					{
                        carry = 0;
    52b8:	2400      	movs	r4, #0
    52ba:	2500      	movs	r5, #0
                    }
                    w[j] = tmp;
    52bc:	4649      	mov	r1, r9
    52be:	c10c      	stmia	r1!, {r2, r3}
    52c0:	4689      	mov	r9, r1

            for (k = 0; w[i] != 0 && k < 3; ++k) 
			{
                v = w[i];
                carry = 0;
                for (j = i - MSW; j < 2 * BIGLEN; ++j) 
    52c2:	2301      	movs	r3, #1
    52c4:	469c      	mov	ip, r3
    52c6:	44e0      	add	r8, ip
    52c8:	3307      	adds	r3, #7
    52ca:	469c      	mov	ip, r3
    52cc:	44e2      	add	sl, ip
    52ce:	4643      	mov	r3, r8
    52d0:	2b12      	cmp	r3, #18
    52d2:	d1c1      	bne.n	5258 <big_mpyP+0x410>
    52d4:	9e00      	ldr	r6, [sp, #0]
    52d6:	9f01      	ldr	r7, [sp, #4]
            int64_t tmp;
            int64_t tmp2;
            int j;
            int k;

            for (k = 0; w[i] != 0 && k < 3; ++k) 
    52d8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    52da:	6813      	ldr	r3, [r2, #0]
    52dc:	9306      	str	r3, [sp, #24]
    52de:	6852      	ldr	r2, [r2, #4]
    52e0:	9208      	str	r2, [sp, #32]
    52e2:	4313      	orrs	r3, r2
    52e4:	d004      	beq.n	52f0 <big_mpyP+0x4a8>
    52e6:	9b02      	ldr	r3, [sp, #8]
    52e8:	3b01      	subs	r3, #1
    52ea:	9302      	str	r3, [sp, #8]
    52ec:	2b00      	cmp	r3, #0
    52ee:	d1a7      	bne.n	5240 <big_mpyP+0x3f8>
    52f0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    52f2:	3b08      	subs	r3, #8
    52f4:	930c      	str	r3, [sp, #48]	; 0x30
        }
        /* i is live */
        w[i] += carry;

        /* each iteration knocks off word i */
        for (i = 2 * BIGLEN - 1; i >= MSW; --i) 
    52f6:	9b04      	ldr	r3, [sp, #16]
    52f8:	1e5a      	subs	r2, r3, #1
    52fa:	9204      	str	r2, [sp, #16]
    52fc:	d200      	bcs.n	5300 <big_mpyP+0x4b8>
    52fe:	e087      	b.n	5410 <big_mpyP+0x5c8>
    5300:	9b04      	ldr	r3, [sp, #16]
    5302:	2208      	movs	r2, #8
    5304:	4694      	mov	ip, r2
    5306:	4463      	add	r3, ip
    5308:	469b      	mov	fp, r3
    530a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    530c:	930a      	str	r3, [sp, #40]	; 0x28
            int64_t tmp;
            int64_t tmp2;
            int j;
            int k;

            for (k = 0; w[i] != 0 && k < 3; ++k) 
    530e:	681a      	ldr	r2, [r3, #0]
    5310:	1c11      	adds	r1, r2, #0
    5312:	9206      	str	r2, [sp, #24]
    5314:	1c1a      	adds	r2, r3, #0
    5316:	685b      	ldr	r3, [r3, #4]
    5318:	1c18      	adds	r0, r3, #0
    531a:	9308      	str	r3, [sp, #32]
    531c:	1c0b      	adds	r3, r1, #0
    531e:	4303      	orrs	r3, r0
    5320:	2103      	movs	r1, #3
    5322:	9102      	str	r1, [sp, #8]
    5324:	3a40      	subs	r2, #64	; 0x40
    5326:	920b      	str	r2, [sp, #44]	; 0x2c
    5328:	2b00      	cmp	r3, #0
    532a:	d189      	bne.n	5240 <big_mpyP+0x3f8>
    532c:	e7e0      	b.n	52f0 <big_mpyP+0x4a8>

    /* propagate carries and copy out to tgt in 32 bit chunks. */
    s_accum = 0;
    for (i = 0; i < BIGLEN; ++i) 
	{
        s_accum += w[i];
    532e:	cc0c      	ldmia	r4!, {r2, r3}
    5330:	1812      	adds	r2, r2, r0
    5332:	414b      	adcs	r3, r1
        tgt->data[i] = (uint32_t)s_accum;
    5334:	c504      	stmia	r5!, {r2}
        s_accum >>= 32; /* signed, so sign bit propagates */
    5336:	1c18      	adds	r0, r3, #0
    5338:	17d9      	asrs	r1, r3, #31
#endif /* ECDSA */
    }

    /* propagate carries and copy out to tgt in 32 bit chunks. */
    s_accum = 0;
    for (i = 0; i < BIGLEN; ++i) 
    533a:	42b4      	cmp	r4, r6
    533c:	d1f7      	bne.n	532e <big_mpyP+0x4e6>
        s_accum >>= 32; /* signed, so sign bit propagates */
    }

    /* final approximate reduction */

    if (MODSELECT == MOD_MODULUS) 
    533e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5340:	2b00      	cmp	r3, #0
    5342:	d10c      	bne.n	535e <big_mpyP+0x516>
	{
        big_approx_reduceP(tgt, tgt);
    5344:	9c11      	ldr	r4, [sp, #68]	; 0x44
    5346:	6a23      	ldr	r3, [r4, #32]
    5348:	9300      	str	r3, [sp, #0]
    534a:	1c18      	adds	r0, r3, #0
    534c:	17d9      	asrs	r1, r3, #31
    534e:	2300      	movs	r3, #0
    5350:	4242      	negs	r2, r0
    5352:	418b      	sbcs	r3, r1
    5354:	1c20      	adds	r0, r4, #0
    5356:	1c21      	adds	r1, r4, #0
    5358:	4c40      	ldr	r4, [pc, #256]	; (545c <big_mpyP+0x614>)
    535a:	47a0      	blx	r4
    535c:	e077      	b.n	544e <big_mpyP+0x606>
    } 
	else 
	{
#ifdef ECDSA
        if (tgt->data[MSW]) 
    535e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    5360:	6a1e      	ldr	r6, [r3, #32]
    5362:	2e00      	cmp	r6, #0
    5364:	d073      	beq.n	544e <big_mpyP+0x606>
            /* Keep it simple! At one time all this was done in place,
               and was totally unobvious. */
            bigval_t tmp;
            /* The most significant word is signed, even though the
               whole array has declared uint32_t.  */
            big_1wd_mpy(&tmp, &orderP, (int32_t)tgt->data[MSW]);
    5366:	9600      	str	r6, [sp, #0]
    5368:	2700      	movs	r7, #0
 * Computes k * a and stores into target.  Conditions: product must
 * be representable in bigval_t.
 */
static void big_1wd_mpy(bigval_t* tgt, bigval_t const* a, int32_t k)
{
    int64_t w = 0;
    536a:	2400      	movs	r4, #0
    536c:	2500      	movs	r5, #0
    int64_t prod;
    int j;

    for (j = 0; j <= MSW; ++j) 
	{
        prod = (int64_t)k * (int64_t)a->data[j];
    536e:	17f3      	asrs	r3, r6, #31
    5370:	9302      	str	r3, [sp, #8]
    5372:	4e3b      	ldr	r6, [pc, #236]	; (5460 <big_mpyP+0x618>)
    5374:	4b3b      	ldr	r3, [pc, #236]	; (5464 <big_mpyP+0x61c>)
    5376:	4698      	mov	r8, r3
    5378:	9800      	ldr	r0, [sp, #0]
    537a:	9902      	ldr	r1, [sp, #8]
    537c:	59ba      	ldr	r2, [r7, r6]
    537e:	2300      	movs	r3, #0
    5380:	47c0      	blx	r8
        tmp = w + prod;
    5382:	1900      	adds	r0, r0, r4
    5384:	4169      	adcs	r1, r5
        w = tmp;
        tgt->data[j] = (uint32_t)w;
    5386:	ab19      	add	r3, sp, #100	; 0x64
    5388:	50f8      	str	r0, [r7, r3]
        w -= tgt->data[j];
    538a:	900e      	str	r0, [sp, #56]	; 0x38
    538c:	2300      	movs	r3, #0
    538e:	930f      	str	r3, [sp, #60]	; 0x3c
    5390:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5392:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5394:	1a80      	subs	r0, r0, r2
    5396:	4199      	sbcs	r1, r3
        w >>= 32;
    5398:	1c0c      	adds	r4, r1, #0
    539a:	17cd      	asrs	r5, r1, #31
    539c:	3704      	adds	r7, #4
    int64_t w = 0;
    int64_t tmp;
    int64_t prod;
    int j;

    for (j = 0; j <= MSW; ++j) 
    539e:	2f24      	cmp	r7, #36	; 0x24
    53a0:	d1ea      	bne.n	5378 <big_mpyP+0x530>
               and was totally unobvious. */
            bigval_t tmp;
            /* The most significant word is signed, even though the
               whole array has declared uint32_t.  */
            big_1wd_mpy(&tmp, &orderP, (int32_t)tgt->data[MSW]);
            big_sub(tgt, tgt, &tmp);
    53a2:	9911      	ldr	r1, [sp, #68]	; 0x44
    53a4:	1c08      	adds	r0, r1, #0
    53a6:	aa19      	add	r2, sp, #100	; 0x64
    53a8:	4b2f      	ldr	r3, [pc, #188]	; (5468 <big_mpyP+0x620>)
    53aa:	4798      	blx	r3
    53ac:	e04f      	b.n	544e <big_mpyP+0x606>

        /* normal multiply */

        /* compute length of b */
        b_words = BIGLEN;
        while (b_words > 0 && b->data[b_words - 1] == 0)
    53ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    53b0:	6a1a      	ldr	r2, [r3, #32]
    53b2:	9200      	str	r2, [sp, #0]
    53b4:	2a00      	cmp	r2, #0
    53b6:	d000      	beq.n	53ba <big_mpyP+0x572>
    53b8:	e56b      	b.n	4e92 <big_mpyP+0x4a>
    53ba:	331c      	adds	r3, #28
    53bc:	3208      	adds	r2, #8
    53be:	e574      	b.n	4eaa <big_mpyP+0x62>
    53c0:	1c16      	adds	r6, r2, #0
#ifdef ARM7_ASM
    sum0 = 0;
    sum1 = 0;
    cum_carry = 0;
#else
    u_accum = 0;
    53c2:	2000      	movs	r0, #0
    53c4:	2100      	movs	r1, #0
    53c6:	9022      	str	r0, [sp, #136]	; 0x88
    53c8:	9123      	str	r1, [sp, #140]	; 0x8c
    cum_carry = 0;
    53ca:	2300      	movs	r3, #0
    53cc:	9325      	str	r3, [sp, #148]	; 0x94
#else
#define NO_SPECIAL_SQUARE 0
#endif


    if (NO_SPECIAL_SQUARE || a != b) 
    53ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    53d0:	459b      	cmp	fp, r3
    53d2:	d1ec      	bne.n	53ae <big_mpyP+0x566>
    53d4:	e553      	b.n	4e7e <big_mpyP+0x36>

#ifdef ARM7_ASM
    w[i] = ((uint64_t)sum1 << 32) | sum0;
    /* sum1 = sum0 = 0;  maintain invariant */
#else
    w[i] = u_accum;
    53d6:	4653      	mov	r3, sl
    53d8:	00db      	lsls	r3, r3, #3
    53da:	aa26      	add	r2, sp, #152	; 0x98
    53dc:	4694      	mov	ip, r2
    53de:	4463      	add	r3, ip
    53e0:	9922      	ldr	r1, [sp, #136]	; 0x88
    53e2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    53e4:	6019      	str	r1, [r3, #0]
    53e6:	605a      	str	r2, [r3, #4]
     * If one arg is zero and the other is negative, obviously no
     * correction is needed, but we do not make a special case, since
     * the "correction" only adds in zero.
     */

    if (big_is_negative(a)) 
    53e8:	465b      	mov	r3, fp
    53ea:	6a1d      	ldr	r5, [r3, #32]
    53ec:	2d00      	cmp	r5, #0
    53ee:	db00      	blt.n	53f2 <big_mpyP+0x5aa>
    53f0:	e6bc      	b.n	516c <big_mpyP+0x324>
    53f2:	ab38      	add	r3, sp, #224	; 0xe0
    53f4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    53f6:	ac4a      	add	r4, sp, #296	; 0x128
    53f8:	e6ae      	b.n	5158 <big_mpyP+0x310>
        for (i = 0; i < BIGLEN; ++i) 
		{
            w[i + BIGLEN] -= b->data[i];
        }
    }
    if (big_is_negative(b)) 
    53fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    53fc:	6a1b      	ldr	r3, [r3, #32]
    53fe:	2b00      	cmp	r3, #0
    5400:	db00      	blt.n	5404 <big_mpyP+0x5bc>
    5402:	e6d0      	b.n	51a6 <big_mpyP+0x35e>
    5404:	e6b7      	b.n	5176 <big_mpyP+0x32e>
     * The code from here to the end of the function maintains w mod
     * modulusP constant, even though it changes the value of w.
     */

    /* reduce (approximate) */
    if (MODSELECT == MOD_MODULUS) 
    5406:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5408:	2b00      	cmp	r3, #0
    540a:	d100      	bne.n	540e <big_mpyP+0x5c6>
    540c:	e6d3      	b.n	51b6 <big_mpyP+0x36e>
    540e:	e6cd      	b.n	51ac <big_mpyP+0x364>
    5410:	ac26      	add	r4, sp, #152	; 0x98
    5412:	9d11      	ldr	r5, [sp, #68]	; 0x44
    5414:	ae38      	add	r6, sp, #224	; 0xe0
            w[i] += carry;
            carry =  w[i] >> 32;
            w[i] -= carry << 32;
        }
        /* i is live */
        w[i] += carry;
    5416:	2000      	movs	r0, #0
    5418:	2100      	movs	r1, #0
    541a:	e788      	b.n	532e <big_mpyP+0x4e6>
#ifdef ARM7_ASM
    sum0 = 0;
    sum1 = 0;
    cum_carry = 0;
#else
    u_accum = 0;
    541c:	2200      	movs	r2, #0
    541e:	2300      	movs	r3, #0
    5420:	9222      	str	r2, [sp, #136]	; 0x88
    5422:	9323      	str	r3, [sp, #140]	; 0x8c
    cum_carry = 0;
    5424:	2300      	movs	r3, #0
    5426:	9325      	str	r3, [sp, #148]	; 0x94
#else
#define MODSELECT MOD_MODULUS
#endif


    a_words = BIGLEN;
    5428:	2609      	movs	r6, #9
#else
#define NO_SPECIAL_SQUARE 0
#endif


    if (NO_SPECIAL_SQUARE || a != b) 
    542a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

#ifdef SPECIAL_SQUARE

        /* a[i] * a[j] + a[j] * a[i] == 2 * (a[i] * a[j]), so
           we can cut the number of multiplies nearly in half. */
        for (i = 0; i < 2 * a_words - 1; ++i) 
    542c:	3212      	adds	r2, #18
#else
#define NO_SPECIAL_SQUARE 0
#endif


    if (NO_SPECIAL_SQUARE || a != b) 
    542e:	4299      	cmp	r1, r3
    5430:	d100      	bne.n	5434 <big_mpyP+0x5ec>
    5432:	e5d2      	b.n	4fda <big_mpyP+0x192>
    5434:	e7bb      	b.n	53ae <big_mpyP+0x566>
#ifdef ARM7_ASM
    sum0 = 0;
    sum1 = 0;
    cum_carry = 0;
#else
    u_accum = 0;
    5436:	2200      	movs	r2, #0
    5438:	2300      	movs	r3, #0
    543a:	9222      	str	r2, [sp, #136]	; 0x88
    543c:	9323      	str	r3, [sp, #140]	; 0x8c
    cum_carry = 0;
    543e:	2300      	movs	r3, #0
    5440:	9325      	str	r3, [sp, #148]	; 0x94
#else
#define NO_SPECIAL_SQUARE 0
#endif


    if (NO_SPECIAL_SQUARE || a != b) 
    5442:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5444:	459b      	cmp	fp, r3
    5446:	d1b2      	bne.n	53ae <big_mpyP+0x566>
    5448:	2300      	movs	r3, #0
    544a:	469a      	mov	sl, r3
    544c:	e66f      	b.n	512e <big_mpyP+0x2e6>
            big_1wd_mpy(&tmp, &orderP, (int32_t)tgt->data[MSW]);
            big_sub(tgt, tgt, &tmp);
        }
#endif /* ECDSA */
    }
}
    544e:	b04b      	add	sp, #300	; 0x12c
    5450:	bc3c      	pop	{r2, r3, r4, r5}
    5452:	4690      	mov	r8, r2
    5454:	4699      	mov	r9, r3
    5456:	46a2      	mov	sl, r4
    5458:	46ab      	mov	fp, r5
    545a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    545c:	00004cd5 	.word	0x00004cd5
    5460:	0001bac0 	.word	0x0001bac0
    5464:	000151a1 	.word	0x000151a1
    5468:	00004df5 	.word	0x00004df5

0000546c <big_subP>:

/*
 * modulo modulusP subtraction with approximate reduction.
 */
static void big_subP(bigval_t* tgt, bigval_t const* a, bigval_t const* b)
{
    546c:	b510      	push	{r4, lr}
    546e:	1c04      	adds	r4, r0, #0
    big_sub(tgt, a, b);
    5470:	4b05      	ldr	r3, [pc, #20]	; (5488 <big_subP+0x1c>)
    5472:	4798      	blx	r3
    big_approx_reduceP(tgt, tgt);
    5474:	6a20      	ldr	r0, [r4, #32]
    5476:	17c1      	asrs	r1, r0, #31
    5478:	2300      	movs	r3, #0
    547a:	4242      	negs	r2, r0
    547c:	418b      	sbcs	r3, r1
    547e:	1c20      	adds	r0, r4, #0
    5480:	1c21      	adds	r1, r4, #0
    5482:	4c02      	ldr	r4, [pc, #8]	; (548c <big_subP+0x20>)
    5484:	47a0      	blx	r4
}
    5486:	bd10      	pop	{r4, pc}
    5488:	00004df5 	.word	0x00004df5
    548c:	00004cd5 	.word	0x00004cd5

00005490 <big_cmp>:

/* returns 1 if a > b, -1 if a < b, and 0 if a == b.
   a and b are 2's complement.  When applied to modular values,
   args must be precisely reduced. */
static int big_cmp(bigval_t const* a, bigval_t const* b)
{
    5490:	b510      	push	{r4, lr}
    int i;

    /* most significant word is treated as 2's complement */
    if ((int32_t)a->data[MSW] > (int32_t)b->data[MSW]) 
    5492:	6a02      	ldr	r2, [r0, #32]
    5494:	6a0b      	ldr	r3, [r1, #32]
	{
        return (1);
    5496:	2401      	movs	r4, #1
static int big_cmp(bigval_t const* a, bigval_t const* b)
{
    int i;

    /* most significant word is treated as 2's complement */
    if ((int32_t)a->data[MSW] > (int32_t)b->data[MSW]) 
    5498:	429a      	cmp	r2, r3
    549a:	dc1f      	bgt.n	54dc <big_cmp+0x4c>
	{
        return (1);
    } 
	else if ((int32_t)a->data[MSW] < (int32_t)b->data[MSW]) 
    549c:	db12      	blt.n	54c4 <big_cmp+0x34>
        return (-1);
    }
    /* remainder treated as unsigned */
    for (i = MSW - 1; i >= 0; --i) 
	{
        if (a->data[i] > b->data[i]) 
    549e:	69c2      	ldr	r2, [r0, #28]
    54a0:	69cb      	ldr	r3, [r1, #28]
    54a2:	429a      	cmp	r2, r3
    54a4:	d811      	bhi.n	54ca <big_cmp+0x3a>
		{
            return (1);
        } 
		else if (a->data[i] < b->data[i]) 
    54a6:	d312      	bcc.n	54ce <big_cmp+0x3e>
    54a8:	2300      	movs	r3, #0
    54aa:	18c2      	adds	r2, r0, r3
        return (-1);
    }
    /* remainder treated as unsigned */
    for (i = MSW - 1; i >= 0; --i) 
	{
        if (a->data[i] > b->data[i]) 
    54ac:	6994      	ldr	r4, [r2, #24]
    54ae:	18ca      	adds	r2, r1, r3
    54b0:	6992      	ldr	r2, [r2, #24]
    54b2:	4294      	cmp	r4, r2
    54b4:	d80e      	bhi.n	54d4 <big_cmp+0x44>
		{
            return (1);
        } 
		else if (a->data[i] < b->data[i]) 
    54b6:	d30f      	bcc.n	54d8 <big_cmp+0x48>
    54b8:	3b04      	subs	r3, #4
	else if ((int32_t)a->data[MSW] < (int32_t)b->data[MSW]) 
	{
        return (-1);
    }
    /* remainder treated as unsigned */
    for (i = MSW - 1; i >= 0; --i) 
    54ba:	1c1a      	adds	r2, r3, #0
    54bc:	321c      	adds	r2, #28
    54be:	d1f4      	bne.n	54aa <big_cmp+0x1a>
		else if (a->data[i] < b->data[i]) 
		{
            return (-1);
        }
    }
    return (0);
    54c0:	2400      	movs	r4, #0
    54c2:	e00b      	b.n	54dc <big_cmp+0x4c>
	{
        return (1);
    } 
	else if ((int32_t)a->data[MSW] < (int32_t)b->data[MSW]) 
	{
        return (-1);
    54c4:	2401      	movs	r4, #1
    54c6:	4264      	negs	r4, r4
    54c8:	e008      	b.n	54dc <big_cmp+0x4c>
    /* remainder treated as unsigned */
    for (i = MSW - 1; i >= 0; --i) 
	{
        if (a->data[i] > b->data[i]) 
		{
            return (1);
    54ca:	2401      	movs	r4, #1
    54cc:	e006      	b.n	54dc <big_cmp+0x4c>
        } 
		else if (a->data[i] < b->data[i]) 
		{
            return (-1);
    54ce:	2401      	movs	r4, #1
    54d0:	4264      	negs	r4, r4
    54d2:	e003      	b.n	54dc <big_cmp+0x4c>
    /* remainder treated as unsigned */
    for (i = MSW - 1; i >= 0; --i) 
	{
        if (a->data[i] > b->data[i]) 
		{
            return (1);
    54d4:	2401      	movs	r4, #1
    54d6:	e001      	b.n	54dc <big_cmp+0x4c>
        } 
		else if (a->data[i] < b->data[i]) 
		{
            return (-1);
    54d8:	2401      	movs	r4, #1
    54da:	4264      	negs	r4, r4
        }
    }
    return (0);
}
    54dc:	1c20      	adds	r0, r4, #0
    54de:	bd10      	pop	{r4, pc}

000054e0 <big_halve>:
    }
}

/* computes floor(a / 2), 2's complement. */
static void big_halve(bigval_t* tgt, bigval_t const* a)
{
    54e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t shiftval;
    uint32_t new_shiftval;
    int i;

    /* most significant word is 2's complement.  Do it separately. */
    shiftval = a->data[MSW] & 1;
    54e2:	6a0a      	ldr	r2, [r1, #32]
    54e4:	2301      	movs	r3, #1
    54e6:	4013      	ands	r3, r2
    tgt->data[MSW] = (uint32_t)((int32_t)a->data[MSW] >> 1);
    54e8:	1052      	asrs	r2, r2, #1
    54ea:	6202      	str	r2, [r0, #32]
    54ec:	2200      	movs	r2, #0

    for (i = MSW - 1; i >= 0; --i) 
	{
        new_shiftval = a->data[i] & 1;
    54ee:	2701      	movs	r7, #1
    54f0:	188c      	adds	r4, r1, r2
    54f2:	69e4      	ldr	r4, [r4, #28]
    54f4:	1885      	adds	r5, r0, r2
        tgt->data[i] = (a->data[i] >> 1) | (shiftval << 31);
    54f6:	0866      	lsrs	r6, r4, #1
    54f8:	07db      	lsls	r3, r3, #31
    54fa:	4333      	orrs	r3, r6
    54fc:	61eb      	str	r3, [r5, #28]
    54fe:	3a04      	subs	r2, #4
        shiftval = new_shiftval;
    5500:	1c23      	adds	r3, r4, #0
    5502:	403b      	ands	r3, r7

    /* most significant word is 2's complement.  Do it separately. */
    shiftval = a->data[MSW] & 1;
    tgt->data[MSW] = (uint32_t)((int32_t)a->data[MSW] >> 1);

    for (i = MSW - 1; i >= 0; --i) 
    5504:	1c14      	adds	r4, r2, #0
    5506:	3420      	adds	r4, #32
    5508:	d1f2      	bne.n	54f0 <big_halve+0x10>
	{
        new_shiftval = a->data[i] & 1;
        tgt->data[i] = (a->data[i] >> 1) | (shiftval << 31);
        shiftval = new_shiftval;
    }
}
    550a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000550c <toJacobian>:
 */

#define jacobian_point_is_infinity(P) (big_is_zero(&(P)->Z))

static void toJacobian(jacobian_point_t* tgt, affine_point_t const* a)
{
    550c:	b570      	push	{r4, r5, r6, lr}
    tgt->X = a->x;
    550e:	1c03      	adds	r3, r0, #0
    5510:	1c0a      	adds	r2, r1, #0
    5512:	ca70      	ldmia	r2!, {r4, r5, r6}
    5514:	c370      	stmia	r3!, {r4, r5, r6}
    5516:	ca70      	ldmia	r2!, {r4, r5, r6}
    5518:	c370      	stmia	r3!, {r4, r5, r6}
    551a:	ca70      	ldmia	r2!, {r4, r5, r6}
    551c:	c370      	stmia	r3!, {r4, r5, r6}
    tgt->Y = a->y;
    551e:	3124      	adds	r1, #36	; 0x24
    5520:	c934      	ldmia	r1!, {r2, r4, r5}
    5522:	c334      	stmia	r3!, {r2, r4, r5}
    5524:	c934      	ldmia	r1!, {r2, r4, r5}
    5526:	c334      	stmia	r3!, {r2, r4, r5}
    5528:	c934      	ldmia	r1!, {r2, r4, r5}
    552a:	c334      	stmia	r3!, {r2, r4, r5}
    tgt->Z = big_one;
    552c:	2300      	movs	r3, #0
    552e:	64c3      	str	r3, [r0, #76]	; 0x4c
    5530:	6503      	str	r3, [r0, #80]	; 0x50
    5532:	6543      	str	r3, [r0, #84]	; 0x54
    5534:	6583      	str	r3, [r0, #88]	; 0x58
    5536:	65c3      	str	r3, [r0, #92]	; 0x5c
    5538:	6603      	str	r3, [r0, #96]	; 0x60
    553a:	6643      	str	r3, [r0, #100]	; 0x64
    553c:	6683      	str	r3, [r0, #104]	; 0x68
    553e:	3301      	adds	r3, #1
    5540:	6483      	str	r3, [r0, #72]	; 0x48
}
    5542:	bd70      	pop	{r4, r5, r6, pc}

00005544 <big_precise_reduce>:
/*
 * Computes tgt = a mod modulus.  Only works with modluii slightly
 * less than 2**(32*(BIGLEN-1)).  Both modulusP and orderP qualify.
 */
static void big_precise_reduce(bigval_t* tgt, bigval_t const* a, bigval_t const* modulus)
{
    5544:	b5f0      	push	{r4, r5, r6, r7, lr}
    5546:	465f      	mov	r7, fp
    5548:	4656      	mov	r6, sl
    554a:	464d      	mov	r5, r9
    554c:	4644      	mov	r4, r8
    554e:	b4f0      	push	{r4, r5, r6, r7}
    5550:	b093      	sub	sp, #76	; 0x4c
    5552:	4680      	mov	r8, r0
    5554:	9105      	str	r1, [sp, #20]
       == 0, and thus loop termination is guaranteed. */


    while ((int32_t)src->data[MSW] != 0) 
	{
        if (modulus != &modulusP) 
    5556:	4b36      	ldr	r3, [pc, #216]	; (5630 <big_precise_reduce+0xec>)
    5558:	4699      	mov	r9, r3
    555a:	4692      	mov	sl, r2
       value smaller than tgt gets subtracted, so eventually target
       becomes < 1 * 2**(32*MSW), but not negative, i.e. tgt->data[MSW]
       == 0, and thus loop termination is guaranteed. */


    while ((int32_t)src->data[MSW] != 0) 
    555c:	e034      	b.n	55c8 <big_precise_reduce+0x84>
	{
        if (modulus != &modulusP) 
    555e:	45ca      	cmp	sl, r9
    5560:	d024      	beq.n	55ac <big_precise_reduce+0x68>
            /* General case.  Keep it simple! */
            bigval_t tmp;

            /* The most significant word is signed, even though the
               whole array has been declared uint32_t.  */
            big_1wd_mpy(&tmp, modulus, (int32_t)src->data[MSW]);
    5562:	9303      	str	r3, [sp, #12]
    5564:	2600      	movs	r6, #0
 * Computes k * a and stores into target.  Conditions: product must
 * be representable in bigval_t.
 */
static void big_1wd_mpy(bigval_t* tgt, bigval_t const* a, int32_t k)
{
    int64_t w = 0;
    5566:	2400      	movs	r4, #0
    5568:	2500      	movs	r5, #0
    int64_t prod;
    int j;

    for (j = 0; j <= MSW; ++j) 
	{
        prod = (int64_t)k * (int64_t)a->data[j];
    556a:	17db      	asrs	r3, r3, #31
    556c:	9304      	str	r3, [sp, #16]
    556e:	4b31      	ldr	r3, [pc, #196]	; (5634 <big_precise_reduce+0xf0>)
    5570:	469b      	mov	fp, r3
    5572:	4657      	mov	r7, sl
    5574:	9803      	ldr	r0, [sp, #12]
    5576:	9904      	ldr	r1, [sp, #16]
    5578:	59ba      	ldr	r2, [r7, r6]
    557a:	2300      	movs	r3, #0
    557c:	47d8      	blx	fp
        tmp = w + prod;
    557e:	1900      	adds	r0, r0, r4
    5580:	4169      	adcs	r1, r5
        w = tmp;
        tgt->data[j] = (uint32_t)w;
    5582:	ab09      	add	r3, sp, #36	; 0x24
    5584:	50f0      	str	r0, [r6, r3]
        w -= tgt->data[j];
    5586:	9000      	str	r0, [sp, #0]
    5588:	2300      	movs	r3, #0
    558a:	9301      	str	r3, [sp, #4]
    558c:	9a00      	ldr	r2, [sp, #0]
    558e:	9b01      	ldr	r3, [sp, #4]
    5590:	1a80      	subs	r0, r0, r2
    5592:	4199      	sbcs	r1, r3
        w >>= 32;
    5594:	1c0c      	adds	r4, r1, #0
    5596:	17cd      	asrs	r5, r1, #31
    5598:	3604      	adds	r6, #4
    int64_t w = 0;
    int64_t tmp;
    int64_t prod;
    int j;

    for (j = 0; j <= MSW; ++j) 
    559a:	2e24      	cmp	r6, #36	; 0x24
    559c:	d1ea      	bne.n	5574 <big_precise_reduce+0x30>
    559e:	46ba      	mov	sl, r7
            bigval_t tmp;

            /* The most significant word is signed, even though the
               whole array has been declared uint32_t.  */
            big_1wd_mpy(&tmp, modulus, (int32_t)src->data[MSW]);
            big_sub(tgt, src, &tmp);
    55a0:	4640      	mov	r0, r8
    55a2:	9905      	ldr	r1, [sp, #20]
    55a4:	aa09      	add	r2, sp, #36	; 0x24
    55a6:	4b24      	ldr	r3, [pc, #144]	; (5638 <big_precise_reduce+0xf4>)
    55a8:	4798      	blx	r3
    55aa:	e00b      	b.n	55c4 <big_precise_reduce+0x80>
        } 
		else 
		{
            /* just an optimization.  The other branch would work, but slower. */
            big_adjustP(tgt, src, -(int64_t)(int32_t)src->data[MSW]);
    55ac:	9306      	str	r3, [sp, #24]
    55ae:	17db      	asrs	r3, r3, #31
    55b0:	9307      	str	r3, [sp, #28]
    55b2:	9806      	ldr	r0, [sp, #24]
    55b4:	9907      	ldr	r1, [sp, #28]
    55b6:	2300      	movs	r3, #0
    55b8:	4242      	negs	r2, r0
    55ba:	418b      	sbcs	r3, r1
    55bc:	4640      	mov	r0, r8
    55be:	9905      	ldr	r1, [sp, #20]
    55c0:	4c1e      	ldr	r4, [pc, #120]	; (563c <big_precise_reduce+0xf8>)
    55c2:	47a0      	blx	r4
    55c4:	4643      	mov	r3, r8
    55c6:	9305      	str	r3, [sp, #20]
       value smaller than tgt gets subtracted, so eventually target
       becomes < 1 * 2**(32*MSW), but not negative, i.e. tgt->data[MSW]
       == 0, and thus loop termination is guaranteed. */


    while ((int32_t)src->data[MSW] != 0) 
    55c8:	9b05      	ldr	r3, [sp, #20]
    55ca:	6a1b      	ldr	r3, [r3, #32]
    55cc:	2b00      	cmp	r3, #0
    55ce:	d1c6      	bne.n	555e <big_precise_reduce+0x1a>
    55d0:	4656      	mov	r6, sl
            big_adjustP(tgt, src, -(int64_t)(int32_t)src->data[MSW]);
        }
        src = tgt;
    }

    while (big_cmp(src, modulus) >= 0) 
    55d2:	4c1b      	ldr	r4, [pc, #108]	; (5640 <big_precise_reduce+0xfc>)
	{
        big_sub(tgt, src, modulus);
    55d4:	4d18      	ldr	r5, [pc, #96]	; (5638 <big_precise_reduce+0xf4>)
    55d6:	4647      	mov	r7, r8
    55d8:	e004      	b.n	55e4 <big_precise_reduce+0xa0>
    55da:	1c38      	adds	r0, r7, #0
    55dc:	9905      	ldr	r1, [sp, #20]
    55de:	1c32      	adds	r2, r6, #0
    55e0:	47a8      	blx	r5
        src = tgt;
    55e2:	9705      	str	r7, [sp, #20]
            big_adjustP(tgt, src, -(int64_t)(int32_t)src->data[MSW]);
        }
        src = tgt;
    }

    while (big_cmp(src, modulus) >= 0) 
    55e4:	9805      	ldr	r0, [sp, #20]
    55e6:	1c31      	adds	r1, r6, #0
    55e8:	47a0      	blx	r4
    55ea:	2800      	cmp	r0, #0
    55ec:	daf5      	bge.n	55da <big_precise_reduce+0x96>
    55ee:	9a05      	ldr	r2, [sp, #20]
    55f0:	1c13      	adds	r3, r2, #0
	{
        big_sub(tgt, src, modulus);
        src = tgt;
    }
    while ((int32_t)src->data[MSW] < 0) 
    55f2:	6a11      	ldr	r1, [r2, #32]
    55f4:	9100      	str	r1, [sp, #0]
    55f6:	2900      	cmp	r1, #0
    55f8:	da0a      	bge.n	5610 <big_precise_reduce+0xcc>
	{
        big_add(tgt, src, modulus);
    55fa:	4c12      	ldr	r4, [pc, #72]	; (5644 <big_precise_reduce+0x100>)
    55fc:	1c3d      	adds	r5, r7, #0
    55fe:	1c11      	adds	r1, r2, #0
    5600:	1c28      	adds	r0, r5, #0
    5602:	1c32      	adds	r2, r6, #0
    5604:	47a0      	blx	r4
        src = tgt;
    5606:	1c29      	adds	r1, r5, #0
    while (big_cmp(src, modulus) >= 0) 
	{
        big_sub(tgt, src, modulus);
        src = tgt;
    }
    while ((int32_t)src->data[MSW] < 0) 
    5608:	6a2b      	ldr	r3, [r5, #32]
    560a:	2b00      	cmp	r3, #0
    560c:	dbf8      	blt.n	5600 <big_precise_reduce+0xbc>
    560e:	e008      	b.n	5622 <big_precise_reduce+0xde>
        src = tgt;
    }

    /* copy src to tgt if not already done */

    if (src != tgt) 
    5610:	42ba      	cmp	r2, r7
    5612:	d006      	beq.n	5622 <big_precise_reduce+0xde>
	{
        *tgt = *src;
    5614:	1c3a      	adds	r2, r7, #0
    5616:	cb13      	ldmia	r3!, {r0, r1, r4}
    5618:	c213      	stmia	r2!, {r0, r1, r4}
    561a:	cb13      	ldmia	r3!, {r0, r1, r4}
    561c:	c213      	stmia	r2!, {r0, r1, r4}
    561e:	cb13      	ldmia	r3!, {r0, r1, r4}
    5620:	c213      	stmia	r2!, {r0, r1, r4}
    }
}
    5622:	b013      	add	sp, #76	; 0x4c
    5624:	bc3c      	pop	{r2, r3, r4, r5}
    5626:	4690      	mov	r8, r2
    5628:	4699      	mov	r9, r3
    562a:	46a2      	mov	sl, r4
    562c:	46ab      	mov	fp, r5
    562e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5630:	0001ba78 	.word	0x0001ba78
    5634:	000151a1 	.word	0x000151a1
    5638:	00004df5 	.word	0x00004df5
    563c:	00004cd5 	.word	0x00004cd5
    5640:	00005491 	.word	0x00005491
    5644:	00004d7d 	.word	0x00004d7d

00005648 <big_divide>:
 * If the denominator is zero, it will loop forever.  Be careful!
 * Modulus must be odd.  num and den must be positive.
 */
static void big_divide(bigval_t* tgt, bigval_t const* num, bigval_t const* den,
                       bigval_t const* modulus)
{
    5648:	b5f0      	push	{r4, r5, r6, r7, lr}
    564a:	4647      	mov	r7, r8
    564c:	b480      	push	{r7}
    564e:	b0a6      	sub	sp, #152	; 0x98
    5650:	9001      	str	r0, [sp, #4]
    5652:	1c1c      	adds	r4, r3, #0
    5654:	9300      	str	r3, [sp, #0]
    bigval_t u, v, x1, x2;

    u = *den;
    5656:	a81d      	add	r0, sp, #116	; 0x74
    5658:	1c03      	adds	r3, r0, #0
    565a:	ca61      	ldmia	r2!, {r0, r5, r6}
    565c:	c361      	stmia	r3!, {r0, r5, r6}
    565e:	ca61      	ldmia	r2!, {r0, r5, r6}
    5660:	c361      	stmia	r3!, {r0, r5, r6}
    5662:	ca61      	ldmia	r2!, {r0, r5, r6}
    5664:	c361      	stmia	r3!, {r0, r5, r6}
    v = *modulus;
    5666:	a814      	add	r0, sp, #80	; 0x50
    5668:	1c03      	adds	r3, r0, #0
    566a:	1c22      	adds	r2, r4, #0
    566c:	ca31      	ldmia	r2!, {r0, r4, r5}
    566e:	c331      	stmia	r3!, {r0, r4, r5}
    5670:	ca31      	ldmia	r2!, {r0, r4, r5}
    5672:	c331      	stmia	r3!, {r0, r4, r5}
    5674:	ca31      	ldmia	r2!, {r0, r4, r5}
    5676:	c331      	stmia	r3!, {r0, r4, r5}
    x1 = *num;
    5678:	aa0b      	add	r2, sp, #44	; 0x2c
    567a:	1c13      	adds	r3, r2, #0
    567c:	c915      	ldmia	r1!, {r0, r2, r4}
    567e:	c315      	stmia	r3!, {r0, r2, r4}
    5680:	c915      	ldmia	r1!, {r0, r2, r4}
    5682:	c315      	stmia	r3!, {r0, r2, r4}
    5684:	c915      	ldmia	r1!, {r0, r2, r4}
    5686:	c315      	stmia	r3!, {r0, r2, r4}
    x2 = big_zero;
    5688:	2300      	movs	r3, #0
    568a:	9302      	str	r3, [sp, #8]
    568c:	9303      	str	r3, [sp, #12]
    568e:	9304      	str	r3, [sp, #16]
    5690:	9305      	str	r3, [sp, #20]
    5692:	9306      	str	r3, [sp, #24]
    5694:	9307      	str	r3, [sp, #28]
    5696:	9308      	str	r3, [sp, #32]
    5698:	9309      	str	r3, [sp, #36]	; 0x24
    569a:	930a      	str	r3, [sp, #40]	; 0x28

    while (!big_is_one(&u) && !big_is_one(&v)) 
	{
        while (!big_is_odd(&u))
		 {
            big_halve(&u, &u);
    569c:	4e3d      	ldr	r6, [pc, #244]	; (5794 <big_divide+0x14c>)
            if (big_is_odd(&x1)) 
			{
                big_add(&x1, &x1, modulus);
    569e:	4b3e      	ldr	r3, [pc, #248]	; (5798 <big_divide+0x150>)
    56a0:	4698      	mov	r8, r3
            }
            big_halve(&x1, &x1);
    56a2:	1c37      	adds	r7, r6, #0
    u = *den;
    v = *modulus;
    x1 = *num;
    x2 = big_zero;

    while (!big_is_one(&u) && !big_is_one(&v)) 
    56a4:	e03e      	b.n	5724 <big_divide+0xdc>
	{
        while (!big_is_odd(&u))
		 {
            big_halve(&u, &u);
    56a6:	a81d      	add	r0, sp, #116	; 0x74
    56a8:	1c01      	adds	r1, r0, #0
    56aa:	47b0      	blx	r6
            if (big_is_odd(&x1)) 
    56ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    56ae:	07db      	lsls	r3, r3, #31
    56b0:	d503      	bpl.n	56ba <big_divide+0x72>
			{
                big_add(&x1, &x1, modulus);
    56b2:	a80b      	add	r0, sp, #44	; 0x2c
    56b4:	1c01      	adds	r1, r0, #0
    56b6:	9a00      	ldr	r2, [sp, #0]
    56b8:	47c0      	blx	r8
            }
            big_halve(&x1, &x1);
    56ba:	a80b      	add	r0, sp, #44	; 0x2c
    56bc:	1c01      	adds	r1, r0, #0
    56be:	47b8      	blx	r7
    x1 = *num;
    x2 = big_zero;

    while (!big_is_one(&u) && !big_is_one(&v)) 
	{
        while (!big_is_odd(&u))
    56c0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    56c2:	07db      	lsls	r3, r3, #31
    56c4:	d5ef      	bpl.n	56a6 <big_divide+0x5e>
			{
                big_add(&x1, &x1, modulus);
            }
            big_halve(&x1, &x1);
        }
        while (!big_is_odd(&v)) 
    56c6:	9b14      	ldr	r3, [sp, #80]	; 0x50
    56c8:	07db      	lsls	r3, r3, #31
    56ca:	d412      	bmi.n	56f2 <big_divide+0xaa>
		{
            big_halve(&v, &v);
    56cc:	4d31      	ldr	r5, [pc, #196]	; (5794 <big_divide+0x14c>)
            if (big_is_odd(&x2)) 
			{
                big_add(&x2, &x2, modulus);
            }
            big_halve(&x2, &x2);
    56ce:	1c2c      	adds	r4, r5, #0
            }
            big_halve(&x1, &x1);
        }
        while (!big_is_odd(&v)) 
		{
            big_halve(&v, &v);
    56d0:	a814      	add	r0, sp, #80	; 0x50
    56d2:	1c01      	adds	r1, r0, #0
    56d4:	47a8      	blx	r5
            if (big_is_odd(&x2)) 
    56d6:	9b02      	ldr	r3, [sp, #8]
    56d8:	07db      	lsls	r3, r3, #31
    56da:	d504      	bpl.n	56e6 <big_divide+0x9e>
			{
                big_add(&x2, &x2, modulus);
    56dc:	a802      	add	r0, sp, #8
    56de:	1c01      	adds	r1, r0, #0
    56e0:	9a00      	ldr	r2, [sp, #0]
    56e2:	4b2d      	ldr	r3, [pc, #180]	; (5798 <big_divide+0x150>)
    56e4:	4798      	blx	r3
            }
            big_halve(&x2, &x2);
    56e6:	a802      	add	r0, sp, #8
    56e8:	1c01      	adds	r1, r0, #0
    56ea:	47a0      	blx	r4
			{
                big_add(&x1, &x1, modulus);
            }
            big_halve(&x1, &x1);
        }
        while (!big_is_odd(&v)) 
    56ec:	9b14      	ldr	r3, [sp, #80]	; 0x50
    56ee:	07db      	lsls	r3, r3, #31
    56f0:	d5ee      	bpl.n	56d0 <big_divide+0x88>
			{
                big_add(&x2, &x2, modulus);
            }
            big_halve(&x2, &x2);
        }
        if (big_cmp(&u, &v) >= 0) 
    56f2:	a81d      	add	r0, sp, #116	; 0x74
    56f4:	a914      	add	r1, sp, #80	; 0x50
    56f6:	4b29      	ldr	r3, [pc, #164]	; (579c <big_divide+0x154>)
    56f8:	4798      	blx	r3
    56fa:	2800      	cmp	r0, #0
    56fc:	db09      	blt.n	5712 <big_divide+0xca>
		{
            big_sub(&u, &u, &v);
    56fe:	a81d      	add	r0, sp, #116	; 0x74
    5700:	1c01      	adds	r1, r0, #0
    5702:	aa14      	add	r2, sp, #80	; 0x50
    5704:	4c26      	ldr	r4, [pc, #152]	; (57a0 <big_divide+0x158>)
    5706:	47a0      	blx	r4
            big_sub(&x1, &x1, &x2);
    5708:	a80b      	add	r0, sp, #44	; 0x2c
    570a:	1c01      	adds	r1, r0, #0
    570c:	aa02      	add	r2, sp, #8
    570e:	47a0      	blx	r4
    5710:	e008      	b.n	5724 <big_divide+0xdc>
        } 
		else 
		{
            big_sub(&v, &v, &u);
    5712:	a814      	add	r0, sp, #80	; 0x50
    5714:	1c01      	adds	r1, r0, #0
    5716:	aa1d      	add	r2, sp, #116	; 0x74
    5718:	4c21      	ldr	r4, [pc, #132]	; (57a0 <big_divide+0x158>)
    571a:	47a0      	blx	r4
            big_sub(&x2, &x2, &x1);
    571c:	a802      	add	r0, sp, #8
    571e:	1c01      	adds	r1, r0, #0
    5720:	aa0b      	add	r2, sp, #44	; 0x2c
    5722:	47a0      	blx	r4
/* returns B_TRUE if a is one */
static boolean_t big_is_one(bigval_t const* a)
{
    int i;

    if (a->data[0] != 1) 
    5724:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    5726:	2a01      	cmp	r2, #1
    5728:	d117      	bne.n	575a <big_divide+0x112>
	{
        return (B_FALSE);
    }
    for (i = 1; i < BIGLEN; ++i) 
	{
        if (a->data[i] != 0) 
    572a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    572c:	2b00      	cmp	r3, #0
    572e:	d126      	bne.n	577e <big_divide+0x136>
    5730:	ab1d      	add	r3, sp, #116	; 0x74
    5732:	a924      	add	r1, sp, #144	; 0x90
    5734:	6898      	ldr	r0, [r3, #8]
    5736:	2800      	cmp	r0, #0
    5738:	d121      	bne.n	577e <big_divide+0x136>
    573a:	3304      	adds	r3, #4

    if (a->data[0] != 1) 
	{
        return (B_FALSE);
    }
    for (i = 1; i < BIGLEN; ++i) 
    573c:	428b      	cmp	r3, r1
    573e:	d1f9      	bne.n	5734 <big_divide+0xec>
    5740:	e011      	b.n	5766 <big_divide+0x11e>
	{
        if (a->data[i] != 0) 
    5742:	9b15      	ldr	r3, [sp, #84]	; 0x54
    5744:	2b00      	cmp	r3, #0
    5746:	d11e      	bne.n	5786 <big_divide+0x13e>
    5748:	ab14      	add	r3, sp, #80	; 0x50
    574a:	a91b      	add	r1, sp, #108	; 0x6c
    574c:	6898      	ldr	r0, [r3, #8]
    574e:	2800      	cmp	r0, #0
    5750:	d119      	bne.n	5786 <big_divide+0x13e>
    5752:	3304      	adds	r3, #4

    if (a->data[0] != 1) 
	{
        return (B_FALSE);
    }
    for (i = 1; i < BIGLEN; ++i) 
    5754:	428b      	cmp	r3, r1
    5756:	d1f9      	bne.n	574c <big_divide+0x104>
    5758:	e00b      	b.n	5772 <big_divide+0x12a>
/* returns B_TRUE if a is one */
static boolean_t big_is_one(bigval_t const* a)
{
    int i;

    if (a->data[0] != 1) 
    575a:	9b14      	ldr	r3, [sp, #80]	; 0x50
    575c:	2b01      	cmp	r3, #1
    575e:	d0f0      	beq.n	5742 <big_divide+0xfa>
    x1 = *num;
    x2 = big_zero;

    while (!big_is_one(&u) && !big_is_one(&v)) 
	{
        while (!big_is_odd(&u))
    5760:	07d3      	lsls	r3, r2, #31
    5762:	d5a0      	bpl.n	56a6 <big_divide+0x5e>
    5764:	e7af      	b.n	56c6 <big_divide+0x7e>
        }
    }

    if (big_is_one(&u)) 
	{
        big_precise_reduce(tgt, &x1, modulus);
    5766:	9801      	ldr	r0, [sp, #4]
    5768:	a90b      	add	r1, sp, #44	; 0x2c
    576a:	9a00      	ldr	r2, [sp, #0]
    576c:	4b0d      	ldr	r3, [pc, #52]	; (57a4 <big_divide+0x15c>)
    576e:	4798      	blx	r3
    5770:	e00c      	b.n	578c <big_divide+0x144>
    } 
	else 
	{
        big_precise_reduce(tgt, &x2, modulus);
    5772:	9801      	ldr	r0, [sp, #4]
    5774:	a902      	add	r1, sp, #8
    5776:	9a00      	ldr	r2, [sp, #0]
    5778:	4b0a      	ldr	r3, [pc, #40]	; (57a4 <big_divide+0x15c>)
    577a:	4798      	blx	r3
    577c:	e006      	b.n	578c <big_divide+0x144>
/* returns B_TRUE if a is one */
static boolean_t big_is_one(bigval_t const* a)
{
    int i;

    if (a->data[0] != 1) 
    577e:	9b14      	ldr	r3, [sp, #80]	; 0x50
    5780:	2b01      	cmp	r3, #1
    5782:	d1a0      	bne.n	56c6 <big_divide+0x7e>
    5784:	e7dd      	b.n	5742 <big_divide+0xfa>
    x1 = *num;
    x2 = big_zero;

    while (!big_is_one(&u) && !big_is_one(&v)) 
	{
        while (!big_is_odd(&u))
    5786:	07d3      	lsls	r3, r2, #31
    5788:	d58d      	bpl.n	56a6 <big_divide+0x5e>
    578a:	e7b2      	b.n	56f2 <big_divide+0xaa>
    } 
	else 
	{
        big_precise_reduce(tgt, &x2, modulus);
    }
}
    578c:	b026      	add	sp, #152	; 0x98
    578e:	bc04      	pop	{r2}
    5790:	4690      	mov	r8, r2
    5792:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5794:	000054e1 	.word	0x000054e1
    5798:	00004d7d 	.word	0x00004d7d
    579c:	00005491 	.word	0x00005491
    57a0:	00004df5 	.word	0x00004df5
    57a4:	00005545 	.word	0x00005545

000057a8 <big_is_zero>:
{
    int i;

    for (i = 0; i < BIGLEN; ++i) 
	{
        if (a->data[i] != 0) 
    57a8:	6803      	ldr	r3, [r0, #0]
    57aa:	2b00      	cmp	r3, #0
    57ac:	d109      	bne.n	57c2 <big_is_zero+0x1a>
    57ae:	1d03      	adds	r3, r0, #4
    57b0:	3024      	adds	r0, #36	; 0x24
    57b2:	681a      	ldr	r2, [r3, #0]
    57b4:	2a00      	cmp	r2, #0
    57b6:	d106      	bne.n	57c6 <big_is_zero+0x1e>
    57b8:	3304      	adds	r3, #4
/* returns B_TRUE if a is zero */
boolean_t big_is_zero(bigval_t const* a)
{
    int i;

    for (i = 0; i < BIGLEN; ++i) 
    57ba:	4283      	cmp	r3, r0
    57bc:	d1f9      	bne.n	57b2 <big_is_zero+0xa>
        if (a->data[i] != 0) 
		{
            return (B_FALSE);
        }
    }
    return (B_TRUE);
    57be:	2001      	movs	r0, #1
    57c0:	e002      	b.n	57c8 <big_is_zero+0x20>

    for (i = 0; i < BIGLEN; ++i) 
	{
        if (a->data[i] != 0) 
		{
            return (B_FALSE);
    57c2:	2000      	movs	r0, #0
    57c4:	e000      	b.n	57c8 <big_is_zero+0x20>
    57c6:	2000      	movs	r0, #0
        }
    }
    return (B_TRUE);
}
    57c8:	4770      	bx	lr
    57ca:	46c0      	nop			; (mov r8, r8)

000057cc <pointDouble>:
 */

/* tgt = 2 * P.  P->Z must be precisely reduced and
   tgt->Z will be precisely reduced */
static void pointDouble(jacobian_point_t* tgt, jacobian_point_t const* P)
{
    57cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    57ce:	4647      	mov	r7, r8
    57d0:	b480      	push	{r7}
    57d2:	b0b8      	sub	sp, #224	; 0xe0
    57d4:	4680      	mov	r8, r0
    57d6:	1c0b      	adds	r3, r1, #0
    57d8:	9101      	str	r1, [sp, #4]
#define x3 (&x3loc)
#define y3 (&y3loc)
#define z3 (&z3loc)

    /* This requires P->Z be precisely reduced */
    if (jacobian_point_is_infinity(P)) 
    57da:	3348      	adds	r3, #72	; 0x48
    57dc:	9300      	str	r3, [sp, #0]
    57de:	1c18      	adds	r0, r3, #0
    57e0:	4b46      	ldr	r3, [pc, #280]	; (58fc <pointDouble+0x130>)
    57e2:	4798      	blx	r3
    57e4:	2800      	cmp	r0, #0
    57e6:	d009      	beq.n	57fc <pointDouble+0x30>
	{
        *tgt = jacobian_infinity;
    57e8:	4640      	mov	r0, r8
    57ea:	2100      	movs	r1, #0
    57ec:	226c      	movs	r2, #108	; 0x6c
    57ee:	4b44      	ldr	r3, [pc, #272]	; (5900 <pointDouble+0x134>)
    57f0:	4798      	blx	r3
    57f2:	2301      	movs	r3, #1
    57f4:	4642      	mov	r2, r8
    57f6:	6013      	str	r3, [r2, #0]
    57f8:	6253      	str	r3, [r2, #36]	; 0x24
    57fa:	e07b      	b.n	58f4 <pointDouble+0x128>
        return;
    }

    big_sqrP(&t1, z1);
    57fc:	a814      	add	r0, sp, #80	; 0x50
    57fe:	9a00      	ldr	r2, [sp, #0]
    5800:	1c11      	adds	r1, r2, #0
    5802:	2300      	movs	r3, #0
    5804:	4e3f      	ldr	r6, [pc, #252]	; (5904 <pointDouble+0x138>)
    5806:	47b0      	blx	r6
    big_subP(&t2, x1, &t1);
    5808:	a80b      	add	r0, sp, #44	; 0x2c
    580a:	9f01      	ldr	r7, [sp, #4]
    580c:	1c39      	adds	r1, r7, #0
    580e:	aa14      	add	r2, sp, #80	; 0x50
    5810:	4b3d      	ldr	r3, [pc, #244]	; (5908 <pointDouble+0x13c>)
    5812:	4798      	blx	r3
    big_addP(&t1, x1, &t1);
    5814:	a814      	add	r0, sp, #80	; 0x50
    5816:	1c39      	adds	r1, r7, #0
    5818:	1c02      	adds	r2, r0, #0
    581a:	4b3c      	ldr	r3, [pc, #240]	; (590c <pointDouble+0x140>)
    581c:	4798      	blx	r3
    big_mpyP(&t2, &t2, &t1, MOD_MODULUS);
    581e:	a80b      	add	r0, sp, #44	; 0x2c
    5820:	1c01      	adds	r1, r0, #0
    5822:	aa14      	add	r2, sp, #80	; 0x50
    5824:	2300      	movs	r3, #0
    5826:	47b0      	blx	r6
    5828:	a90b      	add	r1, sp, #44	; 0x2c
    582a:	a814      	add	r0, sp, #80	; 0x50


static void big_triple(bigval_t* tgt, bigval_t const* a)
{
    int i;
    uint64_t accum = 0;
    582c:	2600      	movs	r6, #0
    582e:	2700      	movs	r7, #0
       shift does not matter.
     */

    for (i = 0; i < BIGLEN; ++i) 
	{
        accum += a->data[i];
    5830:	680c      	ldr	r4, [r1, #0]
    5832:	2500      	movs	r5, #0
    5834:	1c22      	adds	r2, r4, #0
    5836:	1c2b      	adds	r3, r5, #0
    5838:	1912      	adds	r2, r2, r4
    583a:	416b      	adcs	r3, r5
    583c:	1912      	adds	r2, r2, r4
    583e:	416b      	adcs	r3, r5
        accum += a->data[i];
        accum += a->data[i];
    5840:	1992      	adds	r2, r2, r6
    5842:	417b      	adcs	r3, r7
        tgt->data[i] = (uint32_t)accum;
    5844:	c104      	stmia	r1!, {r2}
        accum >>= 32;
    5846:	1c1e      	adds	r6, r3, #0
    5848:	2700      	movs	r7, #0
       significance words, and the most significant word is the last
       word processed, so what is left in the accum after the final
       shift does not matter.
     */

    for (i = 0; i < BIGLEN; ++i) 
    584a:	4281      	cmp	r1, r0
    584c:	d1f0      	bne.n	5830 <pointDouble+0x64>
    big_sqrP(&t1, z1);
    big_subP(&t2, x1, &t1);
    big_addP(&t1, x1, &t1);
    big_mpyP(&t2, &t2, &t1, MOD_MODULUS);
    big_triple(&t2, &t2);
    big_addP(y3, y1, y1);
    584e:	9d01      	ldr	r5, [sp, #4]
    5850:	1c2b      	adds	r3, r5, #0
    5852:	3324      	adds	r3, #36	; 0x24
    5854:	1c1a      	adds	r2, r3, #0
    5856:	a826      	add	r0, sp, #152	; 0x98
    5858:	1c19      	adds	r1, r3, #0
    585a:	4b2c      	ldr	r3, [pc, #176]	; (590c <pointDouble+0x140>)
    585c:	4798      	blx	r3
    big_mpyP(z3, y3, z1, MOD_MODULUS);
    585e:	a81d      	add	r0, sp, #116	; 0x74
    5860:	a926      	add	r1, sp, #152	; 0x98
    5862:	9a00      	ldr	r2, [sp, #0]
    5864:	2300      	movs	r3, #0
    5866:	4c27      	ldr	r4, [pc, #156]	; (5904 <pointDouble+0x138>)
    5868:	47a0      	blx	r4
    big_sqrP(y3, y3);
    586a:	a826      	add	r0, sp, #152	; 0x98
    586c:	1c01      	adds	r1, r0, #0
    586e:	1c02      	adds	r2, r0, #0
    5870:	2300      	movs	r3, #0
    5872:	47a0      	blx	r4
    big_mpyP(&t3, y3, x1, MOD_MODULUS);
    5874:	a802      	add	r0, sp, #8
    5876:	a926      	add	r1, sp, #152	; 0x98
    5878:	1c2a      	adds	r2, r5, #0
    587a:	2300      	movs	r3, #0
    587c:	47a0      	blx	r4
    big_sqrP(y3, y3);
    587e:	a826      	add	r0, sp, #152	; 0x98
    5880:	1c01      	adds	r1, r0, #0
    5882:	1c02      	adds	r2, r0, #0
    5884:	2300      	movs	r3, #0
    5886:	47a0      	blx	r4
 * want to waste cycles.  The code could be written more cleverly to
 * avoid passing over the data twice in the case of an odd value.
 */
static void big_halveP(bigval_t* tgt, bigval_t const* a)
{
    if (a->data[0] & 1) 
    5888:	9b26      	ldr	r3, [sp, #152]	; 0x98
    588a:	07db      	lsls	r3, r3, #31
    588c:	d50a      	bpl.n	58a4 <pointDouble+0xd8>
	{
        /* odd */
        big_adjustP(tgt, a, 1);
    588e:	a826      	add	r0, sp, #152	; 0x98
    5890:	1c01      	adds	r1, r0, #0
    5892:	2201      	movs	r2, #1
    5894:	2300      	movs	r3, #0
    5896:	4c1e      	ldr	r4, [pc, #120]	; (5910 <pointDouble+0x144>)
    5898:	47a0      	blx	r4
        big_halve(tgt, tgt);
    589a:	a826      	add	r0, sp, #152	; 0x98
    589c:	1c01      	adds	r1, r0, #0
    589e:	4b1d      	ldr	r3, [pc, #116]	; (5914 <pointDouble+0x148>)
    58a0:	4798      	blx	r3
    58a2:	e003      	b.n	58ac <pointDouble+0xe0>
    } 
	else
	{
        /* even */
        big_halve(tgt, a);
    58a4:	a826      	add	r0, sp, #152	; 0x98
    58a6:	1c01      	adds	r1, r0, #0
    58a8:	4b1a      	ldr	r3, [pc, #104]	; (5914 <pointDouble+0x148>)
    58aa:	4798      	blx	r3
    big_mpyP(z3, y3, z1, MOD_MODULUS);
    big_sqrP(y3, y3);
    big_mpyP(&t3, y3, x1, MOD_MODULUS);
    big_sqrP(y3, y3);
    big_halveP(y3, y3);
    big_sqrP(x3, &t2);
    58ac:	a82f      	add	r0, sp, #188	; 0xbc
    58ae:	a90b      	add	r1, sp, #44	; 0x2c
    58b0:	1c0a      	adds	r2, r1, #0
    58b2:	2300      	movs	r3, #0
    58b4:	4d13      	ldr	r5, [pc, #76]	; (5904 <pointDouble+0x138>)
    58b6:	47a8      	blx	r5
    big_addP(&t1, &t3, &t3);
    58b8:	a814      	add	r0, sp, #80	; 0x50
    58ba:	a902      	add	r1, sp, #8
    58bc:	1c0a      	adds	r2, r1, #0
    58be:	4b13      	ldr	r3, [pc, #76]	; (590c <pointDouble+0x140>)
    58c0:	4798      	blx	r3
    /* x1 not used after this point.  Safe to store to tgt, even if aliased */
    big_subP(&tgt->X /* x3 */, x3, &t1);
    58c2:	4640      	mov	r0, r8
    58c4:	a92f      	add	r1, sp, #188	; 0xbc
    58c6:	aa14      	add	r2, sp, #80	; 0x50
    58c8:	4c0f      	ldr	r4, [pc, #60]	; (5908 <pointDouble+0x13c>)
    58ca:	47a0      	blx	r4
#undef  x3
#define x3 (&tgt->X)
    big_subP(&t1, &t3, x3);
    58cc:	a814      	add	r0, sp, #80	; 0x50
    58ce:	a902      	add	r1, sp, #8
    58d0:	4642      	mov	r2, r8
    58d2:	47a0      	blx	r4
    big_mpyP(&t1, &t1, &t2, MOD_MODULUS);
    58d4:	a814      	add	r0, sp, #80	; 0x50
    58d6:	1c01      	adds	r1, r0, #0
    58d8:	aa0b      	add	r2, sp, #44	; 0x2c
    58da:	2300      	movs	r3, #0
    58dc:	47a8      	blx	r5
    big_subP(&tgt->Y, &t1, y3);
    58de:	4640      	mov	r0, r8
    58e0:	3024      	adds	r0, #36	; 0x24
    58e2:	a914      	add	r1, sp, #80	; 0x50
    58e4:	aa26      	add	r2, sp, #152	; 0x98
    58e6:	47a0      	blx	r4

    /* Z components of returned Jacobian points must
       be precisely reduced */
    big_precise_reduce(&tgt->Z, z3, &modulusP);
    58e8:	4640      	mov	r0, r8
    58ea:	3048      	adds	r0, #72	; 0x48
    58ec:	a91d      	add	r1, sp, #116	; 0x74
    58ee:	4a0a      	ldr	r2, [pc, #40]	; (5918 <pointDouble+0x14c>)
    58f0:	4b0a      	ldr	r3, [pc, #40]	; (591c <pointDouble+0x150>)
    58f2:	4798      	blx	r3
#undef y1
#undef z1
#undef x3
#undef y3
#undef z3
}
    58f4:	b038      	add	sp, #224	; 0xe0
    58f6:	bc04      	pop	{r2}
    58f8:	4690      	mov	r8, r2
    58fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    58fc:	000057a9 	.word	0x000057a9
    5900:	00016773 	.word	0x00016773
    5904:	00004e49 	.word	0x00004e49
    5908:	0000546d 	.word	0x0000546d
    590c:	00004dd1 	.word	0x00004dd1
    5910:	00004cd5 	.word	0x00004cd5
    5914:	000054e1 	.word	0x000054e1
    5918:	0001ba78 	.word	0x0001ba78
    591c:	00005545 	.word	0x00005545

00005920 <pointAdd>:
/* tgt = P + Q.  P->Z must be precisely reduced.
   tgt->Z will be precisely reduced.  tgt and P can be aliased.
 */
static void pointAdd(jacobian_point_t* tgt, jacobian_point_t const* P,
                     affine_point_t const* Q)
{
    5920:	b5f0      	push	{r4, r5, r6, r7, lr}
    5922:	b0b1      	sub	sp, #196	; 0xc4
    5924:	1c04      	adds	r4, r0, #0
    5926:	1c0d      	adds	r5, r1, #0
    5928:	1c17      	adds	r7, r2, #0
    bigval_t t1, t2, t3, t4, x3loc;

    if (Q->infinity) 
    592a:	6c93      	ldr	r3, [r2, #72]	; 0x48
    592c:	2b00      	cmp	r3, #0
    592e:	d006      	beq.n	593e <pointAdd+0x1e>
	{
        if (tgt != P) 
    5930:	4288      	cmp	r0, r1
    5932:	d100      	bne.n	5936 <pointAdd+0x16>
    5934:	e09f      	b.n	5a76 <pointAdd+0x156>
		{
            *tgt = *P;
    5936:	226c      	movs	r2, #108	; 0x6c
    5938:	4b50      	ldr	r3, [pc, #320]	; (5a7c <pointAdd+0x15c>)
    593a:	4798      	blx	r3
    593c:	e09b      	b.n	5a76 <pointAdd+0x156>
        }
        return;
    }

    /* This requires that P->Z be precisely reduced */
    if (jacobian_point_is_infinity(P)) 
    593e:	2348      	movs	r3, #72	; 0x48
    5940:	469c      	mov	ip, r3
    5942:	448c      	add	ip, r1
    5944:	4663      	mov	r3, ip
    5946:	9300      	str	r3, [sp, #0]
    5948:	4660      	mov	r0, ip
    594a:	4b4d      	ldr	r3, [pc, #308]	; (5a80 <pointAdd+0x160>)
    594c:	4798      	blx	r3
    594e:	2800      	cmp	r0, #0
    5950:	d004      	beq.n	595c <pointAdd+0x3c>
	{
        toJacobian(tgt, Q);
    5952:	1c20      	adds	r0, r4, #0
    5954:	1c39      	adds	r1, r7, #0
    5956:	4b4b      	ldr	r3, [pc, #300]	; (5a84 <pointAdd+0x164>)
    5958:	4798      	blx	r3
        return;
    595a:	e08c      	b.n	5a76 <pointAdd+0x156>
#define y2 (&Q->y)
#define x3 (&x3loc)
#define y3 (&y3loc)
#define z3 (&tgt->Z)

    big_sqrP(&t1, z1);
    595c:	a827      	add	r0, sp, #156	; 0x9c
    595e:	9b00      	ldr	r3, [sp, #0]
    5960:	1c19      	adds	r1, r3, #0
    5962:	1c1a      	adds	r2, r3, #0
    5964:	2300      	movs	r3, #0
    5966:	4e48      	ldr	r6, [pc, #288]	; (5a88 <pointAdd+0x168>)
    5968:	47b0      	blx	r6
    big_mpyP(&t2, &t1, z1, MOD_MODULUS);
    596a:	a81e      	add	r0, sp, #120	; 0x78
    596c:	a927      	add	r1, sp, #156	; 0x9c
    596e:	9a00      	ldr	r2, [sp, #0]
    5970:	2300      	movs	r3, #0
    5972:	47b0      	blx	r6
    big_mpyP(&t1, &t1, x2, MOD_MODULUS);
    5974:	a827      	add	r0, sp, #156	; 0x9c
    5976:	1c01      	adds	r1, r0, #0
    5978:	1c3a      	adds	r2, r7, #0
    597a:	2300      	movs	r3, #0
    597c:	47b0      	blx	r6
    big_mpyP(&t2, &t2, y2, MOD_MODULUS);
    597e:	1c3a      	adds	r2, r7, #0
    5980:	3224      	adds	r2, #36	; 0x24
    5982:	a81e      	add	r0, sp, #120	; 0x78
    5984:	1c01      	adds	r1, r0, #0
    5986:	2300      	movs	r3, #0
    5988:	47b0      	blx	r6
    big_subP(&t1, &t1, x1);
    598a:	a827      	add	r0, sp, #156	; 0x9c
    598c:	1c01      	adds	r1, r0, #0
    598e:	1c2a      	adds	r2, r5, #0
    5990:	4e3e      	ldr	r6, [pc, #248]	; (5a8c <pointAdd+0x16c>)
    5992:	47b0      	blx	r6
    big_subP(&t2, &t2, y1);
    5994:	2324      	movs	r3, #36	; 0x24
    5996:	469c      	mov	ip, r3
    5998:	44ac      	add	ip, r5
    599a:	4663      	mov	r3, ip
    599c:	9301      	str	r3, [sp, #4]
    599e:	a81e      	add	r0, sp, #120	; 0x78
    59a0:	1c01      	adds	r1, r0, #0
    59a2:	4662      	mov	r2, ip
    59a4:	47b0      	blx	r6
    /* big_is_zero requires precisely reduced arg */
    big_precise_reduce(&t1, &t1, &modulusP);
    59a6:	a827      	add	r0, sp, #156	; 0x9c
    59a8:	1c01      	adds	r1, r0, #0
    59aa:	4a39      	ldr	r2, [pc, #228]	; (5a90 <pointAdd+0x170>)
    59ac:	4b39      	ldr	r3, [pc, #228]	; (5a94 <pointAdd+0x174>)
    59ae:	4798      	blx	r3
    if (big_is_zero(&t1)) 
    59b0:	a827      	add	r0, sp, #156	; 0x9c
    59b2:	4b33      	ldr	r3, [pc, #204]	; (5a80 <pointAdd+0x160>)
    59b4:	4798      	blx	r3
    59b6:	2800      	cmp	r0, #0
    59b8:	d01b      	beq.n	59f2 <pointAdd+0xd2>
	{
        big_precise_reduce(&t2, &t2, &modulusP);
    59ba:	a81e      	add	r0, sp, #120	; 0x78
    59bc:	1c01      	adds	r1, r0, #0
    59be:	4a34      	ldr	r2, [pc, #208]	; (5a90 <pointAdd+0x170>)
    59c0:	4b34      	ldr	r3, [pc, #208]	; (5a94 <pointAdd+0x174>)
    59c2:	4798      	blx	r3
        if (big_is_zero(&t2)) 
    59c4:	a81e      	add	r0, sp, #120	; 0x78
    59c6:	4b2e      	ldr	r3, [pc, #184]	; (5a80 <pointAdd+0x160>)
    59c8:	4798      	blx	r3
    59ca:	2800      	cmp	r0, #0
    59cc:	d008      	beq.n	59e0 <pointAdd+0xc0>
		{
            toJacobian(tgt, Q);
    59ce:	1c20      	adds	r0, r4, #0
    59d0:	1c39      	adds	r1, r7, #0
    59d2:	4b2c      	ldr	r3, [pc, #176]	; (5a84 <pointAdd+0x164>)
    59d4:	4798      	blx	r3
            pointDouble(tgt, tgt);
    59d6:	1c20      	adds	r0, r4, #0
    59d8:	1c21      	adds	r1, r4, #0
    59da:	4b2f      	ldr	r3, [pc, #188]	; (5a98 <pointAdd+0x178>)
    59dc:	4798      	blx	r3
    59de:	e04a      	b.n	5a76 <pointAdd+0x156>
        } 
		else 
		{
            *tgt = jacobian_infinity;
    59e0:	1c20      	adds	r0, r4, #0
    59e2:	2100      	movs	r1, #0
    59e4:	226c      	movs	r2, #108	; 0x6c
    59e6:	4b2d      	ldr	r3, [pc, #180]	; (5a9c <pointAdd+0x17c>)
    59e8:	4798      	blx	r3
    59ea:	2301      	movs	r3, #1
    59ec:	6023      	str	r3, [r4, #0]
    59ee:	6263      	str	r3, [r4, #36]	; 0x24
    59f0:	e041      	b.n	5a76 <pointAdd+0x156>
        }
        return;
    }
    /* store into target.  okay, even if tgt is aliased with P,
       as z1 is not subsequently used */
    big_mpyP(z3, z1, &t1, MOD_MODULUS);
    59f2:	1c26      	adds	r6, r4, #0
    59f4:	3648      	adds	r6, #72	; 0x48
    59f6:	1c30      	adds	r0, r6, #0
    59f8:	9900      	ldr	r1, [sp, #0]
    59fa:	aa27      	add	r2, sp, #156	; 0x9c
    59fc:	2300      	movs	r3, #0
    59fe:	4f22      	ldr	r7, [pc, #136]	; (5a88 <pointAdd+0x168>)
    5a00:	47b8      	blx	r7
    /* z coordinates of returned jacobians must be precisely reduced. */
    big_precise_reduce(z3, z3, &modulusP);
    5a02:	1c30      	adds	r0, r6, #0
    5a04:	1c31      	adds	r1, r6, #0
    5a06:	4a22      	ldr	r2, [pc, #136]	; (5a90 <pointAdd+0x170>)
    5a08:	4b22      	ldr	r3, [pc, #136]	; (5a94 <pointAdd+0x174>)
    5a0a:	4798      	blx	r3
    big_sqrP(&t3, &t1);
    5a0c:	a815      	add	r0, sp, #84	; 0x54
    5a0e:	a927      	add	r1, sp, #156	; 0x9c
    5a10:	1c0a      	adds	r2, r1, #0
    5a12:	2300      	movs	r3, #0
    5a14:	47b8      	blx	r7
    big_mpyP(&t4, &t3, &t1, MOD_MODULUS);
    5a16:	a80c      	add	r0, sp, #48	; 0x30
    5a18:	a915      	add	r1, sp, #84	; 0x54
    5a1a:	aa27      	add	r2, sp, #156	; 0x9c
    5a1c:	2300      	movs	r3, #0
    5a1e:	47b8      	blx	r7
    big_mpyP(&t3, &t3, x1, MOD_MODULUS);
    5a20:	a815      	add	r0, sp, #84	; 0x54
    5a22:	1c01      	adds	r1, r0, #0
    5a24:	1c2a      	adds	r2, r5, #0
    5a26:	2300      	movs	r3, #0
    5a28:	47b8      	blx	r7
    big_addP(&t1, &t3, &t3);
    5a2a:	a827      	add	r0, sp, #156	; 0x9c
    5a2c:	a915      	add	r1, sp, #84	; 0x54
    5a2e:	1c0a      	adds	r2, r1, #0
    5a30:	4b1b      	ldr	r3, [pc, #108]	; (5aa0 <pointAdd+0x180>)
    5a32:	4798      	blx	r3
    big_sqrP(x3, &t2);
    5a34:	a803      	add	r0, sp, #12
    5a36:	a91e      	add	r1, sp, #120	; 0x78
    5a38:	1c0a      	adds	r2, r1, #0
    5a3a:	2300      	movs	r3, #0
    5a3c:	47b8      	blx	r7
    big_subP(x3, x3, &t1);
    5a3e:	a803      	add	r0, sp, #12
    5a40:	1c01      	adds	r1, r0, #0
    5a42:	aa27      	add	r2, sp, #156	; 0x9c
    5a44:	4d11      	ldr	r5, [pc, #68]	; (5a8c <pointAdd+0x16c>)
    5a46:	47a8      	blx	r5
    big_subP(&tgt->X /* x3 */, x3, &t4);
    5a48:	1c20      	adds	r0, r4, #0
    5a4a:	a903      	add	r1, sp, #12
    5a4c:	aa0c      	add	r2, sp, #48	; 0x30
    5a4e:	47a8      	blx	r5
    /* switch x3 to tgt */
#undef x3
#define x3 (&tgt->X)
    big_subP(&t3, &t3, x3);
    5a50:	a815      	add	r0, sp, #84	; 0x54
    5a52:	1c01      	adds	r1, r0, #0
    5a54:	1c22      	adds	r2, r4, #0
    5a56:	47a8      	blx	r5
    big_mpyP(&t3, &t3, &t2, MOD_MODULUS);
    5a58:	a815      	add	r0, sp, #84	; 0x54
    5a5a:	1c01      	adds	r1, r0, #0
    5a5c:	aa1e      	add	r2, sp, #120	; 0x78
    5a5e:	2300      	movs	r3, #0
    5a60:	47b8      	blx	r7
    big_mpyP(&t4, &t4, y1, MOD_MODULUS);
    5a62:	a80c      	add	r0, sp, #48	; 0x30
    5a64:	1c01      	adds	r1, r0, #0
    5a66:	9a01      	ldr	r2, [sp, #4]
    5a68:	2300      	movs	r3, #0
    5a6a:	47b8      	blx	r7
    /* switch y3 to tgt */
#undef y3
#define y3 (&tgt->Y)
    big_subP(y3, &t3, &t4);
    5a6c:	1c20      	adds	r0, r4, #0
    5a6e:	3024      	adds	r0, #36	; 0x24
    5a70:	a915      	add	r1, sp, #84	; 0x54
    5a72:	aa0c      	add	r2, sp, #48	; 0x30
    5a74:	47a8      	blx	r5
#undef  y2
#undef  x3
#undef  y3
#undef  z3

}
    5a76:	b031      	add	sp, #196	; 0xc4
    5a78:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5a7a:	46c0      	nop			; (mov r8, r8)
    5a7c:	00016739 	.word	0x00016739
    5a80:	000057a9 	.word	0x000057a9
    5a84:	0000550d 	.word	0x0000550d
    5a88:	00004e49 	.word	0x00004e49
    5a8c:	0000546d 	.word	0x0000546d
    5a90:	0001ba78 	.word	0x0001ba78
    5a94:	00005545 	.word	0x00005545
    5a98:	000057cd 	.word	0x000057cd
    5a9c:	00016773 	.word	0x00016773
    5aa0:	00004dd1 	.word	0x00004dd1

00005aa4 <toAffine>:
    tgt->Z = big_one;
}

/* a->Z must be precisely reduced */
static void toAffine(affine_point_t* tgt, jacobian_point_t const* a)
{
    5aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
    5aa6:	b093      	sub	sp, #76	; 0x4c
    5aa8:	1c04      	adds	r4, r0, #0
    5aaa:	1c0d      	adds	r5, r1, #0
    bigval_t zinv, zinvpwr;

    if (big_is_zero(&a->Z)) 
    5aac:	1c0f      	adds	r7, r1, #0
    5aae:	3748      	adds	r7, #72	; 0x48
    5ab0:	1c38      	adds	r0, r7, #0
    5ab2:	4b1b      	ldr	r3, [pc, #108]	; (5b20 <toAffine+0x7c>)
    5ab4:	4798      	blx	r3
    5ab6:	2800      	cmp	r0, #0
    5ab8:	d007      	beq.n	5aca <toAffine+0x26>
	{
        *tgt = affine_infinity;
    5aba:	1c20      	adds	r0, r4, #0
    5abc:	2100      	movs	r1, #0
    5abe:	224c      	movs	r2, #76	; 0x4c
    5ac0:	4b18      	ldr	r3, [pc, #96]	; (5b24 <toAffine+0x80>)
    5ac2:	4798      	blx	r3
    5ac4:	2301      	movs	r3, #1
    5ac6:	64a3      	str	r3, [r4, #72]	; 0x48
    5ac8:	e028      	b.n	5b1c <toAffine+0x78>
        return;
    }
    big_divide(&zinv, &big_one, &a->Z, &modulusP);
    5aca:	a809      	add	r0, sp, #36	; 0x24
    5acc:	4916      	ldr	r1, [pc, #88]	; (5b28 <toAffine+0x84>)
    5ace:	1c3a      	adds	r2, r7, #0
    5ad0:	4b16      	ldr	r3, [pc, #88]	; (5b2c <toAffine+0x88>)
    5ad2:	4f17      	ldr	r7, [pc, #92]	; (5b30 <toAffine+0x8c>)
    5ad4:	47b8      	blx	r7
    big_sqrP(&zinvpwr, &zinv);  /* Zinv^2 */
    5ad6:	4668      	mov	r0, sp
    5ad8:	a909      	add	r1, sp, #36	; 0x24
    5ada:	1c0a      	adds	r2, r1, #0
    5adc:	2300      	movs	r3, #0
    5ade:	4e15      	ldr	r6, [pc, #84]	; (5b34 <toAffine+0x90>)
    5ae0:	47b0      	blx	r6
    big_mpyP(&tgt->x, &a->X, &zinvpwr, MOD_MODULUS);
    5ae2:	1c20      	adds	r0, r4, #0
    5ae4:	1c29      	adds	r1, r5, #0
    5ae6:	466a      	mov	r2, sp
    5ae8:	2300      	movs	r3, #0
    5aea:	47b0      	blx	r6
    big_mpyP(&zinvpwr, &zinvpwr, &zinv, MOD_MODULUS); /* Zinv^3 */
    5aec:	4668      	mov	r0, sp
    5aee:	4669      	mov	r1, sp
    5af0:	aa09      	add	r2, sp, #36	; 0x24
    5af2:	2300      	movs	r3, #0
    5af4:	47b0      	blx	r6
    big_mpyP(&tgt->y, &a->Y, &zinvpwr, MOD_MODULUS);
    5af6:	1c27      	adds	r7, r4, #0
    5af8:	3724      	adds	r7, #36	; 0x24
    5afa:	1c29      	adds	r1, r5, #0
    5afc:	3124      	adds	r1, #36	; 0x24
    5afe:	1c38      	adds	r0, r7, #0
    5b00:	466a      	mov	r2, sp
    5b02:	2300      	movs	r3, #0
    5b04:	47b0      	blx	r6
    big_precise_reduce(&tgt->x, &tgt->x, &modulusP);
    5b06:	1c20      	adds	r0, r4, #0
    5b08:	1c21      	adds	r1, r4, #0
    5b0a:	4a08      	ldr	r2, [pc, #32]	; (5b2c <toAffine+0x88>)
    5b0c:	4d0a      	ldr	r5, [pc, #40]	; (5b38 <toAffine+0x94>)
    5b0e:	47a8      	blx	r5
    big_precise_reduce(&tgt->y, &tgt->y, &modulusP);
    5b10:	1c38      	adds	r0, r7, #0
    5b12:	1c39      	adds	r1, r7, #0
    5b14:	4a05      	ldr	r2, [pc, #20]	; (5b2c <toAffine+0x88>)
    5b16:	47a8      	blx	r5
    tgt->infinity = B_FALSE;
    5b18:	2300      	movs	r3, #0
    5b1a:	64a3      	str	r3, [r4, #72]	; 0x48
}
    5b1c:	b013      	add	sp, #76	; 0x4c
    5b1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5b20:	000057a9 	.word	0x000057a9
    5b24:	00016773 	.word	0x00016773
    5b28:	0001ba9c 	.word	0x0001ba9c
    5b2c:	0001ba78 	.word	0x0001ba78
    5b30:	00005649 	.word	0x00005649
    5b34:	00004e49 	.word	0x00004e49
    5b38:	00005545 	.word	0x00005545

00005b3c <pointMpyP>:

/* k must be non-negative.  Negative values (incorrectly)
   return the infinite point */

static void pointMpyP(affine_point_t* tgt, bigval_t const* k, affine_point_t const* P)
{
    5b3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b3e:	4657      	mov	r7, sl
    5b40:	464e      	mov	r6, r9
    5b42:	4645      	mov	r5, r8
    5b44:	b4e0      	push	{r5, r6, r7}
    5b46:	b0c6      	sub	sp, #280	; 0x118
    5b48:	4680      	mov	r8, r0
    5b4a:	1c0d      	adds	r5, r1, #0
    5b4c:	1c14      	adds	r4, r2, #0
#ifdef MPY2BITS
    affine_point_t const* mpyset[4];
    affine_point_t twoP, threeP;
#endif /* MPY2BITS */

    if (big_is_negative(k)) 
    5b4e:	6a0b      	ldr	r3, [r1, #32]
    5b50:	2b00      	cmp	r3, #0
    5b52:	da07      	bge.n	5b64 <pointMpyP+0x28>
	{
        /* This should never happen.*/
        *tgt = affine_infinity;
    5b54:	2100      	movs	r1, #0
    5b56:	224c      	movs	r2, #76	; 0x4c
    5b58:	4b46      	ldr	r3, [pc, #280]	; (5c74 <pointMpyP+0x138>)
    5b5a:	4798      	blx	r3
    5b5c:	2301      	movs	r3, #1
    5b5e:	4642      	mov	r2, r8
    5b60:	6493      	str	r3, [r2, #72]	; 0x48
        return;
    5b62:	e081      	b.n	5c68 <pointMpyP+0x12c>
    }

    Q = jacobian_infinity;
    5b64:	a82b      	add	r0, sp, #172	; 0xac
    5b66:	2100      	movs	r1, #0
    5b68:	226c      	movs	r2, #108	; 0x6c
    5b6a:	4b42      	ldr	r3, [pc, #264]	; (5c74 <pointMpyP+0x138>)
    5b6c:	4798      	blx	r3
    5b6e:	2301      	movs	r3, #1
    5b70:	932b      	str	r3, [sp, #172]	; 0xac
    5b72:	9334      	str	r3, [sp, #208]	; 0xd0

    /* faster */
    if (big_is_zero(k) || big_is_negative(k)) 
    5b74:	1c28      	adds	r0, r5, #0
    5b76:	4b40      	ldr	r3, [pc, #256]	; (5c78 <pointMpyP+0x13c>)
    5b78:	4798      	blx	r3
    5b7a:	2800      	cmp	r0, #0
    5b7c:	d008      	beq.n	5b90 <pointMpyP+0x54>
	{
        *tgt = affine_infinity;
    5b7e:	4640      	mov	r0, r8
    5b80:	2100      	movs	r1, #0
    5b82:	224c      	movs	r2, #76	; 0x4c
    5b84:	4b3b      	ldr	r3, [pc, #236]	; (5c74 <pointMpyP+0x138>)
    5b86:	4798      	blx	r3
    5b88:	2301      	movs	r3, #1
    5b8a:	4642      	mov	r2, r8
    5b8c:	6493      	str	r3, [r2, #72]	; 0x48
        return;
    5b8e:	e06b      	b.n	5c68 <pointMpyP+0x12c>
        }
    }
#else /* MPY2BITS defined */
      /* multiply 2 bits at a time */
      /* precompute 1P, 2P, and 3P */
    mpyset[0] = (affine_point_t*)0;
    5b90:	2300      	movs	r3, #0
    5b92:	9327      	str	r3, [sp, #156]	; 0x9c
    mpyset[1] = P;
    5b94:	9428      	str	r4, [sp, #160]	; 0xa0
    toJacobian(&Q, P);  /* Q = P */
    5b96:	a82b      	add	r0, sp, #172	; 0xac
    5b98:	1c21      	adds	r1, r4, #0
    5b9a:	4b38      	ldr	r3, [pc, #224]	; (5c7c <pointMpyP+0x140>)
    5b9c:	4798      	blx	r3
    pointDouble(&Q, &Q); /* now Q = 2P */
    5b9e:	a82b      	add	r0, sp, #172	; 0xac
    5ba0:	1c01      	adds	r1, r0, #0
    5ba2:	4b37      	ldr	r3, [pc, #220]	; (5c80 <pointMpyP+0x144>)
    5ba4:	4798      	blx	r3
    toAffine(&twoP, &Q);
    5ba6:	ae14      	add	r6, sp, #80	; 0x50
    5ba8:	1c30      	adds	r0, r6, #0
    5baa:	a92b      	add	r1, sp, #172	; 0xac
    5bac:	4f35      	ldr	r7, [pc, #212]	; (5c84 <pointMpyP+0x148>)
    5bae:	47b8      	blx	r7
    mpyset[2] = &twoP;
    5bb0:	9629      	str	r6, [sp, #164]	; 0xa4
    pointAdd(&Q, &Q, P); /* now Q = 3P */
    5bb2:	a82b      	add	r0, sp, #172	; 0xac
    5bb4:	1c01      	adds	r1, r0, #0
    5bb6:	1c22      	adds	r2, r4, #0
    5bb8:	4b33      	ldr	r3, [pc, #204]	; (5c88 <pointMpyP+0x14c>)
    5bba:	4798      	blx	r3
    toAffine(&threeP, &Q);
    5bbc:	ac01      	add	r4, sp, #4
    5bbe:	1c20      	adds	r0, r4, #0
    5bc0:	a92b      	add	r1, sp, #172	; 0xac
    5bc2:	47b8      	blx	r7
    mpyset[3] = &threeP;
    5bc4:	942a      	str	r4, [sp, #168]	; 0xa8

    /* discard high order zeros (in pairs) */
    for (i = BIGLEN * 32 - 2; i >= 0; i -= 2) 
	{
        if (big_get_2bits(k, i)) 
    5bc6:	6a2b      	ldr	r3, [r5, #32]
    5bc8:	0f9b      	lsrs	r3, r3, #30
    5bca:	d13d      	bne.n	5c48 <pointMpyP+0x10c>
    5bcc:	248e      	movs	r4, #142	; 0x8e
    5bce:	0064      	lsls	r4, r4, #1
    5bd0:	271f      	movs	r7, #31
    5bd2:	2003      	movs	r0, #3
    5bd4:	17e3      	asrs	r3, r4, #31
    5bd6:	0eda      	lsrs	r2, r3, #27
    5bd8:	1913      	adds	r3, r2, r4
    5bda:	1159      	asrs	r1, r3, #5
    5bdc:	0089      	lsls	r1, r1, #2
    5bde:	403b      	ands	r3, r7
    5be0:	1a9b      	subs	r3, r3, r2
    5be2:	594a      	ldr	r2, [r1, r5]
    5be4:	40da      	lsrs	r2, r3
    5be6:	4210      	tst	r0, r2
    5be8:	d130      	bne.n	5c4c <pointMpyP+0x110>
    pointAdd(&Q, &Q, P); /* now Q = 3P */
    toAffine(&threeP, &Q);
    mpyset[3] = &threeP;

    /* discard high order zeros (in pairs) */
    for (i = BIGLEN * 32 - 2; i >= 0; i -= 2) 
    5bea:	3c02      	subs	r4, #2
    5bec:	1ca3      	adds	r3, r4, #2
    5bee:	d1f1      	bne.n	5bd4 <pointMpyP+0x98>
    5bf0:	e021      	b.n	5c36 <pointMpyP+0xfa>

    Q = jacobian_infinity;

    for (; i >= 0; i -= 2) 
	{
        int mbits = big_get_2bits(k, i);
    5bf2:	17e7      	asrs	r7, r4, #31
    5bf4:	0efb      	lsrs	r3, r7, #27
    5bf6:	191f      	adds	r7, r3, r4
    5bf8:	117a      	asrs	r2, r7, #5
    5bfa:	0092      	lsls	r2, r2, #2
    5bfc:	4649      	mov	r1, r9
    5bfe:	400f      	ands	r7, r1
    5c00:	1aff      	subs	r7, r7, r3
    5c02:	5953      	ldr	r3, [r2, r5]
    5c04:	40fb      	lsrs	r3, r7
    5c06:	1c1f      	adds	r7, r3, #0
    5c08:	2303      	movs	r3, #3
    5c0a:	401f      	ands	r7, r3
        pointDouble(&Q, &Q);
    5c0c:	a82b      	add	r0, sp, #172	; 0xac
    5c0e:	1c01      	adds	r1, r0, #0
    5c10:	47b0      	blx	r6
        pointDouble(&Q, &Q);
    5c12:	a82b      	add	r0, sp, #172	; 0xac
    5c14:	1c01      	adds	r1, r0, #0
    5c16:	47b0      	blx	r6
        if (mpyset[mbits] != (affine_point_t*)0) 
    5c18:	00bf      	lsls	r7, r7, #2
    5c1a:	ab27      	add	r3, sp, #156	; 0x9c
    5c1c:	58fa      	ldr	r2, [r7, r3]
    5c1e:	2a00      	cmp	r2, #0
    5c20:	d002      	beq.n	5c28 <pointMpyP+0xec>
		{
            pointAdd(&Q, &Q, mpyset[mbits]);
    5c22:	a82b      	add	r0, sp, #172	; 0xac
    5c24:	1c01      	adds	r1, r0, #0
    5c26:	47d0      	blx	sl
        }
    }

    Q = jacobian_infinity;

    for (; i >= 0; i -= 2) 
    5c28:	3c02      	subs	r4, #2
    5c2a:	d5e2      	bpl.n	5bf2 <pointMpyP+0xb6>
        }
    }

#endif /* MPY2BITS */

    toAffine(tgt, &Q);
    5c2c:	4640      	mov	r0, r8
    5c2e:	a92b      	add	r1, sp, #172	; 0xac
    5c30:	4b14      	ldr	r3, [pc, #80]	; (5c84 <pointMpyP+0x148>)
    5c32:	4798      	blx	r3
    5c34:	e018      	b.n	5c68 <pointMpyP+0x12c>
		{
            break;
        }
    }

    Q = jacobian_infinity;
    5c36:	a82b      	add	r0, sp, #172	; 0xac
    5c38:	2100      	movs	r1, #0
    5c3a:	226c      	movs	r2, #108	; 0x6c
    5c3c:	4b0d      	ldr	r3, [pc, #52]	; (5c74 <pointMpyP+0x138>)
    5c3e:	4798      	blx	r3
    5c40:	2301      	movs	r3, #1
    5c42:	932b      	str	r3, [sp, #172]	; 0xac
    5c44:	9334      	str	r3, [sp, #208]	; 0xd0
    5c46:	e7f1      	b.n	5c2c <pointMpyP+0xf0>
    pointAdd(&Q, &Q, P); /* now Q = 3P */
    toAffine(&threeP, &Q);
    mpyset[3] = &threeP;

    /* discard high order zeros (in pairs) */
    for (i = BIGLEN * 32 - 2; i >= 0; i -= 2) 
    5c48:	248f      	movs	r4, #143	; 0x8f
    5c4a:	0064      	lsls	r4, r4, #1
		{
            break;
        }
    }

    Q = jacobian_infinity;
    5c4c:	a82b      	add	r0, sp, #172	; 0xac
    5c4e:	2100      	movs	r1, #0
    5c50:	226c      	movs	r2, #108	; 0x6c
    5c52:	4b08      	ldr	r3, [pc, #32]	; (5c74 <pointMpyP+0x138>)
    5c54:	4798      	blx	r3
    5c56:	2301      	movs	r3, #1
    5c58:	932b      	str	r3, [sp, #172]	; 0xac
    5c5a:	9334      	str	r3, [sp, #208]	; 0xd0

    for (; i >= 0; i -= 2) 
	{
        int mbits = big_get_2bits(k, i);
    5c5c:	331e      	adds	r3, #30
    5c5e:	4699      	mov	r9, r3
        pointDouble(&Q, &Q);
    5c60:	4e07      	ldr	r6, [pc, #28]	; (5c80 <pointMpyP+0x144>)
        pointDouble(&Q, &Q);
        if (mpyset[mbits] != (affine_point_t*)0) 
		{
            pointAdd(&Q, &Q, mpyset[mbits]);
    5c62:	4b09      	ldr	r3, [pc, #36]	; (5c88 <pointMpyP+0x14c>)
    5c64:	469a      	mov	sl, r3
    5c66:	e7c4      	b.n	5bf2 <pointMpyP+0xb6>
    }

#endif /* MPY2BITS */

    toAffine(tgt, &Q);
}
    5c68:	b046      	add	sp, #280	; 0x118
    5c6a:	bc1c      	pop	{r2, r3, r4}
    5c6c:	4690      	mov	r8, r2
    5c6e:	4699      	mov	r9, r3
    5c70:	46a2      	mov	sl, r4
    5c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c74:	00016773 	.word	0x00016773
    5c78:	000057a9 	.word	0x000057a9
    5c7c:	0000550d 	.word	0x0000550d
    5c80:	000057cd 	.word	0x000057cd
    5c84:	00005aa5 	.word	0x00005aa5
    5c88:	00005921 	.word	0x00005921

00005c8c <ECDSA_verify_inner>:
 * The implementation follow HMV Algorithm 4.30.
 */
static verify_res_t ECDSA_verify_inner(bigval_t const* msgdgst,
                                       affine_point_t const* pubkey,
                                       ECDSA_sig_t const* sig)
{
    5c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5c8e:	4c36      	ldr	r4, [pc, #216]	; (5d68 <ECDSA_verify_inner+0xdc>)
    5c90:	44a5      	add	sp, r4
    5c92:	1c06      	adds	r6, r0, #0
    5c94:	1c0d      	adds	r5, r1, #0
    5c96:	1c14      	adds	r4, r2, #0
    affine_point_t P2;
    affine_point_t X;
    jacobian_point_t P2Jacobian;
    jacobian_point_t XJacobian;

    if (big_cmp(&sig->r, &big_one) < 0) 
    5c98:	1c10      	adds	r0, r2, #0
    5c9a:	4934      	ldr	r1, [pc, #208]	; (5d6c <ECDSA_verify_inner+0xe0>)
    5c9c:	4b34      	ldr	r3, [pc, #208]	; (5d70 <ECDSA_verify_inner+0xe4>)
    5c9e:	4798      	blx	r3
    5ca0:	2800      	cmp	r0, #0
    5ca2:	db5a      	blt.n	5d5a <ECDSA_verify_inner+0xce>
	{
        return (V_R_ZERO);
    }
    if (big_cmp(&sig->r, &orderP) >= 0) 
    5ca4:	1c20      	adds	r0, r4, #0
    5ca6:	4933      	ldr	r1, [pc, #204]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5ca8:	4b31      	ldr	r3, [pc, #196]	; (5d70 <ECDSA_verify_inner+0xe4>)
    5caa:	4798      	blx	r3
	{
        return(V_R_BIG);
    5cac:	2302      	movs	r3, #2

    if (big_cmp(&sig->r, &big_one) < 0) 
	{
        return (V_R_ZERO);
    }
    if (big_cmp(&sig->r, &orderP) >= 0) 
    5cae:	2800      	cmp	r0, #0
    5cb0:	da54      	bge.n	5d5c <ECDSA_verify_inner+0xd0>
	{
        return(V_R_BIG);
    }
    if (big_cmp(&sig->s, &big_one) < 0) 
    5cb2:	1c27      	adds	r7, r4, #0
    5cb4:	3724      	adds	r7, #36	; 0x24
    5cb6:	1c38      	adds	r0, r7, #0
    5cb8:	492c      	ldr	r1, [pc, #176]	; (5d6c <ECDSA_verify_inner+0xe0>)
    5cba:	4b2d      	ldr	r3, [pc, #180]	; (5d70 <ECDSA_verify_inner+0xe4>)
    5cbc:	4798      	blx	r3
	{
        return (V_S_ZERO);
    5cbe:	2303      	movs	r3, #3
    }
    if (big_cmp(&sig->r, &orderP) >= 0) 
	{
        return(V_R_BIG);
    }
    if (big_cmp(&sig->s, &big_one) < 0) 
    5cc0:	2800      	cmp	r0, #0
    5cc2:	db4b      	blt.n	5d5c <ECDSA_verify_inner+0xd0>
	{
        return (V_S_ZERO);
    }
    if (big_cmp(&sig->s, &orderP) >= 0) 
    5cc4:	1c38      	adds	r0, r7, #0
    5cc6:	492b      	ldr	r1, [pc, #172]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5cc8:	4b29      	ldr	r3, [pc, #164]	; (5d70 <ECDSA_verify_inner+0xe4>)
    5cca:	4798      	blx	r3
	{
        return(V_S_BIG);
    5ccc:	2304      	movs	r3, #4
    }
    if (big_cmp(&sig->s, &big_one) < 0) 
	{
        return (V_S_ZERO);
    }
    if (big_cmp(&sig->s, &orderP) >= 0) 
    5cce:	2800      	cmp	r0, #0
    5cd0:	da44      	bge.n	5d5c <ECDSA_verify_inner+0xd0>
	{
        return(V_S_BIG);
    }

    big_divide(&w, &big_one, &sig->s, &orderP);
    5cd2:	a882      	add	r0, sp, #520	; 0x208
    5cd4:	4925      	ldr	r1, [pc, #148]	; (5d6c <ECDSA_verify_inner+0xe0>)
    5cd6:	1c3a      	adds	r2, r7, #0
    5cd8:	4b26      	ldr	r3, [pc, #152]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5cda:	4f27      	ldr	r7, [pc, #156]	; (5d78 <ECDSA_verify_inner+0xec>)
    5cdc:	47b8      	blx	r7
    big_mpyP(&u1, msgdgst, &w, MOD_ORDER);
    5cde:	a879      	add	r0, sp, #484	; 0x1e4
    5ce0:	1c31      	adds	r1, r6, #0
    5ce2:	aa82      	add	r2, sp, #520	; 0x208
    5ce4:	2301      	movs	r3, #1
    5ce6:	4f25      	ldr	r7, [pc, #148]	; (5d7c <ECDSA_verify_inner+0xf0>)
    5ce8:	47b8      	blx	r7
    big_precise_reduce(&u1, &u1, &orderP);
    5cea:	a879      	add	r0, sp, #484	; 0x1e4
    5cec:	1c01      	adds	r1, r0, #0
    5cee:	4a21      	ldr	r2, [pc, #132]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5cf0:	4e23      	ldr	r6, [pc, #140]	; (5d80 <ECDSA_verify_inner+0xf4>)
    5cf2:	47b0      	blx	r6
    big_mpyP(&u2, &sig->r, &w, MOD_ORDER);
    5cf4:	a870      	add	r0, sp, #448	; 0x1c0
    5cf6:	1c21      	adds	r1, r4, #0
    5cf8:	aa82      	add	r2, sp, #520	; 0x208
    5cfa:	2301      	movs	r3, #1
    5cfc:	47b8      	blx	r7
    big_precise_reduce(&u2, &u2, &orderP);
    5cfe:	a870      	add	r0, sp, #448	; 0x1c0
    5d00:	1c01      	adds	r1, r0, #0
    5d02:	4a1c      	ldr	r2, [pc, #112]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5d04:	47b0      	blx	r6
    pointMpyP(&P1, &u1, &base_point);
    5d06:	a85d      	add	r0, sp, #372	; 0x174
    5d08:	a979      	add	r1, sp, #484	; 0x1e4
    5d0a:	4a1e      	ldr	r2, [pc, #120]	; (5d84 <ECDSA_verify_inner+0xf8>)
    5d0c:	4e1e      	ldr	r6, [pc, #120]	; (5d88 <ECDSA_verify_inner+0xfc>)
    5d0e:	47b0      	blx	r6
    pointMpyP(&P2, &u2, pubkey);
    5d10:	a84a      	add	r0, sp, #296	; 0x128
    5d12:	a970      	add	r1, sp, #448	; 0x1c0
    5d14:	1c2a      	adds	r2, r5, #0
    5d16:	47b0      	blx	r6
    toJacobian(&P2Jacobian, &P2);
    5d18:	a81c      	add	r0, sp, #112	; 0x70
    5d1a:	a94a      	add	r1, sp, #296	; 0x128
    5d1c:	4b1b      	ldr	r3, [pc, #108]	; (5d8c <ECDSA_verify_inner+0x100>)
    5d1e:	4798      	blx	r3
    pointAdd(&XJacobian, &P2Jacobian, &P1);
    5d20:	a801      	add	r0, sp, #4
    5d22:	a91c      	add	r1, sp, #112	; 0x70
    5d24:	aa5d      	add	r2, sp, #372	; 0x174
    5d26:	4b1a      	ldr	r3, [pc, #104]	; (5d90 <ECDSA_verify_inner+0x104>)
    5d28:	4798      	blx	r3
    toAffine(&X, &XJacobian);
    5d2a:	a837      	add	r0, sp, #220	; 0xdc
    5d2c:	a901      	add	r1, sp, #4
    5d2e:	4b19      	ldr	r3, [pc, #100]	; (5d94 <ECDSA_verify_inner+0x108>)
    5d30:	4798      	blx	r3
    if (X.infinity) 
	{
        return (V_INFINITY);
    5d32:	2305      	movs	r3, #5
    pointMpyP(&P1, &u1, &base_point);
    pointMpyP(&P2, &u2, pubkey);
    toJacobian(&P2Jacobian, &P2);
    pointAdd(&XJacobian, &P2Jacobian, &P1);
    toAffine(&X, &XJacobian);
    if (X.infinity) 
    5d34:	9a49      	ldr	r2, [sp, #292]	; 0x124
    5d36:	2a00      	cmp	r2, #0
    5d38:	d110      	bne.n	5d5c <ECDSA_verify_inner+0xd0>
	{
        return (V_INFINITY);
    }
    big_precise_reduce(&v, &X.x, &orderP);
    5d3a:	a88b      	add	r0, sp, #556	; 0x22c
    5d3c:	a937      	add	r1, sp, #220	; 0xdc
    5d3e:	4a0d      	ldr	r2, [pc, #52]	; (5d74 <ECDSA_verify_inner+0xe8>)
    5d40:	4b0f      	ldr	r3, [pc, #60]	; (5d80 <ECDSA_verify_inner+0xf4>)
    5d42:	4798      	blx	r3
    if (big_cmp(&v, &sig->r) != 0) 
    5d44:	a88b      	add	r0, sp, #556	; 0x22c
    5d46:	1c21      	adds	r1, r4, #0
    5d48:	4b09      	ldr	r3, [pc, #36]	; (5d70 <ECDSA_verify_inner+0xe4>)
    5d4a:	4798      	blx	r3
	{
        return (V_UNEQUAL);
    5d4c:	2306      	movs	r3, #6
    }
    return (V_SUCCESS);
    5d4e:	1c02      	adds	r2, r0, #0
    5d50:	1e50      	subs	r0, r2, #1
    5d52:	4182      	sbcs	r2, r0
    5d54:	4252      	negs	r2, r2
    5d56:	4013      	ands	r3, r2
    5d58:	e000      	b.n	5d5c <ECDSA_verify_inner+0xd0>
    jacobian_point_t P2Jacobian;
    jacobian_point_t XJacobian;

    if (big_cmp(&sig->r, &big_one) < 0) 
	{
        return (V_R_ZERO);
    5d5a:	2301      	movs	r3, #1
    if (big_cmp(&v, &sig->r) != 0) 
	{
        return (V_UNEQUAL);
    }
    return (V_SUCCESS);
}
    5d5c:	1c18      	adds	r0, r3, #0
    5d5e:	2395      	movs	r3, #149	; 0x95
    5d60:	009b      	lsls	r3, r3, #2
    5d62:	449d      	add	sp, r3
    5d64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5d66:	46c0      	nop			; (mov r8, r8)
    5d68:	fffffdac 	.word	0xfffffdac
    5d6c:	0001ba9c 	.word	0x0001ba9c
    5d70:	00005491 	.word	0x00005491
    5d74:	0001bac0 	.word	0x0001bac0
    5d78:	00005649 	.word	0x00005649
    5d7c:	00004e49 	.word	0x00004e49
    5d80:	00005545 	.word	0x00005545
    5d84:	0001b998 	.word	0x0001b998
    5d88:	00005b3d 	.word	0x00005b3d
    5d8c:	0000550d 	.word	0x0000550d
    5d90:	00005921 	.word	0x00005921
    5d94:	00005aa5 	.word	0x00005aa5

00005d98 <in_curveP>:

    toAffine(tgt, &Q);
}

COND_STATIC boolean_t in_curveP(affine_point_t const* P)
{
    5d98:	b5f0      	push	{r4, r5, r6, r7, lr}
    5d9a:	4647      	mov	r7, r8
    5d9c:	b480      	push	{r7}
    5d9e:	b092      	sub	sp, #72	; 0x48
    bigval_t sum, product;

    if (P->infinity) 
	{
        return (B_TRUE);
    5da0:	2301      	movs	r3, #1

COND_STATIC boolean_t in_curveP(affine_point_t const* P)
{
    bigval_t sum, product;

    if (P->infinity) 
    5da2:	6c82      	ldr	r2, [r0, #72]	; 0x48
    5da4:	2a00      	cmp	r2, #0
    5da6:	d13e      	bne.n	5e26 <in_curveP+0x8e>
    5da8:	4680      	mov	r8, r0
	{
        return (B_TRUE);
    }

    big_sqrP(&product, &P->x);
    5daa:	4668      	mov	r0, sp
    5dac:	4641      	mov	r1, r8
    5dae:	4642      	mov	r2, r8
    5db0:	2300      	movs	r3, #0
    5db2:	4e1f      	ldr	r6, [pc, #124]	; (5e30 <in_curveP+0x98>)
    5db4:	47b0      	blx	r6
    big_mpyP(&sum, &product, &P->x, MOD_MODULUS); /* x^3 */
    5db6:	a809      	add	r0, sp, #36	; 0x24
    5db8:	4669      	mov	r1, sp
    5dba:	4642      	mov	r2, r8
    5dbc:	2300      	movs	r3, #0
    5dbe:	47b0      	blx	r6
    5dc0:	2100      	movs	r1, #0


static void big_triple(bigval_t* tgt, bigval_t const* a)
{
    int i;
    uint64_t accum = 0;
    5dc2:	2200      	movs	r2, #0
    5dc4:	2300      	movs	r3, #0
       shift does not matter.
     */

    for (i = 0; i < BIGLEN; ++i) 
	{
        accum += a->data[i];
    5dc6:	4640      	mov	r0, r8
    5dc8:	5844      	ldr	r4, [r0, r1]
    5dca:	2500      	movs	r5, #0
    5dcc:	1c26      	adds	r6, r4, #0
    5dce:	1c2f      	adds	r7, r5, #0
    5dd0:	1936      	adds	r6, r6, r4
    5dd2:	416f      	adcs	r7, r5
    5dd4:	1936      	adds	r6, r6, r4
    5dd6:	416f      	adcs	r7, r5
        accum += a->data[i];
        accum += a->data[i];
    5dd8:	18b6      	adds	r6, r6, r2
    5dda:	415f      	adcs	r7, r3
        tgt->data[i] = (uint32_t)accum;
    5ddc:	4668      	mov	r0, sp
    5dde:	500e      	str	r6, [r1, r0]
        accum >>= 32;
    5de0:	1c3a      	adds	r2, r7, #0
    5de2:	2300      	movs	r3, #0
    5de4:	3104      	adds	r1, #4
       significance words, and the most significant word is the last
       word processed, so what is left in the accum after the final
       shift does not matter.
     */

    for (i = 0; i < BIGLEN; ++i) 
    5de6:	2924      	cmp	r1, #36	; 0x24
    5de8:	d1ed      	bne.n	5dc6 <in_curveP+0x2e>
    }

    big_sqrP(&product, &P->x);
    big_mpyP(&sum, &product, &P->x, MOD_MODULUS); /* x^3 */
    big_triple(&product, &P->x); /* 3 x */
    big_subP(&sum, &sum, &product); /* x^3 -3x */
    5dea:	a809      	add	r0, sp, #36	; 0x24
    5dec:	1c01      	adds	r1, r0, #0
    5dee:	466a      	mov	r2, sp
    5df0:	4c10      	ldr	r4, [pc, #64]	; (5e34 <in_curveP+0x9c>)
    5df2:	47a0      	blx	r4
    big_addP(&sum, &sum, &curve_b); /* x^3 -3x + b */
    5df4:	a809      	add	r0, sp, #36	; 0x24
    5df6:	1c01      	adds	r1, r0, #0
    5df8:	4a0f      	ldr	r2, [pc, #60]	; (5e38 <in_curveP+0xa0>)
    5dfa:	4b10      	ldr	r3, [pc, #64]	; (5e3c <in_curveP+0xa4>)
    5dfc:	4798      	blx	r3
    big_sqrP(&product, &P->y); /* y^2 */
    5dfe:	4642      	mov	r2, r8
    5e00:	3224      	adds	r2, #36	; 0x24
    5e02:	4668      	mov	r0, sp
    5e04:	1c11      	adds	r1, r2, #0
    5e06:	2300      	movs	r3, #0
    5e08:	4d09      	ldr	r5, [pc, #36]	; (5e30 <in_curveP+0x98>)
    5e0a:	47a8      	blx	r5
    big_subP(&sum, &sum, &product); /* -y^2 + x^3 -3x + b */
    5e0c:	a809      	add	r0, sp, #36	; 0x24
    5e0e:	1c01      	adds	r1, r0, #0
    5e10:	466a      	mov	r2, sp
    5e12:	47a0      	blx	r4
    big_precise_reduce(&sum, &sum, &modulusP);
    5e14:	a809      	add	r0, sp, #36	; 0x24
    5e16:	1c01      	adds	r1, r0, #0
    5e18:	4a09      	ldr	r2, [pc, #36]	; (5e40 <in_curveP+0xa8>)
    5e1a:	4b0a      	ldr	r3, [pc, #40]	; (5e44 <in_curveP+0xac>)
    5e1c:	4798      	blx	r3

    return(big_is_zero(&sum));
    5e1e:	a809      	add	r0, sp, #36	; 0x24
    5e20:	4b09      	ldr	r3, [pc, #36]	; (5e48 <in_curveP+0xb0>)
    5e22:	4798      	blx	r3
    5e24:	1c03      	adds	r3, r0, #0

}
    5e26:	1c18      	adds	r0, r3, #0
    5e28:	b012      	add	sp, #72	; 0x48
    5e2a:	bc04      	pop	{r2}
    5e2c:	4690      	mov	r8, r2
    5e2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5e30:	00004e49 	.word	0x00004e49
    5e34:	0000546d 	.word	0x0000546d
    5e38:	0001b974 	.word	0x0001b974
    5e3c:	00004dd1 	.word	0x00004dd1
    5e40:	0001ba78 	.word	0x0001ba78
    5e44:	00005545 	.word	0x00005545
    5e48:	000057a9 	.word	0x000057a9

00005e4c <ECDH_generate>:
/*
 * computes a secret value, k, and a point, P1, to send to the other
 * party.  Returns 0 on success, -1 on failure (of the RNG).
 */
int ECDH_generate(affine_point_t* P1, bigval_t* k)
{
    5e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e4e:	1c06      	adds	r6, r0, #0
    5e50:	1c0c      	adds	r4, r1, #0
   and order-1, inclusive.  Returns 0 on success, -1 otherwise */
COND_STATIC int big_get_random_n(bigval_t* tgt, boolean_t allow_zero)
{
    int rv;

    tgt->data[BIGLEN - 1] = 0;
    5e52:	2300      	movs	r3, #0
    5e54:	620b      	str	r3, [r1, #32]
}
#endif /* ECC_TEST */

static int get_random_bytes(uint8_t* buf, int len) 
{
    AJ_RandBytes(buf, len);
    5e56:	4f0b      	ldr	r7, [pc, #44]	; (5e84 <ECDH_generate+0x38>)
        if (rv < 0) 
		{
            return (-1);
        }
		//printf("!allow_zero && big_is_zero(tgt)=%d big_cmp(tgt, &orderP)= %d\n",!allow_zero && big_is_zero(tgt),big_cmp(tgt, &orderP));
    } while ((!allow_zero && big_is_zero(tgt)) || (big_cmp(tgt, &orderP) >= 0));
    5e58:	4d0b      	ldr	r5, [pc, #44]	; (5e88 <ECDH_generate+0x3c>)
}
#endif /* ECC_TEST */

static int get_random_bytes(uint8_t* buf, int len) 
{
    AJ_RandBytes(buf, len);
    5e5a:	1c20      	adds	r0, r4, #0
    5e5c:	2120      	movs	r1, #32
    5e5e:	47b8      	blx	r7
        if (rv < 0) 
		{
            return (-1);
        }
		//printf("!allow_zero && big_is_zero(tgt)=%d big_cmp(tgt, &orderP)= %d\n",!allow_zero && big_is_zero(tgt),big_cmp(tgt, &orderP));
    } while ((!allow_zero && big_is_zero(tgt)) || (big_cmp(tgt, &orderP) >= 0));
    5e60:	1c20      	adds	r0, r4, #0
    5e62:	47a8      	blx	r5
    5e64:	2800      	cmp	r0, #0
    5e66:	d1f8      	bne.n	5e5a <ECDH_generate+0xe>
    5e68:	1c20      	adds	r0, r4, #0
    5e6a:	4908      	ldr	r1, [pc, #32]	; (5e8c <ECDH_generate+0x40>)
    5e6c:	4b08      	ldr	r3, [pc, #32]	; (5e90 <ECDH_generate+0x44>)
    5e6e:	4798      	blx	r3
    5e70:	2800      	cmp	r0, #0
    5e72:	daf2      	bge.n	5e5a <ECDH_generate+0xe>
//	printf("big_get_random_n end rv= %d\n",rv);
    if (rv < 0) 
	{
        return (-1);
    }
    pointMpyP(P1, k, &base_point);
    5e74:	1c30      	adds	r0, r6, #0
    5e76:	1c21      	adds	r1, r4, #0
    5e78:	4a06      	ldr	r2, [pc, #24]	; (5e94 <ECDH_generate+0x48>)
    5e7a:	4b07      	ldr	r3, [pc, #28]	; (5e98 <ECDH_generate+0x4c>)
    5e7c:	4798      	blx	r3
 //   printf("pointMpyP end\n");
    return (0);
}
    5e7e:	2000      	movs	r0, #0
    5e80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5e82:	46c0      	nop			; (mov r8, r8)
    5e84:	0000d6a9 	.word	0x0000d6a9
    5e88:	000057a9 	.word	0x000057a9
    5e8c:	0001bac0 	.word	0x0001bac0
    5e90:	00005491 	.word	0x00005491
    5e94:	0001b998 	.word	0x0001b998
    5e98:	00005b3d 	.word	0x00005b3d

00005e9c <AJ_BigvalEncode>:
    }
    return (B_TRUE);
}

void AJ_BigvalEncode(const bigval_t* src, uint8_t* tgt, size_t tgtlen)
{
    5e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5e9e:	468c      	mov	ip, r1
    size_t i;
    uint8_t v;
    uint8_t highbytes = big_is_negative(src) ? 0xff : 0;
    5ea0:	6a03      	ldr	r3, [r0, #32]
    5ea2:	17df      	asrs	r7, r3, #31
    5ea4:	b2ff      	uxtb	r7, r7
    5ea6:	1e54      	subs	r4, r2, #1
    5ea8:	4464      	add	r4, ip

    /* LSbyte to MS_byte */
    for (i = 0; i < 4 * BIGLEN; ++i) 
    5eaa:	2300      	movs	r3, #0
	{
        if (i < tgtlen) 
		{
            v = src->data[i / 4] >> (8 * (i % 4));
    5eac:	2103      	movs	r1, #3
    uint8_t highbytes = big_is_negative(src) ? 0xff : 0;

    /* LSbyte to MS_byte */
    for (i = 0; i < 4 * BIGLEN; ++i) 
	{
        if (i < tgtlen) 
    5eae:	429a      	cmp	r2, r3
    5eb0:	d907      	bls.n	5ec2 <AJ_BigvalEncode+0x26>
		{
            v = src->data[i / 4] >> (8 * (i % 4));
    5eb2:	089e      	lsrs	r6, r3, #2
    5eb4:	00b6      	lsls	r6, r6, #2
    5eb6:	1c0d      	adds	r5, r1, #0
    5eb8:	401d      	ands	r5, r3
    5eba:	00ed      	lsls	r5, r5, #3
    5ebc:	5836      	ldr	r6, [r6, r0]
    5ebe:	40ee      	lsrs	r6, r5
    5ec0:	7026      	strb	r6, [r4, #0]
    size_t i;
    uint8_t v;
    uint8_t highbytes = big_is_negative(src) ? 0xff : 0;

    /* LSbyte to MS_byte */
    for (i = 0; i < 4 * BIGLEN; ++i) 
    5ec2:	3301      	adds	r3, #1
    5ec4:	3c01      	subs	r4, #1
    5ec6:	2b24      	cmp	r3, #36	; 0x24
    5ec8:	d1f1      	bne.n	5eae <AJ_BigvalEncode+0x12>
            v = src->data[i / 4] >> (8 * (i % 4));
            ((uint8_t*)tgt)[tgtlen - 1 - i] = v;
        }
    }
    /* i is live */
    for (; i < tgtlen; ++i) 
    5eca:	2a24      	cmp	r2, #36	; 0x24
    5ecc:	d908      	bls.n	5ee0 <AJ_BigvalEncode+0x44>
    5ece:	1c13      	adds	r3, r2, #0
    5ed0:	3b25      	subs	r3, #37	; 0x25
    5ed2:	4463      	add	r3, ip
    5ed4:	4661      	mov	r1, ip
    5ed6:	3901      	subs	r1, #1
	{
        ((uint8_t*)tgt)[tgtlen - 1 - i] = highbytes;
    5ed8:	701f      	strb	r7, [r3, #0]
    5eda:	3b01      	subs	r3, #1
            v = src->data[i / 4] >> (8 * (i % 4));
            ((uint8_t*)tgt)[tgtlen - 1 - i] = v;
        }
    }
    /* i is live */
    for (; i < tgtlen; ++i) 
    5edc:	428b      	cmp	r3, r1
    5ede:	d1fb      	bne.n	5ed8 <AJ_BigvalEncode+0x3c>
	{
        ((uint8_t*)tgt)[tgtlen - 1 - i] = highbytes;
    }
}
    5ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5ee2:	46c0      	nop			; (mov r8, r8)

00005ee4 <AJ_BigvalDecode>:

void AJ_BigvalDecode(const uint8_t* src, bigval_t* tgt, size_t srclen)
{
    5ee4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5ee6:	1c06      	adds	r6, r0, #0
    5ee8:	1c0d      	adds	r5, r1, #0
    5eea:	1c14      	adds	r4, r2, #0
    size_t i;
    uint8_t v;

    /* zero the bigval_t */
    memset(tgt, 0, sizeof (bigval_t));
    5eec:	1c08      	adds	r0, r1, #0
    5eee:	2100      	movs	r1, #0
    5ef0:	2224      	movs	r2, #36	; 0x24
    5ef2:	4b0d      	ldr	r3, [pc, #52]	; (5f28 <AJ_BigvalDecode+0x44>)
    5ef4:	4798      	blx	r3
    /* scan from LSbyte to MSbyte */
    for (i = 0; i < srclen && i < 4 * BIGLEN; ++i) 
    5ef6:	2c00      	cmp	r4, #0
    5ef8:	d015      	beq.n	5f26 <AJ_BigvalDecode+0x42>
    5efa:	1e60      	subs	r0, r4, #1
    5efc:	1830      	adds	r0, r6, r0
    5efe:	2200      	movs	r2, #0
	{
        v = ((uint8_t*)src)[srclen - 1 - i];
        tgt->data[i / 4] |= (uint32_t)v << (8 * (i % 4));
    5f00:	2703      	movs	r7, #3
    5f02:	0893      	lsrs	r3, r2, #2
    5f04:	009b      	lsls	r3, r3, #2
    5f06:	18eb      	adds	r3, r5, r3
    5f08:	7806      	ldrb	r6, [r0, #0]
    5f0a:	1c39      	adds	r1, r7, #0
    5f0c:	4011      	ands	r1, r2
    5f0e:	00c9      	lsls	r1, r1, #3
    5f10:	408e      	lsls	r6, r1
    5f12:	1c31      	adds	r1, r6, #0
    5f14:	681e      	ldr	r6, [r3, #0]
    5f16:	4331      	orrs	r1, r6
    5f18:	6019      	str	r1, [r3, #0]
    uint8_t v;

    /* zero the bigval_t */
    memset(tgt, 0, sizeof (bigval_t));
    /* scan from LSbyte to MSbyte */
    for (i = 0; i < srclen && i < 4 * BIGLEN; ++i) 
    5f1a:	3201      	adds	r2, #1
    5f1c:	42a2      	cmp	r2, r4
    5f1e:	d002      	beq.n	5f26 <AJ_BigvalDecode+0x42>
    5f20:	3801      	subs	r0, #1
    5f22:	2a24      	cmp	r2, #36	; 0x24
    5f24:	d1ed      	bne.n	5f02 <AJ_BigvalDecode+0x1e>
	{
        v = ((uint8_t*)src)[srclen - 1 - i];
        tgt->data[i / 4] |= (uint32_t)v << (8 * (i % 4));
    }
}
    5f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5f28:	00016773 	.word	0x00016773

00005f2c <ECDSA_verify>:
}

boolean_t ECDSA_verify(bigval_t const* msgdgst,
                       affine_point_t const* pubkey,
                       ECDSA_sig_t const* sig)
{
    5f2c:	b508      	push	{r3, lr}
    if (ECDSA_verify_inner(msgdgst, pubkey, sig) == V_SUCCESS) 
    5f2e:	4b03      	ldr	r3, [pc, #12]	; (5f3c <ECDSA_verify+0x10>)
    5f30:	4798      	blx	r3
    5f32:	4243      	negs	r3, r0
    5f34:	4158      	adcs	r0, r3
    5f36:	b2c0      	uxtb	r0, r0
	{
        return B_TRUE;
    }
    return B_FALSE;
}
    5f38:	bd08      	pop	{r3, pc}
    5f3a:	46c0      	nop			; (mov r8, r8)
    5f3c:	00005c8d 	.word	0x00005c8d

00005f40 <ECC_hash_to_bigval>:
 * Otherwise the left most b octets of the hash are converted to a
 * number. The hash must be big-endian by byte. There is no alignment
 * requirement on hashp.
 */
void ECC_hash_to_bigval(bigval_t* tgt, void const* hashp, unsigned int hashlen)
{
    5f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    5f42:	2a20      	cmp	r2, #32
    5f44:	d900      	bls.n	5f48 <ECC_hash_to_bigval+0x8>
    5f46:	2220      	movs	r2, #32
    if (hashlen > 4 * (BIGLEN - 1)) 
	{
        hashlen = 4 * (BIGLEN - 1);
    }

    *tgt = big_zero;
    5f48:	2300      	movs	r3, #0
    5f4a:	6003      	str	r3, [r0, #0]
    5f4c:	6043      	str	r3, [r0, #4]
    5f4e:	6083      	str	r3, [r0, #8]
    5f50:	60c3      	str	r3, [r0, #12]
    5f52:	6103      	str	r3, [r0, #16]
    5f54:	6143      	str	r3, [r0, #20]
    5f56:	6183      	str	r3, [r0, #24]
    5f58:	61c3      	str	r3, [r0, #28]
    5f5a:	6203      	str	r3, [r0, #32]
    /* move one byte at a time starting with least significant byte */
    for (i = 0; i < hashlen; ++i) 
    5f5c:	2a00      	cmp	r2, #0
    5f5e:	d013      	beq.n	5f88 <ECC_hash_to_bigval+0x48>
    5f60:	1e53      	subs	r3, r2, #1
    5f62:	18c9      	adds	r1, r1, r3
    5f64:	2600      	movs	r6, #0
	{
        tgt->data[i / 4] |= ((uint8_t*)hashp)[hashlen - 1 - i] << (8 * (i % 4));
    5f66:	2703      	movs	r7, #3
    5f68:	08b3      	lsrs	r3, r6, #2
    5f6a:	009b      	lsls	r3, r3, #2
    5f6c:	18c3      	adds	r3, r0, r3
    5f6e:	780d      	ldrb	r5, [r1, #0]
    5f70:	1c3c      	adds	r4, r7, #0
    5f72:	4034      	ands	r4, r6
    5f74:	00e4      	lsls	r4, r4, #3
    5f76:	40a5      	lsls	r5, r4
    5f78:	1c2c      	adds	r4, r5, #0
    5f7a:	681d      	ldr	r5, [r3, #0]
    5f7c:	432c      	orrs	r4, r5
    5f7e:	601c      	str	r4, [r3, #0]
        hashlen = 4 * (BIGLEN - 1);
    }

    *tgt = big_zero;
    /* move one byte at a time starting with least significant byte */
    for (i = 0; i < hashlen; ++i) 
    5f80:	3601      	adds	r6, #1
    5f82:	3901      	subs	r1, #1
    5f84:	4296      	cmp	r6, r2
    5f86:	d1ef      	bne.n	5f68 <ECC_hash_to_bigval+0x28>
	{
        tgt->data[i / 4] |= ((uint8_t*)hashp)[hashlen - 1 - i] << (8 * (i % 4));
    }
}
    5f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5f8a:	46c0      	nop			; (mov r8, r8)

00005f8c <AJ_GenerateDHKeyPair>:
 *
 * @return  - AJ_OK if the key pair is successfully generated.
 *          - AJ_ERR_SECURITY otherwise
 */
AJ_Status AJ_GenerateDHKeyPair(ecc_publickey* publicKey, ecc_privatekey* privateKey)
{
    5f8c:	b508      	push	{r3, lr}
    if (ECDH_generate(publicKey, privateKey) == 0) 
    5f8e:	4b04      	ldr	r3, [pc, #16]	; (5fa0 <AJ_GenerateDHKeyPair+0x14>)
    5f90:	4798      	blx	r3
    5f92:	2800      	cmp	r0, #0
    5f94:	d001      	beq.n	5f9a <AJ_GenerateDHKeyPair+0xe>
	{
        return AJ_OK;
    }
    return AJ_ERR_SECURITY;
    5f96:	200d      	movs	r0, #13
    5f98:	e000      	b.n	5f9c <AJ_GenerateDHKeyPair+0x10>
 */
AJ_Status AJ_GenerateDHKeyPair(ecc_publickey* publicKey, ecc_privatekey* privateKey)
{
    if (ECDH_generate(publicKey, privateKey) == 0) 
	{
        return AJ_OK;
    5f9a:	2000      	movs	r0, #0
    }
    return AJ_ERR_SECURITY;
}
    5f9c:	bd08      	pop	{r3, pc}
    5f9e:	46c0      	nop			; (mov r8, r8)
    5fa0:	00005e4d 	.word	0x00005e4d

00005fa4 <AJ_GenerateShareSecret>:
 *
 * @return  - AJ_OK if the share secret is successfully generated.
 *          - AJ_ERR_SECURITY otherwise
 */
AJ_Status AJ_GenerateShareSecret(ecc_publickey* peerPublicKey, ecc_privatekey* privateKey, ecc_secret* secret)
{
    5fa4:	b570      	push	{r4, r5, r6, lr}
   returns B_FALSE.  The behavior with k out of range is unspecified,
   but safe. */

COND_STATIC boolean_t ECDH_derive_pt(affine_point_t* tgt, bigval_t const* k, affine_point_t const* Q)
{
    if (Q->infinity)
    5fa6:	6c83      	ldr	r3, [r0, #72]	; 0x48
    5fa8:	2b00      	cmp	r3, #0
    5faa:	d12c      	bne.n	6006 <AJ_GenerateShareSecret+0x62>
	{
        return (B_FALSE);
    }
    if (big_is_negative(&Q->x)) 
    5fac:	6a03      	ldr	r3, [r0, #32]
    5fae:	2b00      	cmp	r3, #0
    5fb0:	db29      	blt.n	6006 <AJ_GenerateShareSecret+0x62>
    5fb2:	1c15      	adds	r5, r2, #0
    5fb4:	1c0e      	adds	r6, r1, #0
    5fb6:	1c04      	adds	r4, r0, #0
	{
        return (B_FALSE);
    }
    if (big_cmp(&Q->x, &modulusP) >= 0) 
    5fb8:	4914      	ldr	r1, [pc, #80]	; (600c <AJ_GenerateShareSecret+0x68>)
    5fba:	4b15      	ldr	r3, [pc, #84]	; (6010 <AJ_GenerateShareSecret+0x6c>)
    5fbc:	4798      	blx	r3
    5fbe:	2800      	cmp	r0, #0
    5fc0:	da21      	bge.n	6006 <AJ_GenerateShareSecret+0x62>
	{
        return (B_FALSE);
    }
    if (big_is_negative(&Q->y)) 
    5fc2:	6c63      	ldr	r3, [r4, #68]	; 0x44
    5fc4:	2b00      	cmp	r3, #0
    5fc6:	db1e      	blt.n	6006 <AJ_GenerateShareSecret+0x62>
	{
        return (B_FALSE);
    }
    if (big_cmp(&Q->y, &modulusP) >= 0)
    5fc8:	1c20      	adds	r0, r4, #0
    5fca:	3024      	adds	r0, #36	; 0x24
    5fcc:	490f      	ldr	r1, [pc, #60]	; (600c <AJ_GenerateShareSecret+0x68>)
    5fce:	4b10      	ldr	r3, [pc, #64]	; (6010 <AJ_GenerateShareSecret+0x6c>)
    5fd0:	4798      	blx	r3
    5fd2:	2800      	cmp	r0, #0
    5fd4:	da17      	bge.n	6006 <AJ_GenerateShareSecret+0x62>
	{
        return (B_FALSE);
    }
    if (!in_curveP(Q)) 
    5fd6:	1c20      	adds	r0, r4, #0
    5fd8:	4b0e      	ldr	r3, [pc, #56]	; (6014 <AJ_GenerateShareSecret+0x70>)
    5fda:	4798      	blx	r3
    5fdc:	2800      	cmp	r0, #0
    5fde:	d012      	beq.n	6006 <AJ_GenerateShareSecret+0x62>
    /* [HMV] Section 4.3 states that the above steps, combined with the
     * fact the h=1 for the curves used here, implies that order*Q =
     * Infinity, which is required by ANSI X9.63.
     */

    pointMpyP(tgt, k, Q);
    5fe0:	1c28      	adds	r0, r5, #0
    5fe2:	1c31      	adds	r1, r6, #0
    5fe4:	1c22      	adds	r2, r4, #0
    5fe6:	4b0c      	ldr	r3, [pc, #48]	; (6018 <AJ_GenerateShareSecret+0x74>)
    5fe8:	4798      	blx	r3
    boolean_t derive_rv;

    derive_rv = ECDH_derive_pt(secret, privateKey, peerPublicKey);
    if (!derive_rv) 
	{
        return AJ_ERR_SECURITY;  /* bad */
    5fea:	200d      	movs	r0, #13
AJ_Status AJ_GenerateShareSecret(ecc_publickey* peerPublicKey, ecc_privatekey* privateKey, ecc_secret* secret)
{
    boolean_t derive_rv;

    derive_rv = ECDH_derive_pt(secret, privateKey, peerPublicKey);
    if (!derive_rv) 
    5fec:	6cab      	ldr	r3, [r5, #72]	; 0x48
    5fee:	2b00      	cmp	r3, #0
    5ff0:	d10a      	bne.n	6008 <AJ_GenerateShareSecret+0x64>
	{
        return AJ_ERR_SECURITY;  /* bad */
    }
    if (derive_rv) 
	{
        if (!in_curveP(secret)) 
    5ff2:	1c28      	adds	r0, r5, #0
    5ff4:	4b07      	ldr	r3, [pc, #28]	; (6014 <AJ_GenerateShareSecret+0x70>)
    5ff6:	4798      	blx	r3
    5ff8:	1c02      	adds	r2, r0, #0
		{
            return AJ_ERR_SECURITY;  /* bad */
    5ffa:	200d      	movs	r0, #13
        }
    }
    return AJ_OK;
    5ffc:	4253      	negs	r3, r2
    5ffe:	4153      	adcs	r3, r2
    6000:	425b      	negs	r3, r3
    6002:	4018      	ands	r0, r3
    6004:	e000      	b.n	6008 <AJ_GenerateShareSecret+0x64>
    boolean_t derive_rv;

    derive_rv = ECDH_derive_pt(secret, privateKey, peerPublicKey);
    if (!derive_rv) 
	{
        return AJ_ERR_SECURITY;  /* bad */
    6006:	200d      	movs	r0, #13
		{
            return AJ_ERR_SECURITY;  /* bad */
        }
    }
    return AJ_OK;
}
    6008:	bd70      	pop	{r4, r5, r6, pc}
    600a:	46c0      	nop			; (mov r8, r8)
    600c:	0001ba78 	.word	0x0001ba78
    6010:	00005491 	.word	0x00005491
    6014:	00005d99 	.word	0x00005d99
    6018:	00005b3d 	.word	0x00005b3d

0000601c <AJ_DSASignDigest>:
 * @param sig The output signature
 * @return  - AJ_OK if the signing process succeeds
 *          - AJ_ERR_SECURITY otherwise
 */
AJ_Status AJ_DSASignDigest(const uint8_t* digest, const ecc_privatekey* signingPrivateKey, ecc_signature* sig)
{
    601c:	b5f0      	push	{r4, r5, r6, r7, lr}
    601e:	b0b1      	sub	sp, #196	; 0xc4
    6020:	1c03      	adds	r3, r0, #0
    6022:	9101      	str	r1, [sp, #4]
    6024:	1c14      	adds	r4, r2, #0
    bigval_t source;

    ECC_hash_to_bigval(&source, digest, SHA256_DIGEST_LENGTH);
    6026:	a827      	add	r0, sp, #156	; 0x9c
    6028:	1c19      	adds	r1, r3, #0
    602a:	2220      	movs	r2, #32
    602c:	4b19      	ldr	r3, [pc, #100]	; (6094 <AJ_DSASignDigest+0x78>)
    602e:	4798      	blx	r3
    bigval_t k;
    bigval_t t;

startpoint:

    rv = ECDH_generate(&P1, &k);
    6030:	4e19      	ldr	r6, [pc, #100]	; (6098 <AJ_DSASignDigest+0x7c>)
    if (rv) 
	{
        return (rv);
    }

    big_precise_reduce(&sig->r, &P1.x, &orderP);
    6032:	4f1a      	ldr	r7, [pc, #104]	; (609c <AJ_DSASignDigest+0x80>)
    bigval_t k;
    bigval_t t;

startpoint:

    rv = ECDH_generate(&P1, &k);
    6034:	a814      	add	r0, sp, #80	; 0x50
    6036:	a902      	add	r1, sp, #8
    6038:	47b0      	blx	r6
    if (rv) 
    603a:	2800      	cmp	r0, #0
    603c:	d001      	beq.n	6042 <AJ_DSASignDigest+0x26>
    ECC_hash_to_bigval(&source, digest, SHA256_DIGEST_LENGTH);
    if (ECDSA_sign(&source, signingPrivateKey, sig) == 0) 
	{
        return AJ_OK;
    }
    return AJ_ERR_SECURITY;
    603e:	200d      	movs	r0, #13
    6040:	e026      	b.n	6090 <AJ_DSASignDigest+0x74>
    if (rv) 
	{
        return (rv);
    }

    big_precise_reduce(&sig->r, &P1.x, &orderP);
    6042:	1c20      	adds	r0, r4, #0
    6044:	a914      	add	r1, sp, #80	; 0x50
    6046:	4a16      	ldr	r2, [pc, #88]	; (60a0 <AJ_DSASignDigest+0x84>)
    6048:	47b8      	blx	r7
    if (big_is_zero(&sig->r)) 
    604a:	1c20      	adds	r0, r4, #0
    604c:	4b15      	ldr	r3, [pc, #84]	; (60a4 <AJ_DSASignDigest+0x88>)
    604e:	4798      	blx	r3
    6050:	2800      	cmp	r0, #0
    6052:	d1ef      	bne.n	6034 <AJ_DSASignDigest+0x18>
	{
        goto startpoint;
    }

    big_mpyP(&t, privkey, &sig->r, MOD_ORDER);
    6054:	a80b      	add	r0, sp, #44	; 0x2c
    6056:	9901      	ldr	r1, [sp, #4]
    6058:	1c22      	adds	r2, r4, #0
    605a:	2301      	movs	r3, #1
    605c:	4d12      	ldr	r5, [pc, #72]	; (60a8 <AJ_DSASignDigest+0x8c>)
    605e:	47a8      	blx	r5
    big_add(&t, &t, msgdgst);
    6060:	a80b      	add	r0, sp, #44	; 0x2c
    6062:	1c01      	adds	r1, r0, #0
    6064:	aa27      	add	r2, sp, #156	; 0x9c
    6066:	4b11      	ldr	r3, [pc, #68]	; (60ac <AJ_DSASignDigest+0x90>)
    6068:	4798      	blx	r3
    big_precise_reduce(&t, &t, &orderP); /* may not be necessary */
    606a:	a80b      	add	r0, sp, #44	; 0x2c
    606c:	1c01      	adds	r1, r0, #0
    606e:	4a0c      	ldr	r2, [pc, #48]	; (60a0 <AJ_DSASignDigest+0x84>)
    6070:	4b0a      	ldr	r3, [pc, #40]	; (609c <AJ_DSASignDigest+0x80>)
    6072:	4798      	blx	r3
    big_divide(&sig->s, &t, &k, &orderP);
    6074:	1c25      	adds	r5, r4, #0
    6076:	3524      	adds	r5, #36	; 0x24
    6078:	9500      	str	r5, [sp, #0]
    607a:	1c28      	adds	r0, r5, #0
    607c:	a90b      	add	r1, sp, #44	; 0x2c
    607e:	aa02      	add	r2, sp, #8
    6080:	4b07      	ldr	r3, [pc, #28]	; (60a0 <AJ_DSASignDigest+0x84>)
    6082:	4d0b      	ldr	r5, [pc, #44]	; (60b0 <AJ_DSASignDigest+0x94>)
    6084:	47a8      	blx	r5
    if (big_is_zero(&sig->s))
    6086:	9800      	ldr	r0, [sp, #0]
    6088:	4b06      	ldr	r3, [pc, #24]	; (60a4 <AJ_DSASignDigest+0x88>)
    608a:	4798      	blx	r3
    608c:	2800      	cmp	r0, #0
    608e:	d1d1      	bne.n	6034 <AJ_DSASignDigest+0x18>
    if (ECDSA_sign(&source, signingPrivateKey, sig) == 0) 
	{
        return AJ_OK;
    }
    return AJ_ERR_SECURITY;
}
    6090:	b031      	add	sp, #196	; 0xc4
    6092:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6094:	00005f41 	.word	0x00005f41
    6098:	00005e4d 	.word	0x00005e4d
    609c:	00005545 	.word	0x00005545
    60a0:	0001bac0 	.word	0x0001bac0
    60a4:	000057a9 	.word	0x000057a9
    60a8:	00004e49 	.word	0x00004e49
    60ac:	00004d7d 	.word	0x00004d7d
    60b0:	00005649 	.word	0x00005649

000060b4 <AJ_DSAVerifyDigest>:
 * @param pubKey The signing public key
 * @return  - AJ_OK if the signature verification succeeds
 *          - AJ_ERR_SECURITY otherwise
 */
AJ_Status AJ_DSAVerifyDigest(const uint8_t* digest, const ecc_signature* sig, const ecc_publickey* pubKey)
{
    60b4:	b530      	push	{r4, r5, lr}
    60b6:	b08b      	sub	sp, #44	; 0x2c
    60b8:	1c03      	adds	r3, r0, #0
    60ba:	1c0c      	adds	r4, r1, #0
    60bc:	1c15      	adds	r5, r2, #0
    bigval_t source;

    ECC_hash_to_bigval(&source, digest, SHA256_DIGEST_LENGTH);
    60be:	a801      	add	r0, sp, #4
    60c0:	1c19      	adds	r1, r3, #0
    60c2:	2220      	movs	r2, #32
    60c4:	4b06      	ldr	r3, [pc, #24]	; (60e0 <AJ_DSAVerifyDigest+0x2c>)
    60c6:	4798      	blx	r3
    if (ECDSA_verify(&source, pubKey, sig) == B_TRUE) 
    60c8:	a801      	add	r0, sp, #4
    60ca:	1c29      	adds	r1, r5, #0
    60cc:	1c22      	adds	r2, r4, #0
    60ce:	4b05      	ldr	r3, [pc, #20]	; (60e4 <AJ_DSAVerifyDigest+0x30>)
    60d0:	4798      	blx	r3
    60d2:	2801      	cmp	r0, #1
    60d4:	d001      	beq.n	60da <AJ_DSAVerifyDigest+0x26>
	{
        return AJ_OK;
    }

    return AJ_ERR_SECURITY;
    60d6:	200d      	movs	r0, #13
    60d8:	e000      	b.n	60dc <AJ_DSAVerifyDigest+0x28>
    bigval_t source;

    ECC_hash_to_bigval(&source, digest, SHA256_DIGEST_LENGTH);
    if (ECDSA_verify(&source, pubKey, sig) == B_TRUE) 
	{
        return AJ_OK;
    60da:	2000      	movs	r0, #0
    }

    return AJ_ERR_SECURITY;
}
    60dc:	b00b      	add	sp, #44	; 0x2c
    60de:	bd30      	pop	{r4, r5, pc}
    60e0:	00005f41 	.word	0x00005f41
    60e4:	00005f2d 	.word	0x00005f2d

000060e8 <AJ_DSAVerify>:
 * @param pubKey The signing public key
 * @return  - AJ_OK if the signature verification succeeds
 *          - AJ_ERR_SECURITY otherwise
 */
AJ_Status AJ_DSAVerify(const uint8_t* buf, uint16_t len, const ecc_signature* sig, const ecc_publickey* pubKey)
{
    60e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    60ea:	b0a3      	sub	sp, #140	; 0x8c
    60ec:	1c07      	adds	r7, r0, #0
    60ee:	1c0e      	adds	r6, r1, #0
    60f0:	1c15      	adds	r5, r2, #0
    60f2:	1c1c      	adds	r4, r3, #0
    AJ_SHA256_Context ctx;
    uint8_t digest[SHA256_DIGEST_LENGTH];

    AJ_SHA256_Init(&ctx);
    60f4:	a808      	add	r0, sp, #32
    60f6:	4b09      	ldr	r3, [pc, #36]	; (611c <AJ_DSAVerify+0x34>)
    60f8:	4798      	blx	r3
    AJ_SHA256_Update(&ctx, (const uint8_t*) buf, (size_t) len);
    60fa:	a808      	add	r0, sp, #32
    60fc:	1c39      	adds	r1, r7, #0
    60fe:	1c32      	adds	r2, r6, #0
    6100:	4b07      	ldr	r3, [pc, #28]	; (6120 <AJ_DSAVerify+0x38>)
    6102:	4798      	blx	r3
    AJ_SHA256_Final(&ctx, digest);
    6104:	a808      	add	r0, sp, #32
    6106:	4669      	mov	r1, sp
    6108:	4b06      	ldr	r3, [pc, #24]	; (6124 <AJ_DSAVerify+0x3c>)
    610a:	4798      	blx	r3

    return AJ_DSAVerifyDigest(digest, sig, pubKey);
    610c:	4668      	mov	r0, sp
    610e:	1c29      	adds	r1, r5, #0
    6110:	1c22      	adds	r2, r4, #0
    6112:	4b05      	ldr	r3, [pc, #20]	; (6128 <AJ_DSAVerify+0x40>)
    6114:	4798      	blx	r3
}
    6116:	b023      	add	sp, #140	; 0x8c
    6118:	bdf0      	pop	{r4, r5, r6, r7, pc}
    611a:	46c0      	nop			; (mov r8, r8)
    611c:	0000612d 	.word	0x0000612d
    6120:	00006139 	.word	0x00006139
    6124:	00006181 	.word	0x00006181
    6128:	000060b5 	.word	0x000060b5

0000612c <AJ_SHA256_Init>:
 * Initialize the hash context
 * @param context the hash context
 * @return AJ_OK if successful
 */
void AJ_SHA256_Init(AJ_SHA256_Context* context) 
{
    612c:	b508      	push	{r3, lr}
    SHA256_Init(context);
    612e:	4b01      	ldr	r3, [pc, #4]	; (6134 <AJ_SHA256_Init+0x8>)
    6130:	4798      	blx	r3
}
    6132:	bd08      	pop	{r3, pc}
    6134:	0000ed89 	.word	0x0000ed89

00006138 <AJ_SHA256_Update>:
 * @param context the hash context
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    6138:	b508      	push	{r3, lr}
    SHA256_Update(context, buf, bufSize);
    613a:	4b01      	ldr	r3, [pc, #4]	; (6140 <AJ_SHA256_Update+0x8>)
    613c:	4798      	blx	r3
}
    613e:	bd08      	pop	{r3, pc}
    6140:	0000f029 	.word	0x0000f029

00006144 <AJ_SHA256_GetDigest>:
 * @param digest the buffer to hold the digest.  Must be of size SHA256_DIGEST_LENGTH
 * @param keepAlive keep the digest process alive for continuing digest
 */

void AJ_SHA256_GetDigest(AJ_SHA256_Context* context, uint8_t* digest, const uint8_t keepAlive) 
{
    6144:	b570      	push	{r4, r5, r6, lr}
    6146:	b09a      	sub	sp, #104	; 0x68
    6148:	1c04      	adds	r4, r0, #0
    614a:	1c0d      	adds	r5, r1, #0
    AJ_SHA256_Context savedCtx;

    if (keepAlive != 0) 
    614c:	2a00      	cmp	r2, #0
    614e:	d00d      	beq.n	616c <AJ_SHA256_GetDigest+0x28>
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    6150:	4668      	mov	r0, sp
    6152:	1c21      	adds	r1, r4, #0
    6154:	2268      	movs	r2, #104	; 0x68
    6156:	4e08      	ldr	r6, [pc, #32]	; (6178 <AJ_SHA256_GetDigest+0x34>)
    6158:	47b0      	blx	r6
    }
    SHA256_Final(digest, context);
    615a:	1c28      	adds	r0, r5, #0
    615c:	1c21      	adds	r1, r4, #0
    615e:	4b07      	ldr	r3, [pc, #28]	; (617c <AJ_SHA256_GetDigest+0x38>)
    6160:	4798      	blx	r3
    if (keepAlive != 0) 
	{
        memcpy(context, &savedCtx, sizeof(AJ_SHA256_Context));
    6162:	1c20      	adds	r0, r4, #0
    6164:	4669      	mov	r1, sp
    6166:	2268      	movs	r2, #104	; 0x68
    6168:	47b0      	blx	r6
    616a:	e003      	b.n	6174 <AJ_SHA256_GetDigest+0x30>

    if (keepAlive != 0) 
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    }
    SHA256_Final(digest, context);
    616c:	1c08      	adds	r0, r1, #0
    616e:	1c21      	adds	r1, r4, #0
    6170:	4b02      	ldr	r3, [pc, #8]	; (617c <AJ_SHA256_GetDigest+0x38>)
    6172:	4798      	blx	r3
    if (keepAlive != 0) 
	{
        memcpy(context, &savedCtx, sizeof(AJ_SHA256_Context));
    }
}
    6174:	b01a      	add	sp, #104	; 0x68
    6176:	bd70      	pop	{r4, r5, r6, pc}
    6178:	00016739 	.word	0x00016739
    617c:	0000f145 	.word	0x0000f145

00006180 <AJ_SHA256_Final>:
 * Retrieve the final digest
 * @param context the hash context
 * @param digest the buffer to hold the digest.  Must be of size SHA256_DIGEST_LENGTH
 */
void AJ_SHA256_Final(AJ_SHA256_Context* context, uint8_t* digest) 
{
    6180:	b508      	push	{r3, lr}
    6182:	1c03      	adds	r3, r0, #0

    if (keepAlive != 0) 
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    }
    SHA256_Final(digest, context);
    6184:	1c08      	adds	r0, r1, #0
    6186:	1c19      	adds	r1, r3, #0
    6188:	4b01      	ldr	r3, [pc, #4]	; (6190 <AJ_SHA256_Final+0x10>)
    618a:	4798      	blx	r3
 * @param digest the buffer to hold the digest.  Must be of size SHA256_DIGEST_LENGTH
 */
void AJ_SHA256_Final(AJ_SHA256_Context* context, uint8_t* digest) 
{
    AJ_SHA256_GetDigest(context, digest, 0);
}
    618c:	bd08      	pop	{r3, pc}
    618e:	46c0      	nop			; (mov r8, r8)
    6190:	0000f145 	.word	0x0000f145

00006194 <AJ_HMAC_SHA256_Init>:

AJ_Status AJ_HMAC_SHA256_Init(AJ_HMAC_SHA256_CTX* ctx, const uint8_t* key, size_t keyLen)
{
    6194:	b5f0      	push	{r4, r5, r6, r7, lr}
    6196:	b08b      	sub	sp, #44	; 0x2c
    6198:	1c04      	adds	r4, r0, #0
    619a:	9101      	str	r1, [sp, #4]
    619c:	1c15      	adds	r5, r2, #0
    int cnt;
    memset(ctx->ipad, 0, HMAC_SHA256_BLOCK_LENGTH);
    619e:	2100      	movs	r1, #0
    61a0:	2240      	movs	r2, #64	; 0x40
    61a2:	4f22      	ldr	r7, [pc, #136]	; (622c <AJ_HMAC_SHA256_Init+0x98>)
    61a4:	47b8      	blx	r7
    memset(ctx->opad, 0, HMAC_SHA256_BLOCK_LENGTH);
    61a6:	1c26      	adds	r6, r4, #0
    61a8:	3640      	adds	r6, #64	; 0x40
    61aa:	1c30      	adds	r0, r6, #0
    61ac:	2100      	movs	r1, #0
    61ae:	2240      	movs	r2, #64	; 0x40
    61b0:	47b8      	blx	r7
    /* if keyLen > 64, hash it and use it as key */
    if (keyLen > HMAC_SHA256_BLOCK_LENGTH) 
    61b2:	2d40      	cmp	r5, #64	; 0x40
    61b4:	d917      	bls.n	61e6 <AJ_HMAC_SHA256_Init+0x52>
	{
        uint8_t digest[SHA256_DIGEST_LENGTH];
        AJ_SHA256_Init(&ctx->hashCtx);
    61b6:	3640      	adds	r6, #64	; 0x40
 * @param context the hash context
 * @return AJ_OK if successful
 */
void AJ_SHA256_Init(AJ_SHA256_Context* context) 
{
    SHA256_Init(context);
    61b8:	1c30      	adds	r0, r6, #0
    61ba:	4b1d      	ldr	r3, [pc, #116]	; (6230 <AJ_HMAC_SHA256_Init+0x9c>)
    61bc:	4798      	blx	r3
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    61be:	1c30      	adds	r0, r6, #0
    61c0:	9901      	ldr	r1, [sp, #4]
    61c2:	1c2a      	adds	r2, r5, #0
    61c4:	4b1b      	ldr	r3, [pc, #108]	; (6234 <AJ_HMAC_SHA256_Init+0xa0>)
    61c6:	4798      	blx	r3

    if (keepAlive != 0) 
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    }
    SHA256_Final(digest, context);
    61c8:	a802      	add	r0, sp, #8
    61ca:	1c31      	adds	r1, r6, #0
    61cc:	4b1a      	ldr	r3, [pc, #104]	; (6238 <AJ_HMAC_SHA256_Init+0xa4>)
    61ce:	4798      	blx	r3
        uint8_t digest[SHA256_DIGEST_LENGTH];
        AJ_SHA256_Init(&ctx->hashCtx);
        AJ_SHA256_Update(&ctx->hashCtx, key, keyLen);
        AJ_SHA256_Final(&ctx->hashCtx, digest);
        keyLen = SHA256_DIGEST_LENGTH;
        memcpy(ctx->ipad, digest, SHA256_DIGEST_LENGTH);
    61d0:	1c20      	adds	r0, r4, #0
    61d2:	a902      	add	r1, sp, #8
    61d4:	2220      	movs	r2, #32
    61d6:	4d19      	ldr	r5, [pc, #100]	; (623c <AJ_HMAC_SHA256_Init+0xa8>)
    61d8:	47a8      	blx	r5
        memcpy(ctx->opad, digest, SHA256_DIGEST_LENGTH);
    61da:	1c20      	adds	r0, r4, #0
    61dc:	3040      	adds	r0, #64	; 0x40
    61de:	a902      	add	r1, sp, #8
    61e0:	2220      	movs	r2, #32
    61e2:	47a8      	blx	r5
    61e4:	e010      	b.n	6208 <AJ_HMAC_SHA256_Init+0x74>
    } 
	else
	{
        memcpy(ctx->ipad, key, keyLen);
    61e6:	1c20      	adds	r0, r4, #0
    61e8:	9901      	ldr	r1, [sp, #4]
    61ea:	1c2a      	adds	r2, r5, #0
    61ec:	4f13      	ldr	r7, [pc, #76]	; (623c <AJ_HMAC_SHA256_Init+0xa8>)
    61ee:	47b8      	blx	r7
        memcpy(ctx->opad, key, keyLen);
    61f0:	1c30      	adds	r0, r6, #0
    61f2:	9901      	ldr	r1, [sp, #4]
    61f4:	1c2a      	adds	r2, r5, #0
    61f6:	47b8      	blx	r7
    61f8:	e006      	b.n	6208 <AJ_HMAC_SHA256_Init+0x74>
     * prepare inner hash SHA256(K XOR ipad, msg)
     * K XOR ipad
     */
    for (cnt = 0; cnt < HMAC_SHA256_BLOCK_LENGTH; cnt++) 
	{
        ctx->ipad[cnt] ^= 0x36;
    61fa:	781a      	ldrb	r2, [r3, #0]
    61fc:	404a      	eors	r2, r1
    61fe:	701a      	strb	r2, [r3, #0]
    6200:	3301      	adds	r3, #1

    /*
     * prepare inner hash SHA256(K XOR ipad, msg)
     * K XOR ipad
     */
    for (cnt = 0; cnt < HMAC_SHA256_BLOCK_LENGTH; cnt++) 
    6202:	4283      	cmp	r3, r0
    6204:	d1f9      	bne.n	61fa <AJ_HMAC_SHA256_Init+0x66>
    6206:	e004      	b.n	6212 <AJ_HMAC_SHA256_Init+0x7e>
    6208:	1c23      	adds	r3, r4, #0
    620a:	1c20      	adds	r0, r4, #0
    620c:	3040      	adds	r0, #64	; 0x40
	{
        ctx->ipad[cnt] ^= 0x36;
    620e:	2136      	movs	r1, #54	; 0x36
    6210:	e7f3      	b.n	61fa <AJ_HMAC_SHA256_Init+0x66>
    }

    AJ_SHA256_Init(&ctx->hashCtx);
    6212:	1c25      	adds	r5, r4, #0
    6214:	3580      	adds	r5, #128	; 0x80
 * @param context the hash context
 * @return AJ_OK if successful
 */
void AJ_SHA256_Init(AJ_SHA256_Context* context) 
{
    SHA256_Init(context);
    6216:	1c28      	adds	r0, r5, #0
    6218:	4b05      	ldr	r3, [pc, #20]	; (6230 <AJ_HMAC_SHA256_Init+0x9c>)
    621a:	4798      	blx	r3
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    621c:	1c28      	adds	r0, r5, #0
    621e:	1c21      	adds	r1, r4, #0
    6220:	2240      	movs	r2, #64	; 0x40
    6222:	4b04      	ldr	r3, [pc, #16]	; (6234 <AJ_HMAC_SHA256_Init+0xa0>)
    6224:	4798      	blx	r3
    }

    AJ_SHA256_Init(&ctx->hashCtx);
    AJ_SHA256_Update(&ctx->hashCtx, ctx->ipad, HMAC_SHA256_BLOCK_LENGTH);
    return AJ_OK;
}
    6226:	2000      	movs	r0, #0
    6228:	b00b      	add	sp, #44	; 0x2c
    622a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    622c:	00016773 	.word	0x00016773
    6230:	0000ed89 	.word	0x0000ed89
    6234:	0000f029 	.word	0x0000f029
    6238:	0000f145 	.word	0x0000f145
    623c:	00016739 	.word	0x00016739

00006240 <AJ_HMAC_SHA256_Final>:
    AJ_SHA256_Update(&ctx->hashCtx, data, dataLen);
    return AJ_OK;
}

AJ_Status AJ_HMAC_SHA256_Final(AJ_HMAC_SHA256_CTX* ctx, uint8_t* digest)
{
    6240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6242:	1c07      	adds	r7, r0, #0
    6244:	1c0d      	adds	r5, r1, #0
    int cnt;
    /* complete inner hash SHA256(K XOR ipad, msg) */
    AJ_SHA256_Final(&ctx->hashCtx, digest);
    6246:	1c04      	adds	r4, r0, #0
    6248:	3480      	adds	r4, #128	; 0x80

    if (keepAlive != 0) 
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    }
    SHA256_Final(digest, context);
    624a:	1c08      	adds	r0, r1, #0
    624c:	1c21      	adds	r1, r4, #0
    624e:	4b0f      	ldr	r3, [pc, #60]	; (628c <AJ_HMAC_SHA256_Final+0x4c>)
    6250:	4798      	blx	r3
    6252:	1c3b      	adds	r3, r7, #0
    6254:	3340      	adds	r3, #64	; 0x40
    6256:	1c26      	adds	r6, r4, #0
    /*
     * perform outer hash SHA256(K XOR opad, SHA256(K XOR ipad, msg))
     */
    for (cnt = 0; cnt < HMAC_SHA256_BLOCK_LENGTH; cnt++) 
	{
        ctx->opad[cnt] ^= 0x5c;
    6258:	205c      	movs	r0, #92	; 0x5c
    625a:	781a      	ldrb	r2, [r3, #0]
    625c:	4042      	eors	r2, r0
    625e:	701a      	strb	r2, [r3, #0]
    6260:	3301      	adds	r3, #1
    AJ_SHA256_Final(&ctx->hashCtx, digest);

    /*
     * perform outer hash SHA256(K XOR opad, SHA256(K XOR ipad, msg))
     */
    for (cnt = 0; cnt < HMAC_SHA256_BLOCK_LENGTH; cnt++) 
    6262:	42b3      	cmp	r3, r6
    6264:	d1f9      	bne.n	625a <AJ_HMAC_SHA256_Final+0x1a>
 * @param context the hash context
 * @return AJ_OK if successful
 */
void AJ_SHA256_Init(AJ_SHA256_Context* context) 
{
    SHA256_Init(context);
    6266:	1c20      	adds	r0, r4, #0
    6268:	4b09      	ldr	r3, [pc, #36]	; (6290 <AJ_HMAC_SHA256_Final+0x50>)
    626a:	4798      	blx	r3
    for (cnt = 0; cnt < HMAC_SHA256_BLOCK_LENGTH; cnt++) 
	{
        ctx->opad[cnt] ^= 0x5c;
    }
    AJ_SHA256_Init(&ctx->hashCtx);
    AJ_SHA256_Update(&ctx->hashCtx, ctx->opad, HMAC_SHA256_BLOCK_LENGTH);
    626c:	1c39      	adds	r1, r7, #0
    626e:	3140      	adds	r1, #64	; 0x40
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    6270:	1c20      	adds	r0, r4, #0
    6272:	2240      	movs	r2, #64	; 0x40
    6274:	4e07      	ldr	r6, [pc, #28]	; (6294 <AJ_HMAC_SHA256_Final+0x54>)
    6276:	47b0      	blx	r6
    6278:	1c20      	adds	r0, r4, #0
    627a:	1c29      	adds	r1, r5, #0
    627c:	2220      	movs	r2, #32
    627e:	47b0      	blx	r6

    if (keepAlive != 0) 
	{
        memcpy(&savedCtx, context, sizeof(AJ_SHA256_Context));
    }
    SHA256_Final(digest, context);
    6280:	1c28      	adds	r0, r5, #0
    6282:	1c21      	adds	r1, r4, #0
    6284:	4b01      	ldr	r3, [pc, #4]	; (628c <AJ_HMAC_SHA256_Final+0x4c>)
    6286:	4798      	blx	r3
    AJ_SHA256_Init(&ctx->hashCtx);
    AJ_SHA256_Update(&ctx->hashCtx, ctx->opad, HMAC_SHA256_BLOCK_LENGTH);
    AJ_SHA256_Update(&ctx->hashCtx, digest, SHA256_DIGEST_LENGTH);
    AJ_SHA256_Final(&ctx->hashCtx, digest);
    return AJ_OK;
}
    6288:	2000      	movs	r0, #0
    628a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    628c:	0000f145 	.word	0x0000f145
    6290:	0000ed89 	.word	0x0000ed89
    6294:	0000f029 	.word	0x0000f029

00006298 <AJ_Crypto_PRF_SHA256>:

AJ_Status AJ_Crypto_PRF_SHA256(const uint8_t** inputs, const uint8_t* lengths, uint32_t count, uint8_t* out, uint32_t outLen)
{
    6298:	b5f0      	push	{r4, r5, r6, r7, lr}
    629a:	465f      	mov	r7, fp
    629c:	4656      	mov	r6, sl
    629e:	464d      	mov	r5, r9
    62a0:	4644      	mov	r4, r8
    62a2:	b4f0      	push	{r4, r5, r6, r7}
    62a4:	b0c5      	sub	sp, #276	; 0x114
    62a6:	4683      	mov	fp, r0
    62a8:	4689      	mov	r9, r1
    62aa:	9201      	str	r2, [sp, #4]
    62ac:	9300      	str	r3, [sp, #0]
    62ae:	9b4e      	ldr	r3, [sp, #312]	; 0x138
    62b0:	4698      	mov	r8, r3
    uint8_t digest[SHA256_DIGEST_LENGTH];
    uint32_t len = 0;

    if (count < 2) 
	{
        return AJ_ERR_INVALID;
    62b2:	2003      	movs	r0, #3
    uint32_t cnt;
    AJ_HMAC_SHA256_CTX msgHash;
    uint8_t digest[SHA256_DIGEST_LENGTH];
    uint32_t len = 0;

    if (count < 2) 
    62b4:	2a01      	cmp	r2, #1
    62b6:	d949      	bls.n	634c <AJ_Crypto_PRF_SHA256+0xb4>
	{
        return AJ_ERR_INVALID;
    }
    while (outLen) 
    62b8:	4643      	mov	r3, r8
        memcpy(out, digest, len);
        outLen -= len;
        out += len;
    }

    return AJ_OK;
    62ba:	2000      	movs	r0, #0

    if (count < 2) 
	{
        return AJ_ERR_INVALID;
    }
    while (outLen) 
    62bc:	2b00      	cmp	r3, #0
    62be:	d045      	beq.n	634c <AJ_Crypto_PRF_SHA256+0xb4>
    62c0:	e03a      	b.n	6338 <AJ_Crypto_PRF_SHA256+0xa0>
	{
        // Initialize SHA256 in HMAC mode with the secret
        AJ_HMAC_SHA256_Init(&msgHash, inputs[0], lengths[0]);
    62c2:	464b      	mov	r3, r9
    62c4:	781a      	ldrb	r2, [r3, #0]
    62c6:	a80a      	add	r0, sp, #40	; 0x28
    62c8:	465b      	mov	r3, fp
    62ca:	6819      	ldr	r1, [r3, #0]
    62cc:	4b23      	ldr	r3, [pc, #140]	; (635c <AJ_Crypto_PRF_SHA256+0xc4>)
    62ce:	4798      	blx	r3
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    62d0:	a82a      	add	r0, sp, #168	; 0xa8
    62d2:	a902      	add	r1, sp, #8
    62d4:	2220      	movs	r2, #32
    62d6:	4b22      	ldr	r3, [pc, #136]	; (6360 <AJ_Crypto_PRF_SHA256+0xc8>)
    62d8:	4798      	blx	r3
    62da:	e01e      	b.n	631a <AJ_Crypto_PRF_SHA256+0x82>
    62dc:	cd02      	ldmia	r5!, {r1}
		{
            AJ_HMAC_SHA256_Update(&msgHash, digest, sizeof(digest));
        }
        for (cnt = 1; cnt < count; cnt++) 
		{
            AJ_HMAC_SHA256_Update(&msgHash, inputs[cnt], lengths[cnt]);
    62de:	7822      	ldrb	r2, [r4, #0]
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    62e0:	a82a      	add	r0, sp, #168	; 0xa8
    62e2:	47b8      	blx	r7
    62e4:	3401      	adds	r4, #1
        // If this is not the first iteration hash in the digest from the previous iteration.
        if (len) 
		{
            AJ_HMAC_SHA256_Update(&msgHash, digest, sizeof(digest));
        }
        for (cnt = 1; cnt < count; cnt++) 
    62e6:	42b4      	cmp	r4, r6
    62e8:	d1f8      	bne.n	62dc <AJ_Crypto_PRF_SHA256+0x44>
		{
            AJ_HMAC_SHA256_Update(&msgHash, inputs[cnt], lengths[cnt]);
        }
        AJ_HMAC_SHA256_Final(&msgHash, digest);
    62ea:	a80a      	add	r0, sp, #40	; 0x28
    62ec:	a902      	add	r1, sp, #8
    62ee:	47d0      	blx	sl
        if (outLen < sizeof(digest)) 
    62f0:	4643      	mov	r3, r8
    62f2:	2b1f      	cmp	r3, #31
    62f4:	d919      	bls.n	632a <AJ_Crypto_PRF_SHA256+0x92>
        } 
		else 
		{
            len = sizeof(digest);
        }
        memcpy(out, digest, len);
    62f6:	9d00      	ldr	r5, [sp, #0]
    62f8:	1c28      	adds	r0, r5, #0
    62fa:	a902      	add	r1, sp, #8
    62fc:	2220      	movs	r2, #32
    62fe:	4c19      	ldr	r4, [pc, #100]	; (6364 <AJ_Crypto_PRF_SHA256+0xcc>)
    6300:	47a0      	blx	r4
        outLen -= len;
    6302:	2220      	movs	r2, #32
    6304:	4252      	negs	r2, r2
    6306:	4694      	mov	ip, r2
    6308:	44e0      	add	r8, ip
        out += len;
    630a:	1c2b      	adds	r3, r5, #0
    630c:	3320      	adds	r3, #32
    630e:	9300      	str	r3, [sp, #0]

    if (count < 2) 
	{
        return AJ_ERR_INVALID;
    }
    while (outLen) 
    6310:	4643      	mov	r3, r8
    6312:	2b00      	cmp	r3, #0
    6314:	d1d5      	bne.n	62c2 <AJ_Crypto_PRF_SHA256+0x2a>
        memcpy(out, digest, len);
        outLen -= len;
        out += len;
    }

    return AJ_OK;
    6316:	2000      	movs	r0, #0
    6318:	e018      	b.n	634c <AJ_Crypto_PRF_SHA256+0xb4>
    631a:	465b      	mov	r3, fp
    631c:	1d1d      	adds	r5, r3, #4
    631e:	464b      	mov	r3, r9
    6320:	1c5c      	adds	r4, r3, #1
    6322:	9b01      	ldr	r3, [sp, #4]
    6324:	444b      	add	r3, r9
    6326:	1c1e      	adds	r6, r3, #0
    6328:	e7d8      	b.n	62dc <AJ_Crypto_PRF_SHA256+0x44>
        } 
		else 
		{
            len = sizeof(digest);
        }
        memcpy(out, digest, len);
    632a:	9800      	ldr	r0, [sp, #0]
    632c:	a902      	add	r1, sp, #8
    632e:	4642      	mov	r2, r8
    6330:	4b0c      	ldr	r3, [pc, #48]	; (6364 <AJ_Crypto_PRF_SHA256+0xcc>)
    6332:	4798      	blx	r3
        outLen -= len;
        out += len;
    }

    return AJ_OK;
    6334:	2000      	movs	r0, #0
    6336:	e009      	b.n	634c <AJ_Crypto_PRF_SHA256+0xb4>
        return AJ_ERR_INVALID;
    }
    while (outLen) 
	{
        // Initialize SHA256 in HMAC mode with the secret
        AJ_HMAC_SHA256_Init(&msgHash, inputs[0], lengths[0]);
    6338:	780a      	ldrb	r2, [r1, #0]
    633a:	a80a      	add	r0, sp, #40	; 0x28
    633c:	465b      	mov	r3, fp
    633e:	6819      	ldr	r1, [r3, #0]
    6340:	4b06      	ldr	r3, [pc, #24]	; (635c <AJ_Crypto_PRF_SHA256+0xc4>)
    6342:	4798      	blx	r3
 * @param buf the bytes to digest
 * @param bufSize the number of bytes to digest
 */
void AJ_SHA256_Update(AJ_SHA256_Context* context, const uint8_t* buf, size_t bufSize)
{
    SHA256_Update(context, buf, bufSize);
    6344:	4f06      	ldr	r7, [pc, #24]	; (6360 <AJ_Crypto_PRF_SHA256+0xc8>)
        }
        for (cnt = 1; cnt < count; cnt++) 
		{
            AJ_HMAC_SHA256_Update(&msgHash, inputs[cnt], lengths[cnt]);
        }
        AJ_HMAC_SHA256_Final(&msgHash, digest);
    6346:	4b08      	ldr	r3, [pc, #32]	; (6368 <AJ_Crypto_PRF_SHA256+0xd0>)
    6348:	469a      	mov	sl, r3
    634a:	e7e6      	b.n	631a <AJ_Crypto_PRF_SHA256+0x82>
        outLen -= len;
        out += len;
    }

    return AJ_OK;
}
    634c:	b045      	add	sp, #276	; 0x114
    634e:	bc3c      	pop	{r2, r3, r4, r5}
    6350:	4690      	mov	r8, r2
    6352:	4699      	mov	r9, r3
    6354:	46a2      	mov	sl, r4
    6356:	46ab      	mov	fp, r5
    6358:	bdf0      	pop	{r4, r5, r6, r7, pc}
    635a:	46c0      	nop			; (mov r8, r8)
    635c:	00006195 	.word	0x00006195
    6360:	0000f029 	.word	0x0000f029
    6364:	00016739 	.word	0x00016739
    6368:	00006241 	.word	0x00006241

0000636c <_AJ_DbgHeader>:
#endif
    }
}

int _AJ_DbgHeader(AJ_DebugLevel level, const char* file, int line)
{
    636c:	b538      	push	{r3, r4, r5, lr}
    636e:	1c05      	adds	r5, r0, #0
    6370:	1c0c      	adds	r4, r1, #0
    static AJ_Time initTime;
    uint32_t logTimeSecond;
    uint32_t logTimeMS;

    if (!(initTime.seconds | initTime.milliseconds)) 
    6372:	4a10      	ldr	r2, [pc, #64]	; (63b4 <_AJ_DbgHeader+0x48>)
    6374:	8811      	ldrh	r1, [r2, #0]
    6376:	6853      	ldr	r3, [r2, #4]
    6378:	430b      	orrs	r3, r1
    637a:	d102      	bne.n	6382 <_AJ_DbgHeader+0x16>
	{
        AJ_InitTimer(&initTime);
    637c:	1c10      	adds	r0, r2, #0
    637e:	4b0e      	ldr	r3, [pc, #56]	; (63b8 <_AJ_DbgHeader+0x4c>)
    6380:	4798      	blx	r3
    }
    if (level <= AJ_DbgLevel) 
    6382:	4b0e      	ldr	r3, [pc, #56]	; (63bc <_AJ_DbgHeader+0x50>)
    6384:	681b      	ldr	r3, [r3, #0]
        }
        return TRUE;
    } 
	else 
	{
        return FALSE;
    6386:	2000      	movs	r0, #0

    if (!(initTime.seconds | initTime.milliseconds)) 
	{
        AJ_InitTimer(&initTime);
    }
    if (level <= AJ_DbgLevel) 
    6388:	42ab      	cmp	r3, r5
    638a:	d311      	bcc.n	63b0 <_AJ_DbgHeader+0x44>
			logTimeSecond = debugTime.seconds;
			logTimeMS = debugTime.milliseconds;
		}
		else 
		{
            uint32_t elapsedTime = AJ_GetElapsedTime(&initTime, TRUE);
    638c:	4809      	ldr	r0, [pc, #36]	; (63b4 <_AJ_DbgHeader+0x48>)
    638e:	2101      	movs	r1, #1
    6390:	4b0b      	ldr	r3, [pc, #44]	; (63c0 <_AJ_DbgHeader+0x54>)
    6392:	4798      	blx	r3
            logTimeSecond = elapsedTime / 1000;
            logTimeMS = elapsedTime % 1000;
        }
        if (file) 
    6394:	2c00      	cmp	r4, #0
    6396:	d008      	beq.n	63aa <_AJ_DbgHeader+0x3e>
		{
            const char* fn = file;
            while (*fn) 
    6398:	7823      	ldrb	r3, [r4, #0]
    639a:	2b00      	cmp	r3, #0
    639c:	d007      	beq.n	63ae <_AJ_DbgHeader+0x42>
			{
                if ((*fn == '/') || (*fn == '\\')) 
				{
                    file = fn + 1;
                }
                ++fn;
    639e:	3401      	adds	r4, #1
            logTimeMS = elapsedTime % 1000;
        }
        if (file) 
		{
            const char* fn = file;
            while (*fn) 
    63a0:	7823      	ldrb	r3, [r4, #0]
    63a2:	2b00      	cmp	r3, #0
    63a4:	d1fb      	bne.n	639e <_AJ_DbgHeader+0x32>
        } 
		else 
		{
  //          AJ_AlwaysPrintf(("%03d.%03d ", logTimeSecond, logTimeMS));
        }
        return TRUE;
    63a6:	2001      	movs	r0, #1
    63a8:	e002      	b.n	63b0 <_AJ_DbgHeader+0x44>
    63aa:	2001      	movs	r0, #1
    63ac:	e000      	b.n	63b0 <_AJ_DbgHeader+0x44>
    63ae:	2001      	movs	r0, #1
    } 
	else 
	{
        return FALSE;
    }
}
    63b0:	bd38      	pop	{r3, r4, r5, pc}
    63b2:	46c0      	nop			; (mov r8, r8)
    63b4:	200006d0 	.word	0x200006d0
    63b8:	0000d7ad 	.word	0x0000d7ad
    63bc:	20000128 	.word	0x20000128
    63c0:	0000d769 	.word	0x0000d769

000063c4 <AJ_StatusText>:
    snprintf(code, sizeof(code), "%03u", status);
#endif

    return code;
#else
    switch (status)
    63c4:	2832      	cmp	r0, #50	; 0x32
    63c6:	d867      	bhi.n	6498 <AJ_StatusText+0xd4>
    63c8:	0080      	lsls	r0, r0, #2
    63ca:	4b35      	ldr	r3, [pc, #212]	; (64a0 <AJ_StatusText+0xdc>)
    63cc:	581b      	ldr	r3, [r3, r0]
    63ce:	469f      	mov	pc, r3
	{
        AJ_CASE(AJ_OK);
        AJ_CASE(AJ_ERR_NULL);
    63d0:	4834      	ldr	r0, [pc, #208]	; (64a4 <AJ_StatusText+0xe0>)
    63d2:	e064      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_UNEXPECTED);
    63d4:	4834      	ldr	r0, [pc, #208]	; (64a8 <AJ_StatusText+0xe4>)
    63d6:	e062      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_INVALID);
    63d8:	4834      	ldr	r0, [pc, #208]	; (64ac <AJ_StatusText+0xe8>)
    63da:	e060      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_IO_BUFFER);
    63dc:	4834      	ldr	r0, [pc, #208]	; (64b0 <AJ_StatusText+0xec>)
    63de:	e05e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_READ);
    63e0:	4834      	ldr	r0, [pc, #208]	; (64b4 <AJ_StatusText+0xf0>)
    63e2:	e05c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_WRITE);
    63e4:	4834      	ldr	r0, [pc, #208]	; (64b8 <AJ_StatusText+0xf4>)
    63e6:	e05a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_TIMEOUT);
    63e8:	4834      	ldr	r0, [pc, #208]	; (64bc <AJ_StatusText+0xf8>)
    63ea:	e058      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_MARSHAL);
    63ec:	4834      	ldr	r0, [pc, #208]	; (64c0 <AJ_StatusText+0xfc>)
    63ee:	e056      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_UNMARSHAL);
    63f0:	4834      	ldr	r0, [pc, #208]	; (64c4 <AJ_StatusText+0x100>)
    63f2:	e054      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_END_OF_DATA);
    63f4:	4834      	ldr	r0, [pc, #208]	; (64c8 <AJ_StatusText+0x104>)
    63f6:	e052      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_RESOURCES);
    63f8:	4834      	ldr	r0, [pc, #208]	; (64cc <AJ_StatusText+0x108>)
    63fa:	e050      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_NO_MORE);
    63fc:	4834      	ldr	r0, [pc, #208]	; (64d0 <AJ_StatusText+0x10c>)
    63fe:	e04e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SECURITY);
    6400:	4834      	ldr	r0, [pc, #208]	; (64d4 <AJ_StatusText+0x110>)
    6402:	e04c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_CONNECT);
    6404:	4834      	ldr	r0, [pc, #208]	; (64d8 <AJ_StatusText+0x114>)
    6406:	e04a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_UNKNOWN);
    6408:	4834      	ldr	r0, [pc, #208]	; (64dc <AJ_StatusText+0x118>)
    640a:	e048      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_NO_MATCH);
    640c:	4834      	ldr	r0, [pc, #208]	; (64e0 <AJ_StatusText+0x11c>)
    640e:	e046      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SIGNATURE);
    6410:	4834      	ldr	r0, [pc, #208]	; (64e4 <AJ_StatusText+0x120>)
    6412:	e044      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_DISALLOWED);
    6414:	4834      	ldr	r0, [pc, #208]	; (64e8 <AJ_StatusText+0x124>)
    6416:	e042      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_FAILURE);
    6418:	4834      	ldr	r0, [pc, #208]	; (64ec <AJ_StatusText+0x128>)
    641a:	e040      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_RESTART);
    641c:	4834      	ldr	r0, [pc, #208]	; (64f0 <AJ_StatusText+0x12c>)
    641e:	e03e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_LINK_TIMEOUT);
    6420:	4834      	ldr	r0, [pc, #208]	; (64f4 <AJ_StatusText+0x130>)
    6422:	e03c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_DRIVER);
    6424:	4834      	ldr	r0, [pc, #208]	; (64f8 <AJ_StatusText+0x134>)
    6426:	e03a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_OBJECT_PATH);
    6428:	4834      	ldr	r0, [pc, #208]	; (64fc <AJ_StatusText+0x138>)
    642a:	e038      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_BUSY);
    642c:	4834      	ldr	r0, [pc, #208]	; (6500 <AJ_StatusText+0x13c>)
    642e:	e036      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_DHCP);
    6430:	4834      	ldr	r0, [pc, #208]	; (6504 <AJ_StatusText+0x140>)
    6432:	e034      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ACCESS);
    6434:	4834      	ldr	r0, [pc, #208]	; (6508 <AJ_StatusText+0x144>)
    6436:	e032      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SESSION_LOST);
    6438:	4834      	ldr	r0, [pc, #208]	; (650c <AJ_StatusText+0x148>)
    643a:	e030      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_LINK_DEAD);
    643c:	4834      	ldr	r0, [pc, #208]	; (6510 <AJ_StatusText+0x14c>)
    643e:	e02e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_HDR_CORRUPT);
    6440:	4834      	ldr	r0, [pc, #208]	; (6514 <AJ_StatusText+0x150>)
    6442:	e02c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_RESTART_APP);
    6444:	4834      	ldr	r0, [pc, #208]	; (6518 <AJ_StatusText+0x154>)
    6446:	e02a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_INTERRUPTED);
    6448:	4834      	ldr	r0, [pc, #208]	; (651c <AJ_StatusText+0x158>)
    644a:	e028      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_REJECTED);
    644c:	4834      	ldr	r0, [pc, #208]	; (6520 <AJ_StatusText+0x15c>)
    644e:	e026      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_RANGE);
    6450:	4834      	ldr	r0, [pc, #208]	; (6524 <AJ_StatusText+0x160>)
    6452:	e024      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ACCESS_ROUTING_NODE);
    6454:	4834      	ldr	r0, [pc, #208]	; (6528 <AJ_StatusText+0x164>)
    6456:	e022      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_KEY_EXPIRED);
    6458:	4834      	ldr	r0, [pc, #208]	; (652c <AJ_StatusText+0x168>)
    645a:	e020      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SPI_NO_SPACE);
    645c:	4834      	ldr	r0, [pc, #208]	; (6530 <AJ_StatusText+0x16c>)
    645e:	e01e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SPI_READ);
    6460:	4834      	ldr	r0, [pc, #208]	; (6534 <AJ_StatusText+0x170>)
    6462:	e01c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_SPI_WRITE);
    6464:	4834      	ldr	r0, [pc, #208]	; (6538 <AJ_StatusText+0x174>)
    6466:	e01a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_OLD_VERSION);
    6468:	4834      	ldr	r0, [pc, #208]	; (653c <AJ_StatusText+0x178>)
    646a:	e018      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_NVRAM_READ);
    646c:	4834      	ldr	r0, [pc, #208]	; (6540 <AJ_StatusText+0x17c>)
    646e:	e016      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_NVRAM_WRITE);
    6470:	4834      	ldr	r0, [pc, #208]	; (6544 <AJ_StatusText+0x180>)
    6472:	e014      	b.n	649e <AJ_StatusText+0xda>

        AJ_CASE(AJ_ERR_WOULD_BLOCK);
    6474:	4834      	ldr	r0, [pc, #208]	; (6548 <AJ_StatusText+0x184>)
    6476:	e012      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_DISCONNECTED);
    6478:	4834      	ldr	r0, [pc, #208]	; (654c <AJ_StatusText+0x188>)
    647a:	e010      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_DISCONNECTING);
    647c:	4834      	ldr	r0, [pc, #208]	; (6550 <AJ_StatusText+0x18c>)
    647e:	e00e      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_REMOTE_CONNECTION_RESET);
    6480:	4834      	ldr	r0, [pc, #208]	; (6554 <AJ_StatusText+0x190>)
    6482:	e00c      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_PROBE_TIMEOUT);
    6484:	4834      	ldr	r0, [pc, #208]	; (6558 <AJ_StatusText+0x194>)
    6486:	e00a      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_BACKPRESSURE);
    6488:	4834      	ldr	r0, [pc, #208]	; (655c <AJ_StatusText+0x198>)
    648a:	e008      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_SEND_EXPIRED);
    648c:	4834      	ldr	r0, [pc, #208]	; (6560 <AJ_StatusText+0x19c>)
    648e:	e006      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_RECV_EXPIRED);
    6490:	4834      	ldr	r0, [pc, #208]	; (6564 <AJ_StatusText+0x1a0>)
    6492:	e004      	b.n	649e <AJ_StatusText+0xda>
        AJ_CASE(AJ_ERR_ARDP_VERSION_NOT_SUPPORTED);
    6494:	4834      	ldr	r0, [pc, #208]	; (6568 <AJ_StatusText+0x1a4>)
    6496:	e002      	b.n	649e <AJ_StatusText+0xda>

    default:
        return "<unknown>";
    6498:	4834      	ldr	r0, [pc, #208]	; (656c <AJ_StatusText+0x1a8>)
    649a:	e000      	b.n	649e <AJ_StatusText+0xda>

    return code;
#else
    switch (status)
	{
        AJ_CASE(AJ_OK);
    649c:	4834      	ldr	r0, [pc, #208]	; (6570 <AJ_StatusText+0x1ac>)

    default:
        return "<unknown>";
    }
#endif
}
    649e:	4770      	bx	lr
    64a0:	0001bae4 	.word	0x0001bae4
    64a4:	0001bbd0 	.word	0x0001bbd0
    64a8:	0001d960 	.word	0x0001d960
    64ac:	0001bbdc 	.word	0x0001bbdc
    64b0:	0001bbec 	.word	0x0001bbec
    64b4:	0001dc44 	.word	0x0001dc44
    64b8:	0001bc00 	.word	0x0001bc00
    64bc:	0001bc10 	.word	0x0001bc10
    64c0:	0001bc20 	.word	0x0001bc20
    64c4:	0001d928 	.word	0x0001d928
    64c8:	0001bc30 	.word	0x0001bc30
    64cc:	0001caf0 	.word	0x0001caf0
    64d0:	0001bc44 	.word	0x0001bc44
    64d4:	0001d98c 	.word	0x0001d98c
    64d8:	0001bc54 	.word	0x0001bc54
    64dc:	0001bc64 	.word	0x0001bc64
    64e0:	0001bc74 	.word	0x0001bc74
    64e4:	0001d9b4 	.word	0x0001d9b4
    64e8:	0001bc84 	.word	0x0001bc84
    64ec:	0001bc98 	.word	0x0001bc98
    64f0:	0001bca8 	.word	0x0001bca8
    64f4:	0001bcb8 	.word	0x0001bcb8
    64f8:	0001bccc 	.word	0x0001bccc
    64fc:	0001bcdc 	.word	0x0001bcdc
    6500:	0001bcf0 	.word	0x0001bcf0
    6504:	0001bcfc 	.word	0x0001bcfc
    6508:	0001bd08 	.word	0x0001bd08
    650c:	0001bd18 	.word	0x0001bd18
    6510:	0001bd2c 	.word	0x0001bd2c
    6514:	0001bd40 	.word	0x0001bd40
    6518:	0001bd54 	.word	0x0001bd54
    651c:	0001bd68 	.word	0x0001bd68
    6520:	0001bd7c 	.word	0x0001bd7c
    6524:	0001bd8c 	.word	0x0001bd8c
    6528:	0001bd9c 	.word	0x0001bd9c
    652c:	0001bdb8 	.word	0x0001bdb8
    6530:	0001bdcc 	.word	0x0001bdcc
    6534:	0001bde0 	.word	0x0001bde0
    6538:	0001bdf0 	.word	0x0001bdf0
    653c:	0001be04 	.word	0x0001be04
    6540:	0001be18 	.word	0x0001be18
    6544:	0001be2c 	.word	0x0001be2c
    6548:	0001be40 	.word	0x0001be40
    654c:	0001be54 	.word	0x0001be54
    6550:	0001be70 	.word	0x0001be70
    6554:	0001be8c 	.word	0x0001be8c
    6558:	0001beb0 	.word	0x0001beb0
    655c:	0001becc 	.word	0x0001becc
    6560:	0001bee8 	.word	0x0001bee8
    6564:	0001bf04 	.word	0x0001bf04
    6568:	0001bf20 	.word	0x0001bf20
    656c:	0001bf44 	.word	0x0001bf44
    6570:	0001dd14 	.word	0x0001dd14

00006574 <ParseMDNSDomainName>:
    }
    return rdlen + 2;
}

static size_t ParseMDNSDomainName(uint8_t const* buffer, uint32_t bufsize, MDNSDomainName* domainName, const uint8_t* payload, uint32_t paylen)
{
    6574:	b5f0      	push	{r4, r5, r6, r7, lr}
    6576:	465f      	mov	r7, fp
    6578:	4656      	mov	r6, sl
    657a:	464d      	mov	r5, r9
    657c:	4644      	mov	r4, r8
    657e:	b4f0      	push	{r4, r5, r6, r7}
    6580:	b083      	sub	sp, #12
    6582:	4682      	mov	sl, r0
    6584:	4691      	mov	r9, r2
    6586:	9301      	str	r3, [sp, #4]
    // the size of labels begin with two zero bits and can be
    // easily distinguished from pointers.
    uint32_t offset = 0;
    size_t size = 0;
    uint8_t const* pos = buffer;
    int32_t len = bufsize;
    6588:	1c0d      	adds	r5, r1, #0
    memset(domainName->name, 0, 256);
    658a:	1c10      	adds	r0, r2, #0
    658c:	2100      	movs	r1, #0
    658e:	2280      	movs	r2, #128	; 0x80
    6590:	0052      	lsls	r2, r2, #1
    6592:	4b41      	ldr	r3, [pc, #260]	; (6698 <ParseMDNSDomainName+0x124>)
    6594:	4798      	blx	r3
    while (len) 
    6596:	2d00      	cmp	r5, #0
    6598:	d071      	beq.n	667e <ParseMDNSDomainName+0x10a>
    659a:	4656      	mov	r6, sl
    659c:	2300      	movs	r3, #0
    659e:	4698      	mov	r8, r3
    65a0:	2700      	movs	r7, #0
            uint8_t label_len = *pos;
            pos++;
            len--;
            if (pos >= buffer)
			{
                size++;
    65a2:	469b      	mov	fp, r3
    uint8_t const* pos = buffer;
    int32_t len = bufsize;
    memset(domainName->name, 0, 256);
    while (len) 
	{
        if (((*pos & 0xc0) >> 6) == 3 && len > 1) 
    65a4:	7834      	ldrb	r4, [r6, #0]
    65a6:	09a3      	lsrs	r3, r4, #6
    65a8:	2b03      	cmp	r3, #3
    65aa:	d134      	bne.n	6616 <ParseMDNSDomainName+0xa2>
    65ac:	2d01      	cmp	r5, #1
    65ae:	dd32      	ble.n	6616 <ParseMDNSDomainName+0xa2>
		{
            uint32_t pointer = ((pos[0] << 8 | pos[1]) & 0x3FFF);
    65b0:	0225      	lsls	r5, r4, #8
    65b2:	7873      	ldrb	r3, [r6, #1]
    65b4:	431d      	orrs	r5, r3
    65b6:	04ad      	lsls	r5, r5, #18
    65b8:	0cad      	lsrs	r5, r5, #18
            if (pointer >= paylen)
    65ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    65bc:	429d      	cmp	r5, r3
    65be:	d30d      	bcc.n	65dc <ParseMDNSDomainName+0x68>
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Insufficient bufsize\n"));
    65c0:	2001      	movs	r0, #1
    65c2:	4936      	ldr	r1, [pc, #216]	; (669c <ParseMDNSDomainName+0x128>)
    65c4:	4a36      	ldr	r2, [pc, #216]	; (66a0 <ParseMDNSDomainName+0x12c>)
    65c6:	4b37      	ldr	r3, [pc, #220]	; (66a4 <ParseMDNSDomainName+0x130>)
    65c8:	4798      	blx	r3
    65ca:	1c03      	adds	r3, r0, #0
                return 0;
    65cc:	2000      	movs	r0, #0
        if (((*pos & 0xc0) >> 6) == 3 && len > 1) 
		{
            uint32_t pointer = ((pos[0] << 8 | pos[1]) & 0x3FFF);
            if (pointer >= paylen)
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Insufficient bufsize\n"));
    65ce:	2b00      	cmp	r3, #0
    65d0:	d05a      	beq.n	6688 <ParseMDNSDomainName+0x114>
    65d2:	4835      	ldr	r0, [pc, #212]	; (66a8 <ParseMDNSDomainName+0x134>)
    65d4:	4b35      	ldr	r3, [pc, #212]	; (66ac <ParseMDNSDomainName+0x138>)
    65d6:	4798      	blx	r3
                return 0;
    65d8:	2000      	movs	r0, #0
    65da:	e055      	b.n	6688 <ParseMDNSDomainName+0x114>
            }
            if (payload[pointer] & 0xc0)
    65dc:	9b01      	ldr	r3, [sp, #4]
    65de:	195a      	adds	r2, r3, r5
    65e0:	7813      	ldrb	r3, [r2, #0]
    65e2:	213f      	movs	r1, #63	; 0x3f
    65e4:	438b      	bics	r3, r1
    65e6:	d00d      	beq.n	6604 <ParseMDNSDomainName+0x90>
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Invalid compression\n"));
    65e8:	2001      	movs	r0, #1
    65ea:	492c      	ldr	r1, [pc, #176]	; (669c <ParseMDNSDomainName+0x128>)
    65ec:	4a30      	ldr	r2, [pc, #192]	; (66b0 <ParseMDNSDomainName+0x13c>)
    65ee:	4b2d      	ldr	r3, [pc, #180]	; (66a4 <ParseMDNSDomainName+0x130>)
    65f0:	4798      	blx	r3
    65f2:	1c03      	adds	r3, r0, #0
                return 0;
    65f4:	2000      	movs	r0, #0
                AJ_ErrPrintf(("ParseMDNSDomainName(): Insufficient bufsize\n"));
                return 0;
            }
            if (payload[pointer] & 0xc0)
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Invalid compression\n"));
    65f6:	2b00      	cmp	r3, #0
    65f8:	d046      	beq.n	6688 <ParseMDNSDomainName+0x114>
    65fa:	482e      	ldr	r0, [pc, #184]	; (66b4 <ParseMDNSDomainName+0x140>)
    65fc:	4b2b      	ldr	r3, [pc, #172]	; (66ac <ParseMDNSDomainName+0x138>)
    65fe:	4798      	blx	r3
                return 0;
    6600:	2000      	movs	r0, #0
    6602:	e041      	b.n	6688 <ParseMDNSDomainName+0x114>
            }
            if (pos >= buffer)
    6604:	45b2      	cmp	sl, r6
    6606:	d802      	bhi.n	660e <ParseMDNSDomainName+0x9a>
			{
                size += 2;
    6608:	2302      	movs	r3, #2
    660a:	469c      	mov	ip, r3
    660c:	44e0      	add	r8, ip
            }
            pos = payload + pointer;
            len = (paylen - pointer);
    660e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6610:	1b5d      	subs	r5, r3, r5
            }
            if (pos >= buffer)
			{
                size += 2;
            }
            pos = payload + pointer;
    6612:	1c16      	adds	r6, r2, #0
    int32_t len = bufsize;
    memset(domainName->name, 0, 256);
    while (len) 
	{
        if (((*pos & 0xc0) >> 6) == 3 && len > 1) 
		{
    6614:	e02f      	b.n	6676 <ParseMDNSDomainName+0x102>
            len = (paylen - pointer);
        } 
		else
		{
            uint8_t label_len = *pos;
            pos++;
    6616:	3601      	adds	r6, #1
            len--;
    6618:	3d01      	subs	r5, #1
            if (pos >= buffer)
			{
                size++;
    661a:	465b      	mov	r3, fp
    661c:	4651      	mov	r1, sl
    661e:	428e      	cmp	r6, r1
    6620:	415b      	adcs	r3, r3
    6622:	4498      	add	r8, r3
            }
            if (label_len > len)
    6624:	42a5      	cmp	r5, r4
    6626:	da0e      	bge.n	6646 <ParseMDNSDomainName+0xd2>
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Insufficient bufsize\n"));
    6628:	2001      	movs	r0, #1
    662a:	491c      	ldr	r1, [pc, #112]	; (669c <ParseMDNSDomainName+0x128>)
    662c:	22b8      	movs	r2, #184	; 0xb8
    662e:	0092      	lsls	r2, r2, #2
    6630:	4b1c      	ldr	r3, [pc, #112]	; (66a4 <ParseMDNSDomainName+0x130>)
    6632:	4798      	blx	r3
    6634:	1c03      	adds	r3, r0, #0
                return 0;
    6636:	2000      	movs	r0, #0
			{
                size++;
            }
            if (label_len > len)
			{
                AJ_ErrPrintf(("ParseMDNSDomainName(): Insufficient bufsize\n"));
    6638:	2b00      	cmp	r3, #0
    663a:	d025      	beq.n	6688 <ParseMDNSDomainName+0x114>
    663c:	481a      	ldr	r0, [pc, #104]	; (66a8 <ParseMDNSDomainName+0x134>)
    663e:	4b1b      	ldr	r3, [pc, #108]	; (66ac <ParseMDNSDomainName+0x138>)
    6640:	4798      	blx	r3
                return 0;
    6642:	2000      	movs	r0, #0
    6644:	e020      	b.n	6688 <ParseMDNSDomainName+0x114>
            }
            if (domainName->name[0])
    6646:	464b      	mov	r3, r9
    6648:	781b      	ldrb	r3, [r3, #0]
    664a:	1c38      	adds	r0, r7, #0
    664c:	2b00      	cmp	r3, #0
    664e:	d003      	beq.n	6658 <ParseMDNSDomainName+0xe4>
			{
                memcpy((domainName->name + offset), ".", 1);
    6650:	464b      	mov	r3, r9
    6652:	222e      	movs	r2, #46	; 0x2e
    6654:	55da      	strb	r2, [r3, r7]
                offset++;
    6656:	1c78      	adds	r0, r7, #1
            }
            if ((label_len > 0) && (offset + label_len) < 256)
    6658:	2c00      	cmp	r4, #0
    665a:	d012      	beq.n	6682 <ParseMDNSDomainName+0x10e>
    665c:	1907      	adds	r7, r0, r4
    665e:	2fff      	cmp	r7, #255	; 0xff
    6660:	d811      	bhi.n	6686 <ParseMDNSDomainName+0x112>
			{
                memcpy((domainName->name + offset), (pos), label_len);
    6662:	4448      	add	r0, r9
    6664:	1c31      	adds	r1, r6, #0
    6666:	1c22      	adds	r2, r4, #0
    6668:	4b13      	ldr	r3, [pc, #76]	; (66b8 <ParseMDNSDomainName+0x144>)
    666a:	4798      	blx	r3
                len -= label_len;
    666c:	1b2d      	subs	r5, r5, r4
                pos += label_len;
    666e:	1936      	adds	r6, r6, r4
                if (pos >= buffer) 
    6670:	45b2      	cmp	sl, r6
    6672:	d800      	bhi.n	6676 <ParseMDNSDomainName+0x102>
				{
                    size += label_len;
    6674:	44a0      	add	r8, r4
    uint32_t offset = 0;
    size_t size = 0;
    uint8_t const* pos = buffer;
    int32_t len = bufsize;
    memset(domainName->name, 0, 256);
    while (len) 
    6676:	2d00      	cmp	r5, #0
    6678:	d194      	bne.n	65a4 <ParseMDNSDomainName+0x30>
    667a:	4640      	mov	r0, r8
    667c:	e004      	b.n	6688 <ParseMDNSDomainName+0x114>
    // A pointer is denoted by an octet where the first two bits
    // are ones. Since the size of labels are at most 63 octets,
    // the size of labels begin with two zero bits and can be
    // easily distinguished from pointers.
    uint32_t offset = 0;
    size_t size = 0;
    667e:	2000      	movs	r0, #0
    6680:	e002      	b.n	6688 <ParseMDNSDomainName+0x114>
    6682:	4640      	mov	r0, r8
    6684:	e000      	b.n	6688 <ParseMDNSDomainName+0x114>
    6686:	4640      	mov	r0, r8
                break;
            }
        }
    }
    return size;
}
    6688:	b003      	add	sp, #12
    668a:	bc3c      	pop	{r2, r3, r4, r5}
    668c:	4690      	mov	r8, r2
    668e:	4699      	mov	r9, r3
    6690:	46a2      	mov	sl, r4
    6692:	46ab      	mov	fp, r5
    6694:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6696:	46c0      	nop			; (mov r8, r8)
    6698:	00016773 	.word	0x00016773
    669c:	0001bfcc 	.word	0x0001bfcc
    66a0:	000002c6 	.word	0x000002c6
    66a4:	0000636d 	.word	0x0000636d
    66a8:	0001bff4 	.word	0x0001bff4
    66ac:	00016f5d 	.word	0x00016f5d
    66b0:	000002cb 	.word	0x000002cb
    66b4:	0001c020 	.word	0x0001c020
    66b8:	00016739 	.word	0x00016739

000066bc <ParseMDNSResourceRecord>:
        return 0;
    }
}

static size_t ParseMDNSResourceRecord(uint8_t const* buffer, uint32_t bufsize, MDNSResourceRecord* record, uint8_t* payload, uint32_t paylen, const char* prefix)
{
    66bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    66be:	465f      	mov	r7, fp
    66c0:	4656      	mov	r6, sl
    66c2:	464d      	mov	r5, r9
    66c4:	4644      	mov	r4, r8
    66c6:	b4f0      	push	{r4, r5, r6, r7}
    66c8:	b089      	sub	sp, #36	; 0x24
    66ca:	1c06      	adds	r6, r0, #0
    66cc:	1c0d      	adds	r5, r1, #0
    66ce:	1c17      	adds	r7, r2, #0
    66d0:	9303      	str	r3, [sp, #12]
    size_t processed = 0;
    uint16_t ptr_len = 0;
    uint8_t const* p = NULL;
	// -  
    size_t size = ParseMDNSDomainName(buffer, bufsize, &(record->rrDomainName), payload, paylen);
    66d2:	9a12      	ldr	r2, [sp, #72]	; 0x48
    66d4:	9200      	str	r2, [sp, #0]
    66d6:	1c3a      	adds	r2, r7, #0
    66d8:	4ca1      	ldr	r4, [pc, #644]	; (6960 <ParseMDNSResourceRecord+0x2a4>)
    66da:	47a0      	blx	r4

    if (size == 0 || bufsize < 8) 
    66dc:	2800      	cmp	r0, #0
    66de:	d001      	beq.n	66e4 <ParseMDNSResourceRecord+0x28>
    66e0:	2d07      	cmp	r5, #7
    66e2:	d80d      	bhi.n	6700 <ParseMDNSResourceRecord+0x44>
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Error occured while deserializing domain name\n"));
    66e4:	2001      	movs	r0, #1
    66e6:	499f      	ldr	r1, [pc, #636]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    66e8:	4a9f      	ldr	r2, [pc, #636]	; (6968 <ParseMDNSResourceRecord+0x2ac>)
    66ea:	4ba0      	ldr	r3, [pc, #640]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    66ec:	4798      	blx	r3
        return 0;
    66ee:	2300      	movs	r3, #0
	// -  
    size_t size = ParseMDNSDomainName(buffer, bufsize, &(record->rrDomainName), payload, paylen);

    if (size == 0 || bufsize < 8) 
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Error occured while deserializing domain name\n"));
    66f0:	2800      	cmp	r0, #0
    66f2:	d100      	bne.n	66f6 <ParseMDNSResourceRecord+0x3a>
    66f4:	e1e8      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    66f6:	489e      	ldr	r0, [pc, #632]	; (6970 <ParseMDNSResourceRecord+0x2b4>)
    66f8:	4b9e      	ldr	r3, [pc, #632]	; (6974 <ParseMDNSResourceRecord+0x2b8>)
    66fa:	4798      	blx	r3
        return 0;
    66fc:	2300      	movs	r3, #0
    66fe:	e1e3      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    }

    if (size > bufsize || ((size + 8) > bufsize)) 
    6700:	4285      	cmp	r5, r0
    6702:	d304      	bcc.n	670e <ParseMDNSResourceRecord+0x52>
    6704:	2308      	movs	r3, #8
    6706:	4699      	mov	r9, r3
    6708:	4481      	add	r9, r0
    670a:	454d      	cmp	r5, r9
    670c:	d20d      	bcs.n	672a <ParseMDNSResourceRecord+0x6e>
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Insufficient buffer size\n"));
    670e:	2001      	movs	r0, #1
    6710:	4994      	ldr	r1, [pc, #592]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    6712:	4a99      	ldr	r2, [pc, #612]	; (6978 <ParseMDNSResourceRecord+0x2bc>)
    6714:	4b95      	ldr	r3, [pc, #596]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    6716:	4798      	blx	r3
        return 0;
    6718:	2300      	movs	r3, #0
        return 0;
    }

    if (size > bufsize || ((size + 8) > bufsize)) 
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Insufficient buffer size\n"));
    671a:	2800      	cmp	r0, #0
    671c:	d100      	bne.n	6720 <ParseMDNSResourceRecord+0x64>
    671e:	e1d3      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    6720:	4896      	ldr	r0, [pc, #600]	; (697c <ParseMDNSResourceRecord+0x2c0>)
    6722:	4b94      	ldr	r3, [pc, #592]	; (6974 <ParseMDNSResourceRecord+0x2b8>)
    6724:	4798      	blx	r3
        return 0;
    6726:	2300      	movs	r3, #0
    6728:	e1ce      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    }
    record->rrType = (RRType)((buffer[size] << 8) | buffer[size + 1]);
    672a:	1833      	adds	r3, r6, r0
    672c:	7859      	ldrb	r1, [r3, #1]
    672e:	2280      	movs	r2, #128	; 0x80
    6730:	0052      	lsls	r2, r2, #1
    6732:	54b9      	strb	r1, [r7, r2]

    //Next two octets are CLASS
    record->rrClass = (RRClass)((buffer[size + 2] << 8) | buffer[size + 3]);
    6734:	78da      	ldrb	r2, [r3, #3]
    6736:	4694      	mov	ip, r2
    6738:	2202      	movs	r2, #2
    673a:	32ff      	adds	r2, #255	; 0xff
    673c:	4664      	mov	r4, ip
    673e:	54bc      	strb	r4, [r7, r2]

    //Next four octets are TTL
    record->rrTTL = (buffer[size + 4] << 24) | (buffer[size + 5] << 16) | (buffer[size + 6] << 8) | buffer[size + 7];
    6740:	791a      	ldrb	r2, [r3, #4]
    6742:	0612      	lsls	r2, r2, #24
    6744:	4694      	mov	ip, r2
    6746:	795a      	ldrb	r2, [r3, #5]
    6748:	0412      	lsls	r2, r2, #16
    674a:	4664      	mov	r4, ip
    674c:	4322      	orrs	r2, r4
    674e:	79dc      	ldrb	r4, [r3, #7]
    6750:	4314      	orrs	r4, r2
    6752:	799a      	ldrb	r2, [r3, #6]
    6754:	0212      	lsls	r2, r2, #8
    6756:	1c23      	adds	r3, r4, #0
    6758:	4313      	orrs	r3, r2
    675a:	2282      	movs	r2, #130	; 0x82
    675c:	0052      	lsls	r2, r2, #1
    675e:	50bb      	str	r3, [r7, r2]
    bufsize -= (size + 8);
    6760:	1a2d      	subs	r5, r5, r0
    6762:	2308      	movs	r3, #8
    6764:	425b      	negs	r3, r3
    6766:	4698      	mov	r8, r3
    6768:	44a8      	add	r8, r5
    size += 8;
    p = &buffer[size];
    676a:	444e      	add	r6, r9

    switch (record->rrType) 
    676c:	290c      	cmp	r1, #12
    676e:	d028      	beq.n	67c2 <ParseMDNSResourceRecord+0x106>
    6770:	d802      	bhi.n	6778 <ParseMDNSResourceRecord+0xbc>
    6772:	2901      	cmp	r1, #1
    6774:	d006      	beq.n	6784 <ParseMDNSResourceRecord+0xc8>
    6776:	e17f      	b.n	6a78 <ParseMDNSResourceRecord+0x3bc>
    6778:	2910      	cmp	r1, #16
    677a:	d100      	bne.n	677e <ParseMDNSResourceRecord+0xc2>
    677c:	e088      	b.n	6890 <ParseMDNSResourceRecord+0x1d4>
    677e:	2921      	cmp	r1, #33	; 0x21
    6780:	d037      	beq.n	67f2 <ParseMDNSResourceRecord+0x136>
    6782:	e179      	b.n	6a78 <ParseMDNSResourceRecord+0x3bc>

}

static size_t ParseMDNSARData(uint8_t const* buffer, uint32_t bufsize, MDNSARData* a)
{
    memset(a->ipv4Addr, 0, 16);
    6784:	3709      	adds	r7, #9
    6786:	37ff      	adds	r7, #255	; 0xff
    6788:	1c38      	adds	r0, r7, #0
    678a:	2100      	movs	r1, #0
    678c:	2210      	movs	r2, #16
    678e:	4b7c      	ldr	r3, [pc, #496]	; (6980 <ParseMDNSResourceRecord+0x2c4>)
    6790:	4798      	blx	r3
    if (bufsize < 6) 
    6792:	4643      	mov	r3, r8
    6794:	2b05      	cmp	r3, #5
    6796:	d800      	bhi.n	679a <ParseMDNSResourceRecord+0xde>
    6798:	e17b      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
	{
        return 0;
    }
    if (buffer[0] != 0 || buffer[1] != 4)
    679a:	7833      	ldrb	r3, [r6, #0]
    679c:	2b00      	cmp	r3, #0
    679e:	d000      	beq.n	67a2 <ParseMDNSResourceRecord+0xe6>
    67a0:	e177      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    67a2:	7873      	ldrb	r3, [r6, #1]
    67a4:	2b04      	cmp	r3, #4
    67a6:	d000      	beq.n	67aa <ParseMDNSResourceRecord+0xee>
    67a8:	e173      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
	{
        return 0;
    }
    memset(a->ipv4Addr, 0, 4);
    67aa:	2300      	movs	r3, #0
    67ac:	703b      	strb	r3, [r7, #0]
    67ae:	707b      	strb	r3, [r7, #1]
    67b0:	70bb      	strb	r3, [r7, #2]
    67b2:	70fb      	strb	r3, [r7, #3]
    memcpy(a->ipv4Addr, (buffer + 2), 4);
    67b4:	1cb1      	adds	r1, r6, #2
    67b6:	1c38      	adds	r0, r7, #0
    67b8:	2204      	movs	r2, #4
    67ba:	4b72      	ldr	r3, [pc, #456]	; (6984 <ParseMDNSResourceRecord+0x2c8>)
    67bc:	4798      	blx	r3
    return 6;
    67be:	2306      	movs	r3, #6
    67c0:	e175      	b.n	6aae <ParseMDNSResourceRecord+0x3f2>

    case PTR:
       AJ_InfoPrintf(("ParseMDNSResourceRecord(): Found a PTR record\n"));
        ptr_len = (*p << 8 | *(p + 1));
        p += 2;
        bufsize -= 2;
    67c2:	1c29      	adds	r1, r5, #0
    67c4:	390a      	subs	r1, #10
        processed = ParseMDNSARData(p, bufsize, &(record->rdata.aRData));
        break;

    case PTR:
       AJ_InfoPrintf(("ParseMDNSResourceRecord(): Found a PTR record\n"));
        ptr_len = (*p << 8 | *(p + 1));
    67c6:	7832      	ldrb	r2, [r6, #0]
    67c8:	0212      	lsls	r2, r2, #8
    67ca:	7873      	ldrb	r3, [r6, #1]
        p += 2;
        bufsize -= 2;
        if (ptr_len > bufsize) 
    67cc:	431a      	orrs	r2, r3
		{
            return 0;
    67ce:	2300      	movs	r3, #0
    case PTR:
       AJ_InfoPrintf(("ParseMDNSResourceRecord(): Found a PTR record\n"));
        ptr_len = (*p << 8 | *(p + 1));
        p += 2;
        bufsize -= 2;
        if (ptr_len > bufsize) 
    67d0:	4291      	cmp	r1, r2
    67d2:	d200      	bcs.n	67d6 <ParseMDNSResourceRecord+0x11a>
    67d4:	e178      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
        break;

    case PTR:
       AJ_InfoPrintf(("ParseMDNSResourceRecord(): Found a PTR record\n"));
        ptr_len = (*p << 8 | *(p + 1));
        p += 2;
    67d6:	1cb0      	adds	r0, r6, #2
        if (ptr_len > bufsize) 
		{
            return 0;
        }
		//
        processed = ParseMDNSDomainName(p, bufsize, &(record->rdata.ptrRData), payload, paylen);
    67d8:	1c3a      	adds	r2, r7, #0
    67da:	3209      	adds	r2, #9
    67dc:	32ff      	adds	r2, #255	; 0xff
    67de:	9b12      	ldr	r3, [sp, #72]	; 0x48
    67e0:	9300      	str	r3, [sp, #0]
    67e2:	9b03      	ldr	r3, [sp, #12]
    67e4:	4c5e      	ldr	r4, [pc, #376]	; (6960 <ParseMDNSResourceRecord+0x2a4>)
    67e6:	47a0      	blx	r4
        if (processed) 
		{
            processed += 2;
    67e8:	1c83      	adds	r3, r0, #2
		{
            return 0;
        }
		//
        processed = ParseMDNSDomainName(p, bufsize, &(record->rdata.ptrRData), payload, paylen);
        if (processed) 
    67ea:	2800      	cmp	r0, #0
    67ec:	d000      	beq.n	67f0 <ParseMDNSResourceRecord+0x134>
    67ee:	e14e      	b.n	6a8e <ParseMDNSResourceRecord+0x3d2>
    67f0:	e14f      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
{
    uint16_t length = 0;
    size_t size = 0;
    size_t ret = 0;
    uint8_t const* p = NULL;
    if (bufsize < 2) 
    67f2:	4643      	mov	r3, r8
    67f4:	2b01      	cmp	r3, #1
    67f6:	d80c      	bhi.n	6812 <ParseMDNSResourceRecord+0x156>
	{
        AJ_ErrPrintf(("ParseMDNSSrvRData(): Insufficient bufsize %d", bufsize));
    67f8:	2001      	movs	r0, #1
    67fa:	495a      	ldr	r1, [pc, #360]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    67fc:	4a62      	ldr	r2, [pc, #392]	; (6988 <ParseMDNSResourceRecord+0x2cc>)
    67fe:	4b5b      	ldr	r3, [pc, #364]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    6800:	4798      	blx	r3
    6802:	2800      	cmp	r0, #0
    6804:	d100      	bne.n	6808 <ParseMDNSResourceRecord+0x14c>
    6806:	e144      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    6808:	4860      	ldr	r0, [pc, #384]	; (698c <ParseMDNSResourceRecord+0x2d0>)
    680a:	4641      	mov	r1, r8
    680c:	4b60      	ldr	r3, [pc, #384]	; (6990 <ParseMDNSResourceRecord+0x2d4>)
    680e:	4798      	blx	r3
    6810:	e13f      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
        return 0;
    }

    length = buffer[0] << 8 | buffer[1];
    6812:	7833      	ldrb	r3, [r6, #0]
    6814:	021b      	lsls	r3, r3, #8
    6816:	7872      	ldrb	r2, [r6, #1]
    6818:	431a      	orrs	r2, r3
    681a:	4690      	mov	r8, r2
    bufsize -= 2;
    681c:	230a      	movs	r3, #10
    681e:	425b      	negs	r3, r3
    6820:	469a      	mov	sl, r3
    6822:	44aa      	add	sl, r5

    if (bufsize < length || length < 6)
    6824:	4592      	cmp	sl, r2
    6826:	d301      	bcc.n	682c <ParseMDNSResourceRecord+0x170>
    6828:	2a05      	cmp	r2, #5
    682a:	d80d      	bhi.n	6848 <ParseMDNSResourceRecord+0x18c>
	{
        AJ_ErrPrintf(("ParseMDNSSrvRData(): Insufficient bufsize %d or invalid length %d", bufsize, length));
    682c:	2001      	movs	r0, #1
    682e:	494d      	ldr	r1, [pc, #308]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    6830:	4a58      	ldr	r2, [pc, #352]	; (6994 <ParseMDNSResourceRecord+0x2d8>)
    6832:	4b4e      	ldr	r3, [pc, #312]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    6834:	4798      	blx	r3
    6836:	2800      	cmp	r0, #0
    6838:	d100      	bne.n	683c <ParseMDNSResourceRecord+0x180>
    683a:	e12a      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    683c:	4856      	ldr	r0, [pc, #344]	; (6998 <ParseMDNSResourceRecord+0x2dc>)
    683e:	4651      	mov	r1, sl
    6840:	4642      	mov	r2, r8
    6842:	4b53      	ldr	r3, [pc, #332]	; (6990 <ParseMDNSResourceRecord+0x2d4>)
    6844:	4798      	blx	r3
    6846:	e124      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
        return 0;
    }
    srvRData->priority = buffer[2] << 8 | buffer[3];
    6848:	78b3      	ldrb	r3, [r6, #2]
    684a:	021b      	lsls	r3, r3, #8
    684c:	78f2      	ldrb	r2, [r6, #3]
    684e:	4313      	orrs	r3, r2
    6850:	2284      	movs	r2, #132	; 0x84
    6852:	0052      	lsls	r2, r2, #1
    6854:	52bb      	strh	r3, [r7, r2]
    bufsize -= 2;

    srvRData->weight = buffer[4] << 8 | buffer[5];
    6856:	7933      	ldrb	r3, [r6, #4]
    6858:	021b      	lsls	r3, r3, #8
    685a:	7972      	ldrb	r2, [r6, #5]
    685c:	4313      	orrs	r3, r2
    685e:	1c3a      	adds	r2, r7, #0
    6860:	3209      	adds	r2, #9
    6862:	32ff      	adds	r2, #255	; 0xff
    6864:	8053      	strh	r3, [r2, #2]
    bufsize -= 2;

    srvRData->port = buffer[6] << 8 | buffer[7];
    6866:	79b3      	ldrb	r3, [r6, #6]
    6868:	021b      	lsls	r3, r3, #8
    686a:	79f1      	ldrb	r1, [r6, #7]
    686c:	430b      	orrs	r3, r1
    686e:	8093      	strh	r3, [r2, #4]
    bufsize -= 2;

    size = 8;
    p = &buffer[size];
    6870:	1c30      	adds	r0, r6, #0
    6872:	3008      	adds	r0, #8

    srvRData->weight = buffer[4] << 8 | buffer[5];
    bufsize -= 2;

    srvRData->port = buffer[6] << 8 | buffer[7];
    bufsize -= 2;
    6874:	1c29      	adds	r1, r5, #0
    6876:	3910      	subs	r1, #16

    size = 8;
    p = &buffer[size];
    ret = ParseMDNSDomainName(p, bufsize, &(srvRData->target), payload, paylen);
    6878:	3206      	adds	r2, #6
    687a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    687c:	9300      	str	r3, [sp, #0]
    687e:	9b03      	ldr	r3, [sp, #12]
    6880:	4c37      	ldr	r4, [pc, #220]	; (6960 <ParseMDNSResourceRecord+0x2a4>)
    6882:	47a0      	blx	r4
    if (ret)
    6884:	2800      	cmp	r0, #0
    6886:	d100      	bne.n	688a <ParseMDNSResourceRecord+0x1ce>
    6888:	e103      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
	{
        return (size + ret);
    688a:	1c03      	adds	r3, r0, #0
    688c:	3308      	adds	r3, #8
    688e:	e0fe      	b.n	6a8e <ParseMDNSResourceRecord+0x3d2>
    uint16_t rdlen = 0;
    uint8_t const* p = NULL;
    uint8_t* pos = NULL;
    uint8_t sz = 0;
    size_t size = 0;
    memset(textRData->BusNodeName, 0, 256);
    6890:	2384      	movs	r3, #132	; 0x84
    6892:	005b      	lsls	r3, r3, #1
    6894:	469c      	mov	ip, r3
    6896:	44bc      	add	ip, r7
    6898:	4663      	mov	r3, ip
    689a:	9306      	str	r3, [sp, #24]
    689c:	4660      	mov	r0, ip
    689e:	2100      	movs	r1, #0
    68a0:	2280      	movs	r2, #128	; 0x80
    68a2:	0052      	lsls	r2, r2, #1
    68a4:	4c36      	ldr	r4, [pc, #216]	; (6980 <ParseMDNSResourceRecord+0x2c4>)
    68a6:	47a0      	blx	r4
    memset(textRData->BusNodeTransport, 0, 256);
    68a8:	2382      	movs	r3, #130	; 0x82
    68aa:	009b      	lsls	r3, r3, #2
    68ac:	469c      	mov	ip, r3
    68ae:	44bc      	add	ip, r7
    68b0:	4663      	mov	r3, ip
    68b2:	9304      	str	r3, [sp, #16]
    68b4:	4660      	mov	r0, ip
    68b6:	2100      	movs	r1, #0
    68b8:	2280      	movs	r2, #128	; 0x80
    68ba:	0052      	lsls	r2, r2, #1
    68bc:	47a0      	blx	r4
    memset(textRData->BusNodeProtocolVersion, 0, 8);
    68be:	23c2      	movs	r3, #194	; 0xc2
    68c0:	009b      	lsls	r3, r3, #2
    68c2:	469a      	mov	sl, r3
    68c4:	44ba      	add	sl, r7
    68c6:	2300      	movs	r3, #0
    68c8:	4652      	mov	r2, sl
    68ca:	7013      	strb	r3, [r2, #0]
    68cc:	7053      	strb	r3, [r2, #1]
    68ce:	7093      	strb	r3, [r2, #2]
    68d0:	70d3      	strb	r3, [r2, #3]
    68d2:	7113      	strb	r3, [r2, #4]
    68d4:	7153      	strb	r3, [r2, #5]
    68d6:	7193      	strb	r3, [r2, #6]
    68d8:	71d3      	strb	r3, [r2, #7]

    if (bufsize < 2) 
    68da:	4643      	mov	r3, r8
    68dc:	2b01      	cmp	r3, #1
    68de:	d80c      	bhi.n	68fa <ParseMDNSResourceRecord+0x23e>
	{
        AJ_ErrPrintf(("ParseMDNSTextRData(): Insufficient bufsize %d", bufsize));
    68e0:	2001      	movs	r0, #1
    68e2:	4920      	ldr	r1, [pc, #128]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    68e4:	4a2d      	ldr	r2, [pc, #180]	; (699c <ParseMDNSResourceRecord+0x2e0>)
    68e6:	4b21      	ldr	r3, [pc, #132]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    68e8:	4798      	blx	r3
    68ea:	2800      	cmp	r0, #0
    68ec:	d100      	bne.n	68f0 <ParseMDNSResourceRecord+0x234>
    68ee:	e0d0      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    68f0:	482b      	ldr	r0, [pc, #172]	; (69a0 <ParseMDNSResourceRecord+0x2e4>)
    68f2:	4641      	mov	r1, r8
    68f4:	4b26      	ldr	r3, [pc, #152]	; (6990 <ParseMDNSResourceRecord+0x2d4>)
    68f6:	4798      	blx	r3
    68f8:	e0cb      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
        return 0;
    }
    rdlen = buffer[0] << 8 | buffer[1];
    68fa:	7833      	ldrb	r3, [r6, #0]
    68fc:	021b      	lsls	r3, r3, #8
    68fe:	7872      	ldrb	r2, [r6, #1]
    6900:	431a      	orrs	r2, r3
    6902:	9205      	str	r2, [sp, #20]

    bufsize -= 2;
    6904:	1c2c      	adds	r4, r5, #0
    6906:	3c0a      	subs	r4, #10
    size = 2 + rdlen;
    // If there's not enough data in the buffer then bail.
    if (bufsize < rdlen)
    6908:	4294      	cmp	r4, r2
    690a:	d20c      	bcs.n	6926 <ParseMDNSResourceRecord+0x26a>
	{
        AJ_ErrPrintf(("ParseMDNSTextRData(): Insufficient bufsize %d", bufsize));
    690c:	2001      	movs	r0, #1
    690e:	4915      	ldr	r1, [pc, #84]	; (6964 <ParseMDNSResourceRecord+0x2a8>)
    6910:	4a24      	ldr	r2, [pc, #144]	; (69a4 <ParseMDNSResourceRecord+0x2e8>)
    6912:	4b16      	ldr	r3, [pc, #88]	; (696c <ParseMDNSResourceRecord+0x2b0>)
    6914:	4798      	blx	r3
    6916:	2800      	cmp	r0, #0
    6918:	d100      	bne.n	691c <ParseMDNSResourceRecord+0x260>
    691a:	e0ba      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    691c:	4820      	ldr	r0, [pc, #128]	; (69a0 <ParseMDNSResourceRecord+0x2e4>)
    691e:	1c21      	adds	r1, r4, #0
    6920:	4b1b      	ldr	r3, [pc, #108]	; (6990 <ParseMDNSResourceRecord+0x2d4>)
    6922:	4798      	blx	r3
    6924:	e0b5      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
        return 0;
    }
    p = &buffer[2];
    while (rdlen > 0 && bufsize > 0) 
    6926:	9b05      	ldr	r3, [sp, #20]
    6928:	2b00      	cmp	r3, #0
    692a:	d100      	bne.n	692e <ParseMDNSResourceRecord+0x272>
    692c:	e0c9      	b.n	6ac2 <ParseMDNSResourceRecord+0x406>
    692e:	2c00      	cmp	r4, #0
    6930:	d100      	bne.n	6934 <ParseMDNSResourceRecord+0x278>
    6932:	e0be      	b.n	6ab2 <ParseMDNSResourceRecord+0x3f6>
	{
        sz = *p++;
    6934:	1cf2      	adds	r2, r6, #3
    6936:	78b6      	ldrb	r6, [r6, #2]
        bufsize--;
    6938:	3d0b      	subs	r5, #11
    693a:	1c2c      	adds	r4, r5, #0
        if (!sz || !bufsize ||  bufsize < sz) 
    693c:	2e00      	cmp	r6, #0
    693e:	d100      	bne.n	6942 <ParseMDNSResourceRecord+0x286>
    6940:	e0a7      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    6942:	2d00      	cmp	r5, #0
    6944:	d100      	bne.n	6948 <ParseMDNSResourceRecord+0x28c>
    6946:	e0a4      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    6948:	42ae      	cmp	r6, r5
    694a:	d900      	bls.n	694e <ParseMDNSResourceRecord+0x292>
    694c:	e0a1      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    694e:	46a0      	mov	r8, r4
    6950:	469b      	mov	fp, r3
    6952:	1c35      	adds	r5, r6, #0
    6954:	1c14      	adds	r4, r2, #0
    6956:	4653      	mov	r3, sl
    6958:	9307      	str	r3, [sp, #28]
    695a:	9703      	str	r7, [sp, #12]
    695c:	e02f      	b.n	69be <ParseMDNSResourceRecord+0x302>
    695e:	46c0      	nop			; (mov r8, r8)
    6960:	00006575 	.word	0x00006575
    6964:	0001bfcc 	.word	0x0001bfcc
    6968:	0000037d 	.word	0x0000037d
    696c:	0000636d 	.word	0x0000636d
    6970:	0001c04c 	.word	0x0001c04c
    6974:	00016f5d 	.word	0x00016f5d
    6978:	00000383 	.word	0x00000383
    697c:	0001c098 	.word	0x0001c098
    6980:	00016773 	.word	0x00016773
    6984:	00016739 	.word	0x00016739
    6988:	00000351 	.word	0x00000351
    698c:	0001c0cc 	.word	0x0001c0cc
    6990:	00016e3d 	.word	0x00016e3d
    6994:	0000035a 	.word	0x0000035a
    6998:	0001c0fc 	.word	0x0001c0fc
    699c:	0000030d 	.word	0x0000030d
    69a0:	0001c140 	.word	0x0001c140
    69a4:	00000317 	.word	0x00000317
        return 0;
    }
    p = &buffer[2];
    while (rdlen > 0 && bufsize > 0) 
	{
        sz = *p++;
    69a8:	1c54      	adds	r4, r2, #1
    69aa:	7816      	ldrb	r6, [r2, #0]
        bufsize--;
    69ac:	3b01      	subs	r3, #1
    69ae:	4698      	mov	r8, r3
        if (!sz || !bufsize ||  bufsize < sz) 
    69b0:	2e00      	cmp	r6, #0
    69b2:	d06e      	beq.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    69b4:	2b00      	cmp	r3, #0
    69b6:	d06c      	beq.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    69b8:	1c35      	adds	r5, r6, #0
    69ba:	42b3      	cmp	r3, r6
    69bc:	d369      	bcc.n	6a92 <ParseMDNSResourceRecord+0x3d6>
            return 0;
        }
        // For now we are only interested in three specific
        // key-value pairs: the bus node transport, bus node
        // name and the bus node protocol version.
        pos = (uint8_t*) memchr((char const*)p, '=', sz);
    69be:	1c20      	adds	r0, r4, #0
    69c0:	213d      	movs	r1, #61	; 0x3d
    69c2:	1c2a      	adds	r2, r5, #0
    69c4:	4b44      	ldr	r3, [pc, #272]	; (6ad8 <ParseMDNSResourceRecord+0x41c>)
    69c6:	4798      	blx	r3
    69c8:	4682      	mov	sl, r0
        if (pos) 
    69ca:	2800      	cmp	r0, #0
    69cc:	d043      	beq.n	6a56 <ParseMDNSResourceRecord+0x39a>
    69ce:	1e77      	subs	r7, r6, #1
		{
            uint8_t indx = pos - p;
    69d0:	1b03      	subs	r3, r0, r4
            uint8_t valsz = (sz - indx - 1);
    69d2:	1aff      	subs	r7, r7, r3
    69d4:	b2ff      	uxtb	r7, r7
            if (!memcmp(p, "ajpv", 4)) 
    69d6:	1c20      	adds	r0, r4, #0
    69d8:	4940      	ldr	r1, [pc, #256]	; (6adc <ParseMDNSResourceRecord+0x420>)
    69da:	2204      	movs	r2, #4
    69dc:	4b40      	ldr	r3, [pc, #256]	; (6ae0 <ParseMDNSResourceRecord+0x424>)
    69de:	4798      	blx	r3
    69e0:	2800      	cmp	r0, #0
    69e2:	d107      	bne.n	69f4 <ParseMDNSResourceRecord+0x338>
			{
                if (valsz < 8)
    69e4:	2f07      	cmp	r7, #7
    69e6:	d805      	bhi.n	69f4 <ParseMDNSResourceRecord+0x338>
				{
                    memcpy(textRData->BusNodeProtocolVersion, pos + 1, valsz);
    69e8:	4653      	mov	r3, sl
    69ea:	1c59      	adds	r1, r3, #1
    69ec:	9807      	ldr	r0, [sp, #28]
    69ee:	1c3a      	adds	r2, r7, #0
    69f0:	4b3c      	ldr	r3, [pc, #240]	; (6ae4 <ParseMDNSResourceRecord+0x428>)
    69f2:	4798      	blx	r3
                }
            }
            if (!memcmp(p, "t_", 2) && !textRData->BusNodeName[0]) 
    69f4:	1c20      	adds	r0, r4, #0
    69f6:	493c      	ldr	r1, [pc, #240]	; (6ae8 <ParseMDNSResourceRecord+0x42c>)
    69f8:	2202      	movs	r2, #2
    69fa:	4b39      	ldr	r3, [pc, #228]	; (6ae0 <ParseMDNSResourceRecord+0x424>)
    69fc:	4798      	blx	r3
    69fe:	2800      	cmp	r0, #0
    6a00:	d10b      	bne.n	6a1a <ParseMDNSResourceRecord+0x35e>
    6a02:	2384      	movs	r3, #132	; 0x84
    6a04:	005b      	lsls	r3, r3, #1
    6a06:	9a03      	ldr	r2, [sp, #12]
    6a08:	5cd3      	ldrb	r3, [r2, r3]
    6a0a:	2b00      	cmp	r3, #0
    6a0c:	d105      	bne.n	6a1a <ParseMDNSResourceRecord+0x35e>
			{
                memcpy(textRData->BusNodeTransport, pos + 1, valsz);
    6a0e:	4653      	mov	r3, sl
    6a10:	1c59      	adds	r1, r3, #1
    6a12:	9804      	ldr	r0, [sp, #16]
    6a14:	1c3a      	adds	r2, r7, #0
    6a16:	4b33      	ldr	r3, [pc, #204]	; (6ae4 <ParseMDNSResourceRecord+0x428>)
    6a18:	4798      	blx	r3
            }
            if (!memcmp(p, "n_", 2) && (prefix != NULL) && (valsz >= strlen(prefix)) && !memcmp(pos + 1, prefix, strlen(prefix)))
    6a1a:	1c20      	adds	r0, r4, #0
    6a1c:	4933      	ldr	r1, [pc, #204]	; (6aec <ParseMDNSResourceRecord+0x430>)
    6a1e:	2202      	movs	r2, #2
    6a20:	4b2f      	ldr	r3, [pc, #188]	; (6ae0 <ParseMDNSResourceRecord+0x424>)
    6a22:	4798      	blx	r3
    6a24:	2800      	cmp	r0, #0
    6a26:	d116      	bne.n	6a56 <ParseMDNSResourceRecord+0x39a>
    6a28:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    6a2a:	2b00      	cmp	r3, #0
    6a2c:	d013      	beq.n	6a56 <ParseMDNSResourceRecord+0x39a>
    6a2e:	1c18      	adds	r0, r3, #0
    6a30:	4b2f      	ldr	r3, [pc, #188]	; (6af0 <ParseMDNSResourceRecord+0x434>)
    6a32:	4798      	blx	r3
    6a34:	1c02      	adds	r2, r0, #0
    6a36:	4287      	cmp	r7, r0
    6a38:	d30d      	bcc.n	6a56 <ParseMDNSResourceRecord+0x39a>
    6a3a:	2301      	movs	r3, #1
    6a3c:	469c      	mov	ip, r3
    6a3e:	44e2      	add	sl, ip
    6a40:	4650      	mov	r0, sl
    6a42:	9913      	ldr	r1, [sp, #76]	; 0x4c
    6a44:	4b26      	ldr	r3, [pc, #152]	; (6ae0 <ParseMDNSResourceRecord+0x424>)
    6a46:	4798      	blx	r3
    6a48:	2800      	cmp	r0, #0
    6a4a:	d104      	bne.n	6a56 <ParseMDNSResourceRecord+0x39a>
			{
                memcpy(textRData->BusNodeName, pos + 1, valsz);
    6a4c:	9806      	ldr	r0, [sp, #24]
    6a4e:	4651      	mov	r1, sl
    6a50:	1c3a      	adds	r2, r7, #0
    6a52:	4b24      	ldr	r3, [pc, #144]	; (6ae4 <ParseMDNSResourceRecord+0x428>)
    6a54:	4798      	blx	r3
            }
        }
        p += sz;
    6a56:	1962      	adds	r2, r4, r5
    6a58:	43f6      	mvns	r6, r6
        rdlen -= sz + 1;
    6a5a:	445e      	add	r6, fp
    6a5c:	b2b3      	uxth	r3, r6
    6a5e:	469b      	mov	fp, r3
        bufsize -= sz;
    6a60:	4643      	mov	r3, r8
    6a62:	1b5b      	subs	r3, r3, r5
	{
        AJ_ErrPrintf(("ParseMDNSTextRData(): Insufficient bufsize %d", bufsize));
        return 0;
    }
    p = &buffer[2];
    while (rdlen > 0 && bufsize > 0) 
    6a64:	4659      	mov	r1, fp
    6a66:	2900      	cmp	r1, #0
    6a68:	d02b      	beq.n	6ac2 <ParseMDNSResourceRecord+0x406>
    6a6a:	2b00      	cmp	r3, #0
    6a6c:	d19c      	bne.n	69a8 <ParseMDNSResourceRecord+0x2ec>
    6a6e:	e020      	b.n	6ab2 <ParseMDNSResourceRecord+0x3f6>
        bufsize -= sz;
    }

    if (rdlen != 0)
	{
        AJ_ErrPrintf(("ParseMDNSTextRData(): Mismatched RDLength"));
    6a70:	4820      	ldr	r0, [pc, #128]	; (6af4 <ParseMDNSResourceRecord+0x438>)
    6a72:	4b21      	ldr	r3, [pc, #132]	; (6af8 <ParseMDNSResourceRecord+0x43c>)
    6a74:	4798      	blx	r3
    6a76:	e00c      	b.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    // Default data is skipped as it's deemed to be a
    // resource record type that is not currently used
    // or reserved for future use.
    uint16_t rdlen = 0;

    if (bufsize < 2) 
    6a78:	4643      	mov	r3, r8
    6a7a:	2b01      	cmp	r3, #1
    6a7c:	d909      	bls.n	6a92 <ParseMDNSResourceRecord+0x3d6>
	{
        return 0;
    }
    rdlen = (buffer[0] << 8 | buffer[1]);
    6a7e:	7833      	ldrb	r3, [r6, #0]
    6a80:	021b      	lsls	r3, r3, #8
    6a82:	7870      	ldrb	r0, [r6, #1]
    6a84:	4303      	orrs	r3, r0
    bufsize -= 2;
    6a86:	3d0a      	subs	r5, #10
    if (bufsize < rdlen) 
    6a88:	429d      	cmp	r5, r3
    6a8a:	d302      	bcc.n	6a92 <ParseMDNSResourceRecord+0x3d6>
	{
        return 0;
    }
    return rdlen + 2;
    6a8c:	3302      	adds	r3, #2
       AJ_InfoPrintf(("ParseMDNSResourceRecord(): Found a non-relevant or unknown record type that will be ignored\n"));
		// 
        processed = ParseMDNSDefaultRData(p, bufsize);
        break;
    }
    if (!processed) 
    6a8e:	2b00      	cmp	r3, #0
    6a90:	d10d      	bne.n	6aae <ParseMDNSResourceRecord+0x3f2>
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Error occured while deserializing resource data"));
    6a92:	2001      	movs	r0, #1
    6a94:	4919      	ldr	r1, [pc, #100]	; (6afc <ParseMDNSResourceRecord+0x440>)
    6a96:	22f2      	movs	r2, #242	; 0xf2
    6a98:	0092      	lsls	r2, r2, #2
    6a9a:	4b19      	ldr	r3, [pc, #100]	; (6b00 <ParseMDNSResourceRecord+0x444>)
    6a9c:	4798      	blx	r3
        return 0;
    6a9e:	2300      	movs	r3, #0
        processed = ParseMDNSDefaultRData(p, bufsize);
        break;
    }
    if (!processed) 
	{
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Error occured while deserializing resource data"));
    6aa0:	2800      	cmp	r0, #0
    6aa2:	d011      	beq.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    6aa4:	4817      	ldr	r0, [pc, #92]	; (6b04 <ParseMDNSResourceRecord+0x448>)
    6aa6:	4b14      	ldr	r3, [pc, #80]	; (6af8 <ParseMDNSResourceRecord+0x43c>)
    6aa8:	4798      	blx	r3
        return 0;
    6aaa:	2300      	movs	r3, #0
    6aac:	e00c      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
    }
    size += processed;
    6aae:	444b      	add	r3, r9
    return size;
    6ab0:	e00a      	b.n	6ac8 <ParseMDNSResourceRecord+0x40c>
        bufsize -= sz;
    }

    if (rdlen != 0)
	{
        AJ_ErrPrintf(("ParseMDNSTextRData(): Mismatched RDLength"));
    6ab2:	2001      	movs	r0, #1
    6ab4:	4911      	ldr	r1, [pc, #68]	; (6afc <ParseMDNSResourceRecord+0x440>)
    6ab6:	4a14      	ldr	r2, [pc, #80]	; (6b08 <ParseMDNSResourceRecord+0x44c>)
    6ab8:	4b11      	ldr	r3, [pc, #68]	; (6b00 <ParseMDNSResourceRecord+0x444>)
    6aba:	4798      	blx	r3
    6abc:	2800      	cmp	r0, #0
    6abe:	d0e8      	beq.n	6a92 <ParseMDNSResourceRecord+0x3d6>
    6ac0:	e7d6      	b.n	6a70 <ParseMDNSResourceRecord+0x3b4>
        return 0;
    }
    rdlen = buffer[0] << 8 | buffer[1];

    bufsize -= 2;
    size = 2 + rdlen;
    6ac2:	9b05      	ldr	r3, [sp, #20]
    6ac4:	3302      	adds	r3, #2
    6ac6:	e7e2      	b.n	6a8e <ParseMDNSResourceRecord+0x3d2>
        AJ_ErrPrintf(("ParseMDNSResourceRecord(): Error occured while deserializing resource data"));
        return 0;
    }
    size += processed;
    return size;
}
    6ac8:	1c18      	adds	r0, r3, #0
    6aca:	b009      	add	sp, #36	; 0x24
    6acc:	bc3c      	pop	{r2, r3, r4, r5}
    6ace:	4690      	mov	r8, r2
    6ad0:	4699      	mov	r9, r3
    6ad2:	46a2      	mov	sl, r4
    6ad4:	46ab      	mov	fp, r5
    6ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ad8:	00016705 	.word	0x00016705
    6adc:	0001c170 	.word	0x0001c170
    6ae0:	0001671b 	.word	0x0001671b
    6ae4:	00016739 	.word	0x00016739
    6ae8:	0001c178 	.word	0x0001c178
    6aec:	0001c17c 	.word	0x0001c17c
    6af0:	0001715b 	.word	0x0001715b
    6af4:	0001c180 	.word	0x0001c180
    6af8:	00016e3d 	.word	0x00016e3d
    6afc:	0001bfcc 	.word	0x0001bfcc
    6b00:	0000636d 	.word	0x0000636d
    6b04:	0001c1ac 	.word	0x0001c1ac
    6b08:	00000343 	.word	0x00000343

00006b0c <ParseMDNSResp>:

static AJ_Status ParseMDNSResp(AJ_IOBuffer* rxBuf, const char* prefix, AJ_Service* service)
{
    6b0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b0e:	465f      	mov	r7, fp
    6b10:	4656      	mov	r6, sl
    6b12:	464d      	mov	r5, r9
    6b14:	4644      	mov	r4, r8
    6b16:	b4f0      	push	{r4, r5, r6, r7}
    6b18:	4cdc      	ldr	r4, [pc, #880]	; (6e8c <ParseMDNSResp+0x380>)
    6b1a:	44a5      	add	sp, r4
    6b1c:	9103      	str	r1, [sp, #12]
    6b1e:	1c14      	adds	r4, r2, #0
    uint8_t* buffer = (uint8_t*)rxBuf->readPtr;
    6b20:	6887      	ldr	r7, [r0, #8]
    uint32_t bufsize = AJ_IO_BUF_AVAIL(rxBuf);
    6b22:	68c3      	ldr	r3, [r0, #12]
    6b24:	1bdd      	subs	r5, r3, r7
    uint8_t bus_a_record = 0;
    uint16_t service_port_tcp = 0;
    uint16_t service_port_udp = 0;
    uint16_t service_priority = 0;
    uint32_t protocol_version;
    uint8_t bus_addr[3 * 4 + 3 + 1] = { 0 };
    6b26:	abff      	add	r3, sp, #1020	; 0x3fc
    6b28:	3350      	adds	r3, #80	; 0x50
    6b2a:	2600      	movs	r6, #0
    6b2c:	601e      	str	r6, [r3, #0]
    6b2e:	605e      	str	r6, [r3, #4]
    6b30:	609e      	str	r6, [r3, #8]
    6b32:	60de      	str	r6, [r3, #12]
    uint8_t service_target[256] = { 0 };
    6b34:	a8d3      	add	r0, sp, #844	; 0x34c
    6b36:	2100      	movs	r1, #0
    6b38:	2280      	movs	r2, #128	; 0x80
    6b3a:	0052      	lsls	r2, r2, #1
    6b3c:	4bd4      	ldr	r3, [pc, #848]	; (6e90 <ParseMDNSResp+0x384>)
    6b3e:	4798      	blx	r3
    MDNSResourceRecord r;

    memset(&header, 0, sizeof(MDNSHeader));
    6b40:	abff      	add	r3, sp, #1020	; 0x3fc
    6b42:	3360      	adds	r3, #96	; 0x60
    6b44:	601e      	str	r6, [r3, #0]
    6b46:	605e      	str	r6, [r3, #4]
    6b48:	609e      	str	r6, [r3, #8]
	//  -  
	printf("--------------Start mDNS parse ---------------\n");
    6b4a:	48d2      	ldr	r0, [pc, #840]	; (6e94 <ParseMDNSResp+0x388>)
    6b4c:	4bd2      	ldr	r3, [pc, #840]	; (6e98 <ParseMDNSResp+0x38c>)
    6b4e:	4798      	blx	r3
}

static size_t ParseMDNSHeader(uint8_t const* buffer, uint32_t bufsize, MDNSHeader* hdr)
{
    size_t size = 0;
    if (bufsize < 12) 
    6b50:	2d0b      	cmp	r5, #11
    6b52:	d80c      	bhi.n	6b6e <ParseMDNSResp+0x62>
	{
        AJ_ErrPrintf(("ParseMDNSHeader(): Insufficient bufsize %d\n", bufsize));
    6b54:	2001      	movs	r0, #1
    6b56:	49d1      	ldr	r1, [pc, #836]	; (6e9c <ParseMDNSResp+0x390>)
    6b58:	4ad1      	ldr	r2, [pc, #836]	; (6ea0 <ParseMDNSResp+0x394>)
    6b5a:	4bd2      	ldr	r3, [pc, #840]	; (6ea4 <ParseMDNSResp+0x398>)
    6b5c:	4798      	blx	r3
    6b5e:	2800      	cmp	r0, #0
    6b60:	d100      	bne.n	6b64 <ParseMDNSResp+0x58>
    6b62:	e2ae      	b.n	70c2 <ParseMDNSResp+0x5b6>
    6b64:	48d0      	ldr	r0, [pc, #832]	; (6ea8 <ParseMDNSResp+0x39c>)
    6b66:	1c29      	adds	r1, r5, #0
    6b68:	4bd0      	ldr	r3, [pc, #832]	; (6eac <ParseMDNSResp+0x3a0>)
    6b6a:	4798      	blx	r3
    6b6c:	e2a9      	b.n	70c2 <ParseMDNSResp+0x5b6>
        return 0;
    }
    // The first two octets are ID  
    hdr->queryId = (buffer[0] << 8) | buffer[1];
    6b6e:	aaff      	add	r2, sp, #1020	; 0x3fc
    6b70:	3260      	adds	r2, #96	; 0x60
    6b72:	783b      	ldrb	r3, [r7, #0]
    6b74:	021b      	lsls	r3, r3, #8
    6b76:	7879      	ldrb	r1, [r7, #1]
    6b78:	430b      	orrs	r3, r1
    6b7a:	8013      	strh	r3, [r2, #0]
    size += 2;
    // The next two octects are the flags
    hdr->qrType = (buffer[2] << 8) | buffer[3];
    6b7c:	78bb      	ldrb	r3, [r7, #2]
    6b7e:	021b      	lsls	r3, r3, #8
    6b80:	78f9      	ldrb	r1, [r7, #3]
    6b82:	430b      	orrs	r3, r1
    6b84:	8053      	strh	r3, [r2, #2]
    size += 2;
    // The next two octets are QDCOUNT
    hdr->qdCount = (buffer[4] << 8) | buffer[5];
    6b86:	7939      	ldrb	r1, [r7, #4]
    6b88:	0209      	lsls	r1, r1, #8
    6b8a:	7978      	ldrb	r0, [r7, #5]
    6b8c:	4301      	orrs	r1, r0
    6b8e:	8091      	strh	r1, [r2, #4]
    size += 2;

    // The next two octets are ANCOUNT
    hdr->anCount = (buffer[6] << 8) | buffer[7];
    6b90:	79b9      	ldrb	r1, [r7, #6]
    6b92:	0209      	lsls	r1, r1, #8
    6b94:	79f8      	ldrb	r0, [r7, #7]
    6b96:	4301      	orrs	r1, r0
    6b98:	80d1      	strh	r1, [r2, #6]
    size += 2;

    // The next two octets are NSCOUNT
    hdr->m_nsCount = (buffer[8] << 8) | buffer[9];
    6b9a:	7a39      	ldrb	r1, [r7, #8]
    6b9c:	0209      	lsls	r1, r1, #8
    6b9e:	7a78      	ldrb	r0, [r7, #9]
    6ba0:	4301      	orrs	r1, r0
    6ba2:	8111      	strh	r1, [r2, #8]
    size += 2;

    // The next two octets are ARCOUNT
    hdr->arCount = (buffer[10] << 8) | buffer[11];
    6ba4:	7ab9      	ldrb	r1, [r7, #10]
    6ba6:	0209      	lsls	r1, r1, #8
    6ba8:	7af8      	ldrb	r0, [r7, #11]
    6baa:	4308      	orrs	r0, r1
    6bac:	1c06      	adds	r6, r0, #0
    6bae:	8150      	strh	r0, [r2, #10]
    }
	else
	{
        AJ_InfoPrintf(("Successfully parsed header with %d answers and %d additional\n", header.anCount, header.arCount));
    }
    if ((header.qrType & MDNS_QR) == 0)
    6bb0:	b21b      	sxth	r3, r3
	{
        return AJ_ERR_NO_MATCH;
    6bb2:	2010      	movs	r0, #16
    }
	else
	{
        AJ_InfoPrintf(("Successfully parsed header with %d answers and %d additional\n", header.anCount, header.arCount));
    }
    if ((header.qrType & MDNS_QR) == 0)
    6bb4:	2b00      	cmp	r3, #0
    6bb6:	db00      	blt.n	6bba <ParseMDNSResp+0xae>
    6bb8:	e2a7      	b.n	710a <ParseMDNSResp+0x5fe>
    6bba:	e004      	b.n	6bc6 <ParseMDNSResp+0xba>
	//  -  
	printf("--------------Start mDNS parse ---------------\n");
    size = ParseMDNSHeader(buffer, bufsize, &header);
    if (size == 0) 
	{
        AJ_ErrPrintf(("Error occured while deserializing header\n"));
    6bbc:	48bc      	ldr	r0, [pc, #752]	; (6eb0 <ParseMDNSResp+0x3a4>)
    6bbe:	4bb6      	ldr	r3, [pc, #728]	; (6e98 <ParseMDNSResp+0x38c>)
    6bc0:	4798      	blx	r3
        return AJ_ERR_NO_MATCH;
    6bc2:	2010      	movs	r0, #16
    6bc4:	e2a1      	b.n	710a <ParseMDNSResp+0x5fe>
    }
    if ((header.qrType & MDNS_QR) == 0)
	{
        return AJ_ERR_NO_MATCH;
    }
    if (!header.anCount || !header.arCount)
    6bc6:	abff      	add	r3, sp, #1020	; 0x3fc
    6bc8:	3360      	adds	r3, #96	; 0x60
    6bca:	88db      	ldrh	r3, [r3, #6]
    6bcc:	4699      	mov	r9, r3
	{
        return AJ_ERR_NO_MATCH;
    6bce:	2010      	movs	r0, #16
    }
    if ((header.qrType & MDNS_QR) == 0)
	{
        return AJ_ERR_NO_MATCH;
    }
    if (!header.anCount || !header.arCount)
    6bd0:	2b00      	cmp	r3, #0
    6bd2:	d100      	bne.n	6bd6 <ParseMDNSResp+0xca>
    6bd4:	e299      	b.n	710a <ParseMDNSResp+0x5fe>
    6bd6:	2e00      	cmp	r6, #0
    6bd8:	d100      	bne.n	6bdc <ParseMDNSResp+0xd0>
    6bda:	e296      	b.n	710a <ParseMDNSResp+0x5fe>
	{
        return AJ_ERR_NO_MATCH;
    }
    if (size >= bufsize) 
    6bdc:	2d0c      	cmp	r5, #12
    6bde:	d800      	bhi.n	6be2 <ParseMDNSResp+0xd6>
    6be0:	e293      	b.n	710a <ParseMDNSResp+0x5fe>
	{
        return AJ_ERR_NO_MATCH;
    }
    bufsize -= size;
    6be2:	230c      	movs	r3, #12
    6be4:	425b      	negs	r3, r3
    6be6:	4698      	mov	r8, r3
    6be8:	44a8      	add	r8, r5
    p = &buffer[size];
    6bea:	3318      	adds	r3, #24
    6bec:	469a      	mov	sl, r3
    6bee:	44ba      	add	sl, r7

    for (i = 0; i < header.qdCount; i++) 
    6bf0:	abff      	add	r3, sp, #1020	; 0x3fc
    6bf2:	3360      	adds	r3, #96	; 0x60
    6bf4:	889b      	ldrh	r3, [r3, #4]
    6bf6:	2b00      	cmp	r3, #0
    6bf8:	dd32      	ble.n	6c60 <ParseMDNSResp+0x154>
    6bfa:	2300      	movs	r3, #0
            return AJ_ERR_NO_MATCH;
        }
        size += ret;
        bufsize -= ret;
        p += ret;
        printf("Skipping unexpected question in response, will be silently ignored.\n");
    6bfc:	9704      	str	r7, [sp, #16]
    6bfe:	1c1f      	adds	r7, r3, #0
    6c00:	46ab      	mov	fp, r5
    6c02:	4655      	mov	r5, sl
    6c04:	9405      	str	r4, [sp, #20]
    6c06:	4644      	mov	r4, r8
    6c08:	46b2      	mov	sl, r6
    bufsize -= size;
    p = &buffer[size];

    for (i = 0; i < header.qdCount; i++) 
	{
        memset(&r, 0, sizeof(MDNSResourceRecord));
    6c0a:	a80f      	add	r0, sp, #60	; 0x3c
    6c0c:	2100      	movs	r1, #0
    6c0e:	22c4      	movs	r2, #196	; 0xc4
    6c10:	0092      	lsls	r2, r2, #2
    6c12:	4b9f      	ldr	r3, [pc, #636]	; (6e90 <ParseMDNSResp+0x384>)
    6c14:	4798      	blx	r3
        ret = ParseMDNSResourceRecord(p, bufsize, &r, buffer, paylen, NULL);
    6c16:	465b      	mov	r3, fp
    6c18:	9300      	str	r3, [sp, #0]
    6c1a:	2300      	movs	r3, #0
    6c1c:	9301      	str	r3, [sp, #4]
    6c1e:	1c28      	adds	r0, r5, #0
    6c20:	1c21      	adds	r1, r4, #0
    6c22:	aa0f      	add	r2, sp, #60	; 0x3c
    6c24:	9b04      	ldr	r3, [sp, #16]
    6c26:	4ea3      	ldr	r6, [pc, #652]	; (6eb4 <ParseMDNSResp+0x3a8>)
    6c28:	47b0      	blx	r6
        if (ret == 0 || ret > bufsize) 
    6c2a:	2800      	cmp	r0, #0
    6c2c:	d001      	beq.n	6c32 <ParseMDNSResp+0x126>
    6c2e:	42a0      	cmp	r0, r4
    6c30:	d904      	bls.n	6c3c <ParseMDNSResp+0x130>
		{
            printf("Error while deserializing question record.\n");
    6c32:	48a1      	ldr	r0, [pc, #644]	; (6eb8 <ParseMDNSResp+0x3ac>)
    6c34:	4b98      	ldr	r3, [pc, #608]	; (6e98 <ParseMDNSResp+0x38c>)
    6c36:	4798      	blx	r3
            return AJ_ERR_NO_MATCH;
    6c38:	2010      	movs	r0, #16
    6c3a:	e266      	b.n	710a <ParseMDNSResp+0x5fe>
        }
        size += ret;
        bufsize -= ret;
    6c3c:	1a24      	subs	r4, r4, r0
        p += ret;
    6c3e:	182d      	adds	r5, r5, r0
        printf("Skipping unexpected question in response, will be silently ignored.\n");
    6c40:	489e      	ldr	r0, [pc, #632]	; (6ebc <ParseMDNSResp+0x3b0>)
    6c42:	4b95      	ldr	r3, [pc, #596]	; (6e98 <ParseMDNSResp+0x38c>)
    6c44:	4798      	blx	r3
        return AJ_ERR_NO_MATCH;
    }
    bufsize -= size;
    p = &buffer[size];

    for (i = 0; i < header.qdCount; i++) 
    6c46:	3701      	adds	r7, #1
    6c48:	abff      	add	r3, sp, #1020	; 0x3fc
    6c4a:	3360      	adds	r3, #96	; 0x60
    6c4c:	889b      	ldrh	r3, [r3, #4]
    6c4e:	42bb      	cmp	r3, r7
    6c50:	dcdb      	bgt.n	6c0a <ParseMDNSResp+0xfe>
    6c52:	9f04      	ldr	r7, [sp, #16]
    6c54:	46a0      	mov	r8, r4
    6c56:	4653      	mov	r3, sl
    6c58:	46aa      	mov	sl, r5
    6c5a:	465d      	mov	r5, fp
    6c5c:	9c05      	ldr	r4, [sp, #20]
    6c5e:	1c1e      	adds	r6, r3, #0
        }

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._udp.local", 19))
		{
          printf("Found _alljoyn_._udp.local PTR record.\n");
            alljoyn_ptr_record_udp = 1;
    6c60:	2300      	movs	r3, #0
    6c62:	9307      	str	r3, [sp, #28]
    6c64:	9306      	str	r3, [sp, #24]
    6c66:	9305      	str	r3, [sp, #20]
    6c68:	930a      	str	r3, [sp, #40]	; 0x28
    6c6a:	9309      	str	r3, [sp, #36]	; 0x24
    6c6c:	469b      	mov	fp, r3
    6c6e:	9704      	str	r7, [sp, #16]
    6c70:	4643      	mov	r3, r8
    6c72:	46a8      	mov	r8, r5
    6c74:	1c32      	adds	r2, r6, #0
    6c76:	4656      	mov	r6, sl
    6c78:	940b      	str	r4, [sp, #44]	; 0x2c
    6c7a:	465c      	mov	r4, fp
    6c7c:	4692      	mov	sl, r2
    6c7e:	1c1d      	adds	r5, r3, #0
    6c80:	e0ae      	b.n	6de0 <ParseMDNSResp+0x2d4>
        p += ret;
        printf("Skipping unexpected question in response, will be silently ignored.\n");
    }
    for (i = 0; i < header.anCount; i++) 
	{
        memset(&r, 0, sizeof(MDNSResourceRecord));
    6c82:	a80f      	add	r0, sp, #60	; 0x3c
    6c84:	2100      	movs	r1, #0
    6c86:	22c4      	movs	r2, #196	; 0xc4
    6c88:	0092      	lsls	r2, r2, #2
    6c8a:	4b81      	ldr	r3, [pc, #516]	; (6e90 <ParseMDNSResp+0x384>)
    6c8c:	4798      	blx	r3
        ret = ParseMDNSResourceRecord(p, bufsize, &r, buffer, paylen, NULL);
    6c8e:	4643      	mov	r3, r8
    6c90:	9300      	str	r3, [sp, #0]
    6c92:	2300      	movs	r3, #0
    6c94:	9301      	str	r3, [sp, #4]
    6c96:	1c30      	adds	r0, r6, #0
    6c98:	1c29      	adds	r1, r5, #0
    6c9a:	aa0f      	add	r2, sp, #60	; 0x3c
    6c9c:	9b04      	ldr	r3, [sp, #16]
    6c9e:	4f85      	ldr	r7, [pc, #532]	; (6eb4 <ParseMDNSResp+0x3a8>)
    6ca0:	47b8      	blx	r7
        if (ret == 0 || ret > bufsize) 
    6ca2:	2800      	cmp	r0, #0
    6ca4:	d001      	beq.n	6caa <ParseMDNSResp+0x19e>
    6ca6:	4285      	cmp	r5, r0
    6ca8:	d204      	bcs.n	6cb4 <ParseMDNSResp+0x1a8>
		{
            printf("Error while deserializing answer record.\n");
    6caa:	4885      	ldr	r0, [pc, #532]	; (6ec0 <ParseMDNSResp+0x3b4>)
    6cac:	4b7a      	ldr	r3, [pc, #488]	; (6e98 <ParseMDNSResp+0x38c>)
    6cae:	4798      	blx	r3
            return AJ_ERR_NO_MATCH;
    6cb0:	2010      	movs	r0, #16
    6cb2:	e22a      	b.n	710a <ParseMDNSResp+0x5fe>
        }
        size += ret;
        bufsize -= ret;
    6cb4:	1a2d      	subs	r5, r5, r0
        p += ret;
    6cb6:	1836      	adds	r6, r6, r0
      printf("Processed answer %d\n", (i + 1));
    6cb8:	3401      	adds	r4, #1
    6cba:	4882      	ldr	r0, [pc, #520]	; (6ec4 <ParseMDNSResp+0x3b8>)
    6cbc:	1c21      	adds	r1, r4, #0
    6cbe:	4b7b      	ldr	r3, [pc, #492]	; (6eac <ParseMDNSResp+0x3a0>)
    6cc0:	4798      	blx	r3

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._tcp.local", 19))
    6cc2:	2380      	movs	r3, #128	; 0x80
    6cc4:	005b      	lsls	r3, r3, #1
    6cc6:	aa0f      	add	r2, sp, #60	; 0x3c
    6cc8:	5cd3      	ldrb	r3, [r2, r3]
    6cca:	2b0c      	cmp	r3, #12
    6ccc:	d119      	bne.n	6d02 <ParseMDNSResp+0x1f6>
    6cce:	1c10      	adds	r0, r2, #0
    6cd0:	497d      	ldr	r1, [pc, #500]	; (6ec8 <ParseMDNSResp+0x3bc>)
    6cd2:	2213      	movs	r2, #19
    6cd4:	4b7d      	ldr	r3, [pc, #500]	; (6ecc <ParseMDNSResp+0x3c0>)
    6cd6:	4798      	blx	r3
    6cd8:	2800      	cmp	r0, #0
    6cda:	d000      	beq.n	6cde <ParseMDNSResp+0x1d2>
    6cdc:	e204      	b.n	70e8 <ParseMDNSResp+0x5dc>
		{
         printf("Found _alljoyn_.tcp.local PTR record.\n");
    6cde:	487c      	ldr	r0, [pc, #496]	; (6ed0 <ParseMDNSResp+0x3c4>)
    6ce0:	4b6d      	ldr	r3, [pc, #436]	; (6e98 <ParseMDNSResp+0x38c>)
    6ce2:	4798      	blx	r3
            alljoyn_ptr_record_tcp = 1;
        }

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._udp.local", 19))
    6ce4:	2380      	movs	r3, #128	; 0x80
    6ce6:	005b      	lsls	r3, r3, #1
    6ce8:	aa0f      	add	r2, sp, #60	; 0x3c
    6cea:	5cd3      	ldrb	r3, [r2, r3]
      printf("Processed answer %d\n", (i + 1));

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._tcp.local", 19))
		{
         printf("Found _alljoyn_.tcp.local PTR record.\n");
            alljoyn_ptr_record_tcp = 1;
    6cec:	2201      	movs	r2, #1
    6cee:	9209      	str	r2, [sp, #36]	; 0x24
        }

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._udp.local", 19))
    6cf0:	2b0c      	cmp	r3, #12
    6cf2:	d100      	bne.n	6cf6 <ParseMDNSResp+0x1ea>
    6cf4:	e1f8      	b.n	70e8 <ParseMDNSResp+0x5dc>
    6cf6:	e004      	b.n	6d02 <ParseMDNSResp+0x1f6>
		{
          printf("Found _alljoyn_._udp.local PTR record.\n");
    6cf8:	4876      	ldr	r0, [pc, #472]	; (6ed4 <ParseMDNSResp+0x3c8>)
    6cfa:	4b67      	ldr	r3, [pc, #412]	; (6e98 <ParseMDNSResp+0x38c>)
    6cfc:	4798      	blx	r3
            alljoyn_ptr_record_udp = 1;
    6cfe:	2301      	movs	r3, #1
    6d00:	930a      	str	r3, [sp, #40]	; 0x28
        }

        // We ignore the sender's "guid." (32 chars + 1 char for the dot) in the <guid>._alljoyn._tcp.local domain name.
        if (r.rrType == SRV && !memcmp(r.rrDomainName.name + 33, "_alljoyn._tcp.local", 19)) 
    6d02:	2380      	movs	r3, #128	; 0x80
    6d04:	005b      	lsls	r3, r3, #1
    6d06:	aa0f      	add	r2, sp, #60	; 0x3c
    6d08:	5cd3      	ldrb	r3, [r2, r3]
    6d0a:	2b21      	cmp	r3, #33	; 0x21
    6d0c:	d168      	bne.n	6de0 <ParseMDNSResp+0x2d4>
    6d0e:	202d      	movs	r0, #45	; 0x2d
    6d10:	ab0c      	add	r3, sp, #48	; 0x30
    6d12:	469c      	mov	ip, r3
    6d14:	4460      	add	r0, ip
    6d16:	496c      	ldr	r1, [pc, #432]	; (6ec8 <ParseMDNSResp+0x3bc>)
    6d18:	2213      	movs	r2, #19
    6d1a:	4b6c      	ldr	r3, [pc, #432]	; (6ecc <ParseMDNSResp+0x3c0>)
    6d1c:	4798      	blx	r3
    6d1e:	2800      	cmp	r0, #0
    6d20:	d12d      	bne.n	6d7e <ParseMDNSResp+0x272>
		{
       printf("Found a SRV answer with domain name  %s.\n", r.rdata.srvRData.target.name);
    6d22:	486d      	ldr	r0, [pc, #436]	; (6ed8 <ParseMDNSResp+0x3cc>)
    6d24:	238d      	movs	r3, #141	; 0x8d
    6d26:	005b      	lsls	r3, r3, #1
    6d28:	aa0c      	add	r2, sp, #48	; 0x30
    6d2a:	4694      	mov	ip, r2
    6d2c:	4463      	add	r3, ip
    6d2e:	1c19      	adds	r1, r3, #0
    6d30:	4b5e      	ldr	r3, [pc, #376]	; (6eac <ParseMDNSResp+0x3a0>)
    6d32:	4798      	blx	r3
            memset(service_target, 0, 256);
    6d34:	a8d3      	add	r0, sp, #844	; 0x34c
    6d36:	2100      	movs	r1, #0
    6d38:	2280      	movs	r2, #128	; 0x80
    6d3a:	0052      	lsls	r2, r2, #1
    6d3c:	4b54      	ldr	r3, [pc, #336]	; (6e90 <ParseMDNSResp+0x384>)
    6d3e:	4798      	blx	r3
            memcpy(service_target, r.rdata.srvRData.target.name, 256);
    6d40:	a8d3      	add	r0, sp, #844	; 0x34c
    6d42:	238d      	movs	r3, #141	; 0x8d
    6d44:	005b      	lsls	r3, r3, #1
    6d46:	aa0c      	add	r2, sp, #48	; 0x30
    6d48:	4694      	mov	ip, r2
    6d4a:	4463      	add	r3, ip
    6d4c:	1c19      	adds	r1, r3, #0
    6d4e:	2280      	movs	r2, #128	; 0x80
    6d50:	0052      	lsls	r2, r2, #1
    6d52:	4b62      	ldr	r3, [pc, #392]	; (6edc <ParseMDNSResp+0x3d0>)
    6d54:	4798      	blx	r3
            service_port_tcp = (r.rdata.srvRData.port);
    6d56:	2386      	movs	r3, #134	; 0x86
    6d58:	005b      	lsls	r3, r3, #1
    6d5a:	aa0c      	add	r2, sp, #48	; 0x30
    6d5c:	210c      	movs	r1, #12
    6d5e:	1852      	adds	r2, r2, r1
    6d60:	5ad3      	ldrh	r3, [r2, r3]
    6d62:	9305      	str	r3, [sp, #20]
            service_priority = r.rdata.srvRData.priority;
    6d64:	2384      	movs	r3, #132	; 0x84
    6d66:	005b      	lsls	r3, r3, #1
    6d68:	aa0c      	add	r2, sp, #48	; 0x30
    6d6a:	1852      	adds	r2, r2, r1
    6d6c:	5ad3      	ldrh	r3, [r2, r3]
    6d6e:	9307      	str	r3, [sp, #28]
        }

        // We ignore the sender's "guid." (32 chars + 1 char for the dot) in the <guid>._alljoyn._udp.local domain name.
        if (r.rrType == SRV && !memcmp(r.rrDomainName.name + 33, "_alljoyn._udp.local", 19))
    6d70:	ab0c      	add	r3, sp, #48	; 0x30
    6d72:	2280      	movs	r2, #128	; 0x80
    6d74:	0052      	lsls	r2, r2, #1
    6d76:	185b      	adds	r3, r3, r1
    6d78:	5c9b      	ldrb	r3, [r3, r2]
    6d7a:	2b21      	cmp	r3, #33	; 0x21
    6d7c:	d130      	bne.n	6de0 <ParseMDNSResp+0x2d4>
    6d7e:	202d      	movs	r0, #45	; 0x2d
    6d80:	ab0c      	add	r3, sp, #48	; 0x30
    6d82:	469c      	mov	ip, r3
    6d84:	4460      	add	r0, ip
    6d86:	4956      	ldr	r1, [pc, #344]	; (6ee0 <ParseMDNSResp+0x3d4>)
    6d88:	2213      	movs	r2, #19
    6d8a:	4b50      	ldr	r3, [pc, #320]	; (6ecc <ParseMDNSResp+0x3c0>)
    6d8c:	4798      	blx	r3
    6d8e:	2800      	cmp	r0, #0
    6d90:	d126      	bne.n	6de0 <ParseMDNSResp+0x2d4>
		{
           printf("Found a SRV answer with domain name  %s.\n", r.rdata.srvRData.target.name);
    6d92:	4851      	ldr	r0, [pc, #324]	; (6ed8 <ParseMDNSResp+0x3cc>)
    6d94:	238d      	movs	r3, #141	; 0x8d
    6d96:	005b      	lsls	r3, r3, #1
    6d98:	aa0c      	add	r2, sp, #48	; 0x30
    6d9a:	4694      	mov	ip, r2
    6d9c:	4463      	add	r3, ip
    6d9e:	1c19      	adds	r1, r3, #0
    6da0:	4b42      	ldr	r3, [pc, #264]	; (6eac <ParseMDNSResp+0x3a0>)
    6da2:	4798      	blx	r3
            memset(service_target, 0, 256);
    6da4:	a8d3      	add	r0, sp, #844	; 0x34c
    6da6:	2100      	movs	r1, #0
    6da8:	2280      	movs	r2, #128	; 0x80
    6daa:	0052      	lsls	r2, r2, #1
    6dac:	4b38      	ldr	r3, [pc, #224]	; (6e90 <ParseMDNSResp+0x384>)
    6dae:	4798      	blx	r3
            memcpy(service_target, r.rdata.srvRData.target.name, 256);
    6db0:	a8d3      	add	r0, sp, #844	; 0x34c
    6db2:	238d      	movs	r3, #141	; 0x8d
    6db4:	005b      	lsls	r3, r3, #1
    6db6:	aa0c      	add	r2, sp, #48	; 0x30
    6db8:	4694      	mov	ip, r2
    6dba:	4463      	add	r3, ip
    6dbc:	1c19      	adds	r1, r3, #0
    6dbe:	2280      	movs	r2, #128	; 0x80
    6dc0:	0052      	lsls	r2, r2, #1
    6dc2:	4b46      	ldr	r3, [pc, #280]	; (6edc <ParseMDNSResp+0x3d0>)
    6dc4:	4798      	blx	r3
            service_port_udp = r.rdata.srvRData.port;
    6dc6:	2386      	movs	r3, #134	; 0x86
    6dc8:	005b      	lsls	r3, r3, #1
    6dca:	aa0c      	add	r2, sp, #48	; 0x30
    6dcc:	210c      	movs	r1, #12
    6dce:	1852      	adds	r2, r2, r1
    6dd0:	5ad3      	ldrh	r3, [r2, r3]
    6dd2:	9306      	str	r3, [sp, #24]
            service_priority = r.rdata.srvRData.priority;
    6dd4:	2384      	movs	r3, #132	; 0x84
    6dd6:	005b      	lsls	r3, r3, #1
    6dd8:	aa0c      	add	r2, sp, #48	; 0x30
    6dda:	1852      	adds	r2, r2, r1
    6ddc:	5ad3      	ldrh	r3, [r2, r3]
    6dde:	9307      	str	r3, [sp, #28]
        size += ret;
        bufsize -= ret;
        p += ret;
        printf("Skipping unexpected question in response, will be silently ignored.\n");
    }
    for (i = 0; i < header.anCount; i++) 
    6de0:	454c      	cmp	r4, r9
    6de2:	da00      	bge.n	6de6 <ParseMDNSResp+0x2da>
    6de4:	e74d      	b.n	6c82 <ParseMDNSResp+0x176>
    6de6:	9f04      	ldr	r7, [sp, #16]
    6de8:	1c2a      	adds	r2, r5, #0
    6dea:	4645      	mov	r5, r8
    6dec:	4653      	mov	r3, sl
    6dee:	46b2      	mov	sl, r6
    6df0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    6df2:	1c1e      	adds	r6, r3, #0
    6df4:	4690      	mov	r8, r2

    // PTR record must be parsed and service port should be non-zero
    // to continue with the parsing. Zero is an invalid service port.
    if ((!alljoyn_ptr_record_tcp && !alljoyn_ptr_record_udp) || (!service_port_tcp && !service_port_udp))
	{
        return AJ_ERR_NO_MATCH;
    6df6:	2010      	movs	r0, #16
        }
    }

    // PTR record must be parsed and service port should be non-zero
    // to continue with the parsing. Zero is an invalid service port.
    if ((!alljoyn_ptr_record_tcp && !alljoyn_ptr_record_udp) || (!service_port_tcp && !service_port_udp))
    6df8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6dfa:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6dfc:	4313      	orrs	r3, r2
    6dfe:	d100      	bne.n	6e02 <ParseMDNSResp+0x2f6>
    6e00:	e183      	b.n	710a <ParseMDNSResp+0x5fe>
    6e02:	9b06      	ldr	r3, [sp, #24]
    6e04:	9a05      	ldr	r2, [sp, #20]
    6e06:	4313      	orrs	r3, r2
    6e08:	d100      	bne.n	6e0c <ParseMDNSResp+0x300>
    6e0a:	e17e      	b.n	710a <ParseMDNSResp+0x5fe>
    6e0c:	2300      	movs	r3, #0
    6e0e:	469b      	mov	fp, r3
        return AJ_ERR_NO_MATCH;
    }

    for (i = 0; i < header.m_nsCount; i++) 
	{
        memset(&r, 0, sizeof(MDNSResourceRecord));
    6e10:	4699      	mov	r9, r3
    6e12:	1c23      	adds	r3, r4, #0
    6e14:	4644      	mov	r4, r8
    6e16:	46a8      	mov	r8, r5
    6e18:	9304      	str	r3, [sp, #16]
    6e1a:	e020      	b.n	6e5e <ParseMDNSResp+0x352>
    6e1c:	a80f      	add	r0, sp, #60	; 0x3c
    6e1e:	4649      	mov	r1, r9
    6e20:	22c4      	movs	r2, #196	; 0xc4
    6e22:	0092      	lsls	r2, r2, #2
    6e24:	4b1a      	ldr	r3, [pc, #104]	; (6e90 <ParseMDNSResp+0x384>)
    6e26:	4798      	blx	r3
        ret = ParseMDNSResourceRecord(p, bufsize, &r, buffer, paylen, NULL);
    6e28:	4643      	mov	r3, r8
    6e2a:	9300      	str	r3, [sp, #0]
    6e2c:	464b      	mov	r3, r9
    6e2e:	9301      	str	r3, [sp, #4]
    6e30:	4650      	mov	r0, sl
    6e32:	1c21      	adds	r1, r4, #0
    6e34:	aa0f      	add	r2, sp, #60	; 0x3c
    6e36:	1c3b      	adds	r3, r7, #0
    6e38:	4d1e      	ldr	r5, [pc, #120]	; (6eb4 <ParseMDNSResp+0x3a8>)
    6e3a:	47a8      	blx	r5
        if (ret == 0 || ret > bufsize)
    6e3c:	2800      	cmp	r0, #0
    6e3e:	d001      	beq.n	6e44 <ParseMDNSResp+0x338>
    6e40:	4284      	cmp	r4, r0
    6e42:	d204      	bcs.n	6e4e <ParseMDNSResp+0x342>
		{
            printf("Error while deserializing authority record.\n");
    6e44:	4827      	ldr	r0, [pc, #156]	; (6ee4 <ParseMDNSResp+0x3d8>)
    6e46:	4b14      	ldr	r3, [pc, #80]	; (6e98 <ParseMDNSResp+0x38c>)
    6e48:	4798      	blx	r3
            return AJ_ERR_NO_MATCH;
    6e4a:	2010      	movs	r0, #16
    6e4c:	e15d      	b.n	710a <ParseMDNSResp+0x5fe>
        }
        size += ret;
        bufsize -= ret;
    6e4e:	1a24      	subs	r4, r4, r0
        p += ret;
    6e50:	4482      	add	sl, r0
     printf("Skipping non-relevant authority record, will be silently ignored.\n");
    6e52:	4825      	ldr	r0, [pc, #148]	; (6ee8 <ParseMDNSResp+0x3dc>)
    6e54:	4b10      	ldr	r3, [pc, #64]	; (6e98 <ParseMDNSResp+0x38c>)
    6e56:	4798      	blx	r3
    if ((!alljoyn_ptr_record_tcp && !alljoyn_ptr_record_udp) || (!service_port_tcp && !service_port_udp))
	{
        return AJ_ERR_NO_MATCH;
    }

    for (i = 0; i < header.m_nsCount; i++) 
    6e58:	2301      	movs	r3, #1
    6e5a:	469c      	mov	ip, r3
    6e5c:	44e3      	add	fp, ip
    6e5e:	abff      	add	r3, sp, #1020	; 0x3fc
    6e60:	3360      	adds	r3, #96	; 0x60
    6e62:	891b      	ldrh	r3, [r3, #8]
    6e64:	459b      	cmp	fp, r3
    6e66:	dbd9      	blt.n	6e1c <ParseMDNSResp+0x310>
    6e68:	9b04      	ldr	r3, [sp, #16]
    6e6a:	4645      	mov	r5, r8
    6e6c:	46a0      	mov	r8, r4
    6e6e:	1c1c      	adds	r4, r3, #0
    6e70:	2300      	movs	r3, #0
    6e72:	930d      	str	r3, [sp, #52]	; 0x34
    6e74:	930b      	str	r3, [sp, #44]	; 0x2c
    6e76:	930c      	str	r3, [sp, #48]	; 0x30
    6e78:	9304      	str	r3, [sp, #16]
        }
        size += ret;
        bufsize -= ret;
        p += ret;
        printf("Processing additional record %d\n", (i + 1));
        if (r.rrType == TXT) 
    6e7a:	3301      	adds	r3, #1
    6e7c:	33ff      	adds	r3, #255	; 0xff
    6e7e:	469b      	mov	fp, r3
    6e80:	4643      	mov	r3, r8
    6e82:	46a8      	mov	r8, r5
    6e84:	46b1      	mov	r9, r6
    6e86:	1c26      	adds	r6, r4, #0
    6e88:	1c1d      	adds	r5, r3, #0
    6e8a:	e0d0      	b.n	702e <ParseMDNSResp+0x522>
    6e8c:	fffffb94 	.word	0xfffffb94
    6e90:	00016773 	.word	0x00016773
    6e94:	0001c1f8 	.word	0x0001c1f8
    6e98:	00016f5d 	.word	0x00016f5d
    6e9c:	0001bfcc 	.word	0x0001bfcc
    6ea0:	0000026b 	.word	0x0000026b
    6ea4:	0000636d 	.word	0x0000636d
    6ea8:	0001c228 	.word	0x0001c228
    6eac:	00016e3d 	.word	0x00016e3d
    6eb0:	0001c254 	.word	0x0001c254
    6eb4:	000066bd 	.word	0x000066bd
    6eb8:	0001c280 	.word	0x0001c280
    6ebc:	0001c2ac 	.word	0x0001c2ac
    6ec0:	0001c2f0 	.word	0x0001c2f0
    6ec4:	0001c31c 	.word	0x0001c31c
    6ec8:	0001c334 	.word	0x0001c334
    6ecc:	0001671b 	.word	0x0001671b
    6ed0:	0001c348 	.word	0x0001c348
    6ed4:	0001c370 	.word	0x0001c370
    6ed8:	0001c398 	.word	0x0001c398
    6edc:	00016739 	.word	0x00016739
    6ee0:	0001c3c4 	.word	0x0001c3c4
    6ee4:	0001c3d8 	.word	0x0001c3d8
    6ee8:	0001c404 	.word	0x0001c404
        p += ret;
     printf("Skipping non-relevant authority record, will be silently ignored.\n");
    }
    for (i = 0; i < header.arCount; i++)
	{
        memset(&r, 0, sizeof(MDNSResourceRecord));
    6eec:	a80f      	add	r0, sp, #60	; 0x3c
    6eee:	2100      	movs	r1, #0
    6ef0:	22c4      	movs	r2, #196	; 0xc4
    6ef2:	0092      	lsls	r2, r2, #2
    6ef4:	4b89      	ldr	r3, [pc, #548]	; (711c <ParseMDNSResp+0x610>)
    6ef6:	4798      	blx	r3
        ret = ParseMDNSResourceRecord(p, bufsize, &r, buffer, paylen, prefix);
    6ef8:	4643      	mov	r3, r8
    6efa:	9300      	str	r3, [sp, #0]
    6efc:	9b03      	ldr	r3, [sp, #12]
    6efe:	9301      	str	r3, [sp, #4]
    6f00:	4650      	mov	r0, sl
    6f02:	1c29      	adds	r1, r5, #0
    6f04:	aa0f      	add	r2, sp, #60	; 0x3c
    6f06:	1c3b      	adds	r3, r7, #0
    6f08:	4c85      	ldr	r4, [pc, #532]	; (7120 <ParseMDNSResp+0x614>)
    6f0a:	47a0      	blx	r4
        if (ret == 0 || ret > bufsize)
    6f0c:	2800      	cmp	r0, #0
    6f0e:	d001      	beq.n	6f14 <ParseMDNSResp+0x408>
    6f10:	4285      	cmp	r5, r0
    6f12:	d20e      	bcs.n	6f32 <ParseMDNSResp+0x426>
		{
            AJ_ErrPrintf(("Error while deserializing additional record.\n"));
    6f14:	2001      	movs	r0, #1
    6f16:	4983      	ldr	r1, [pc, #524]	; (7124 <ParseMDNSResp+0x618>)
    6f18:	4a83      	ldr	r2, [pc, #524]	; (7128 <ParseMDNSResp+0x61c>)
    6f1a:	4b84      	ldr	r3, [pc, #528]	; (712c <ParseMDNSResp+0x620>)
    6f1c:	4798      	blx	r3
    6f1e:	1c03      	adds	r3, r0, #0
            return AJ_ERR_NO_MATCH;
    6f20:	2010      	movs	r0, #16
	{
        memset(&r, 0, sizeof(MDNSResourceRecord));
        ret = ParseMDNSResourceRecord(p, bufsize, &r, buffer, paylen, prefix);
        if (ret == 0 || ret > bufsize)
		{
            AJ_ErrPrintf(("Error while deserializing additional record.\n"));
    6f22:	2b00      	cmp	r3, #0
    6f24:	d100      	bne.n	6f28 <ParseMDNSResp+0x41c>
    6f26:	e0f0      	b.n	710a <ParseMDNSResp+0x5fe>
    6f28:	4881      	ldr	r0, [pc, #516]	; (7130 <ParseMDNSResp+0x624>)
    6f2a:	4b82      	ldr	r3, [pc, #520]	; (7134 <ParseMDNSResp+0x628>)
    6f2c:	4798      	blx	r3
            return AJ_ERR_NO_MATCH;
    6f2e:	2010      	movs	r0, #16
    6f30:	e0eb      	b.n	710a <ParseMDNSResp+0x5fe>
        }
        size += ret;
        bufsize -= ret;
    6f32:	1a2d      	subs	r5, r5, r0
        p += ret;
    6f34:	4482      	add	sl, r0
        printf("Processing additional record %d\n", (i + 1));
    6f36:	9b04      	ldr	r3, [sp, #16]
    6f38:	3301      	adds	r3, #1
    6f3a:	9304      	str	r3, [sp, #16]
    6f3c:	487e      	ldr	r0, [pc, #504]	; (7138 <ParseMDNSResp+0x62c>)
    6f3e:	1c19      	adds	r1, r3, #0
    6f40:	4b7e      	ldr	r3, [pc, #504]	; (713c <ParseMDNSResp+0x630>)
    6f42:	4798      	blx	r3
        if (r.rrType == TXT) 
    6f44:	ab0f      	add	r3, sp, #60	; 0x3c
    6f46:	465a      	mov	r2, fp
    6f48:	5c9b      	ldrb	r3, [r3, r2]
    6f4a:	2b10      	cmp	r3, #16
    6f4c:	d151      	bne.n	6ff2 <ParseMDNSResp+0x4e6>
		{
            // Ensure the advertise TXT record refers to the same guid in the SRV record.
            if (!memcmp(r.rrDomainName.name, "advertise.", 10) && !memcmp(r.rrDomainName.name + 10, service_target, 38)) 
    6f4e:	a80f      	add	r0, sp, #60	; 0x3c
    6f50:	497b      	ldr	r1, [pc, #492]	; (7140 <ParseMDNSResp+0x634>)
    6f52:	220a      	movs	r2, #10
    6f54:	4b7b      	ldr	r3, [pc, #492]	; (7144 <ParseMDNSResp+0x638>)
    6f56:	4798      	blx	r3
    6f58:	2800      	cmp	r0, #0
    6f5a:	d000      	beq.n	6f5e <ParseMDNSResp+0x452>
    6f5c:	e0bc      	b.n	70d8 <ParseMDNSResp+0x5cc>
    6f5e:	3016      	adds	r0, #22
    6f60:	ab0c      	add	r3, sp, #48	; 0x30
    6f62:	469c      	mov	ip, r3
    6f64:	4460      	add	r0, ip
    6f66:	a9d3      	add	r1, sp, #844	; 0x34c
    6f68:	2226      	movs	r2, #38	; 0x26
    6f6a:	4b76      	ldr	r3, [pc, #472]	; (7144 <ParseMDNSResp+0x638>)
    6f6c:	4798      	blx	r3
    6f6e:	2800      	cmp	r0, #0
    6f70:	d000      	beq.n	6f74 <ParseMDNSResp+0x468>
    6f72:	e0b1      	b.n	70d8 <ParseMDNSResp+0x5cc>
			{
               printf("Found advertise.* TXT record with full label %s.\n", r.rrDomainName.name);
    6f74:	4874      	ldr	r0, [pc, #464]	; (7148 <ParseMDNSResp+0x63c>)
    6f76:	a90f      	add	r1, sp, #60	; 0x3c
    6f78:	4b70      	ldr	r3, [pc, #448]	; (713c <ParseMDNSResp+0x630>)
    6f7a:	4798      	blx	r3
                // Ensure the sender-info TXT record included a transport and had the requested name prefix
                if (r.rdata.textRData.BusNodeTransport[0] && r.rdata.textRData.BusNodeName[0])
    6f7c:	2382      	movs	r3, #130	; 0x82
    6f7e:	009b      	lsls	r3, r3, #2
    6f80:	aa0f      	add	r2, sp, #60	; 0x3c
    6f82:	5cd3      	ldrb	r3, [r2, r3]
    6f84:	2b00      	cmp	r3, #0
    6f86:	d006      	beq.n	6f96 <ParseMDNSResp+0x48a>
    6f88:	2384      	movs	r3, #132	; 0x84
    6f8a:	005b      	lsls	r3, r3, #1
    6f8c:	5cd3      	ldrb	r3, [r2, r3]
    6f8e:	2b00      	cmp	r3, #0
    6f90:	d001      	beq.n	6f96 <ParseMDNSResp+0x48a>
				{
                    bus_transport = 1;
    6f92:	2301      	movs	r3, #1
    6f94:	930c      	str	r3, [sp, #48]	; 0x30
                }
            }
            // Ensure the sender-info TXT record refers to the same guid in the SRV record.
            if (!memcmp(r.rrDomainName.name, "sender-info.", 12) && !memcmp(r.rrDomainName.name + 12, service_target, 38))
    6f96:	a80f      	add	r0, sp, #60	; 0x3c
    6f98:	496c      	ldr	r1, [pc, #432]	; (714c <ParseMDNSResp+0x640>)
    6f9a:	220c      	movs	r2, #12
    6f9c:	4b69      	ldr	r3, [pc, #420]	; (7144 <ParseMDNSResp+0x638>)
    6f9e:	4798      	blx	r3
    6fa0:	2800      	cmp	r0, #0
    6fa2:	d126      	bne.n	6ff2 <ParseMDNSResp+0x4e6>
    6fa4:	a812      	add	r0, sp, #72	; 0x48
    6fa6:	a9d3      	add	r1, sp, #844	; 0x34c
    6fa8:	2226      	movs	r2, #38	; 0x26
    6faa:	4b66      	ldr	r3, [pc, #408]	; (7144 <ParseMDNSResp+0x638>)
    6fac:	4798      	blx	r3
    6fae:	2800      	cmp	r0, #0
    6fb0:	d11f      	bne.n	6ff2 <ParseMDNSResp+0x4e6>
			 {
                printf("Found sender-info.* TXT record with full name: %s.\n", r.rrDomainName.name);
    6fb2:	4867      	ldr	r0, [pc, #412]	; (7150 <ParseMDNSResp+0x644>)
    6fb4:	a90f      	add	r1, sp, #60	; 0x3c
    6fb6:	4b61      	ldr	r3, [pc, #388]	; (713c <ParseMDNSResp+0x630>)
    6fb8:	4798      	blx	r3
                // If the sender-info TXT record included the protocol version
                protocol_version = 0;
                if (r.rdata.textRData.BusNodeProtocolVersion[0]) 
    6fba:	23c2      	movs	r3, #194	; 0xc2
    6fbc:	009b      	lsls	r3, r3, #2
    6fbe:	aa0f      	add	r2, sp, #60	; 0x3c
    6fc0:	5cd3      	ldrb	r3, [r2, r3]
    6fc2:	2b00      	cmp	r3, #0
    6fc4:	d00b      	beq.n	6fde <ParseMDNSResp+0x4d2>
				{
                    // Ensure that it greater than or equal to the minimum allowed
                    protocol_version = atoi(r.rdata.textRData.BusNodeProtocolVersion);
    6fc6:	a8d1      	add	r0, sp, #836	; 0x344
    6fc8:	4b62      	ldr	r3, [pc, #392]	; (7154 <ParseMDNSResp+0x648>)
    6fca:	4798      	blx	r3
    6fcc:	1c04      	adds	r4, r0, #0
    6fce:	9008      	str	r0, [sp, #32]
                    if (protocol_version >= AJ_GetMinProtoVersion()) 
    6fd0:	4b61      	ldr	r3, [pc, #388]	; (7158 <ParseMDNSResp+0x64c>)
    6fd2:	4798      	blx	r3
    6fd4:	4284      	cmp	r4, r0
    6fd6:	d30c      	bcc.n	6ff2 <ParseMDNSResp+0x4e6>
					{
                        bus_protocol = 1;
    6fd8:	2301      	movs	r3, #1
    6fda:	930b      	str	r3, [sp, #44]	; 0x2c
    6fdc:	e009      	b.n	6ff2 <ParseMDNSResp+0x4e6>
                } 
				else 
				{
                    // Only protocol version 10 does not send the protocol version
                    // Ensure this is greater than or equal to the minimum allowed
                    if (10 >= AJ_GetMinProtoVersion())
    6fde:	4b5e      	ldr	r3, [pc, #376]	; (7158 <ParseMDNSResp+0x64c>)
    6fe0:	4798      	blx	r3
            // Ensure the sender-info TXT record refers to the same guid in the SRV record.
            if (!memcmp(r.rrDomainName.name, "sender-info.", 12) && !memcmp(r.rrDomainName.name + 12, service_target, 38))
			 {
                printf("Found sender-info.* TXT record with full name: %s.\n", r.rrDomainName.name);
                // If the sender-info TXT record included the protocol version
                protocol_version = 0;
    6fe2:	2300      	movs	r3, #0
    6fe4:	9308      	str	r3, [sp, #32]
                } 
				else 
				{
                    // Only protocol version 10 does not send the protocol version
                    // Ensure this is greater than or equal to the minimum allowed
                    if (10 >= AJ_GetMinProtoVersion())
    6fe6:	280a      	cmp	r0, #10
    6fe8:	d803      	bhi.n	6ff2 <ParseMDNSResp+0x4e6>
					{
                        protocol_version = 10;
    6fea:	330a      	adds	r3, #10
    6fec:	9308      	str	r3, [sp, #32]
                        bus_protocol = 1;
    6fee:	3b09      	subs	r3, #9
    6ff0:	930b      	str	r3, [sp, #44]	; 0x2c
                    }
                }
            }
        }
        // Ensure the A record refers to the same guid in the SRV record.
        if (r.rrType == A && !memcmp(r.rrDomainName.name, service_target, 38)) 
    6ff2:	ab0f      	add	r3, sp, #60	; 0x3c
    6ff4:	465a      	mov	r2, fp
    6ff6:	5c9b      	ldrb	r3, [r3, r2]
    6ff8:	2b01      	cmp	r3, #1
    6ffa:	d118      	bne.n	702e <ParseMDNSResp+0x522>
    6ffc:	a80f      	add	r0, sp, #60	; 0x3c
    6ffe:	a9d3      	add	r1, sp, #844	; 0x34c
    7000:	2226      	movs	r2, #38	; 0x26
    7002:	4b50      	ldr	r3, [pc, #320]	; (7144 <ParseMDNSResp+0x638>)
    7004:	4798      	blx	r3
    7006:	2800      	cmp	r0, #0
    7008:	d111      	bne.n	702e <ParseMDNSResp+0x522>
		{
            printf("Found an A additional record.\n");
    700a:	4854      	ldr	r0, [pc, #336]	; (715c <ParseMDNSResp+0x650>)
    700c:	4b49      	ldr	r3, [pc, #292]	; (7134 <ParseMDNSResp+0x628>)
    700e:	4798      	blx	r3
            memset(bus_addr, 0, (3 * 4 + 3 + 1));
    7010:	acff      	add	r4, sp, #1020	; 0x3fc
    7012:	3450      	adds	r4, #80	; 0x50
    7014:	1c20      	adds	r0, r4, #0
    7016:	2100      	movs	r1, #0
    7018:	2210      	movs	r2, #16
    701a:	4b40      	ldr	r3, [pc, #256]	; (711c <ParseMDNSResp+0x610>)
    701c:	4798      	blx	r3
            memcpy(bus_addr, r.rdata.aRData.ipv4Addr, (3 * 4 + 3 + 1));
    701e:	ab51      	add	r3, sp, #324	; 0x144
    7020:	1c22      	adds	r2, r4, #0
    7022:	cb13      	ldmia	r3!, {r0, r1, r4}
    7024:	c213      	stmia	r2!, {r0, r1, r4}
    7026:	681b      	ldr	r3, [r3, #0]
    7028:	6013      	str	r3, [r2, #0]
            bus_a_record = 1;
    702a:	2301      	movs	r3, #1
    702c:	930d      	str	r3, [sp, #52]	; 0x34
        size += ret;
        bufsize -= ret;
        p += ret;
     printf("Skipping non-relevant authority record, will be silently ignored.\n");
    }
    for (i = 0; i < header.arCount; i++)
    702e:	9b04      	ldr	r3, [sp, #16]
    7030:	454b      	cmp	r3, r9
    7032:	da00      	bge.n	7036 <ParseMDNSResp+0x52a>
    7034:	e75a      	b.n	6eec <ParseMDNSResp+0x3e0>
    7036:	1c34      	adds	r4, r6, #0

        return AJ_OK;
    }
	else 
	{
        return AJ_ERR_NO_MATCH;
    7038:	2010      	movs	r0, #16

    // To report a match, we must have successfully parsed an _alljoyn._tcp.local OR _alljoyn._udp.local
    // PRT record, SRV record, advertise TXT record and A record for the same
    // guid. Note that other records might have been ignored to ensure forward
    // compatibility with other record types that may be in use in the future.
    if ((alljoyn_ptr_record_tcp || alljoyn_ptr_record_udp) && (service_port_tcp || service_port_udp) && bus_transport && bus_protocol && bus_a_record) 
    703a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    703c:	2b00      	cmp	r3, #0
    703e:	d064      	beq.n	710a <ParseMDNSResp+0x5fe>
    7040:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7042:	2b00      	cmp	r3, #0
    7044:	d061      	beq.n	710a <ParseMDNSResp+0x5fe>
    7046:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7048:	2b00      	cmp	r3, #0
    704a:	d05e      	beq.n	710a <ParseMDNSResp+0x5fe>
	{

        if (alljoyn_ptr_record_tcp && service_port_tcp) 
    704c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    704e:	2b00      	cmp	r3, #0
    7050:	d01b      	beq.n	708a <ParseMDNSResp+0x57e>
    7052:	9b05      	ldr	r3, [sp, #20]
    7054:	2b00      	cmp	r3, #0
    7056:	d018      	beq.n	708a <ParseMDNSResp+0x57e>
		{
            service->ipv4port = service_port_tcp;
    7058:	466b      	mov	r3, sp
    705a:	8a9b      	ldrh	r3, [r3, #20]
    705c:	80b3      	strh	r3, [r6, #4]
			service->ipv4 = (bus_addr[0] << 24) | (bus_addr[1]<<16)|(bus_addr[2]<<8)|bus_addr[3];
    705e:	aaff      	add	r2, sp, #1020	; 0x3fc
    7060:	3250      	adds	r2, #80	; 0x50
    7062:	7813      	ldrb	r3, [r2, #0]
    7064:	0619      	lsls	r1, r3, #24
    7066:	7853      	ldrb	r3, [r2, #1]
    7068:	4083      	lsls	r3, r0
    706a:	430b      	orrs	r3, r1
    706c:	78d1      	ldrb	r1, [r2, #3]
    706e:	4319      	orrs	r1, r3
    7070:	7893      	ldrb	r3, [r2, #2]
    7072:	021b      	lsls	r3, r3, #8
    7074:	430b      	orrs	r3, r1
    7076:	60b3      	str	r3, [r6, #8]
			//p += sizeof(service->ipv4);
            //memcpy(&service->ipv4, bus_addr, sizeof(service->ipv4));
            service->addrTypes |= AJ_ADDR_TCP4;
    7078:	7833      	ldrb	r3, [r6, #0]
    707a:	2204      	movs	r2, #4
    707c:	4313      	orrs	r3, r2
    707e:	7033      	strb	r3, [r6, #0]
            service->pv = protocol_version;
    7080:	9b08      	ldr	r3, [sp, #32]
    7082:	6133      	str	r3, [r6, #16]
            service->priority = service_priority;
    7084:	466b      	mov	r3, sp
    7086:	8b9b      	ldrh	r3, [r3, #28]
    7088:	81b3      	strh	r3, [r6, #12]
            service->addrTypes |= AJ_ADDR_UDP4;
            service->pv = protocol_version;
            service->priority = service_priority;
        }

        return AJ_OK;
    708a:	2000      	movs	r0, #0
            //memcpy(&service->ipv4, bus_addr, sizeof(service->ipv4));
            service->addrTypes |= AJ_ADDR_TCP4;
            service->pv = protocol_version;
            service->priority = service_priority;
        }
        if (alljoyn_ptr_record_udp && service_port_udp)
    708c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    708e:	4283      	cmp	r3, r0
    7090:	d03b      	beq.n	710a <ParseMDNSResp+0x5fe>
    7092:	9b06      	ldr	r3, [sp, #24]
    7094:	4283      	cmp	r3, r0
    7096:	d038      	beq.n	710a <ParseMDNSResp+0x5fe>
		{
            service->ipv4portUdp = service_port_udp;
    7098:	466b      	mov	r3, sp
    709a:	8b1b      	ldrh	r3, [r3, #24]
    709c:	84a3      	strh	r3, [r4, #36]	; 0x24
            memcpy(&service->ipv4Udp, bus_addr, sizeof(service->ipv4Udp));
    709e:	1c20      	adds	r0, r4, #0
    70a0:	3028      	adds	r0, #40	; 0x28
    70a2:	a9ff      	add	r1, sp, #1020	; 0x3fc
    70a4:	3150      	adds	r1, #80	; 0x50
    70a6:	2204      	movs	r2, #4
    70a8:	4b2d      	ldr	r3, [pc, #180]	; (7160 <ParseMDNSResp+0x654>)
    70aa:	4798      	blx	r3
            service->addrTypes |= AJ_ADDR_UDP4;
    70ac:	7823      	ldrb	r3, [r4, #0]
    70ae:	2201      	movs	r2, #1
    70b0:	4313      	orrs	r3, r2
    70b2:	7023      	strb	r3, [r4, #0]
            service->pv = protocol_version;
    70b4:	9b08      	ldr	r3, [sp, #32]
    70b6:	6123      	str	r3, [r4, #16]
            service->priority = service_priority;
    70b8:	466b      	mov	r3, sp
    70ba:	8b9b      	ldrh	r3, [r3, #28]
    70bc:	81a3      	strh	r3, [r4, #12]
        }

        return AJ_OK;
    70be:	2000      	movs	r0, #0
    70c0:	e023      	b.n	710a <ParseMDNSResp+0x5fe>
	//  -  
	printf("--------------Start mDNS parse ---------------\n");
    size = ParseMDNSHeader(buffer, bufsize, &header);
    if (size == 0) 
	{
        AJ_ErrPrintf(("Error occured while deserializing header\n"));
    70c2:	2001      	movs	r0, #1
    70c4:	4917      	ldr	r1, [pc, #92]	; (7124 <ParseMDNSResp+0x618>)
    70c6:	22fb      	movs	r2, #251	; 0xfb
    70c8:	0092      	lsls	r2, r2, #2
    70ca:	4b18      	ldr	r3, [pc, #96]	; (712c <ParseMDNSResp+0x620>)
    70cc:	4798      	blx	r3
    70ce:	2800      	cmp	r0, #0
    70d0:	d000      	beq.n	70d4 <ParseMDNSResp+0x5c8>
    70d2:	e573      	b.n	6bbc <ParseMDNSResp+0xb0>
        return AJ_ERR_NO_MATCH;
    70d4:	3010      	adds	r0, #16
    70d6:	e018      	b.n	710a <ParseMDNSResp+0x5fe>
				{
                    bus_transport = 1;
                }
            }
            // Ensure the sender-info TXT record refers to the same guid in the SRV record.
            if (!memcmp(r.rrDomainName.name, "sender-info.", 12) && !memcmp(r.rrDomainName.name + 12, service_target, 38))
    70d8:	a80f      	add	r0, sp, #60	; 0x3c
    70da:	491c      	ldr	r1, [pc, #112]	; (714c <ParseMDNSResp+0x640>)
    70dc:	220c      	movs	r2, #12
    70de:	4b19      	ldr	r3, [pc, #100]	; (7144 <ParseMDNSResp+0x638>)
    70e0:	4798      	blx	r3
    70e2:	2800      	cmp	r0, #0
    70e4:	d009      	beq.n	70fa <ParseMDNSResp+0x5ee>
    70e6:	e7a2      	b.n	702e <ParseMDNSResp+0x522>
		{
         printf("Found _alljoyn_.tcp.local PTR record.\n");
            alljoyn_ptr_record_tcp = 1;
        }

        if (r.rrType == PTR && !memcmp(r.rrDomainName.name, "_alljoyn._udp.local", 19))
    70e8:	a80f      	add	r0, sp, #60	; 0x3c
    70ea:	491e      	ldr	r1, [pc, #120]	; (7164 <ParseMDNSResp+0x658>)
    70ec:	2213      	movs	r2, #19
    70ee:	4b15      	ldr	r3, [pc, #84]	; (7144 <ParseMDNSResp+0x638>)
    70f0:	4798      	blx	r3
    70f2:	2800      	cmp	r0, #0
    70f4:	d000      	beq.n	70f8 <ParseMDNSResp+0x5ec>
    70f6:	e673      	b.n	6de0 <ParseMDNSResp+0x2d4>
    70f8:	e5fe      	b.n	6cf8 <ParseMDNSResp+0x1ec>
				{
                    bus_transport = 1;
                }
            }
            // Ensure the sender-info TXT record refers to the same guid in the SRV record.
            if (!memcmp(r.rrDomainName.name, "sender-info.", 12) && !memcmp(r.rrDomainName.name + 12, service_target, 38))
    70fa:	a812      	add	r0, sp, #72	; 0x48
    70fc:	a9d3      	add	r1, sp, #844	; 0x34c
    70fe:	2226      	movs	r2, #38	; 0x26
    7100:	4b10      	ldr	r3, [pc, #64]	; (7144 <ParseMDNSResp+0x638>)
    7102:	4798      	blx	r3
    7104:	2800      	cmp	r0, #0
    7106:	d192      	bne.n	702e <ParseMDNSResp+0x522>
    7108:	e753      	b.n	6fb2 <ParseMDNSResp+0x4a6>
    }
	else 
	{
        return AJ_ERR_NO_MATCH;
    }
}
    710a:	4b17      	ldr	r3, [pc, #92]	; (7168 <ParseMDNSResp+0x65c>)
    710c:	449d      	add	sp, r3
    710e:	bc3c      	pop	{r2, r3, r4, r5}
    7110:	4690      	mov	r8, r2
    7112:	4699      	mov	r9, r3
    7114:	46a2      	mov	sl, r4
    7116:	46ab      	mov	fp, r5
    7118:	bdf0      	pop	{r4, r5, r6, r7, pc}
    711a:	46c0      	nop			; (mov r8, r8)
    711c:	00016773 	.word	0x00016773
    7120:	000066bd 	.word	0x000066bd
    7124:	0001bfcc 	.word	0x0001bfcc
    7128:	0000045a 	.word	0x0000045a
    712c:	0000636d 	.word	0x0000636d
    7130:	0001c448 	.word	0x0001c448
    7134:	00016f5d 	.word	0x00016f5d
    7138:	0001c478 	.word	0x0001c478
    713c:	00016e3d 	.word	0x00016e3d
    7140:	0001c49c 	.word	0x0001c49c
    7144:	0001671b 	.word	0x0001671b
    7148:	0001c4a8 	.word	0x0001c4a8
    714c:	0001c4dc 	.word	0x0001c4dc
    7150:	0001c4ec 	.word	0x0001c4ec
    7154:	00016665 	.word	0x00016665
    7158:	00003a01 	.word	0x00003a01
    715c:	0001c520 	.word	0x0001c520
    7160:	00016739 	.word	0x00016739
    7164:	0001c3c4 	.word	0x0001c3c4
    7168:	0000046c 	.word	0x0000046c

0000716c <AJ_Discover>:
#define AJ_INITIAL_INTERVAL  1000

static uint32_t searchId = 0;

AJ_Status AJ_Discover(const char* prefix, AJ_Service* service, uint32_t timeout, uint32_t selectionTimeout)
{
    716c:	b5f0      	push	{r4, r5, r6, r7, lr}
    716e:	465f      	mov	r7, fp
    7170:	4656      	mov	r6, sl
    7172:	464d      	mov	r5, r9
    7174:	4644      	mov	r4, r8
    7176:	b4f0      	push	{r4, r5, r6, r7}
    7178:	b0b1      	sub	sp, #196	; 0xc4
    717a:	9002      	str	r0, [sp, #8]
    717c:	9103      	str	r1, [sp, #12]
    717e:	1e14      	subs	r4, r2, #0
    volatile AJ_Status status;
    uint32_t burstCount;
    uint32_t interval = AJ_INITIAL_INTERVAL;
    uint32_t queries = 0;
    int32_t discover = (int32_t) timeout;
    7180:	4691      	mov	r9, r2
    int32_t selection = (int32_t) selectionTimeout;
    7182:	469a      	mov	sl, r3
    AJ_Time listenTimer;
    AJ_Time selectionTimer;
    AJ_MCastSocket sock;
    AJ_GUID guid;

    if (selectionTimeout > timeout)
    7184:	429c      	cmp	r4, r3
    7186:	d201      	bcs.n	718c <AJ_Discover+0x20>
	{
        selectionTimeout = timeout;
        selection = (int32_t) selectionTimeout;
    7188:	4692      	mov	sl, r2
    AJ_MCastSocket sock;
    AJ_GUID guid;

    if (selectionTimeout > timeout)
	{
        selectionTimeout = timeout;
    718a:	1c13      	adds	r3, r2, #0
        selection = (int32_t) selectionTimeout;
    }
    printf("AJ_Discover(prefix=\"%s\", service=0x%p, timeout=%d, selection timeout=%d.)\n", prefix, service, timeout, selectionTimeout);
    718c:	9300      	str	r3, [sp, #0]
    718e:	48e2      	ldr	r0, [pc, #904]	; (7518 <AJ_Discover+0x3ac>)
    7190:	9902      	ldr	r1, [sp, #8]
    7192:	9a03      	ldr	r2, [sp, #12]
    7194:	1c23      	adds	r3, r4, #0
    7196:	4ce1      	ldr	r4, [pc, #900]	; (751c <AJ_Discover+0x3b0>)
    7198:	47a0      	blx	r4

    // Enable multicast I/O for the discovery packets.     
    status = AJ_Net_MCastUp(&sock);
    719a:	a81d      	add	r0, sp, #116	; 0x74
    719c:	4be0      	ldr	r3, [pc, #896]	; (7520 <AJ_Discover+0x3b4>)
    719e:	4798      	blx	r3
    71a0:	239f      	movs	r3, #159	; 0x9f
    71a2:	aa08      	add	r2, sp, #32
    71a4:	4694      	mov	ip, r2
    71a6:	4463      	add	r3, ip
    71a8:	7018      	strb	r0, [r3, #0]
    if (status != AJ_OK)
    71aa:	781b      	ldrb	r3, [r3, #0]
    71ac:	b2db      	uxtb	r3, r3
    71ae:	9307      	str	r3, [sp, #28]
    71b0:	2b00      	cmp	r3, #0
    71b2:	d00c      	beq.n	71ce <AJ_Discover+0x62>
	{
        printf("AJ_Discover(): status=%s\n", AJ_StatusText(status));
    71b4:	249f      	movs	r4, #159	; 0x9f
    71b6:	4464      	add	r4, ip
    71b8:	7820      	ldrb	r0, [r4, #0]
    71ba:	b2c0      	uxtb	r0, r0
    71bc:	4bd9      	ldr	r3, [pc, #868]	; (7524 <AJ_Discover+0x3b8>)
    71be:	4798      	blx	r3
    71c0:	1c01      	adds	r1, r0, #0
    71c2:	48d9      	ldr	r0, [pc, #868]	; (7528 <AJ_Discover+0x3bc>)
    71c4:	4bd5      	ldr	r3, [pc, #852]	; (751c <AJ_Discover+0x3b0>)
    71c6:	4798      	blx	r3
        return status;
    71c8:	7820      	ldrb	r0, [r4, #0]
    71ca:	b2c0      	uxtb	r0, r0
    71cc:	e3ce      	b.n	796c <AJ_Discover+0x800>
    }

    // Perform discovery until node discovered or overall discover timeout reached
    burstCount = 0;
    AJ_InitTimer(&selectionTimer);
    71ce:	a829      	add	r0, sp, #164	; 0xa4
    71d0:	4cd6      	ldr	r4, [pc, #856]	; (752c <AJ_Discover+0x3c0>)
    71d2:	47a0      	blx	r4
    printf("Selection timer started\n");
    71d4:	48d6      	ldr	r0, [pc, #856]	; (7530 <AJ_Discover+0x3c4>)
    71d6:	4bd7      	ldr	r3, [pc, #860]	; (7534 <AJ_Discover+0x3c8>)
    71d8:	4798      	blx	r3
    AJ_InitTimer(&discoverTimer);
    71da:	a82d      	add	r0, sp, #180	; 0xb4
    71dc:	47a0      	blx	r4
    while (discover > 0) 
    71de:	464b      	mov	r3, r9
    71e0:	2b00      	cmp	r3, #0
    71e2:	dc00      	bgt.n	71e6 <AJ_Discover+0x7a>
    71e4:	e397      	b.n	7916 <AJ_Discover+0x7aa>
    71e6:	2300      	movs	r3, #0
    71e8:	22fa      	movs	r2, #250	; 0xfa
    71ea:	0092      	lsls	r2, r2, #2
    71ec:	9204      	str	r2, [sp, #16]
    71ee:	2200      	movs	r2, #0
    71f0:	4693      	mov	fp, r2

static AJ_Status RewriteSenderInfo(AJ_IOBuffer* buf, uint32_t addr, uint16_t port)
{
	uint16_t sidVal;
	const char snd[4] = { 'd', 'n', 'e', 's' };
	const char sid[] = { 's', 'i', 'd', '=' };
    71f2:	4ad1      	ldr	r2, [pc, #836]	; (7538 <AJ_Discover+0x3cc>)
    71f4:	3204      	adds	r2, #4
    71f6:	9205      	str	r2, [sp, #20]
    71f8:	4656      	mov	r6, sl
    71fa:	469a      	mov	sl, r3
    AJ_InitTimer(&selectionTimer);
    printf("Selection timer started\n");
    AJ_InitTimer(&discoverTimer);
    while (discover > 0) 
	{
        burstCount++;
    71fc:	2301      	movs	r3, #1
    71fe:	469c      	mov	ip, r3
    7200:	44e3      	add	fp, ip
        // Only send WHO-HAS if configured to consider pre-14.06 routers.
		//AJ_GetMinProtoVersion   10
        if (AJ_GetMinProtoVersion() < 10)
    7202:	4bce      	ldr	r3, [pc, #824]	; (753c <AJ_Discover+0x3d0>)
    7204:	4798      	blx	r3
    7206:	2809      	cmp	r0, #9
    7208:	d85d      	bhi.n	72c6 <AJ_Discover+0x15a>
		{
            AJ_IO_BUF_RESET(&sock.tx);
    720a:	ac1d      	add	r4, sp, #116	; 0x74
    720c:	9d1e      	ldr	r5, [sp, #120]	; 0x78
    720e:	951f      	str	r5, [sp, #124]	; 0x7c
    7210:	9520      	str	r5, [sp, #128]	; 0x80
    7212:	2300      	movs	r3, #0
    7214:	7063      	strb	r3, [r4, #1]
extern volatile int sock_rx_state;
extern volatile uint8_t sock_tx_state;

static AJ_Status ComposeWhoHas(AJ_IOBuffer* txBuf, const char* prefix)
{
    size_t preLen = strlen(prefix);
    7216:	9802      	ldr	r0, [sp, #8]
    7218:	4bc9      	ldr	r3, [pc, #804]	; (7540 <AJ_Discover+0x3d4>)
    721a:	4798      	blx	r3
    721c:	4680      	mov	r8, r0
    NSHeader* hdr = (NSHeader*)txBuf->writePtr;
    uint8_t* p = txBuf->writePtr + 6;
    size_t outLen = (6 + preLen + 2);
    721e:	1c07      	adds	r7, r0, #0
    7220:	3708      	adds	r7, #8

    AJ_InfoPrintf(("ComposeWhoHas(txbuf=0x%p, prefix=\"%s\")\n", txBuf, prefix));

    if (outLen > AJ_IO_BUF_SPACE(txBuf)) 
    7222:	8863      	ldrh	r3, [r4, #2]
    7224:	429f      	cmp	r7, r3
    7226:	d90c      	bls.n	7242 <AJ_Discover+0xd6>
	{
        AJ_ErrPrintf(("ComposeWhoHas(): AJ_ERR_RESOURCES\n"));
    7228:	2001      	movs	r0, #1
    722a:	49c6      	ldr	r1, [pc, #792]	; (7544 <AJ_Discover+0x3d8>)
    722c:	225d      	movs	r2, #93	; 0x5d
    722e:	4bc6      	ldr	r3, [pc, #792]	; (7548 <AJ_Discover+0x3dc>)
    7230:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    7232:	220b      	movs	r2, #11

    AJ_InfoPrintf(("ComposeWhoHas(txbuf=0x%p, prefix=\"%s\")\n", txBuf, prefix));

    if (outLen > AJ_IO_BUF_SPACE(txBuf)) 
	{
        AJ_ErrPrintf(("ComposeWhoHas(): AJ_ERR_RESOURCES\n"));
    7234:	2800      	cmp	r0, #0
    7236:	d020      	beq.n	727a <AJ_Discover+0x10e>
    7238:	48c4      	ldr	r0, [pc, #784]	; (754c <AJ_Discover+0x3e0>)
    723a:	4bbe      	ldr	r3, [pc, #760]	; (7534 <AJ_Discover+0x3c8>)
    723c:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    723e:	220b      	movs	r2, #11
    7240:	e01b      	b.n	727a <AJ_Discover+0x10e>
    }
    hdr->version = MSG_V1 | NSV_V1;
    7242:	2311      	movs	r3, #17
    7244:	702b      	strb	r3, [r5, #0]
    hdr->qCount = 1;
    7246:	3b10      	subs	r3, #16
    7248:	706b      	strb	r3, [r5, #1]
    hdr->aCount = 0;
    724a:	2200      	movs	r2, #0
    724c:	70aa      	strb	r2, [r5, #2]
    hdr->ttl = 0;
    724e:	70ea      	strb	r2, [r5, #3]
    hdr->flags = WHO_HAS_MSG;
    7250:	3280      	adds	r2, #128	; 0x80
    7252:	712a      	strb	r2, [r5, #4]
    hdr->nameCount = 1;
    7254:	716b      	strb	r3, [r5, #5]
    *p++ = (uint8_t)(preLen + 1);
    7256:	1dec      	adds	r4, r5, #7
    7258:	1c03      	adds	r3, r0, #0
    725a:	3301      	adds	r3, #1
    725c:	71ab      	strb	r3, [r5, #6]
    memcpy(p, prefix, preLen);
    725e:	1c20      	adds	r0, r4, #0
    7260:	9902      	ldr	r1, [sp, #8]
    7262:	4642      	mov	r2, r8
    7264:	4bba      	ldr	r3, [pc, #744]	; (7550 <AJ_Discover+0x3e4>)
    7266:	4798      	blx	r3
    // Tack wild-card onto the end of the name to indicate it's prefix
    p[preLen] = '*';
    7268:	232a      	movs	r3, #42	; 0x2a
    726a:	4642      	mov	r2, r8
    726c:	54a3      	strb	r3, [r4, r2]
    txBuf->writePtr += outLen;
    726e:	9b20      	ldr	r3, [sp, #128]	; 0x80
    7270:	9306      	str	r3, [sp, #24]
    7272:	469c      	mov	ip, r3
    7274:	4467      	add	r7, ip
    7276:	9720      	str	r7, [sp, #128]	; 0x80
    return AJ_OK;
    7278:	9a07      	ldr	r2, [sp, #28]
		//AJ_GetMinProtoVersion   10
        if (AJ_GetMinProtoVersion() < 10)
		{
            AJ_IO_BUF_RESET(&sock.tx);
            AJ_InfoPrintf(("AJ_Discover(): WHO-HAS \"%s\"\n", prefix));
            status = ComposeWhoHas(&sock.tx, prefix); //aj_disco.c (((((
    727a:	239f      	movs	r3, #159	; 0x9f
    727c:	a908      	add	r1, sp, #32
    727e:	468c      	mov	ip, r1
    7280:	4463      	add	r3, ip
    7282:	701a      	strb	r2, [r3, #0]
            if (status == AJ_OK)
    7284:	781b      	ldrb	r3, [r3, #0]
    7286:	2b00      	cmp	r3, #0
    7288:	d117      	bne.n	72ba <AJ_Discover+0x14e>
			{
                sock.tx.flags |= AJ_IO_BUF_AJ;
    728a:	a81d      	add	r0, sp, #116	; 0x74
    728c:	7842      	ldrb	r2, [r0, #1]
    728e:	2301      	movs	r3, #1
    7290:	4313      	orrs	r3, r2
    7292:	7043      	strb	r3, [r0, #1]
                status = sock.tx.send(&sock.tx);
    7294:	6903      	ldr	r3, [r0, #16]
    7296:	4798      	blx	r3
    7298:	249f      	movs	r4, #159	; 0x9f
    729a:	ab08      	add	r3, sp, #32
    729c:	469c      	mov	ip, r3
    729e:	4464      	add	r4, ip
    72a0:	7020      	strb	r0, [r4, #0]
                printf("AJ_Discover(): WHO-HAS send status=%s\n", AJ_StatusText(status));
    72a2:	7820      	ldrb	r0, [r4, #0]
    72a4:	b2c0      	uxtb	r0, r0
    72a6:	4b9f      	ldr	r3, [pc, #636]	; (7524 <AJ_Discover+0x3b8>)
    72a8:	4798      	blx	r3
    72aa:	1c01      	adds	r1, r0, #0
    72ac:	48a9      	ldr	r0, [pc, #676]	; (7554 <AJ_Discover+0x3e8>)
    72ae:	4b9b      	ldr	r3, [pc, #620]	; (751c <AJ_Discover+0x3b0>)
    72b0:	4798      	blx	r3
                // If the send failed the socket has probably gone away.
                if (status != AJ_OK) 
    72b2:	7823      	ldrb	r3, [r4, #0]
    72b4:	2b00      	cmp	r3, #0
    72b6:	d006      	beq.n	72c6 <AJ_Discover+0x15a>
    72b8:	e32d      	b.n	7916 <AJ_Discover+0x7aa>
                }
            }
			else
			{
                // If compose failed just continue on
                status = AJ_OK;
    72ba:	2200      	movs	r2, #0
    72bc:	239f      	movs	r3, #159	; 0x9f
    72be:	a908      	add	r1, sp, #32
    72c0:	468c      	mov	ip, r1
    72c2:	4463      	add	r3, ip
    72c4:	701a      	strb	r2, [r3, #0]
            }
         }

         status = AJ_GetLocalGUID(&guid);
    72c6:	a819      	add	r0, sp, #100	; 0x64
    72c8:	4ba3      	ldr	r3, [pc, #652]	; (7558 <AJ_Discover+0x3ec>)
    72ca:	4798      	blx	r3
    72cc:	239f      	movs	r3, #159	; 0x9f
    72ce:	aa08      	add	r2, sp, #32
    72d0:	4694      	mov	ip, r2
    72d2:	4463      	add	r3, ip
    72d4:	7018      	strb	r0, [r3, #0]
        if (status != AJ_OK) 
    72d6:	781d      	ldrb	r5, [r3, #0]
    72d8:	b2ed      	uxtb	r5, r5
    72da:	2d00      	cmp	r5, #0
    72dc:	d00b      	beq.n	72f6 <AJ_Discover+0x18a>
		{
            AJ_ErrPrintf(("AJ_Discover(): No GUID!\n"));
    72de:	2001      	movs	r0, #1
    72e0:	4998      	ldr	r1, [pc, #608]	; (7544 <AJ_Discover+0x3d8>)
    72e2:	4a9e      	ldr	r2, [pc, #632]	; (755c <AJ_Discover+0x3f0>)
    72e4:	4b98      	ldr	r3, [pc, #608]	; (7548 <AJ_Discover+0x3dc>)
    72e6:	4798      	blx	r3
    72e8:	2800      	cmp	r0, #0
    72ea:	d100      	bne.n	72ee <AJ_Discover+0x182>
    72ec:	e313      	b.n	7916 <AJ_Discover+0x7aa>
    72ee:	489c      	ldr	r0, [pc, #624]	; (7560 <AJ_Discover+0x3f4>)
    72f0:	4b90      	ldr	r3, [pc, #576]	; (7534 <AJ_Discover+0x3c8>)
    72f2:	4798      	blx	r3
    72f4:	e30f      	b.n	7916 <AJ_Discover+0x7aa>
            goto _Exit;
        }

        AJ_IO_BUF_RESET(&sock.tx);
    72f6:	ab1d      	add	r3, sp, #116	; 0x74
    72f8:	9c1e      	ldr	r4, [sp, #120]	; 0x78
    72fa:	941f      	str	r4, [sp, #124]	; 0x7c
    72fc:	9420      	str	r4, [sp, #128]	; 0x80
    72fe:	2200      	movs	r2, #0
    7300:	705a      	strb	r2, [r3, #1]
   //     AJ_InfoPrintf(("AJ_Discover(): mDNS \"%s\"\n", prefix));
	
		// -   -   
        status = ComposeMDnsReq(&sock.tx, prefix, &guid, searchId);
    7302:	4b98      	ldr	r3, [pc, #608]	; (7564 <AJ_Discover+0x3f8>)
        0x0a, 0x75, 0x70, 0x63, 0x76,0x34,0x3d,0x35, 0x33, 0x35,0x33        // upcv4=5353    
    };
	
    uint8_t* pkt = (uint8_t*)txBuf->writePtr;

    hdr[0] = (sidVal >> 8) & 0xFF;
    7304:	4998      	ldr	r1, [pc, #608]	; (7568 <AJ_Discover+0x3fc>)
    7306:	681a      	ldr	r2, [r3, #0]
    7308:	785b      	ldrb	r3, [r3, #1]
    730a:	700b      	strb	r3, [r1, #0]
    hdr[1] = sidVal & 0xFF;
    730c:	704a      	strb	r2, [r1, #1]
    memcpy(pkt, hdr, sizeof(hdr));
    730e:	1c20      	adds	r0, r4, #0
    7310:	220c      	movs	r2, #12
    7312:	4f8f      	ldr	r7, [pc, #572]	; (7550 <AJ_Discover+0x3e4>)
    7314:	47b8      	blx	r7
    pkt += sizeof(hdr);

    memcpy(pkt, queries, sizeof(queries));
    7316:	1c20      	adds	r0, r4, #0
    7318:	300c      	adds	r0, #12
    731a:	4994      	ldr	r1, [pc, #592]	; (756c <AJ_Discover+0x400>)
    731c:	222d      	movs	r2, #45	; 0x2d
    731e:	47b8      	blx	r7
    pkt += sizeof(queries);

    //Append search TXT record with actual GUID and prefix
    memcpy(pkt, search, sizeof(search));
    7320:	1c20      	adds	r0, r4, #0
    7322:	3039      	adds	r0, #57	; 0x39
    7324:	4992      	ldr	r1, [pc, #584]	; (7570 <AJ_Discover+0x404>)
    7326:	2207      	movs	r2, #7
    7328:	47b8      	blx	r7
    pkt += sizeof(search);

    *pkt++ = 32;
    732a:	2220      	movs	r2, #32
    732c:	2340      	movs	r3, #64	; 0x40
    732e:	54e2      	strb	r2, [r4, r3]
    7330:	1c21      	adds	r1, r4, #0
    7332:	3141      	adds	r1, #65	; 0x41
    AJ_GUID_ToString(guid, (char*) pkt, 33);
    7334:	a819      	add	r0, sp, #100	; 0x64
    7336:	3201      	adds	r2, #1
    7338:	4b8e      	ldr	r3, [pc, #568]	; (7574 <AJ_Discover+0x408>)
    733a:	4798      	blx	r3
    pkt += 32;

    memcpy(pkt, local, sizeof(local));
    733c:	1c20      	adds	r0, r4, #0
    733e:	3061      	adds	r0, #97	; 0x61
    7340:	498d      	ldr	r1, [pc, #564]	; (7578 <AJ_Discover+0x40c>)
    7342:	220a      	movs	r2, #10
    7344:	47b8      	blx	r7
    pkt += sizeof(local);

    dataLength = sizeof(txtvers) + 1 + sizeof(nameone) + strlen(prefix) + 1 + sizeof(sendmatchonly);
    7346:	9802      	ldr	r0, [sp, #8]
    7348:	4b7d      	ldr	r3, [pc, #500]	; (7540 <AJ_Discover+0x3d4>)
    734a:	4698      	mov	r8, r3
    734c:	4798      	blx	r3
    734e:	3014      	adds	r0, #20
    7350:	b280      	uxth	r0, r0
    *pkt++ = (uint8_t) (dataLength >> 8);
    7352:	0a02      	lsrs	r2, r0, #8
    7354:	236b      	movs	r3, #107	; 0x6b
    7356:	54e2      	strb	r2, [r4, r3]
    *pkt++ = (uint8_t) (dataLength & 0xFF);
    7358:	3301      	adds	r3, #1
    735a:	54e0      	strb	r0, [r4, r3]

    memcpy(pkt, txtvers, sizeof(txtvers));
    735c:	1c23      	adds	r3, r4, #0
    735e:	336d      	adds	r3, #109	; 0x6d
    7360:	1c18      	adds	r0, r3, #0
    7362:	4986      	ldr	r1, [pc, #536]	; (757c <AJ_Discover+0x410>)
    7364:	220a      	movs	r2, #10
    7366:	47b8      	blx	r7
    pkt += sizeof(txtvers);

    if ((sizeof(nameone) + strlen(prefix) + 1) > 255) 
    7368:	9802      	ldr	r0, [sp, #8]
    736a:	47c0      	blx	r8
    736c:	1d43      	adds	r3, r0, #5
    736e:	2bff      	cmp	r3, #255	; 0xff
    7370:	d910      	bls.n	7394 <AJ_Discover+0x228>
	{
        AJ_ErrPrintf(("ComposeMDnsReq(): prefix too long: %d\n", strlen(prefix)));
    7372:	2001      	movs	r0, #1
    7374:	4973      	ldr	r1, [pc, #460]	; (7544 <AJ_Discover+0x3d8>)
    7376:	4a82      	ldr	r2, [pc, #520]	; (7580 <AJ_Discover+0x414>)
    7378:	4b73      	ldr	r3, [pc, #460]	; (7548 <AJ_Discover+0x3dc>)
    737a:	4798      	blx	r3
        return AJ_ERR_INVALID;
    737c:	2503      	movs	r5, #3
    memcpy(pkt, txtvers, sizeof(txtvers));
    pkt += sizeof(txtvers);

    if ((sizeof(nameone) + strlen(prefix) + 1) > 255) 
	{
        AJ_ErrPrintf(("ComposeMDnsReq(): prefix too long: %d\n", strlen(prefix)));
    737e:	2800      	cmp	r0, #0
    7380:	d100      	bne.n	7384 <AJ_Discover+0x218>
    7382:	e118      	b.n	75b6 <AJ_Discover+0x44a>
    7384:	9802      	ldr	r0, [sp, #8]
    7386:	4b6e      	ldr	r3, [pc, #440]	; (7540 <AJ_Discover+0x3d4>)
    7388:	4798      	blx	r3
    738a:	1c01      	adds	r1, r0, #0
    738c:	487d      	ldr	r0, [pc, #500]	; (7584 <AJ_Discover+0x418>)
    738e:	4b63      	ldr	r3, [pc, #396]	; (751c <AJ_Discover+0x3b0>)
    7390:	4798      	blx	r3
    7392:	e110      	b.n	75b6 <AJ_Discover+0x44a>
        return AJ_ERR_INVALID;
    }
    *pkt++ = sizeof(nameone) + strlen(prefix) + 1;
    7394:	3005      	adds	r0, #5
    7396:	2377      	movs	r3, #119	; 0x77
    7398:	54e0      	strb	r0, [r4, r3]
    memcpy(pkt, nameone, sizeof(nameone));
    739a:	1c20      	adds	r0, r4, #0
    739c:	3078      	adds	r0, #120	; 0x78
    739e:	497a      	ldr	r1, [pc, #488]	; (7588 <AJ_Discover+0x41c>)
    73a0:	2204      	movs	r2, #4
    73a2:	4f6b      	ldr	r7, [pc, #428]	; (7550 <AJ_Discover+0x3e4>)
    73a4:	47b8      	blx	r7
    pkt += sizeof(nameone);
    73a6:	347c      	adds	r4, #124	; 0x7c
    memcpy(pkt, prefix, strlen(prefix));
    73a8:	9802      	ldr	r0, [sp, #8]
    73aa:	4b65      	ldr	r3, [pc, #404]	; (7540 <AJ_Discover+0x3d4>)
    73ac:	4698      	mov	r8, r3
    73ae:	4798      	blx	r3
    73b0:	1c02      	adds	r2, r0, #0
    73b2:	1c20      	adds	r0, r4, #0
    73b4:	9902      	ldr	r1, [sp, #8]
    73b6:	47b8      	blx	r7
    pkt += strlen(prefix);
    73b8:	9802      	ldr	r0, [sp, #8]
    73ba:	47c0      	blx	r8
    73bc:	1824      	adds	r4, r4, r0
    *pkt++ = '*';
    73be:	232a      	movs	r3, #42	; 0x2a
    73c0:	7023      	strb	r3, [r4, #0]
    memcpy(pkt, sendmatchonly, sizeof(sendmatchonly));
    73c2:	1c60      	adds	r0, r4, #1
    73c4:	4971      	ldr	r1, [pc, #452]	; (758c <AJ_Discover+0x420>)
    73c6:	2204      	movs	r2, #4
    73c8:	47b8      	blx	r7
    pkt += sizeof(sendmatchonly);
		
    // Append sender-info TXT record static fields
    memcpy(pkt, senderinfo, sizeof(senderinfo));
    73ca:	1d60      	adds	r0, r4, #5
    73cc:	4970      	ldr	r1, [pc, #448]	; (7590 <AJ_Discover+0x424>)
    73ce:	2254      	movs	r2, #84	; 0x54
    73d0:	47b8      	blx	r7
    pkt += sizeof(senderinfo);
    73d2:	3459      	adds	r4, #89	; 0x59
    uint16_t port=5353;


    pktLen = pkt - txBuf->writePtr;
    txBuf->writePtr += pktLen;
    73d4:	9420      	str	r4, [sp, #128]	; 0x80
	    if (RewriteSenderInfo(txBuf, own_IPAddress, port) != AJ_OK)
    73d6:	4b6f      	ldr	r3, [pc, #444]	; (7594 <AJ_Discover+0x428>)
    73d8:	681c      	ldr	r4, [r3, #0]
extern uint32_t own_IPAddress;

static AJ_Status RewriteSenderInfo(AJ_IOBuffer* buf, uint32_t addr, uint16_t port)
{
	uint16_t sidVal;
	const char snd[4] = { 'd', 'n', 'e', 's' };
    73da:	a80a      	add	r0, sp, #40	; 0x28
    73dc:	4956      	ldr	r1, [pc, #344]	; (7538 <AJ_Discover+0x3cc>)
    73de:	2204      	movs	r2, #4
    73e0:	47b8      	blx	r7
	const char sid[] = { 's', 'i', 'd', '=' };
    73e2:	a80b      	add	r0, sp, #44	; 0x2c
    73e4:	9905      	ldr	r1, [sp, #20]
    73e6:	2204      	movs	r2, #4
    73e8:	47b8      	blx	r7
	const char ipv4[] = { 'i', 'p', 'v', '4', '=' };
    73ea:	4953      	ldr	r1, [pc, #332]	; (7538 <AJ_Discover+0x3cc>)
    73ec:	3108      	adds	r1, #8
    73ee:	a80c      	add	r0, sp, #48	; 0x30
    73f0:	2205      	movs	r2, #5
    73f2:	47b8      	blx	r7
	const char upcv4[] = { 'u', 'p', 'c', 'v', '4', '=' };
    73f4:	4950      	ldr	r1, [pc, #320]	; (7538 <AJ_Discover+0x3cc>)
    73f6:	3110      	adds	r1, #16
    73f8:	a80e      	add	r0, sp, #56	; 0x38
    73fa:	2206      	movs	r2, #6
    73fc:	47b8      	blx	r7
	uint16_t dataLength;
	int match;
	AJ_Status status;

	// first, pluck the search ID from the mDNS header
	sidVal = *(buf->readPtr) << 8;
    73fe:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    7400:	7818      	ldrb	r0, [r3, #0]
    7402:	0200      	lsls	r0, r0, #8
	sidVal += *(buf->readPtr + 1);
    7404:	785b      	ldrb	r3, [r3, #1]
    7406:	18c0      	adds	r0, r0, r3

	// convert to strings
	status = AJ_IntToString((int32_t) sidVal, sidStr, sizeof(sidStr));
    7408:	b280      	uxth	r0, r0
    740a:	a910      	add	r1, sp, #64	; 0x40
    740c:	2206      	movs	r2, #6
    740e:	4b62      	ldr	r3, [pc, #392]	; (7598 <AJ_Discover+0x42c>)
    7410:	4798      	blx	r3
	if (status != AJ_OK) {
    7412:	2800      	cmp	r0, #0
    7414:	d000      	beq.n	7418 <AJ_Discover+0x2ac>
    7416:	e2a0      	b.n	795a <AJ_Discover+0x7ee>
		return AJ_ERR_WRITE;
	}
	status = AJ_IntToString((int32_t) port, upcv4Str, sizeof(upcv4Str));
    7418:	4860      	ldr	r0, [pc, #384]	; (759c <AJ_Discover+0x430>)
    741a:	a912      	add	r1, sp, #72	; 0x48
    741c:	2206      	movs	r2, #6
    741e:	4b5e      	ldr	r3, [pc, #376]	; (7598 <AJ_Discover+0x42c>)
    7420:	4798      	blx	r3
	if (status != AJ_OK) {
    7422:	2800      	cmp	r0, #0
    7424:	d000      	beq.n	7428 <AJ_Discover+0x2bc>
    7426:	e298      	b.n	795a <AJ_Discover+0x7ee>
		return AJ_ERR_WRITE;
	}
	status = AJ_InetToString(addr, ipv4Str, sizeof(ipv4Str));
    7428:	1c20      	adds	r0, r4, #0
    742a:	a914      	add	r1, sp, #80	; 0x50
    742c:	2211      	movs	r2, #17
    742e:	4b5c      	ldr	r3, [pc, #368]	; (75a0 <AJ_Discover+0x434>)
    7430:	4798      	blx	r3
	if (status != AJ_OK) {
    7432:	2800      	cmp	r0, #0
    7434:	d000      	beq.n	7438 <AJ_Discover+0x2cc>
    7436:	e290      	b.n	795a <AJ_Discover+0x7ee>
	// ASSUMPTIONS: sender-info resource record is the final resource record in the packet.
	// sid, ipv4, and upcv4 key value pairs are the final three key/value pairs in the record.
	// The length of the other fields in the record are static.
	//
	// search backwards through packet to find the start of "sender-info"
	pkt = buf->writePtr;
    7438:	9c20      	ldr	r4, [sp, #128]	; 0x80
		if (*(pkt--) == snd[match]) {
			match++;
			} else {
			match = 0;
		}
	} while (pkt != buf->readPtr && match != 4);
    743a:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	// sid, ipv4, and upcv4 key value pairs are the final three key/value pairs in the record.
	// The length of the other fields in the record are static.
	//
	// search backwards through packet to find the start of "sender-info"
	pkt = buf->writePtr;
	match = 0;
    743c:	2200      	movs	r2, #0
    743e:	e001      	b.n	7444 <AJ_Discover+0x2d8>
	do {
		if (*(pkt--) == snd[match]) {
			match++;
			} else {
			match = 0;
    7440:	2200      	movs	r2, #0
    7442:	1c1c      	adds	r4, r3, #0
	//
	// search backwards through packet to find the start of "sender-info"
	pkt = buf->writePtr;
	match = 0;
	do {
		if (*(pkt--) == snd[match]) {
    7444:	1e63      	subs	r3, r4, #1
    7446:	7858      	ldrb	r0, [r3, #1]
    7448:	a90a      	add	r1, sp, #40	; 0x28
    744a:	5c89      	ldrb	r1, [r1, r2]
    744c:	4288      	cmp	r0, r1
    744e:	d000      	beq.n	7452 <AJ_Discover+0x2e6>
    7450:	e280      	b.n	7954 <AJ_Discover+0x7e8>
			match++;
    7452:	3201      	adds	r2, #1
			} else {
			match = 0;
		}
	} while (pkt != buf->readPtr && match != 4);
    7454:	429f      	cmp	r7, r3
    7456:	d002      	beq.n	745e <AJ_Discover+0x2f2>
    7458:	2a04      	cmp	r2, #4
    745a:	d1f2      	bne.n	7442 <AJ_Discover+0x2d6>
    745c:	e002      	b.n	7464 <AJ_Discover+0x2f8>
	if (match != 4) {
    745e:	2a04      	cmp	r2, #4
    7460:	d000      	beq.n	7464 <AJ_Discover+0x2f8>
    7462:	e27a      	b.n	795a <AJ_Discover+0x7ee>
	// move forward to the Data Length field
	pkt += 22;

	// actual data length is the length of the static values already in the buffer plus
	// the three dynamic key-value pairs to re-write
	dataLength = 23 + 1 + sizeof(sid) + strlen(sidStr) + 1 + sizeof(ipv4) + strlen(ipv4Str) + 1 + sizeof(upcv4) + strlen(upcv4Str);
    7464:	a810      	add	r0, sp, #64	; 0x40
    7466:	4f36      	ldr	r7, [pc, #216]	; (7540 <AJ_Discover+0x3d4>)
    7468:	47b8      	blx	r7
    746a:	4680      	mov	r8, r0
    746c:	a814      	add	r0, sp, #80	; 0x50
    746e:	47b8      	blx	r7
    7470:	9006      	str	r0, [sp, #24]
    7472:	a812      	add	r0, sp, #72	; 0x48
    7474:	47b8      	blx	r7
    7476:	9b06      	ldr	r3, [sp, #24]
    7478:	4443      	add	r3, r8
    747a:	3329      	adds	r3, #41	; 0x29
    747c:	181b      	adds	r3, r3, r0
    747e:	b29b      	uxth	r3, r3
	*pkt++ = (dataLength >> 8) & 0xFF;
    7480:	0a1a      	lsrs	r2, r3, #8
    7482:	7562      	strb	r2, [r4, #21]
	*pkt++ = dataLength & 0xFF;
    7484:	75a3      	strb	r3, [r4, #22]

	// move forward past the static key-value pairs
	pkt += 23;

	// ASSERT: must be at the start of "sid="
	assert(*(pkt + 1) == 's');
    7486:	232f      	movs	r3, #47	; 0x2f
    7488:	5ce3      	ldrb	r3, [r4, r3]
    748a:	2b73      	cmp	r3, #115	; 0x73
    748c:	d006      	beq.n	749c <AJ_Discover+0x330>
    748e:	482d      	ldr	r0, [pc, #180]	; (7544 <AJ_Discover+0x3d8>)
    7490:	219e      	movs	r1, #158	; 0x9e
    7492:	31ff      	adds	r1, #255	; 0xff
    7494:	4a43      	ldr	r2, [pc, #268]	; (75a4 <AJ_Discover+0x438>)
    7496:	4b44      	ldr	r3, [pc, #272]	; (75a8 <AJ_Discover+0x43c>)
    7498:	4c44      	ldr	r4, [pc, #272]	; (75ac <AJ_Discover+0x440>)
    749a:	47a0      	blx	r4

	// re-write new values
	*pkt++ = sizeof(sid) + strlen(sidStr);
    749c:	a810      	add	r0, sp, #64	; 0x40
    749e:	4f28      	ldr	r7, [pc, #160]	; (7540 <AJ_Discover+0x3d4>)
    74a0:	47b8      	blx	r7
    74a2:	3004      	adds	r0, #4
    74a4:	232e      	movs	r3, #46	; 0x2e
    74a6:	54e0      	strb	r0, [r4, r3]
	memcpy(pkt, sid, sizeof(sid));
    74a8:	1c20      	adds	r0, r4, #0
    74aa:	302f      	adds	r0, #47	; 0x2f
    74ac:	a90b      	add	r1, sp, #44	; 0x2c
    74ae:	2204      	movs	r2, #4
    74b0:	4b27      	ldr	r3, [pc, #156]	; (7550 <AJ_Discover+0x3e4>)
    74b2:	4698      	mov	r8, r3
    74b4:	4798      	blx	r3
	pkt += sizeof(sid);
    74b6:	3433      	adds	r4, #51	; 0x33
	memcpy(pkt, sidStr, strlen(sidStr));
    74b8:	a810      	add	r0, sp, #64	; 0x40
    74ba:	47b8      	blx	r7
    74bc:	1c02      	adds	r2, r0, #0
    74be:	1c20      	adds	r0, r4, #0
    74c0:	a910      	add	r1, sp, #64	; 0x40
    74c2:	47c0      	blx	r8
	pkt += strlen(sidStr);
    74c4:	a810      	add	r0, sp, #64	; 0x40
    74c6:	47b8      	blx	r7
    74c8:	1824      	adds	r4, r4, r0

	*pkt++ = sizeof(ipv4) + strlen(ipv4Str);
    74ca:	a814      	add	r0, sp, #80	; 0x50
    74cc:	47b8      	blx	r7
    74ce:	3005      	adds	r0, #5
    74d0:	7020      	strb	r0, [r4, #0]
	memcpy(pkt, ipv4, sizeof(ipv4));
    74d2:	1c60      	adds	r0, r4, #1
    74d4:	a90c      	add	r1, sp, #48	; 0x30
    74d6:	2205      	movs	r2, #5
    74d8:	47c0      	blx	r8
	pkt += sizeof(ipv4);
    74da:	3406      	adds	r4, #6
	memcpy(pkt, ipv4Str, strlen(ipv4Str));
    74dc:	a814      	add	r0, sp, #80	; 0x50
    74de:	47b8      	blx	r7
    74e0:	1c02      	adds	r2, r0, #0
    74e2:	1c20      	adds	r0, r4, #0
    74e4:	a914      	add	r1, sp, #80	; 0x50
    74e6:	47c0      	blx	r8
	pkt += strlen(ipv4Str);
    74e8:	a814      	add	r0, sp, #80	; 0x50
    74ea:	47b8      	blx	r7
    74ec:	1824      	adds	r4, r4, r0

	*pkt++ = sizeof(upcv4) + strlen(upcv4Str);
    74ee:	a812      	add	r0, sp, #72	; 0x48
    74f0:	47b8      	blx	r7
    74f2:	3006      	adds	r0, #6
    74f4:	7020      	strb	r0, [r4, #0]
	memcpy(pkt, upcv4, sizeof(upcv4));
    74f6:	1c60      	adds	r0, r4, #1
    74f8:	a90e      	add	r1, sp, #56	; 0x38
    74fa:	2206      	movs	r2, #6
    74fc:	47c0      	blx	r8
	pkt += sizeof(upcv4);
    74fe:	3407      	adds	r4, #7
	memcpy(pkt, upcv4Str, strlen(upcv4Str));
    7500:	a812      	add	r0, sp, #72	; 0x48
    7502:	47b8      	blx	r7
    7504:	1c02      	adds	r2, r0, #0
    7506:	1c20      	adds	r0, r4, #0
    7508:	a912      	add	r1, sp, #72	; 0x48
    750a:	47c0      	blx	r8
	pkt += strlen(upcv4Str);
    750c:	a812      	add	r0, sp, #72	; 0x48
    750e:	47b8      	blx	r7
    7510:	1824      	adds	r4, r4, r0

	buf->writePtr = pkt;
    7512:	9420      	str	r4, [sp, #128]	; 0x80
    7514:	e04f      	b.n	75b6 <AJ_Discover+0x44a>
    7516:	46c0      	nop			; (mov r8, r8)
    7518:	0001c540 	.word	0x0001c540
    751c:	00016e3d 	.word	0x00016e3d
    7520:	0000c2f5 	.word	0x0000c2f5
    7524:	000063c5 	.word	0x000063c5
    7528:	0001c58c 	.word	0x0001c58c
    752c:	0000d7ad 	.word	0x0000d7ad
    7530:	0001c5a8 	.word	0x0001c5a8
    7534:	00016f5d 	.word	0x00016f5d
    7538:	0001bf50 	.word	0x0001bf50
    753c:	00003a01 	.word	0x00003a01
    7540:	0001715b 	.word	0x0001715b
    7544:	0001bfcc 	.word	0x0001bfcc
    7548:	0000636d 	.word	0x0000636d
    754c:	0001c5c0 	.word	0x0001c5c0
    7550:	00016739 	.word	0x00016739
    7554:	0001c5e4 	.word	0x0001c5e4
    7558:	00004431 	.word	0x00004431
    755c:	000004fc 	.word	0x000004fc
    7560:	0001c60c 	.word	0x0001c60c
    7564:	200006d8 	.word	0x200006d8
    7568:	2000012c 	.word	0x2000012c
    756c:	0001bf7c 	.word	0x0001bf7c
    7570:	0001bfb8 	.word	0x0001bfb8
    7574:	00007a7d 	.word	0x00007a7d
    7578:	0001bfc0 	.word	0x0001bfc0
    757c:	0001bfac 	.word	0x0001bfac
    7580:	00000223 	.word	0x00000223
    7584:	0001c624 	.word	0x0001c624
    7588:	0001c798 	.word	0x0001c798
    758c:	0001c79c 	.word	0x0001c79c
    7590:	0001c744 	.word	0x0001c744
    7594:	20002c1c 	.word	0x20002c1c
    7598:	0000d941 	.word	0x0000d941
    759c:	000014e9 	.word	0x000014e9
    75a0:	0000d969 	.word	0x0000d969
    75a4:	0001bf68 	.word	0x0001bf68
    75a8:	0001c64c 	.word	0x0001c64c
    75ac:	00016629 	.word	0x00016629

    pktLen = pkt - txBuf->writePtr;
    txBuf->writePtr += pktLen;
	    if (RewriteSenderInfo(txBuf, own_IPAddress, port) != AJ_OK)
	    {
		    AJ_WarnPrintf(("AJ_Net_SendTo(): RewriteSenderInfo failed.\n"));
    75b0:	48b7      	ldr	r0, [pc, #732]	; (7890 <AJ_Discover+0x724>)
    75b2:	4bb8      	ldr	r3, [pc, #736]	; (7894 <AJ_Discover+0x728>)
    75b4:	4798      	blx	r3

        AJ_IO_BUF_RESET(&sock.tx);
   //     AJ_InfoPrintf(("AJ_Discover(): mDNS \"%s\"\n", prefix));
	
		// -   -   
        status = ComposeMDnsReq(&sock.tx, prefix, &guid, searchId);
    75b6:	239f      	movs	r3, #159	; 0x9f
    75b8:	aa08      	add	r2, sp, #32
    75ba:	4694      	mov	ip, r2
    75bc:	4463      	add	r3, ip
    75be:	701d      	strb	r5, [r3, #0]
        if (status == AJ_OK)
    75c0:	781b      	ldrb	r3, [r3, #0]
    75c2:	2b00      	cmp	r3, #0
    75c4:	d10f      	bne.n	75e6 <AJ_Discover+0x47a>
		{
            sock.tx.flags |= AJ_IO_BUF_MDNS;
    75c6:	a81d      	add	r0, sp, #116	; 0x74
    75c8:	7842      	ldrb	r2, [r0, #1]
    75ca:	2302      	movs	r3, #2
    75cc:	4313      	orrs	r3, r2
    75ce:	7043      	strb	r3, [r0, #1]
            status = sock.tx.send(&sock.tx);
    75d0:	6903      	ldr	r3, [r0, #16]
    75d2:	4798      	blx	r3
    75d4:	239f      	movs	r3, #159	; 0x9f
    75d6:	aa08      	add	r2, sp, #32
    75d8:	4694      	mov	ip, r2
    75da:	4463      	add	r3, ip
    75dc:	7018      	strb	r0, [r3, #0]
    //        printf("AJ_Discover(): mDNS send status=%s\n", AJ_StatusText(status));
            if (status != AJ_OK)
    75de:	781b      	ldrb	r3, [r3, #0]
    75e0:	2b00      	cmp	r3, #0
    75e2:	d006      	beq.n	75f2 <AJ_Discover+0x486>
    75e4:	e197      	b.n	7916 <AJ_Discover+0x7aa>
                goto _Exit;
            }
        } 
		else 
		{
            status = AJ_OK;
    75e6:	2200      	movs	r2, #0
    75e8:	239f      	movs	r3, #159	; 0x9f
    75ea:	a908      	add	r1, sp, #32
    75ec:	468c      	mov	ip, r1
    75ee:	4463      	add	r3, ip
    75f0:	701a      	strb	r2, [r3, #0]
                   }
            listen = interval + AJ_BURST_INTERVAL;
        }
		else 
		{
            listen = AJ_BURST_INTERVAL;
    75f2:	2464      	movs	r4, #100	; 0x64
		{
            status = AJ_OK;
        }

        // Calculate listen interval
        if (burstCount >= AJ_BURST_COUNT)
    75f4:	465b      	mov	r3, fp
    75f6:	2b02      	cmp	r3, #2
    75f8:	d918      	bls.n	762c <AJ_Discover+0x4c0>
		{
            burstCount = 0;
            searchId++;
    75fa:	4aa7      	ldr	r2, [pc, #668]	; (7898 <AJ_Discover+0x72c>)
    75fc:	6813      	ldr	r3, [r2, #0]
    75fe:	3301      	adds	r3, #1
    7600:	6013      	str	r3, [r2, #0]
            queries++;
    7602:	2301      	movs	r3, #1
    7604:	469c      	mov	ip, r3
    7606:	44e2      	add	sl, ip
            if (queries == 10) 
    7608:	4653      	mov	r3, sl
    760a:	2b0a      	cmp	r3, #10
    760c:	d005      	beq.n	761a <AJ_Discover+0x4ae>
			{
                interval = 10000;
            }
			else 
			   if (queries == 11)
    760e:	2b0b      	cmp	r3, #11
    7610:	d006      	beq.n	7620 <AJ_Discover+0x4b4>
			   {
                  interval = 20000;
				  
               } 
			   else
			       if (queries >= 12)
    7612:	d907      	bls.n	7624 <AJ_Discover+0x4b8>
				   {
                     interval = 40000;
    7614:	4ba1      	ldr	r3, [pc, #644]	; (789c <AJ_Discover+0x730>)
    7616:	9304      	str	r3, [sp, #16]
    7618:	e004      	b.n	7624 <AJ_Discover+0x4b8>
            burstCount = 0;
            searchId++;
            queries++;
            if (queries == 10) 
			{
                interval = 10000;
    761a:	4ba1      	ldr	r3, [pc, #644]	; (78a0 <AJ_Discover+0x734>)
    761c:	9304      	str	r3, [sp, #16]
    761e:	e001      	b.n	7624 <AJ_Discover+0x4b8>
            }
			else 
			   if (queries == 11)
			   {
                  interval = 20000;
    7620:	4ba0      	ldr	r3, [pc, #640]	; (78a4 <AJ_Discover+0x738>)
    7622:	9304      	str	r3, [sp, #16]
			   else
			       if (queries >= 12)
				   {
                     interval = 40000;
                   }
            listen = interval + AJ_BURST_INTERVAL;
    7624:	9c04      	ldr	r4, [sp, #16]
    7626:	3464      	adds	r4, #100	; 0x64
        }

        // Calculate listen interval
        if (burstCount >= AJ_BURST_COUNT)
		{
            burstCount = 0;
    7628:	2300      	movs	r3, #0
    762a:	469b      	mov	fp, r3
		{
            listen = AJ_BURST_INTERVAL;
        }

        // If selection period has not passed do not listen longer than the selection timeout
        if ((selection > 0) && (listen > selection))
    762c:	2e00      	cmp	r6, #0
    762e:	dd02      	ble.n	7636 <AJ_Discover+0x4ca>
    7630:	42b4      	cmp	r4, r6
    7632:	dd00      	ble.n	7636 <AJ_Discover+0x4ca>
    7634:	1c34      	adds	r4, r6, #0
    7636:	454c      	cmp	r4, r9
    7638:	dd00      	ble.n	763c <AJ_Discover+0x4d0>
    763a:	464c      	mov	r4, r9
		{
            listen = discover;
        }

        // recv for the listen period
        AJ_InitTimer(&listenTimer);
    763c:	a82b      	add	r0, sp, #172	; 0xac
    763e:	4b9a      	ldr	r3, [pc, #616]	; (78a8 <AJ_Discover+0x73c>)
    7640:	4798      	blx	r3
        while (listen > 0)
    7642:	2c00      	cmp	r4, #0
    7644:	dc00      	bgt.n	7648 <AJ_Discover+0x4dc>
    7646:	e152      	b.n	78ee <AJ_Discover+0x782>
				sock.rx.flags|= AJ_IO_BUF_MDNS;
              if (sock.rx.flags & AJ_IO_BUF_MDNS) 
				{
	//				printf("ParseMDNSResp\n");
                    memset(service, 0, sizeof(AJ_Service));
                    status = ParseMDNSResp(&sock.rx, prefix, service);
    7648:	1c22      	adds	r2, r4, #0

        // recv for the listen period
        AJ_InitTimer(&listenTimer);
        while (listen > 0)
		 {
            AJ_IO_BUF_RESET(&sock.rx);
    764a:	ab1d      	add	r3, sp, #116	; 0x74
    764c:	9924      	ldr	r1, [sp, #144]	; 0x90
    764e:	9125      	str	r1, [sp, #148]	; 0x94
    7650:	9126      	str	r1, [sp, #152]	; 0x98
    7652:	2100      	movs	r1, #0
    7654:	7659      	strb	r1, [r3, #25]
	//		printf("Receive started\n");
	//		printf("listen = %d\n",listen);
            status = sock.rx.recv(&sock.rx, AJ_IO_BUF_SPACE(&sock.rx), listen);
    7656:	1c15      	adds	r5, r2, #0
    7658:	8b59      	ldrh	r1, [r3, #26]
    765a:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    765c:	a823      	add	r0, sp, #140	; 0x8c
    765e:	4798      	blx	r3
    7660:	239f      	movs	r3, #159	; 0x9f
    7662:	aa08      	add	r2, sp, #32
    7664:	4694      	mov	ip, r2
    7666:	4463      	add	r3, ip
    7668:	7018      	strb	r0, [r3, #0]
		/*	if (sock_rx_state==0)
			{
				 goto _Exit;
				
			}*/
                if (status != AJ_OK) 
    766a:	781c      	ldrb	r4, [r3, #0]
    766c:	b2e4      	uxtb	r4, r4
    766e:	2c00      	cmp	r4, #0
    7670:	d003      	beq.n	767a <AJ_Discover+0x50e>
			    {
                // Anything other than AJ_ERR_TIMEOUT means bail
                if (status != AJ_ERR_TIMEOUT)
    7672:	239f      	movs	r3, #159	; 0x9f
    7674:	4463      	add	r3, ip
    7676:	781b      	ldrb	r3, [r3, #0]
    7678:	e131      	b.n	78de <AJ_Discover+0x772>
            } 
			else
			{
	//			printf("---------------Parse------------\n");
	//			printf("sock.rx.flags=%d\n",sock.rx.flags);
				sock_rx_state=0;
    767a:	2300      	movs	r3, #0
    767c:	4a8b      	ldr	r2, [pc, #556]	; (78ac <AJ_Discover+0x740>)
    767e:	6013      	str	r3, [r2, #0]
				sock.rx.flags|= AJ_IO_BUF_MDNS;
    7680:	ab1d      	add	r3, sp, #116	; 0x74
    7682:	7e59      	ldrb	r1, [r3, #25]
    7684:	2202      	movs	r2, #2
    7686:	430a      	orrs	r2, r1
    7688:	765a      	strb	r2, [r3, #25]
              if (sock.rx.flags & AJ_IO_BUF_MDNS) 
				{
	//				printf("ParseMDNSResp\n");
                    memset(service, 0, sizeof(AJ_Service));
    768a:	9f03      	ldr	r7, [sp, #12]
    768c:	1c38      	adds	r0, r7, #0
    768e:	2100      	movs	r1, #0
    7690:	223c      	movs	r2, #60	; 0x3c
    7692:	4b87      	ldr	r3, [pc, #540]	; (78b0 <AJ_Discover+0x744>)
    7694:	4798      	blx	r3
                    status = ParseMDNSResp(&sock.rx, prefix, service);
    7696:	a823      	add	r0, sp, #140	; 0x8c
    7698:	9902      	ldr	r1, [sp, #8]
    769a:	1c3a      	adds	r2, r7, #0
    769c:	4b85      	ldr	r3, [pc, #532]	; (78b4 <AJ_Discover+0x748>)
    769e:	4798      	blx	r3
    76a0:	239f      	movs	r3, #159	; 0x9f
    76a2:	aa08      	add	r2, sp, #32
    76a4:	4694      	mov	ip, r2
    76a6:	4463      	add	r3, ip
    76a8:	7018      	strb	r0, [r3, #0]
                    if (status == AJ_OK)
    76aa:	781b      	ldrb	r3, [r3, #0]
    76ac:	2b00      	cmp	r3, #0
    76ae:	d10f      	bne.n	76d0 <AJ_Discover+0x564>
					{
                        printf("AJ_Discover(): mDNS discovered \"%s\"\n", prefix);
    76b0:	4881      	ldr	r0, [pc, #516]	; (78b8 <AJ_Discover+0x74c>)
    76b2:	9902      	ldr	r1, [sp, #8]
    76b4:	4b81      	ldr	r3, [pc, #516]	; (78bc <AJ_Discover+0x750>)
    76b6:	4798      	blx	r3

                        // skip blacklisted addresses!
						//       ()
                        if (!AJ_IsRoutingNodeBlacklisted(service)) 
    76b8:	9803      	ldr	r0, [sp, #12]
    76ba:	4b81      	ldr	r3, [pc, #516]	; (78c0 <AJ_Discover+0x754>)
    76bc:	4798      	blx	r3
    76be:	2800      	cmp	r0, #0
    76c0:	d103      	bne.n	76ca <AJ_Discover+0x55e>
						{
							//     
                            AJ_AddRoutingNodeToResponseList(service);
    76c2:	9803      	ldr	r0, [sp, #12]
    76c4:	4b7f      	ldr	r3, [pc, #508]	; (78c4 <AJ_Discover+0x758>)
    76c6:	4798      	blx	r3
    76c8:	e002      	b.n	76d0 <AJ_Discover+0x564>
                        } 
						else
						{
                            printf("AJ_Discover(): Skipping blacklisted Routing Node\n");
    76ca:	487f      	ldr	r0, [pc, #508]	; (78c8 <AJ_Discover+0x75c>)
    76cc:	4b71      	ldr	r3, [pc, #452]	; (7894 <AJ_Discover+0x728>)
    76ce:	4798      	blx	r3
                        }
                    }
                }
                if (sock.rx.flags & AJ_IO_BUF_AJ)
    76d0:	ab1d      	add	r3, sp, #116	; 0x74
    76d2:	7e5b      	ldrb	r3, [r3, #25]
    76d4:	07db      	lsls	r3, r3, #31
    76d6:	d400      	bmi.n	76da <AJ_Discover+0x56e>
    76d8:	e101      	b.n	78de <AJ_Discover+0x772>
				 {
					 printf("ParseIsAt\n");
    76da:	487c      	ldr	r0, [pc, #496]	; (78cc <AJ_Discover+0x760>)
    76dc:	4b6d      	ldr	r3, [pc, #436]	; (7894 <AJ_Discover+0x728>)
    76de:	4798      	blx	r3
                    memset(service, 0, sizeof(AJ_Service));
    76e0:	9f03      	ldr	r7, [sp, #12]
    76e2:	1c38      	adds	r0, r7, #0
    76e4:	2100      	movs	r1, #0
    76e6:	223c      	movs	r2, #60	; 0x3c
    76e8:	4b71      	ldr	r3, [pc, #452]	; (78b0 <AJ_Discover+0x744>)
    76ea:	4798      	blx	r3

static AJ_Status ParseIsAt(AJ_IOBuffer* rxBuf, const char* prefix, AJ_Service* service)
{
    AJ_Status status = AJ_ERR_NO_MATCH;
    size_t preLen = strlen(prefix);
    NSHeader* hdr = (NSHeader*)rxBuf->readPtr;
    76ec:	9b25      	ldr	r3, [sp, #148]	; 0x94
    76ee:	4698      	mov	r8, r3
    uint32_t len = AJ_IO_BUF_AVAIL(rxBuf);
    76f0:	9926      	ldr	r1, [sp, #152]	; 0x98
    uint8_t* p = rxBuf->readPtr + 4;
    uint8_t* eod = (uint8_t*)hdr + len;

    AJ_InfoPrintf(("ParseIsAt(rxbuf=0x%p, prefix=\"%s\", service=0x%p)\n", rxBuf, prefix, service));

    service->addrTypes = 0;
    76f2:	2300      	movs	r3, #0
    76f4:	703b      	strb	r3, [r7, #0]

    // Silently ignore versions we don't know how to parse
    if (MSG_VERSION(hdr->version) != MSG_V1)
    76f6:	4643      	mov	r3, r8
    76f8:	781b      	ldrb	r3, [r3, #0]
    76fa:	220f      	movs	r2, #15
    76fc:	4013      	ands	r3, r2
    76fe:	2b01      	cmp	r3, #1
    7700:	d000      	beq.n	7704 <AJ_Discover+0x598>
    7702:	e09c      	b.n	783e <AJ_Discover+0x6d2>
{
    AJ_Status status = AJ_ERR_NO_MATCH;
    size_t preLen = strlen(prefix);
    NSHeader* hdr = (NSHeader*)rxBuf->readPtr;
    uint32_t len = AJ_IO_BUF_AVAIL(rxBuf);
    uint8_t* p = rxBuf->readPtr + 4;
    7704:	4643      	mov	r3, r8
    7706:	3304      	adds	r3, #4
    7708:	46a4      	mov	ip, r4
    770a:	4640      	mov	r0, r8
    770c:	1c1c      	adds	r4, r3, #0
    770e:	e013      	b.n	7738 <AJ_Discover+0x5cc>
    }
    // Questions come in first - we currently ignore them
    while (hdr->qCount--)
    {
        uint8_t flags = *p++;
        uint8_t nameCount = *p++;
    7710:	1ca2      	adds	r2, r4, #2
    7712:	7863      	ldrb	r3, [r4, #1]
        // Questions must be WHO_HAS messages
        if (MSG_TYPE(flags) != WHO_HAS_MSG) 
    7714:	7824      	ldrb	r4, [r4, #0]
    7716:	273f      	movs	r7, #63	; 0x3f
    7718:	43bc      	bics	r4, r7
    771a:	2c80      	cmp	r4, #128	; 0x80
    771c:	d000      	beq.n	7720 <AJ_Discover+0x5b4>
    771e:	e090      	b.n	7842 <AJ_Discover+0x6d6>
    7720:	e007      	b.n	7732 <AJ_Discover+0x5c6>
            return AJ_ERR_INVALID;
        }
        while (nameCount--)
		{
            uint8_t sz = *p++;
            p += sz;
    7722:	7814      	ldrb	r4, [r2, #0]
    7724:	3401      	adds	r4, #1
    7726:	1912      	adds	r2, r2, r4
    7728:	3b01      	subs	r3, #1
    772a:	b2db      	uxtb	r3, r3
            if (p > eod) 
    772c:	4291      	cmp	r1, r2
    772e:	d200      	bcs.n	7732 <AJ_Discover+0x5c6>
    7730:	e089      	b.n	7846 <AJ_Discover+0x6da>
        if (MSG_TYPE(flags) != WHO_HAS_MSG) 
		{
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_INVALID\n"));
            return AJ_ERR_INVALID;
        }
        while (nameCount--)
    7732:	2b00      	cmp	r3, #0
    7734:	d1f5      	bne.n	7722 <AJ_Discover+0x5b6>
    7736:	1c14      	adds	r4, r2, #0
    if (MSG_VERSION(hdr->version) != MSG_V1)
	{
        return status;
    }
    // Questions come in first - we currently ignore them
    while (hdr->qCount--)
    7738:	7843      	ldrb	r3, [r0, #1]
    773a:	1e5a      	subs	r2, r3, #1
    773c:	7042      	strb	r2, [r0, #1]
    773e:	2b00      	cmp	r3, #0
    7740:	d1e6      	bne.n	7710 <AJ_Discover+0x5a4>
    7742:	4680      	mov	r8, r0
    7744:	1c22      	adds	r2, r4, #0
    7746:	4664      	mov	r4, ip
    7748:	465f      	mov	r7, fp
    774a:	4653      	mov	r3, sl
    774c:	9306      	str	r3, [sp, #24]
    774e:	9508      	str	r5, [sp, #32]
    7750:	9409      	str	r4, [sp, #36]	; 0x24
    7752:	46b3      	mov	fp, r6
    7754:	1c14      	adds	r4, r2, #0
    7756:	9e03      	ldr	r6, [sp, #12]
    7758:	e063      	b.n	7822 <AJ_Discover+0x6b6>
        }
    }
    // Now the answers - this is what we are looking for
    while (hdr->aCount--) 
	{
        uint8_t flags = *p++;
    775a:	7825      	ldrb	r5, [r4, #0]
        uint8_t nameCount = *p++;
    775c:	7863      	ldrb	r3, [r4, #1]
    775e:	469a      	mov	sl, r3
        // Answers must be IS_AT messages
        if (MSG_TYPE(flags) != IS_AT_MSG) 
    7760:	233f      	movs	r3, #63	; 0x3f
    7762:	1c2a      	adds	r2, r5, #0
    7764:	439a      	bics	r2, r3
    7766:	2a40      	cmp	r2, #64	; 0x40
    7768:	d16f      	bne.n	784a <AJ_Discover+0x6de>
		{
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_INVALID\n"));
            return AJ_ERR_INVALID;
        }
        // Get transport mask
        service->transportMask = (p[0] << 8) | p[1];
    776a:	78a3      	ldrb	r3, [r4, #2]
    776c:	021b      	lsls	r3, r3, #8
    776e:	78e2      	ldrb	r2, [r4, #3]
    7770:	4313      	orrs	r3, r2
    7772:	8073      	strh	r3, [r6, #2]
        p += 2;
        // Decode addresses
        if (flags & R4_FLAG)
    7774:	072b      	lsls	r3, r5, #28
    7776:	d401      	bmi.n	777c <AJ_Discover+0x610>
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_INVALID\n"));
            return AJ_ERR_INVALID;
        }
        // Get transport mask
        service->transportMask = (p[0] << 8) | p[1];
        p += 2;
    7778:	3404      	adds	r4, #4
    777a:	e014      	b.n	77a6 <AJ_Discover+0x63a>
        // Decode addresses
        if (flags & R4_FLAG)
		{
          //  memcpy(&service->ipv4, p, sizeof(service->ipv4));
			service->ipv4 = (p[0] << 24) | (p[1]<<16)|(p[2]<<8)|p[3];
    777c:	7923      	ldrb	r3, [r4, #4]
    777e:	061a      	lsls	r2, r3, #24
    7780:	7963      	ldrb	r3, [r4, #5]
    7782:	041b      	lsls	r3, r3, #16
    7784:	4313      	orrs	r3, r2
    7786:	79e2      	ldrb	r2, [r4, #7]
    7788:	431a      	orrs	r2, r3
    778a:	79a3      	ldrb	r3, [r4, #6]
    778c:	021b      	lsls	r3, r3, #8
    778e:	4313      	orrs	r3, r2
    7790:	60b3      	str	r3, [r6, #8]
            p += sizeof(service->ipv4);
            service->ipv4port = (p[0] << 8) | p[1];
    7792:	7a23      	ldrb	r3, [r4, #8]
    7794:	021b      	lsls	r3, r3, #8
    7796:	7a62      	ldrb	r2, [r4, #9]
    7798:	4313      	orrs	r3, r2
    779a:	80b3      	strh	r3, [r6, #4]
            p += 2;
    779c:	340a      	adds	r4, #10
            service->addrTypes |= AJ_ADDR_TCP4;
    779e:	7832      	ldrb	r2, [r6, #0]
    77a0:	2304      	movs	r3, #4
    77a2:	4313      	orrs	r3, r2
    77a4:	7033      	strb	r3, [r6, #0]
        }
        if (flags & U4_FLAG) 
    77a6:	076b      	lsls	r3, r5, #29
    77a8:	d50f      	bpl.n	77ca <AJ_Discover+0x65e>
		{
            memcpy(&service->ipv4Udp, p, sizeof(service->ipv4Udp));
    77aa:	1c30      	adds	r0, r6, #0
    77ac:	3028      	adds	r0, #40	; 0x28
    77ae:	1c21      	adds	r1, r4, #0
    77b0:	2204      	movs	r2, #4
    77b2:	4b47      	ldr	r3, [pc, #284]	; (78d0 <AJ_Discover+0x764>)
    77b4:	4798      	blx	r3
            p += sizeof(service->ipv4Udp);
            service->ipv4portUdp = (p[0] << 8) | p[1];
    77b6:	7923      	ldrb	r3, [r4, #4]
    77b8:	021b      	lsls	r3, r3, #8
    77ba:	7962      	ldrb	r2, [r4, #5]
    77bc:	4313      	orrs	r3, r2
    77be:	84b3      	strh	r3, [r6, #36]	; 0x24
            p += 2;
    77c0:	3406      	adds	r4, #6
            service->addrTypes |= AJ_ADDR_UDP4;
    77c2:	7832      	ldrb	r2, [r6, #0]
    77c4:	2301      	movs	r3, #1
    77c6:	4313      	orrs	r3, r2
    77c8:	7033      	strb	r3, [r6, #0]
        }
        if (flags & R6_FLAG) 
    77ca:	07ab      	lsls	r3, r5, #30
    77cc:	d50f      	bpl.n	77ee <AJ_Discover+0x682>
		{
            memcpy(&service->ipv6, p, sizeof(service->ipv6));
    77ce:	1c30      	adds	r0, r6, #0
    77d0:	3014      	adds	r0, #20
    77d2:	1c21      	adds	r1, r4, #0
    77d4:	2210      	movs	r2, #16
    77d6:	4b3e      	ldr	r3, [pc, #248]	; (78d0 <AJ_Discover+0x764>)
    77d8:	4798      	blx	r3
            p += sizeof(service->ipv6);
            service->ipv6port = (p[0] << 8) | p[1];
    77da:	7c23      	ldrb	r3, [r4, #16]
    77dc:	021b      	lsls	r3, r3, #8
    77de:	7c62      	ldrb	r2, [r4, #17]
    77e0:	4313      	orrs	r3, r2
    77e2:	80f3      	strh	r3, [r6, #6]
            p += 2;
    77e4:	3412      	adds	r4, #18
            service->addrTypes |= AJ_ADDR_TCP6;
    77e6:	7832      	ldrb	r2, [r6, #0]
    77e8:	2308      	movs	r3, #8
    77ea:	4313      	orrs	r3, r2
    77ec:	7033      	strb	r3, [r6, #0]
        }
        if (flags & U6_FLAG) 
    77ee:	07eb      	lsls	r3, r5, #31
    77f0:	d50f      	bpl.n	7812 <AJ_Discover+0x6a6>
		{
            memcpy(&service->ipv6Udp, p, sizeof(service->ipv6Udp));
    77f2:	1c30      	adds	r0, r6, #0
    77f4:	302c      	adds	r0, #44	; 0x2c
    77f6:	1c21      	adds	r1, r4, #0
    77f8:	2210      	movs	r2, #16
    77fa:	4b35      	ldr	r3, [pc, #212]	; (78d0 <AJ_Discover+0x764>)
    77fc:	4798      	blx	r3
            p += sizeof(service->ipv6Udp);
            service->ipv6portUdp = (p[0] << 8) | p[1];
    77fe:	7c23      	ldrb	r3, [r4, #16]
    7800:	021b      	lsls	r3, r3, #8
    7802:	7c62      	ldrb	r2, [r4, #17]
    7804:	4313      	orrs	r3, r2
    7806:	84f3      	strh	r3, [r6, #38]	; 0x26
            p += 2;
    7808:	3412      	adds	r4, #18
            service->addrTypes |= AJ_ADDR_UDP6;
    780a:	7832      	ldrb	r2, [r6, #0]
    780c:	2302      	movs	r3, #2
    780e:	4313      	orrs	r3, r2
    7810:	7033      	strb	r3, [r6, #0]
        }
        // Skip guid if it's present
        if (flags & G_FLAG) 
    7812:	06ab      	lsls	r3, r5, #26
    7814:	d502      	bpl.n	781c <AJ_Discover+0x6b0>
		{
            uint8_t sz = *p++;
            len -= 1 + sz;
    7816:	7823      	ldrb	r3, [r4, #0]
    7818:	3301      	adds	r3, #1
            p += sz;
    781a:	18e4      	adds	r4, r4, r3
		{
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_END_OF_DATA\n"));
            return AJ_ERR_END_OF_DATA;
        }*/
        // Iterate over the names
        while (nameCount--)
    781c:	4653      	mov	r3, sl
    781e:	2b00      	cmp	r3, #0
    7820:	d11a      	bne.n	7858 <AJ_Discover+0x6ec>
                goto Exit;
            }
        }
    }
    // Now the answers - this is what we are looking for
    while (hdr->aCount--) 
    7822:	4643      	mov	r3, r8
    7824:	789b      	ldrb	r3, [r3, #2]
    7826:	1e5a      	subs	r2, r3, #1
    7828:	4641      	mov	r1, r8
    782a:	708a      	strb	r2, [r1, #2]
    782c:	2b00      	cmp	r3, #0
    782e:	d194      	bne.n	775a <AJ_Discover+0x5ee>
    7830:	9b06      	ldr	r3, [sp, #24]
    7832:	469a      	mov	sl, r3
    7834:	9d08      	ldr	r5, [sp, #32]
    7836:	465e      	mov	r6, fp
    7838:	46bb      	mov	fp, r7
    return AJ_OK;
}

static AJ_Status ParseIsAt(AJ_IOBuffer* rxBuf, const char* prefix, AJ_Service* service)
{
    AJ_Status status = AJ_ERR_NO_MATCH;
    783a:	2410      	movs	r4, #16
    783c:	e012      	b.n	7864 <AJ_Discover+0x6f8>
    service->addrTypes = 0;

    // Silently ignore versions we don't know how to parse
    if (MSG_VERSION(hdr->version) != MSG_V1)
	{
        return status;
    783e:	2410      	movs	r4, #16
    7840:	e010      	b.n	7864 <AJ_Discover+0x6f8>
        uint8_t nameCount = *p++;
        // Questions must be WHO_HAS messages
        if (MSG_TYPE(flags) != WHO_HAS_MSG) 
		{
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_INVALID\n"));
            return AJ_ERR_INVALID;
    7842:	2403      	movs	r4, #3
    7844:	e00e      	b.n	7864 <AJ_Discover+0x6f8>
            uint8_t sz = *p++;
            p += sz;
            if (p > eod) 
			{
                AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_END_OF_DATA\n"));
                status = AJ_ERR_END_OF_DATA;
    7846:	240a      	movs	r4, #10
    7848:	e00c      	b.n	7864 <AJ_Discover+0x6f8>
    784a:	9b06      	ldr	r3, [sp, #24]
    784c:	469a      	mov	sl, r3
    784e:	9d08      	ldr	r5, [sp, #32]
    7850:	465e      	mov	r6, fp
    7852:	46bb      	mov	fp, r7
        uint8_t nameCount = *p++;
        // Answers must be IS_AT messages
        if (MSG_TYPE(flags) != IS_AT_MSG) 
		{
            AJ_InfoPrintf(("ParseIsAt(): AJ_ERR_INVALID\n"));
            return AJ_ERR_INVALID;
    7854:	2403      	movs	r4, #3
    7856:	e005      	b.n	7864 <AJ_Discover+0x6f8>
    7858:	9b06      	ldr	r3, [sp, #24]
    785a:	469a      	mov	sl, r3
    785c:	9d08      	ldr	r5, [sp, #32]
    785e:	9c09      	ldr	r4, [sp, #36]	; 0x24
    7860:	465e      	mov	r6, fp
    7862:	46bb      	mov	fp, r7
                if (sock.rx.flags & AJ_IO_BUF_AJ)
				 {
					 printf("ParseIsAt\n");
                    memset(service, 0, sizeof(AJ_Service));
					// 
                    status = ParseIsAt(&sock.rx, prefix, service);
    7864:	239f      	movs	r3, #159	; 0x9f
    7866:	aa08      	add	r2, sp, #32
    7868:	4694      	mov	ip, r2
    786a:	4463      	add	r3, ip
    786c:	701c      	strb	r4, [r3, #0]
                    if (status == AJ_OK) 
    786e:	781b      	ldrb	r3, [r3, #0]
    7870:	2b00      	cmp	r3, #0
    7872:	d134      	bne.n	78de <AJ_Discover+0x772>
					{
                        printf("AJ_Discover(): IS-AT discovered \"%s\"\n", prefix);
    7874:	4817      	ldr	r0, [pc, #92]	; (78d4 <AJ_Discover+0x768>)
    7876:	9902      	ldr	r1, [sp, #8]
    7878:	4b10      	ldr	r3, [pc, #64]	; (78bc <AJ_Discover+0x750>)
    787a:	4798      	blx	r3

                        // skip blacklisted addresses!
						//       ()
                        if (!AJ_IsRoutingNodeBlacklisted(service))
    787c:	9803      	ldr	r0, [sp, #12]
    787e:	4b10      	ldr	r3, [pc, #64]	; (78c0 <AJ_Discover+0x754>)
    7880:	4798      	blx	r3
    7882:	2800      	cmp	r0, #0
    7884:	d128      	bne.n	78d8 <AJ_Discover+0x76c>
						{
							//     
                            AJ_AddRoutingNodeToResponseList(service);
    7886:	9803      	ldr	r0, [sp, #12]
    7888:	4b0e      	ldr	r3, [pc, #56]	; (78c4 <AJ_Discover+0x758>)
    788a:	4798      	blx	r3
    788c:	e027      	b.n	78de <AJ_Discover+0x772>
    788e:	46c0      	nop			; (mov r8, r8)
    7890:	0001c660 	.word	0x0001c660
    7894:	00016f5d 	.word	0x00016f5d
    7898:	200006d8 	.word	0x200006d8
    789c:	00009c40 	.word	0x00009c40
    78a0:	00002710 	.word	0x00002710
    78a4:	00004e20 	.word	0x00004e20
    78a8:	0000d7ad 	.word	0x0000d7ad
    78ac:	20001ec8 	.word	0x20001ec8
    78b0:	00016773 	.word	0x00016773
    78b4:	00006b0d 	.word	0x00006b0d
    78b8:	0001c68c 	.word	0x0001c68c
    78bc:	00016e3d 	.word	0x00016e3d
    78c0:	00003c65 	.word	0x00003c65
    78c4:	00003cad 	.word	0x00003cad
    78c8:	0001c6b4 	.word	0x0001c6b4
    78cc:	0001c6e8 	.word	0x0001c6e8
    78d0:	00016739 	.word	0x00016739
    78d4:	0001c6f4 	.word	0x0001c6f4
                        } 
						else 
						{
                           printf("AJ_Discover(): Skipping blacklisted Routing Node\n");
    78d8:	4828      	ldr	r0, [pc, #160]	; (797c <AJ_Discover+0x810>)
    78da:	4b29      	ldr	r3, [pc, #164]	; (7980 <AJ_Discover+0x814>)
    78dc:	4798      	blx	r3
                        }
                    }
				}

            }
            listen -= AJ_GetElapsedTime(&listenTimer, FALSE);
    78de:	a82b      	add	r0, sp, #172	; 0xac
    78e0:	2100      	movs	r1, #0
    78e2:	4b28      	ldr	r3, [pc, #160]	; (7984 <AJ_Discover+0x818>)
    78e4:	4798      	blx	r3
    78e6:	1a2a      	subs	r2, r5, r0
            listen = discover;
        }

        // recv for the listen period
        AJ_InitTimer(&listenTimer);
        while (listen > 0)
    78e8:	2a00      	cmp	r2, #0
    78ea:	dd00      	ble.n	78ee <AJ_Discover+0x782>
    78ec:	e6ad      	b.n	764a <AJ_Discover+0x4de>
				}

            }
            listen -= AJ_GetElapsedTime(&listenTimer, FALSE);
        }
        selection -= AJ_GetElapsedTime(&selectionTimer, FALSE);
    78ee:	a829      	add	r0, sp, #164	; 0xa4
    78f0:	2100      	movs	r1, #0
    78f2:	4b24      	ldr	r3, [pc, #144]	; (7984 <AJ_Discover+0x818>)
    78f4:	4798      	blx	r3
    78f6:	1a36      	subs	r6, r6, r0
        if (selection < 0 && AJ_GetRoutingNodeResponseListSize() > 0) 
    78f8:	d503      	bpl.n	7902 <AJ_Discover+0x796>
    78fa:	4b23      	ldr	r3, [pc, #140]	; (7988 <AJ_Discover+0x81c>)
    78fc:	4798      	blx	r3
    78fe:	2800      	cmp	r0, #0
    7900:	d109      	bne.n	7916 <AJ_Discover+0x7aa>
		{
            break;
        }
        discover -= AJ_GetElapsedTime(&discoverTimer, FALSE);
    7902:	a82d      	add	r0, sp, #180	; 0xb4
    7904:	2100      	movs	r1, #0
    7906:	4b1f      	ldr	r3, [pc, #124]	; (7984 <AJ_Discover+0x818>)
    7908:	4798      	blx	r3
    790a:	464b      	mov	r3, r9
    790c:	1a1b      	subs	r3, r3, r0
    790e:	4699      	mov	r9, r3
    // Perform discovery until node discovered or overall discover timeout reached
    burstCount = 0;
    AJ_InitTimer(&selectionTimer);
    printf("Selection timer started\n");
    AJ_InitTimer(&discoverTimer);
    while (discover > 0) 
    7910:	2b00      	cmp	r3, #0
    7912:	dd00      	ble.n	7916 <AJ_Discover+0x7aa>
    7914:	e472      	b.n	71fc <AJ_Discover+0x90>
        }
        discover -= AJ_GetElapsedTime(&discoverTimer, FALSE);
    }

_Exit:
    memset(service, 0, sizeof(AJ_Service));
    7916:	9c03      	ldr	r4, [sp, #12]
    7918:	1c20      	adds	r0, r4, #0
    791a:	2100      	movs	r1, #0
    791c:	223c      	movs	r2, #60	; 0x3c
    791e:	4b1b      	ldr	r3, [pc, #108]	; (798c <AJ_Discover+0x820>)
    7920:	4798      	blx	r3
	//-   
    status = AJ_SelectRoutingNodeFromResponseList(service);
    7922:	1c20      	adds	r0, r4, #0
    7924:	4b1a      	ldr	r3, [pc, #104]	; (7990 <AJ_Discover+0x824>)
    7926:	4798      	blx	r3
    7928:	249f      	movs	r4, #159	; 0x9f
    792a:	ab08      	add	r3, sp, #32
    792c:	469c      	mov	ip, r3
    792e:	4464      	add	r4, ip
    7930:	7020      	strb	r0, [r4, #0]
    // All done with multicast for now
	// udp
    AJ_Net_MCastDown(&sock);
    7932:	a81d      	add	r0, sp, #116	; 0x74
    7934:	4b17      	ldr	r3, [pc, #92]	; (7994 <AJ_Discover+0x828>)
    7936:	4798      	blx	r3
    if (status != AJ_OK) 
    7938:	7823      	ldrb	r3, [r4, #0]
    793a:	2b00      	cmp	r3, #0
    793c:	d003      	beq.n	7946 <AJ_Discover+0x7da>
	{
        printf("AJ_Discover(): Stop discovery of \"%s\"\n", prefix);
    793e:	4816      	ldr	r0, [pc, #88]	; (7998 <AJ_Discover+0x82c>)
    7940:	9902      	ldr	r1, [sp, #8]
    7942:	4b16      	ldr	r3, [pc, #88]	; (799c <AJ_Discover+0x830>)
    7944:	4798      	blx	r3
    }
    return status;
    7946:	239f      	movs	r3, #159	; 0x9f
    7948:	aa08      	add	r2, sp, #32
    794a:	4694      	mov	ip, r2
    794c:	4463      	add	r3, ip
    794e:	7818      	ldrb	r0, [r3, #0]
    7950:	b2c0      	uxtb	r0, r0
    7952:	e00b      	b.n	796c <AJ_Discover+0x800>
		if (*(pkt--) == snd[match]) {
			match++;
			} else {
			match = 0;
		}
	} while (pkt != buf->readPtr && match != 4);
    7954:	42bb      	cmp	r3, r7
    7956:	d000      	beq.n	795a <AJ_Discover+0x7ee>
    7958:	e572      	b.n	7440 <AJ_Discover+0x2d4>

    pktLen = pkt - txBuf->writePtr;
    txBuf->writePtr += pktLen;
	    if (RewriteSenderInfo(txBuf, own_IPAddress, port) != AJ_OK)
	    {
		    AJ_WarnPrintf(("AJ_Net_SendTo(): RewriteSenderInfo failed.\n"));
    795a:	2002      	movs	r0, #2
    795c:	4910      	ldr	r1, [pc, #64]	; (79a0 <AJ_Discover+0x834>)
    795e:	4a11      	ldr	r2, [pc, #68]	; (79a4 <AJ_Discover+0x838>)
    7960:	4b11      	ldr	r3, [pc, #68]	; (79a8 <AJ_Discover+0x83c>)
    7962:	4798      	blx	r3
    7964:	2800      	cmp	r0, #0
    7966:	d100      	bne.n	796a <AJ_Discover+0x7fe>
    7968:	e625      	b.n	75b6 <AJ_Discover+0x44a>
    796a:	e621      	b.n	75b0 <AJ_Discover+0x444>
    if (status != AJ_OK) 
	{
        printf("AJ_Discover(): Stop discovery of \"%s\"\n", prefix);
    }
    return status;
}
    796c:	b031      	add	sp, #196	; 0xc4
    796e:	bc3c      	pop	{r2, r3, r4, r5}
    7970:	4690      	mov	r8, r2
    7972:	4699      	mov	r9, r3
    7974:	46a2      	mov	sl, r4
    7976:	46ab      	mov	fp, r5
    7978:	bdf0      	pop	{r4, r5, r6, r7, pc}
    797a:	46c0      	nop			; (mov r8, r8)
    797c:	0001c6b4 	.word	0x0001c6b4
    7980:	00016f5d 	.word	0x00016f5d
    7984:	0000d769 	.word	0x0000d769
    7988:	00003e79 	.word	0x00003e79
    798c:	00016773 	.word	0x00016773
    7990:	00003eb1 	.word	0x00003eb1
    7994:	0000c335 	.word	0x0000c335
    7998:	0001c71c 	.word	0x0001c71c
    799c:	00016e3d 	.word	0x00016e3d
    79a0:	0001bfcc 	.word	0x0001bfcc
    79a4:	00000239 	.word	0x00000239
    79a8:	0000636d 	.word	0x0000636d

000079ac <LookupName>:
{
    return AJ_HexToRaw(str, 32, guid->val, 16);
}

static NameToGUID* LookupName(const char* name)
{
    79ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    79ae:	1c06      	adds	r6, r0, #0
    79b0:	4c11      	ldr	r4, [pc, #68]	; (79f8 <LookupName+0x4c>)
    79b2:	3401      	adds	r4, #1
    uint32_t i;
  //  AJ_InfoPrintf(("LookupName(name=\"%s\")\n", name));

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i)
    79b4:	2500      	movs	r5, #0
	{
        if (strcmp(nameMap[i].uniqueName, name) == 0) 
    79b6:	4f11      	ldr	r7, [pc, #68]	; (79fc <LookupName+0x50>)
    79b8:	1c20      	adds	r0, r4, #0
    79ba:	1c31      	adds	r1, r6, #0
    79bc:	47b8      	blx	r7
    79be:	2800      	cmp	r0, #0
    79c0:	d104      	bne.n	79cc <LookupName+0x20>
		{
            return &nameMap[i];
    79c2:	3068      	adds	r0, #104	; 0x68
    79c4:	4345      	muls	r5, r0
    79c6:	480c      	ldr	r0, [pc, #48]	; (79f8 <LookupName+0x4c>)
    79c8:	1940      	adds	r0, r0, r5
    79ca:	e013      	b.n	79f4 <LookupName+0x48>
    79cc:	1c23      	adds	r3, r4, #0
    79ce:	3317      	adds	r3, #23
        }
        if (nameMap[i].serviceName && (strcmp(nameMap[i].serviceName, name)) == 0) 
    79d0:	6818      	ldr	r0, [r3, #0]
    79d2:	2800      	cmp	r0, #0
    79d4:	d009      	beq.n	79ea <LookupName+0x3e>
    79d6:	1c31      	adds	r1, r6, #0
    79d8:	4b08      	ldr	r3, [pc, #32]	; (79fc <LookupName+0x50>)
    79da:	4798      	blx	r3
    79dc:	2800      	cmp	r0, #0
    79de:	d104      	bne.n	79ea <LookupName+0x3e>
		{
            return &nameMap[i];
    79e0:	3068      	adds	r0, #104	; 0x68
    79e2:	4345      	muls	r5, r0
    79e4:	4804      	ldr	r0, [pc, #16]	; (79f8 <LookupName+0x4c>)
    79e6:	1940      	adds	r0, r0, r5
    79e8:	e004      	b.n	79f4 <LookupName+0x48>
static NameToGUID* LookupName(const char* name)
{
    uint32_t i;
  //  AJ_InfoPrintf(("LookupName(name=\"%s\")\n", name));

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i)
    79ea:	3501      	adds	r5, #1
    79ec:	3468      	adds	r4, #104	; 0x68
    79ee:	2d04      	cmp	r5, #4
    79f0:	d1e2      	bne.n	79b8 <LookupName+0xc>
		{
            return &nameMap[i];
        }
    }
 //   AJ_InfoPrintf(("LookupName(): NULL\n"));
    return NULL;
    79f2:	2000      	movs	r0, #0
}
    79f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    79f6:	46c0      	nop			; (mov r8, r8)
    79f8:	200006e0 	.word	0x200006e0
    79fc:	00017137 	.word	0x00017137

00007a00 <SetNameOwnerChangedRule>:
    }
    return AJ_OK;
}

static AJ_Status SetNameOwnerChangedRule(AJ_BusAttachment* bus, const char* oldOwner, uint8_t rule, uint32_t* serialNum)
{
    7a00:	b5f0      	push	{r4, r5, r6, r7, lr}
    7a02:	b085      	sub	sp, #20
    7a04:	9002      	str	r0, [sp, #8]
    7a06:	1c0d      	adds	r5, r1, #0
    7a08:	9203      	str	r2, [sp, #12]
    7a0a:	1c1e      	adds	r6, r3, #0
    size_t ruleLen;
    char* ruleStr;
    const char* rulePrefix = "type='signal',member='NameOwnerChanged',interface='org.freedesktop.DBus',arg1='";
    const char* ruleSuffix = "',arg2=''";

    ruleLen = strlen(rulePrefix) + strlen(oldOwner) + strlen(ruleSuffix);
    7a0c:	1c08      	adds	r0, r1, #0
    7a0e:	4b13      	ldr	r3, [pc, #76]	; (7a5c <SetNameOwnerChangedRule+0x5c>)
    7a10:	4798      	blx	r3
    ruleStr = (char*) AJ_Malloc(ruleLen + 1 /* \0 */);
    7a12:	3059      	adds	r0, #89	; 0x59
    7a14:	4b12      	ldr	r3, [pc, #72]	; (7a60 <SetNameOwnerChangedRule+0x60>)
    7a16:	4798      	blx	r3
    7a18:	1c04      	adds	r4, r0, #0
    if (ruleStr == NULL) 
	{
        return AJ_ERR_RESOURCES;
    7a1a:	200b      	movs	r0, #11
    const char* rulePrefix = "type='signal',member='NameOwnerChanged',interface='org.freedesktop.DBus',arg1='";
    const char* ruleSuffix = "',arg2=''";

    ruleLen = strlen(rulePrefix) + strlen(oldOwner) + strlen(ruleSuffix);
    ruleStr = (char*) AJ_Malloc(ruleLen + 1 /* \0 */);
    if (ruleStr == NULL) 
    7a1c:	2c00      	cmp	r4, #0
    7a1e:	d01b      	beq.n	7a58 <SetNameOwnerChangedRule+0x58>
	{
        return AJ_ERR_RESOURCES;
    }
    strcpy(ruleStr, rulePrefix);
    7a20:	1c20      	adds	r0, r4, #0
    7a22:	4910      	ldr	r1, [pc, #64]	; (7a64 <SetNameOwnerChangedRule+0x64>)
    7a24:	2250      	movs	r2, #80	; 0x50
    7a26:	4f10      	ldr	r7, [pc, #64]	; (7a68 <SetNameOwnerChangedRule+0x68>)
    7a28:	47b8      	blx	r7
    strcat(ruleStr, oldOwner);
    7a2a:	1c20      	adds	r0, r4, #0
    7a2c:	1c29      	adds	r1, r5, #0
    7a2e:	4b0f      	ldr	r3, [pc, #60]	; (7a6c <SetNameOwnerChangedRule+0x6c>)
    7a30:	4798      	blx	r3
    strcat(ruleStr, ruleSuffix);
    7a32:	1c20      	adds	r0, r4, #0
    7a34:	4b09      	ldr	r3, [pc, #36]	; (7a5c <SetNameOwnerChangedRule+0x5c>)
    7a36:	4798      	blx	r3
    7a38:	1820      	adds	r0, r4, r0
    7a3a:	490d      	ldr	r1, [pc, #52]	; (7a70 <SetNameOwnerChangedRule+0x70>)
    7a3c:	220a      	movs	r2, #10
    7a3e:	47b8      	blx	r7
    status = AJ_BusSetSignalRuleSerial(bus, ruleStr, rule, 0, serialNum);
    7a40:	9600      	str	r6, [sp, #0]
    7a42:	9802      	ldr	r0, [sp, #8]
    7a44:	1c21      	adds	r1, r4, #0
    7a46:	9a03      	ldr	r2, [sp, #12]
    7a48:	2300      	movs	r3, #0
    7a4a:	4d0a      	ldr	r5, [pc, #40]	; (7a74 <SetNameOwnerChangedRule+0x74>)
    7a4c:	47a8      	blx	r5
    7a4e:	1c05      	adds	r5, r0, #0
    AJ_Free(ruleStr);
    7a50:	1c20      	adds	r0, r4, #0
    7a52:	4b09      	ldr	r3, [pc, #36]	; (7a78 <SetNameOwnerChangedRule+0x78>)
    7a54:	4798      	blx	r3
    return status;
    7a56:	1c28      	adds	r0, r5, #0
}
    7a58:	b005      	add	sp, #20
    7a5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7a5c:	0001715b 	.word	0x0001715b
    7a60:	0000d7dd 	.word	0x0000d7dd
    7a64:	0001c7a0 	.word	0x0001c7a0
    7a68:	00016739 	.word	0x00016739
    7a6c:	0001711d 	.word	0x0001711d
    7a70:	0001c7f0 	.word	0x0001c7f0
    7a74:	00002abd 	.word	0x00002abd
    7a78:	0000d7e9 	.word	0x0000d7e9

00007a7c <AJ_GUID_ToString>:

static AJ_Status SetNameOwnerChangedRule(AJ_BusAttachment* bus, const char* oldOwner, uint8_t rule, uint32_t* serialNum);
static AJ_Status NameHasOwner(AJ_Message* msg, const char* name, uint32_t* serialNum);

AJ_Status AJ_GUID_ToString(const AJ_GUID* guid, char* buffer, uint32_t bufLen)
{
    7a7c:	b510      	push	{r4, lr}
    7a7e:	b082      	sub	sp, #8
    7a80:	1c0c      	adds	r4, r1, #0
    7a82:	1c13      	adds	r3, r2, #0
    return AJ_RawToHex(guid->val, 16, buffer, bufLen, TRUE);
    7a84:	2201      	movs	r2, #1
    7a86:	9200      	str	r2, [sp, #0]
    7a88:	2110      	movs	r1, #16
    7a8a:	1c22      	adds	r2, r4, #0
    7a8c:	4c01      	ldr	r4, [pc, #4]	; (7a94 <AJ_GUID_ToString+0x18>)
    7a8e:	47a0      	blx	r4
}
    7a90:	b002      	add	sp, #8
    7a92:	bd10      	pop	{r4, pc}
    7a94:	0000d86d 	.word	0x0000d86d

00007a98 <AJ_GUID_FromString>:

AJ_Status AJ_GUID_FromString(AJ_GUID* guid, const char* str)
{
    7a98:	b510      	push	{r4, lr}
    7a9a:	1c02      	adds	r2, r0, #0
    return AJ_HexToRaw(str, 32, guid->val, 16);
    7a9c:	1c08      	adds	r0, r1, #0
    7a9e:	2120      	movs	r1, #32
    7aa0:	2310      	movs	r3, #16
    7aa2:	4c01      	ldr	r4, [pc, #4]	; (7aa8 <AJ_GUID_FromString+0x10>)
    7aa4:	47a0      	blx	r4
}
    7aa6:	bd10      	pop	{r4, pc}
    7aa8:	0000d8c1 	.word	0x0000d8c1

00007aac <AJ_GUID_AddNameMapping>:
    }
    return NULL;
}

AJ_Status AJ_GUID_AddNameMapping(AJ_BusAttachment* bus, const AJ_GUID* guid, const char* uniqueName, const char* serviceName)
{
    7aac:	b5f0      	push	{r4, r5, r6, r7, lr}
    7aae:	b087      	sub	sp, #28
    7ab0:	9003      	str	r0, [sp, #12]
    7ab2:	9101      	str	r1, [sp, #4]
    7ab4:	1c14      	adds	r4, r2, #0
    7ab6:	9200      	str	r2, [sp, #0]
    7ab8:	9302      	str	r3, [sp, #8]
    AJ_Status status;
    size_t len = strlen(uniqueName);
    7aba:	1c10      	adds	r0, r2, #0
    7abc:	4b2b      	ldr	r3, [pc, #172]	; (7b6c <AJ_GUID_AddNameMapping+0xc0>)
    7abe:	4798      	blx	r3
    7ac0:	1c05      	adds	r5, r0, #0
    7ac2:	1c06      	adds	r6, r0, #0
    int isNew;
    uint32_t serialNum;

 //   AJ_InfoPrintf(("AJ_GUID_AddNameMapping(guid=0x%p, uniqueName=\"%s\", serviceName=\"%s\")\n", guid, uniqueName, serviceName));

    mapping = LookupName(uniqueName);
    7ac4:	1c20      	adds	r0, r4, #0
    7ac6:	4b2a      	ldr	r3, [pc, #168]	; (7b70 <AJ_GUID_AddNameMapping+0xc4>)
    7ac8:	4798      	blx	r3
    7aca:	1c04      	adds	r4, r0, #0
    isNew = !mapping;
    7acc:	4247      	negs	r7, r0
    7ace:	4147      	adcs	r7, r0
    if (isNew) 
    7ad0:	2f00      	cmp	r7, #0
    7ad2:	d003      	beq.n	7adc <AJ_GUID_AddNameMapping+0x30>
	{
        mapping = LookupName("");
    7ad4:	4827      	ldr	r0, [pc, #156]	; (7b74 <AJ_GUID_AddNameMapping+0xc8>)
    7ad6:	4b26      	ldr	r3, [pc, #152]	; (7b70 <AJ_GUID_AddNameMapping+0xc4>)
    7ad8:	4798      	blx	r3
    7ada:	1c04      	adds	r4, r0, #0
    }
    if (mapping && (len <= AJ_MAX_NAME_SIZE)) 
    7adc:	2c00      	cmp	r4, #0
    7ade:	d035      	beq.n	7b4c <AJ_GUID_AddNameMapping+0xa0>
    7ae0:	2e14      	cmp	r6, #20
    7ae2:	d833      	bhi.n	7b4c <AJ_GUID_AddNameMapping+0xa0>
	{
        if (isNew && (AJ_GetRoutingProtoVersion() >= 11)) 
    7ae4:	2f00      	cmp	r7, #0
    7ae6:	d01d      	beq.n	7b24 <AJ_GUID_AddNameMapping+0x78>
    7ae8:	4b23      	ldr	r3, [pc, #140]	; (7b78 <AJ_GUID_AddNameMapping+0xcc>)
    7aea:	4798      	blx	r3
    7aec:	280a      	cmp	r0, #10
    7aee:	d919      	bls.n	7b24 <AJ_GUID_AddNameMapping+0x78>
		{
            status = SetNameOwnerChangedRule(bus, uniqueName, AJ_BUS_SIGNAL_ALLOW, &serialNum);
    7af0:	9803      	ldr	r0, [sp, #12]
    7af2:	9900      	ldr	r1, [sp, #0]
    7af4:	2200      	movs	r2, #0
    7af6:	ab05      	add	r3, sp, #20
    7af8:	4e20      	ldr	r6, [pc, #128]	; (7b7c <AJ_GUID_AddNameMapping+0xd0>)
    7afa:	47b0      	blx	r6
    7afc:	1e06      	subs	r6, r0, #0
            if (status != AJ_OK) 
    7afe:	d00f      	beq.n	7b20 <AJ_GUID_AddNameMapping+0x74>
			{
                AJ_ErrPrintf(("AJ_GUID_AddNameMapping(guid=0x%p, uniqueName=\"%s\", serviceName=\"%s\"): Add match rule error\n", guid, uniqueName, serviceName));
    7b00:	2001      	movs	r0, #1
    7b02:	491f      	ldr	r1, [pc, #124]	; (7b80 <AJ_GUID_AddNameMapping+0xd4>)
    7b04:	2281      	movs	r2, #129	; 0x81
    7b06:	4b1f      	ldr	r3, [pc, #124]	; (7b84 <AJ_GUID_AddNameMapping+0xd8>)
    7b08:	4798      	blx	r3
                return status;
    7b0a:	1c33      	adds	r3, r6, #0
        if (isNew && (AJ_GetRoutingProtoVersion() >= 11)) 
		{
            status = SetNameOwnerChangedRule(bus, uniqueName, AJ_BUS_SIGNAL_ALLOW, &serialNum);
            if (status != AJ_OK) 
			{
                AJ_ErrPrintf(("AJ_GUID_AddNameMapping(guid=0x%p, uniqueName=\"%s\", serviceName=\"%s\"): Add match rule error\n", guid, uniqueName, serviceName));
    7b0c:	2800      	cmp	r0, #0
    7b0e:	d029      	beq.n	7b64 <AJ_GUID_AddNameMapping+0xb8>
    7b10:	481d      	ldr	r0, [pc, #116]	; (7b88 <AJ_GUID_AddNameMapping+0xdc>)
    7b12:	9901      	ldr	r1, [sp, #4]
    7b14:	9a00      	ldr	r2, [sp, #0]
    7b16:	9b02      	ldr	r3, [sp, #8]
    7b18:	4c1c      	ldr	r4, [pc, #112]	; (7b8c <AJ_GUID_AddNameMapping+0xe0>)
    7b1a:	47a0      	blx	r4
                return status;
    7b1c:	1c33      	adds	r3, r6, #0
    7b1e:	e021      	b.n	7b64 <AJ_GUID_AddNameMapping+0xb8>
            }
            mapping->replySerial = serialNum;
    7b20:	9b05      	ldr	r3, [sp, #20]
    7b22:	64e3      	str	r3, [r4, #76]	; 0x4c
        }
        memcpy(&mapping->guid, guid, sizeof(AJ_GUID));
    7b24:	1c20      	adds	r0, r4, #0
    7b26:	301c      	adds	r0, #28
    7b28:	9901      	ldr	r1, [sp, #4]
    7b2a:	2210      	movs	r2, #16
    7b2c:	4f18      	ldr	r7, [pc, #96]	; (7b90 <AJ_GUID_AddNameMapping+0xe4>)
    7b2e:	47b8      	blx	r7
        memcpy(&mapping->uniqueName, uniqueName, len + 1);
    7b30:	1c60      	adds	r0, r4, #1
    7b32:	1c6a      	adds	r2, r5, #1
    7b34:	9900      	ldr	r1, [sp, #0]
    7b36:	47b8      	blx	r7
        mapping->serviceName = serviceName;
    7b38:	9b02      	ldr	r3, [sp, #8]
    7b3a:	61a3      	str	r3, [r4, #24]
        mapping->incoming.serial = 0;
    7b3c:	2300      	movs	r3, #0
    7b3e:	65a3      	str	r3, [r4, #88]	; 0x58
        mapping->incoming.offset = 0;
    7b40:	2200      	movs	r2, #0
    7b42:	2300      	movs	r3, #0
    7b44:	6622      	str	r2, [r4, #96]	; 0x60
    7b46:	6663      	str	r3, [r4, #100]	; 0x64
        return AJ_OK;
    7b48:	2300      	movs	r3, #0
    7b4a:	e00b      	b.n	7b64 <AJ_GUID_AddNameMapping+0xb8>
    } 
	else 
	{
        AJ_ErrPrintf(("AJ_GUID_AddNameMapping(): AJ_ERR_RESOURCES\n"));
    7b4c:	2001      	movs	r0, #1
    7b4e:	490c      	ldr	r1, [pc, #48]	; (7b80 <AJ_GUID_AddNameMapping+0xd4>)
    7b50:	228f      	movs	r2, #143	; 0x8f
    7b52:	4b0c      	ldr	r3, [pc, #48]	; (7b84 <AJ_GUID_AddNameMapping+0xd8>)
    7b54:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    7b56:	230b      	movs	r3, #11
        mapping->incoming.offset = 0;
        return AJ_OK;
    } 
	else 
	{
        AJ_ErrPrintf(("AJ_GUID_AddNameMapping(): AJ_ERR_RESOURCES\n"));
    7b58:	2800      	cmp	r0, #0
    7b5a:	d003      	beq.n	7b64 <AJ_GUID_AddNameMapping+0xb8>
    7b5c:	480d      	ldr	r0, [pc, #52]	; (7b94 <AJ_GUID_AddNameMapping+0xe8>)
    7b5e:	4b0e      	ldr	r3, [pc, #56]	; (7b98 <AJ_GUID_AddNameMapping+0xec>)
    7b60:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    7b62:	230b      	movs	r3, #11
    }
}
    7b64:	1c18      	adds	r0, r3, #0
    7b66:	b007      	add	sp, #28
    7b68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7b6a:	46c0      	nop			; (mov r8, r8)
    7b6c:	0001715b 	.word	0x0001715b
    7b70:	000079ad 	.word	0x000079ad
    7b74:	0001d368 	.word	0x0001d368
    7b78:	00003a11 	.word	0x00003a11
    7b7c:	00007a01 	.word	0x00007a01
    7b80:	0001c7fc 	.word	0x0001c7fc
    7b84:	0000636d 	.word	0x0000636d
    7b88:	0001c824 	.word	0x0001c824
    7b8c:	00016e3d 	.word	0x00016e3d
    7b90:	00016739 	.word	0x00016739
    7b94:	0001c880 	.word	0x0001c880
    7b98:	00016f5d 	.word	0x00016f5d

00007b9c <AJ_GUID_DeleteNameMapping>:

void AJ_GUID_DeleteNameMapping(AJ_BusAttachment* bus, const char* uniqueName)
{
    7b9c:	b570      	push	{r4, r5, r6, lr}
    7b9e:	1c06      	adds	r6, r0, #0
    7ba0:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_GUID_DeleteNameMapping(uniqueName=\"%s\")\n", uniqueName));
    mapping = LookupName(uniqueName);
    7ba2:	1c08      	adds	r0, r1, #0
    7ba4:	4b09      	ldr	r3, [pc, #36]	; (7bcc <AJ_GUID_DeleteNameMapping+0x30>)
    7ba6:	4798      	blx	r3
    7ba8:	1e04      	subs	r4, r0, #0
    if (mapping) 
    7baa:	d00e      	beq.n	7bca <AJ_GUID_DeleteNameMapping+0x2e>
	{
        if (AJ_GetRoutingProtoVersion() >= 11) 
    7bac:	4b08      	ldr	r3, [pc, #32]	; (7bd0 <AJ_GUID_DeleteNameMapping+0x34>)
    7bae:	4798      	blx	r3
    7bb0:	280a      	cmp	r0, #10
    7bb2:	d905      	bls.n	7bc0 <AJ_GUID_DeleteNameMapping+0x24>
		{
            status = SetNameOwnerChangedRule(bus, uniqueName, AJ_BUS_SIGNAL_DENY, NULL);
    7bb4:	1c30      	adds	r0, r6, #0
    7bb6:	1c29      	adds	r1, r5, #0
    7bb8:	2201      	movs	r2, #1
    7bba:	2300      	movs	r3, #0
    7bbc:	4d05      	ldr	r5, [pc, #20]	; (7bd4 <AJ_GUID_DeleteNameMapping+0x38>)
    7bbe:	47a8      	blx	r5
            if (status != AJ_OK) 
			{
 //               AJ_WarnPrintf(("AJ_GUID_DeleteNameMapping(uniqueName=\"%s\"): Remove match rule error\n", uniqueName));
            }
        }
        memset(mapping, 0, sizeof(NameToGUID));
    7bc0:	1c20      	adds	r0, r4, #0
    7bc2:	2100      	movs	r1, #0
    7bc4:	2268      	movs	r2, #104	; 0x68
    7bc6:	4b04      	ldr	r3, [pc, #16]	; (7bd8 <AJ_GUID_DeleteNameMapping+0x3c>)
    7bc8:	4798      	blx	r3
    }
}
    7bca:	bd70      	pop	{r4, r5, r6, pc}
    7bcc:	000079ad 	.word	0x000079ad
    7bd0:	00003a11 	.word	0x00003a11
    7bd4:	00007a01 	.word	0x00007a01
    7bd8:	00016773 	.word	0x00016773

00007bdc <AJ_GUID_Find>:

const AJ_GUID* AJ_GUID_Find(const char* name)
{
    7bdc:	b508      	push	{r3, lr}
    NameToGUID* mapping = LookupName(name);
    7bde:	4b04      	ldr	r3, [pc, #16]	; (7bf0 <AJ_GUID_Find+0x14>)
    7be0:	4798      	blx	r3
  //  AJ_InfoPrintf(("AJ_GUID_Find(name=\"%s\")\n", name));

    return mapping ? &mapping->guid : NULL;
    7be2:	2800      	cmp	r0, #0
    7be4:	d001      	beq.n	7bea <AJ_GUID_Find+0xe>
    7be6:	301c      	adds	r0, #28
    7be8:	e000      	b.n	7bec <AJ_GUID_Find+0x10>
    7bea:	2000      	movs	r0, #0
}
    7bec:	bd08      	pop	{r3, pc}
    7bee:	46c0      	nop			; (mov r8, r8)
    7bf0:	000079ad 	.word	0x000079ad

00007bf4 <AJ_GUID_ClearNameMap>:


void AJ_GUID_ClearNameMap(void)
{
    7bf4:	b508      	push	{r3, lr}
  //  AJ_InfoPrintf(("AJ_GUID_ClearNameMap()\n"));
    memset(nameMap, 0, sizeof(nameMap));
    7bf6:	4803      	ldr	r0, [pc, #12]	; (7c04 <AJ_GUID_ClearNameMap+0x10>)
    7bf8:	2100      	movs	r1, #0
    7bfa:	22d0      	movs	r2, #208	; 0xd0
    7bfc:	0052      	lsls	r2, r2, #1
    7bfe:	4b02      	ldr	r3, [pc, #8]	; (7c08 <AJ_GUID_ClearNameMap+0x14>)
    7c00:	4798      	blx	r3
}
    7c02:	bd08      	pop	{r3, pc}
    7c04:	200006e0 	.word	0x200006e0
    7c08:	00016773 	.word	0x00016773

00007c0c <AJ_SetGroupKey>:

AJ_Status AJ_SetGroupKey(const char* uniqueName, const uint8_t* key)
{
    7c0c:	b510      	push	{r4, lr}
    7c0e:	1c0c      	adds	r4, r1, #0
    NameToGUID* mapping;

   // AJ_InfoPrintf(("AJ_SetGroupKey(uniqueName=\"%s\", key=0x%p)\n", uniqueName, key));

    mapping = LookupName(uniqueName);
    7c10:	4b06      	ldr	r3, [pc, #24]	; (7c2c <AJ_SetGroupKey+0x20>)
    7c12:	4798      	blx	r3
        return AJ_OK;
    } 
	else
	{
    //    AJ_WarnPrintf(("AJ_SetGroupKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    7c14:	2310      	movs	r3, #16
    NameToGUID* mapping;

   // AJ_InfoPrintf(("AJ_SetGroupKey(uniqueName=\"%s\", key=0x%p)\n", uniqueName, key));

    mapping = LookupName(uniqueName);
    if (mapping) 
    7c16:	2800      	cmp	r0, #0
    7c18:	d005      	beq.n	7c26 <AJ_SetGroupKey+0x1a>
	{
        memcpy(mapping->groupKey, key, 16);
    7c1a:	303c      	adds	r0, #60	; 0x3c
    7c1c:	1c21      	adds	r1, r4, #0
    7c1e:	2210      	movs	r2, #16
    7c20:	4b03      	ldr	r3, [pc, #12]	; (7c30 <AJ_SetGroupKey+0x24>)
    7c22:	4798      	blx	r3
        return AJ_OK;
    7c24:	2300      	movs	r3, #0
	else
	{
    //    AJ_WarnPrintf(("AJ_SetGroupKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
}
    7c26:	1c18      	adds	r0, r3, #0
    7c28:	bd10      	pop	{r4, pc}
    7c2a:	46c0      	nop			; (mov r8, r8)
    7c2c:	000079ad 	.word	0x000079ad
    7c30:	00016739 	.word	0x00016739

00007c34 <AJ_SetSessionKey>:

AJ_Status AJ_SetSessionKey(const char* uniqueName, const uint8_t* key, uint8_t role, uint32_t authVersion)
{
    7c34:	b570      	push	{r4, r5, r6, lr}
    7c36:	1c0c      	adds	r4, r1, #0
    7c38:	1c16      	adds	r6, r2, #0
    7c3a:	1c1d      	adds	r5, r3, #0
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_SetGroupKey(uniqueName=\"%s\", key=0x%p)\n", uniqueName, key));

    mapping = LookupName(uniqueName);
    7c3c:	4b07      	ldr	r3, [pc, #28]	; (7c5c <AJ_SetSessionKey+0x28>)
    7c3e:	4798      	blx	r3
        return AJ_OK;
    }
	else
	{
    //    AJ_WarnPrintf(("AJ_SetSessionKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    7c40:	2310      	movs	r3, #16
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_SetGroupKey(uniqueName=\"%s\", key=0x%p)\n", uniqueName, key));

    mapping = LookupName(uniqueName);
    if (mapping)
    7c42:	2800      	cmp	r0, #0
    7c44:	d007      	beq.n	7c56 <AJ_SetSessionKey+0x22>
	{
        mapping->keyRole = role;
    7c46:	7006      	strb	r6, [r0, #0]
        mapping->authVersion = authVersion;
    7c48:	6505      	str	r5, [r0, #80]	; 0x50
        memcpy(mapping->sessionKey, key, 16);
    7c4a:	302c      	adds	r0, #44	; 0x2c
    7c4c:	1c21      	adds	r1, r4, #0
    7c4e:	2210      	movs	r2, #16
    7c50:	4b03      	ldr	r3, [pc, #12]	; (7c60 <AJ_SetSessionKey+0x2c>)
    7c52:	4798      	blx	r3
        return AJ_OK;
    7c54:	2300      	movs	r3, #0
	else
	{
    //    AJ_WarnPrintf(("AJ_SetSessionKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
}
    7c56:	1c18      	adds	r0, r3, #0
    7c58:	bd70      	pop	{r4, r5, r6, pc}
    7c5a:	46c0      	nop			; (mov r8, r8)
    7c5c:	000079ad 	.word	0x000079ad
    7c60:	00016739 	.word	0x00016739

00007c64 <AJ_GetSessionKey>:

AJ_Status AJ_GetSessionKey(const char* name, uint8_t* key, uint8_t* role, uint32_t* authVersion)
{
    7c64:	b570      	push	{r4, r5, r6, lr}
    7c66:	1c0c      	adds	r4, r1, #0
    7c68:	1c15      	adds	r5, r2, #0
    7c6a:	1c1e      	adds	r6, r3, #0
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_GetSessionKey(name=\"%s\", key=0x%p, role=0x%p)\n", name, key, role));

    mapping = LookupName(name);
    7c6c:	4b08      	ldr	r3, [pc, #32]	; (7c90 <AJ_GetSessionKey+0x2c>)
    7c6e:	4798      	blx	r3
        return AJ_OK;
    } 
	else
	{
 //       AJ_WarnPrintf(("AJ_GetSessionKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    7c70:	2310      	movs	r3, #16
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_GetSessionKey(name=\"%s\", key=0x%p, role=0x%p)\n", name, key, role));

    mapping = LookupName(name);
    if (mapping) 
    7c72:	2800      	cmp	r0, #0
    7c74:	d00a      	beq.n	7c8c <AJ_GetSessionKey+0x28>
	{
        *role = mapping->keyRole;
    7c76:	7803      	ldrb	r3, [r0, #0]
    7c78:	702b      	strb	r3, [r5, #0]
        *authVersion = mapping->authVersion;
    7c7a:	6d03      	ldr	r3, [r0, #80]	; 0x50
    7c7c:	6033      	str	r3, [r6, #0]
        memcpy(key, mapping->sessionKey, 16);
    7c7e:	1c01      	adds	r1, r0, #0
    7c80:	312c      	adds	r1, #44	; 0x2c
    7c82:	1c20      	adds	r0, r4, #0
    7c84:	2210      	movs	r2, #16
    7c86:	4b03      	ldr	r3, [pc, #12]	; (7c94 <AJ_GetSessionKey+0x30>)
    7c88:	4798      	blx	r3
        return AJ_OK;
    7c8a:	2300      	movs	r3, #0
	else
	{
 //       AJ_WarnPrintf(("AJ_GetSessionKey(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
}
    7c8c:	1c18      	adds	r0, r3, #0
    7c8e:	bd70      	pop	{r4, r5, r6, pc}
    7c90:	000079ad 	.word	0x000079ad
    7c94:	00016739 	.word	0x00016739

00007c98 <AJ_GetSerialNumbers>:

AJ_Status AJ_GetSerialNumbers(const char* name, AJ_SerialNum** incoming)
{
    7c98:	b510      	push	{r4, lr}
    7c9a:	1c0c      	adds	r4, r1, #0
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_GetSerialNumbers(name=\"%s\", incoming=%p)\n", name, incoming));

    mapping = LookupName(name);
    7c9c:	4b06      	ldr	r3, [pc, #24]	; (7cb8 <AJ_GetSerialNumbers+0x20>)
    7c9e:	4798      	blx	r3
    if (mapping)
    7ca0:	2800      	cmp	r0, #0
    7ca2:	d005      	beq.n	7cb0 <AJ_GetSerialNumbers+0x18>
	{
        if (incoming) 
    7ca4:	2c00      	cmp	r4, #0
    7ca6:	d005      	beq.n	7cb4 <AJ_GetSerialNumbers+0x1c>
		{
            *incoming = &mapping->incoming;
    7ca8:	3058      	adds	r0, #88	; 0x58
    7caa:	6020      	str	r0, [r4, #0]
        }
        return AJ_OK;
    7cac:	2000      	movs	r0, #0
    7cae:	e002      	b.n	7cb6 <AJ_GetSerialNumbers+0x1e>
    } 
	else
	{
   //     AJ_WarnPrintf(("AJ_GetSerialNumbers(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    7cb0:	2010      	movs	r0, #16
    7cb2:	e000      	b.n	7cb6 <AJ_GetSerialNumbers+0x1e>
	{
        if (incoming) 
		{
            *incoming = &mapping->incoming;
        }
        return AJ_OK;
    7cb4:	2000      	movs	r0, #0
	else
	{
   //     AJ_WarnPrintf(("AJ_GetSerialNumbers(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
}
    7cb6:	bd10      	pop	{r4, pc}
    7cb8:	000079ad 	.word	0x000079ad

00007cbc <AJ_GetRemoteUniqueName>:

AJ_Status AJ_GetRemoteUniqueName(const char* name, const char** unique)
{
    7cbc:	b510      	push	{r4, lr}
    7cbe:	1c0c      	adds	r4, r1, #0
    NameToGUID* mapping;

  //  AJ_InfoPrintf(("AJ_GetRemoteUniqueName(name=\"%s\", unique=%p)\n", name, unique));

    mapping = LookupName(name);
    7cc0:	4b04      	ldr	r3, [pc, #16]	; (7cd4 <AJ_GetRemoteUniqueName+0x18>)
    7cc2:	4798      	blx	r3
    if (mapping) 
    7cc4:	2800      	cmp	r0, #0
    7cc6:	d003      	beq.n	7cd0 <AJ_GetRemoteUniqueName+0x14>
	{
        *unique = mapping->uniqueName;
    7cc8:	3001      	adds	r0, #1
    7cca:	6020      	str	r0, [r4, #0]
        return AJ_OK;
    7ccc:	2000      	movs	r0, #0
    7cce:	e000      	b.n	7cd2 <AJ_GetRemoteUniqueName+0x16>
    }
	else
	{
        return AJ_ERR_NO_MATCH;
    7cd0:	2010      	movs	r0, #16
    }
}
    7cd2:	bd10      	pop	{r4, pc}
    7cd4:	000079ad 	.word	0x000079ad

00007cd8 <AJ_GetGroupKey>:

AJ_Status AJ_GetGroupKey(const char* name, uint8_t* key)
{
    7cd8:	b510      	push	{r4, lr}
    7cda:	1c0c      	adds	r4, r1, #0
  //  AJ_InfoPrintf(("AJ_GetGroupKey(name=\"%s\", key=0x%p)\n", name, key));
    if (name) 
    7cdc:	2800      	cmp	r0, #0
    7cde:	d00c      	beq.n	7cfa <AJ_GetGroupKey+0x22>
	{
        NameToGUID* mapping = LookupName(name);
    7ce0:	4b12      	ldr	r3, [pc, #72]	; (7d2c <AJ_GetGroupKey+0x54>)
    7ce2:	4798      	blx	r3
        if (!mapping) 
		{
    //        AJ_WarnPrintf(("AJ_GetGroupKey(): AJ_ERR_NO_MATCH\n"));
            return AJ_ERR_NO_MATCH;
    7ce4:	2310      	movs	r3, #16
{
  //  AJ_InfoPrintf(("AJ_GetGroupKey(name=\"%s\", key=0x%p)\n", name, key));
    if (name) 
	{
        NameToGUID* mapping = LookupName(name);
        if (!mapping) 
    7ce6:	2800      	cmp	r0, #0
    7ce8:	d01d      	beq.n	7d26 <AJ_GetGroupKey+0x4e>
		{
    //        AJ_WarnPrintf(("AJ_GetGroupKey(): AJ_ERR_NO_MATCH\n"));
            return AJ_ERR_NO_MATCH;
        }
        memcpy(key, mapping->groupKey, 16);
    7cea:	1c01      	adds	r1, r0, #0
    7cec:	313c      	adds	r1, #60	; 0x3c
    7cee:	1c20      	adds	r0, r4, #0
    7cf0:	2210      	movs	r2, #16
    7cf2:	4b0f      	ldr	r3, [pc, #60]	; (7d30 <AJ_GetGroupKey+0x58>)
    7cf4:	4798      	blx	r3
		{
            AJ_RandBytes(localGroupKey, 16);
        }
        memcpy(key, localGroupKey, 16);
    }
    return AJ_OK;
    7cf6:	2300      	movs	r3, #0
    7cf8:	e015      	b.n	7d26 <AJ_GetGroupKey+0x4e>
        memcpy(key, mapping->groupKey, 16);
    }
	else
	{
        // Check if the group key needs to be initialized
        memset(key, 0, 16);
    7cfa:	1c08      	adds	r0, r1, #0
    7cfc:	2100      	movs	r1, #0
    7cfe:	2210      	movs	r2, #16
    7d00:	4b0c      	ldr	r3, [pc, #48]	; (7d34 <AJ_GetGroupKey+0x5c>)
    7d02:	4798      	blx	r3
        if (memcmp(localGroupKey, key, 16) == 0)
    7d04:	480c      	ldr	r0, [pc, #48]	; (7d38 <AJ_GetGroupKey+0x60>)
    7d06:	1c21      	adds	r1, r4, #0
    7d08:	2210      	movs	r2, #16
    7d0a:	4b0c      	ldr	r3, [pc, #48]	; (7d3c <AJ_GetGroupKey+0x64>)
    7d0c:	4798      	blx	r3
    7d0e:	2800      	cmp	r0, #0
    7d10:	d103      	bne.n	7d1a <AJ_GetGroupKey+0x42>
		{
            AJ_RandBytes(localGroupKey, 16);
    7d12:	4809      	ldr	r0, [pc, #36]	; (7d38 <AJ_GetGroupKey+0x60>)
    7d14:	2110      	movs	r1, #16
    7d16:	4b0a      	ldr	r3, [pc, #40]	; (7d40 <AJ_GetGroupKey+0x68>)
    7d18:	4798      	blx	r3
        }
        memcpy(key, localGroupKey, 16);
    7d1a:	1c20      	adds	r0, r4, #0
    7d1c:	4906      	ldr	r1, [pc, #24]	; (7d38 <AJ_GetGroupKey+0x60>)
    7d1e:	2210      	movs	r2, #16
    7d20:	4b03      	ldr	r3, [pc, #12]	; (7d30 <AJ_GetGroupKey+0x58>)
    7d22:	4798      	blx	r3
    }
    return AJ_OK;
    7d24:	2300      	movs	r3, #0
}
    7d26:	1c18      	adds	r0, r3, #0
    7d28:	bd10      	pop	{r4, pc}
    7d2a:	46c0      	nop			; (mov r8, r8)
    7d2c:	000079ad 	.word	0x000079ad
    7d30:	00016739 	.word	0x00016739
    7d34:	00016773 	.word	0x00016773
    7d38:	20000880 	.word	0x20000880
    7d3c:	0001671b 	.word	0x0001671b
    7d40:	0000d6a9 	.word	0x0000d6a9

00007d44 <AJ_GUID_HandleAddMatchReply>:
    AJ_Free(ruleStr);
    return status;
}

AJ_Status AJ_GUID_HandleAddMatchReply(AJ_Message* msg)
{
    7d44:	b5f0      	push	{r4, r5, r6, r7, lr}
    7d46:	4647      	mov	r7, r8
    7d48:	b480      	push	{r7}
    7d4a:	b094      	sub	sp, #80	; 0x50
    NameToGUID* mapping;
    uint32_t serialNum = 0;

  //  AJ_InfoPrintf(("AJ_GUID_HandleAddMatchReply(msg=0x%p)\n", msg));

    mapping = LookupReplySerial(msg->replySerial);
    7d4c:	6883      	ldr	r3, [r0, #8]
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
	{
        if (nameMap[i].replySerial == replySerial) 
    7d4e:	4a3d      	ldr	r2, [pc, #244]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7d50:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    7d52:	4293      	cmp	r3, r2
    7d54:	d015      	beq.n	7d82 <AJ_GUID_HandleAddMatchReply+0x3e>
    7d56:	22b4      	movs	r2, #180	; 0xb4
    7d58:	493a      	ldr	r1, [pc, #232]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7d5a:	588a      	ldr	r2, [r1, r2]
    7d5c:	4293      	cmp	r3, r2
    7d5e:	d00c      	beq.n	7d7a <AJ_GUID_HandleAddMatchReply+0x36>
    7d60:	228e      	movs	r2, #142	; 0x8e
    7d62:	0052      	lsls	r2, r2, #1
    7d64:	588a      	ldr	r2, [r1, r2]
    7d66:	4293      	cmp	r3, r2
    7d68:	d009      	beq.n	7d7e <AJ_GUID_HandleAddMatchReply+0x3a>
    7d6a:	22c2      	movs	r2, #194	; 0xc2
    7d6c:	0052      	lsls	r2, r2, #1
    7d6e:	588a      	ldr	r2, [r1, r2]
  //  AJ_InfoPrintf(("AJ_GUID_HandleAddMatchReply(msg=0x%p)\n", msg));

    mapping = LookupReplySerial(msg->replySerial);
    if (!mapping) 
	{
        return AJ_OK;
    7d70:	2400      	movs	r4, #0

static NameToGUID* LookupReplySerial(uint32_t replySerial)
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
    7d72:	2603      	movs	r6, #3
	{
        if (nameMap[i].replySerial == replySerial) 
    7d74:	4293      	cmp	r3, r2
    7d76:	d005      	beq.n	7d84 <AJ_GUID_HandleAddMatchReply+0x40>
    7d78:	e05f      	b.n	7e3a <AJ_GUID_HandleAddMatchReply+0xf6>

static NameToGUID* LookupReplySerial(uint32_t replySerial)
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
    7d7a:	2601      	movs	r6, #1
    7d7c:	e002      	b.n	7d84 <AJ_GUID_HandleAddMatchReply+0x40>
    7d7e:	2602      	movs	r6, #2
    7d80:	e000      	b.n	7d84 <AJ_GUID_HandleAddMatchReply+0x40>
    7d82:	2600      	movs	r6, #0
    7d84:	1c07      	adds	r7, r0, #0
    mapping = LookupReplySerial(msg->replySerial);
    if (!mapping) 
	{
        return AJ_OK;
    }
    mapping->replySerial = 0;
    7d86:	2368      	movs	r3, #104	; 0x68
    7d88:	4373      	muls	r3, r6
    7d8a:	4a2e      	ldr	r2, [pc, #184]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7d8c:	18d3      	adds	r3, r2, r3
    7d8e:	2200      	movs	r2, #0
    7d90:	64da      	str	r2, [r3, #76]	; 0x4c

    if (msg->hdr->msgType == AJ_MSG_ERROR) 
    7d92:	6843      	ldr	r3, [r0, #4]
    7d94:	785b      	ldrb	r3, [r3, #1]
    7d96:	2b03      	cmp	r3, #3
    7d98:	d116      	bne.n	7dc8 <AJ_GUID_HandleAddMatchReply+0x84>
	{
        AJ_ErrPrintf(("AJ_GUID_HandleAddMatchReply(msg=0x%p): error=%s.\n", msg, msg->error));
    7d9a:	2001      	movs	r0, #1
    7d9c:	492a      	ldr	r1, [pc, #168]	; (7e48 <AJ_GUID_HandleAddMatchReply+0x104>)
    7d9e:	325f      	adds	r2, #95	; 0x5f
    7da0:	32ff      	adds	r2, #255	; 0xff
    7da2:	4b2a      	ldr	r3, [pc, #168]	; (7e4c <AJ_GUID_HandleAddMatchReply+0x108>)
    7da4:	4798      	blx	r3
    7da6:	2800      	cmp	r0, #0
    7da8:	d004      	beq.n	7db4 <AJ_GUID_HandleAddMatchReply+0x70>
    7daa:	4829      	ldr	r0, [pc, #164]	; (7e50 <AJ_GUID_HandleAddMatchReply+0x10c>)
    7dac:	1c39      	adds	r1, r7, #0
    7dae:	68fa      	ldr	r2, [r7, #12]
    7db0:	4b28      	ldr	r3, [pc, #160]	; (7e54 <AJ_GUID_HandleAddMatchReply+0x110>)
    7db2:	4798      	blx	r3
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    7db4:	6b38      	ldr	r0, [r7, #48]	; 0x30
    7db6:	2168      	movs	r1, #104	; 0x68
    7db8:	4371      	muls	r1, r6
    7dba:	4b22      	ldr	r3, [pc, #136]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7dbc:	1859      	adds	r1, r3, r1
    7dbe:	3101      	adds	r1, #1
    7dc0:	4b25      	ldr	r3, [pc, #148]	; (7e58 <AJ_GUID_HandleAddMatchReply+0x114>)
    7dc2:	4798      	blx	r3
        return AJ_ERR_FAILURE;
    7dc4:	2413      	movs	r4, #19
    7dc6:	e038      	b.n	7e3a <AJ_GUID_HandleAddMatchReply+0xf6>
    }

    // Add match complete.
   // AJ_InfoPrintf(("Add match Complete\n"));
    status = NameHasOwner(msg, mapping->uniqueName, &serialNum);
    7dc8:	2268      	movs	r2, #104	; 0x68
    7dca:	4372      	muls	r2, r6
    7dcc:	4b1d      	ldr	r3, [pc, #116]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7dce:	189a      	adds	r2, r3, r2
    7dd0:	1c55      	adds	r5, r2, #1
    AJ_Message call;

   // AJ_InfoPrintf(("NameHasOwner(msg=0x%p)\n", msg));

    // Ask if name has an owner
    status = AJ_MarshalMethodCall(msg->bus, &call, AJ_METHOD_NAME_HAS_OWNER, AJ_DBusDestination, 0, 0, AJ_METHOD_TIMEOUT);
    7dd2:	2300      	movs	r3, #0
    7dd4:	9300      	str	r3, [sp, #0]
    7dd6:	9301      	str	r3, [sp, #4]
    7dd8:	4b20      	ldr	r3, [pc, #128]	; (7e5c <AJ_GUID_HandleAddMatchReply+0x118>)
    7dda:	9302      	str	r3, [sp, #8]
    7ddc:	6b00      	ldr	r0, [r0, #48]	; 0x30
    7dde:	a904      	add	r1, sp, #16
    7de0:	2209      	movs	r2, #9
    7de2:	4b1f      	ldr	r3, [pc, #124]	; (7e60 <AJ_GUID_HandleAddMatchReply+0x11c>)
    7de4:	4c1f      	ldr	r4, [pc, #124]	; (7e64 <AJ_GUID_HandleAddMatchReply+0x120>)
    7de6:	47a0      	blx	r4
    7de8:	1e04      	subs	r4, r0, #0
    if (status == AJ_OK) 
    7dea:	d109      	bne.n	7e00 <AJ_GUID_HandleAddMatchReply+0xbc>
	{
        *serialNum = call.hdr->serialNum;
    7dec:	9b05      	ldr	r3, [sp, #20]
    7dee:	689b      	ldr	r3, [r3, #8]
    7df0:	4698      	mov	r8, r3
        status = AJ_MarshalArgs(&call, "s", name);
    7df2:	a804      	add	r0, sp, #16
    7df4:	491c      	ldr	r1, [pc, #112]	; (7e68 <AJ_GUID_HandleAddMatchReply+0x124>)
    7df6:	1c2a      	adds	r2, r5, #0
    7df8:	4b1c      	ldr	r3, [pc, #112]	; (7e6c <AJ_GUID_HandleAddMatchReply+0x128>)
    7dfa:	4798      	blx	r3
    7dfc:	1e04      	subs	r4, r0, #0
    }
    if (status != AJ_OK)
    7dfe:	d00c      	beq.n	7e1a <AJ_GUID_HandleAddMatchReply+0xd6>
	{
        AJ_ErrPrintf(("NameHasOwner(msg=0x%p): Marshal error\n", msg));
    7e00:	2001      	movs	r0, #1
    7e02:	4911      	ldr	r1, [pc, #68]	; (7e48 <AJ_GUID_HandleAddMatchReply+0x104>)
    7e04:	2282      	movs	r2, #130	; 0x82
    7e06:	32ff      	adds	r2, #255	; 0xff
    7e08:	4b10      	ldr	r3, [pc, #64]	; (7e4c <AJ_GUID_HandleAddMatchReply+0x108>)
    7e0a:	4798      	blx	r3
    7e0c:	2800      	cmp	r0, #0
    7e0e:	d010      	beq.n	7e32 <AJ_GUID_HandleAddMatchReply+0xee>
    7e10:	4817      	ldr	r0, [pc, #92]	; (7e70 <AJ_GUID_HandleAddMatchReply+0x12c>)
    7e12:	1c39      	adds	r1, r7, #0
    7e14:	4b0f      	ldr	r3, [pc, #60]	; (7e54 <AJ_GUID_HandleAddMatchReply+0x110>)
    7e16:	4798      	blx	r3
    7e18:	e00b      	b.n	7e32 <AJ_GUID_HandleAddMatchReply+0xee>
        return status;
    }
    return AJ_DeliverMsg(&call);
    7e1a:	a804      	add	r0, sp, #16
    7e1c:	4b15      	ldr	r3, [pc, #84]	; (7e74 <AJ_GUID_HandleAddMatchReply+0x130>)
    7e1e:	4798      	blx	r3
    7e20:	1e04      	subs	r4, r0, #0
    }

    // Add match complete.
   // AJ_InfoPrintf(("Add match Complete\n"));
    status = NameHasOwner(msg, mapping->uniqueName, &serialNum);
    if (status == AJ_OK) 
    7e22:	d106      	bne.n	7e32 <AJ_GUID_HandleAddMatchReply+0xee>
	{
        mapping->replySerial = serialNum;
    7e24:	2168      	movs	r1, #104	; 0x68
    7e26:	4371      	muls	r1, r6
    7e28:	4e06      	ldr	r6, [pc, #24]	; (7e44 <AJ_GUID_HandleAddMatchReply+0x100>)
    7e2a:	1871      	adds	r1, r6, r1
    7e2c:	4643      	mov	r3, r8
    7e2e:	64cb      	str	r3, [r1, #76]	; 0x4c
    7e30:	e003      	b.n	7e3a <AJ_GUID_HandleAddMatchReply+0xf6>
    } 
	else 
	{
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    7e32:	6b38      	ldr	r0, [r7, #48]	; 0x30
    7e34:	1c29      	adds	r1, r5, #0
    7e36:	4b08      	ldr	r3, [pc, #32]	; (7e58 <AJ_GUID_HandleAddMatchReply+0x114>)
    7e38:	4798      	blx	r3
    }
    return status;
}
    7e3a:	1c20      	adds	r0, r4, #0
    7e3c:	b014      	add	sp, #80	; 0x50
    7e3e:	bc04      	pop	{r2}
    7e40:	4690      	mov	r8, r2
    7e42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7e44:	200006e0 	.word	0x200006e0
    7e48:	0001c7fc 	.word	0x0001c7fc
    7e4c:	0000636d 	.word	0x0000636d
    7e50:	0001c8ac 	.word	0x0001c8ac
    7e54:	00016e3d 	.word	0x00016e3d
    7e58:	00007b9d 	.word	0x00007b9d
    7e5c:	00000bb8 	.word	0x00000bb8
    7e60:	0001e7b8 	.word	0x0001e7b8
    7e64:	0000bca5 	.word	0x0000bca5
    7e68:	0001f054 	.word	0x0001f054
    7e6c:	0000bc85 	.word	0x0000bc85
    7e70:	0001c8e0 	.word	0x0001c8e0
    7e74:	0000a539 	.word	0x0000a539

00007e78 <AJ_GUID_HandleNameHasOwnerReply>:
    }
    return AJ_DeliverMsg(&call);
}

AJ_Status AJ_GUID_HandleNameHasOwnerReply(AJ_Message* msg)
{
    7e78:	b570      	push	{r4, r5, r6, lr}
    7e7a:	b082      	sub	sp, #8
    AJ_Status status;
    NameToGUID* mapping;
    uint32_t hasOwner;

  //  AJ_InfoPrintf(("AJ_GUID_HandleNameHasOwnerReply(msg=0x%p)\n", msg));
    mapping = LookupReplySerial(msg->replySerial);
    7e7c:	6883      	ldr	r3, [r0, #8]
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
	{
        if (nameMap[i].replySerial == replySerial) 
    7e7e:	4a34      	ldr	r2, [pc, #208]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7e80:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    7e82:	4293      	cmp	r3, r2
    7e84:	d015      	beq.n	7eb2 <AJ_GUID_HandleNameHasOwnerReply+0x3a>
    7e86:	22b4      	movs	r2, #180	; 0xb4
    7e88:	4931      	ldr	r1, [pc, #196]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7e8a:	588a      	ldr	r2, [r1, r2]
    7e8c:	4293      	cmp	r3, r2
    7e8e:	d00c      	beq.n	7eaa <AJ_GUID_HandleNameHasOwnerReply+0x32>
    7e90:	228e      	movs	r2, #142	; 0x8e
    7e92:	0052      	lsls	r2, r2, #1
    7e94:	588a      	ldr	r2, [r1, r2]
    7e96:	4293      	cmp	r3, r2
    7e98:	d009      	beq.n	7eae <AJ_GUID_HandleNameHasOwnerReply+0x36>
    7e9a:	22c2      	movs	r2, #194	; 0xc2
    7e9c:	0052      	lsls	r2, r2, #1
    7e9e:	5889      	ldr	r1, [r1, r2]

  //  AJ_InfoPrintf(("AJ_GUID_HandleNameHasOwnerReply(msg=0x%p)\n", msg));
    mapping = LookupReplySerial(msg->replySerial);
    if (!mapping) 
	{
        return AJ_OK;
    7ea0:	2200      	movs	r2, #0

static NameToGUID* LookupReplySerial(uint32_t replySerial)
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
    7ea2:	2603      	movs	r6, #3
	{
        if (nameMap[i].replySerial == replySerial) 
    7ea4:	428b      	cmp	r3, r1
    7ea6:	d005      	beq.n	7eb4 <AJ_GUID_HandleNameHasOwnerReply+0x3c>
    7ea8:	e04f      	b.n	7f4a <AJ_GUID_HandleNameHasOwnerReply+0xd2>

static NameToGUID* LookupReplySerial(uint32_t replySerial)
{
    uint32_t i;

    for (i = 0; i < AJ_NAME_MAP_GUID_SIZE; ++i) 
    7eaa:	2601      	movs	r6, #1
    7eac:	e002      	b.n	7eb4 <AJ_GUID_HandleNameHasOwnerReply+0x3c>
    7eae:	2602      	movs	r6, #2
    7eb0:	e000      	b.n	7eb4 <AJ_GUID_HandleNameHasOwnerReply+0x3c>
    7eb2:	2600      	movs	r6, #0
    7eb4:	1c05      	adds	r5, r0, #0
    mapping = LookupReplySerial(msg->replySerial);
    if (!mapping) 
	{
        return AJ_OK;
    }
    mapping->replySerial = 0;
    7eb6:	2368      	movs	r3, #104	; 0x68
    7eb8:	4373      	muls	r3, r6
    7eba:	4a25      	ldr	r2, [pc, #148]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7ebc:	18d3      	adds	r3, r2, r3
    7ebe:	2200      	movs	r2, #0
    7ec0:	64da      	str	r2, [r3, #76]	; 0x4c

    if (msg->hdr->msgType == AJ_MSG_ERROR) 
    7ec2:	6843      	ldr	r3, [r0, #4]
    7ec4:	785b      	ldrb	r3, [r3, #1]
    7ec6:	2b03      	cmp	r3, #3
    7ec8:	d116      	bne.n	7ef8 <AJ_GUID_HandleNameHasOwnerReply+0x80>
	{
        AJ_ErrPrintf(("AJ_GUID_HandleNameHasOwnerReply(msg=0x%p): error=%s.\n", msg, msg->error));
    7eca:	2001      	movs	r0, #1
    7ecc:	4921      	ldr	r1, [pc, #132]	; (7f54 <AJ_GUID_HandleNameHasOwnerReply+0xdc>)
    7ece:	2298      	movs	r2, #152	; 0x98
    7ed0:	32ff      	adds	r2, #255	; 0xff
    7ed2:	4b21      	ldr	r3, [pc, #132]	; (7f58 <AJ_GUID_HandleNameHasOwnerReply+0xe0>)
    7ed4:	4798      	blx	r3
    7ed6:	2800      	cmp	r0, #0
    7ed8:	d004      	beq.n	7ee4 <AJ_GUID_HandleNameHasOwnerReply+0x6c>
    7eda:	4820      	ldr	r0, [pc, #128]	; (7f5c <AJ_GUID_HandleNameHasOwnerReply+0xe4>)
    7edc:	1c29      	adds	r1, r5, #0
    7ede:	68ea      	ldr	r2, [r5, #12]
    7ee0:	4b1f      	ldr	r3, [pc, #124]	; (7f60 <AJ_GUID_HandleNameHasOwnerReply+0xe8>)
    7ee2:	4798      	blx	r3
        status = AJ_ERR_FAILURE;
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    7ee4:	6b28      	ldr	r0, [r5, #48]	; 0x30
    7ee6:	2168      	movs	r1, #104	; 0x68
    7ee8:	4371      	muls	r1, r6
    7eea:	4b19      	ldr	r3, [pc, #100]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7eec:	1859      	adds	r1, r3, r1
    7eee:	3101      	adds	r1, #1
    7ef0:	4b1c      	ldr	r3, [pc, #112]	; (7f64 <AJ_GUID_HandleNameHasOwnerReply+0xec>)
    7ef2:	4798      	blx	r3
        return status;
    7ef4:	2213      	movs	r2, #19
    7ef6:	e028      	b.n	7f4a <AJ_GUID_HandleNameHasOwnerReply+0xd2>
    }
    status = AJ_UnmarshalArgs(msg, "b", &hasOwner);
    7ef8:	491b      	ldr	r1, [pc, #108]	; (7f68 <AJ_GUID_HandleNameHasOwnerReply+0xf0>)
    7efa:	aa01      	add	r2, sp, #4
    7efc:	4b1b      	ldr	r3, [pc, #108]	; (7f6c <AJ_GUID_HandleNameHasOwnerReply+0xf4>)
    7efe:	4798      	blx	r3
    7f00:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    7f02:	d015      	beq.n	7f30 <AJ_GUID_HandleNameHasOwnerReply+0xb8>
	{
        AJ_ErrPrintf(("AJ_GUID_HandleNameHasOwnerReply(msg=0x%p): Unmarshal error\n", msg));
    7f04:	2001      	movs	r0, #1
    7f06:	4913      	ldr	r1, [pc, #76]	; (7f54 <AJ_GUID_HandleNameHasOwnerReply+0xdc>)
    7f08:	22a0      	movs	r2, #160	; 0xa0
    7f0a:	32ff      	adds	r2, #255	; 0xff
    7f0c:	4b12      	ldr	r3, [pc, #72]	; (7f58 <AJ_GUID_HandleNameHasOwnerReply+0xe0>)
    7f0e:	4798      	blx	r3
    7f10:	2800      	cmp	r0, #0
    7f12:	d003      	beq.n	7f1c <AJ_GUID_HandleNameHasOwnerReply+0xa4>
    7f14:	4816      	ldr	r0, [pc, #88]	; (7f70 <AJ_GUID_HandleNameHasOwnerReply+0xf8>)
    7f16:	1c29      	adds	r1, r5, #0
    7f18:	4b11      	ldr	r3, [pc, #68]	; (7f60 <AJ_GUID_HandleNameHasOwnerReply+0xe8>)
    7f1a:	4798      	blx	r3
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    7f1c:	6b28      	ldr	r0, [r5, #48]	; 0x30
    7f1e:	2168      	movs	r1, #104	; 0x68
    7f20:	4371      	muls	r1, r6
    7f22:	4e0b      	ldr	r6, [pc, #44]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7f24:	1871      	adds	r1, r6, r1
    7f26:	3101      	adds	r1, #1
    7f28:	4b0e      	ldr	r3, [pc, #56]	; (7f64 <AJ_GUID_HandleNameHasOwnerReply+0xec>)
    7f2a:	4798      	blx	r3
        return status;
    7f2c:	1c22      	adds	r2, r4, #0
    7f2e:	e00c      	b.n	7f4a <AJ_GUID_HandleNameHasOwnerReply+0xd2>
    if (!hasOwner) 
	{
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    }

    return status;
    7f30:	2200      	movs	r2, #0
        return status;
    }

    // Name has owner complete.
 //   AJ_InfoPrintf(("Name %s has owner %d\n", mapping->uniqueName, hasOwner));
    if (!hasOwner) 
    7f32:	9b01      	ldr	r3, [sp, #4]
    7f34:	2b00      	cmp	r3, #0
    7f36:	d108      	bne.n	7f4a <AJ_GUID_HandleNameHasOwnerReply+0xd2>
	{
        AJ_GUID_DeleteNameMapping(msg->bus, mapping->uniqueName);
    7f38:	6b28      	ldr	r0, [r5, #48]	; 0x30
    7f3a:	2168      	movs	r1, #104	; 0x68
    7f3c:	4371      	muls	r1, r6
    7f3e:	4e04      	ldr	r6, [pc, #16]	; (7f50 <AJ_GUID_HandleNameHasOwnerReply+0xd8>)
    7f40:	1871      	adds	r1, r6, r1
    7f42:	3101      	adds	r1, #1
    7f44:	4b07      	ldr	r3, [pc, #28]	; (7f64 <AJ_GUID_HandleNameHasOwnerReply+0xec>)
    7f46:	4798      	blx	r3
    }

    return status;
    7f48:	2200      	movs	r2, #0
}
    7f4a:	1c10      	adds	r0, r2, #0
    7f4c:	b002      	add	sp, #8
    7f4e:	bd70      	pop	{r4, r5, r6, pc}
    7f50:	200006e0 	.word	0x200006e0
    7f54:	0001c7fc 	.word	0x0001c7fc
    7f58:	0000636d 	.word	0x0000636d
    7f5c:	0001c908 	.word	0x0001c908
    7f60:	00016e3d 	.word	0x00016e3d
    7f64:	00007b9d 	.word	0x00007b9d
    7f68:	0001ed84 	.word	0x0001ed84
    7f6c:	0000b5f5 	.word	0x0000b5f5
    7f70:	0001c940 	.word	0x0001c940

00007f74 <AJ_GUID_HandleNameOwnerChanged>:

AJ_Status AJ_GUID_HandleNameOwnerChanged(AJ_Message* msg)
{
    7f74:	b530      	push	{r4, r5, lr}
    7f76:	b087      	sub	sp, #28
    7f78:	1c05      	adds	r5, r0, #0
    AJ_Status status;
    char* name;
    char* oldOwner;
    char* newOwner;

    status = AJ_UnmarshalArgs(msg, "sss", &name, &oldOwner, &newOwner);
    7f7a:	ab03      	add	r3, sp, #12
    7f7c:	9300      	str	r3, [sp, #0]
    7f7e:	490b      	ldr	r1, [pc, #44]	; (7fac <AJ_GUID_HandleNameOwnerChanged+0x38>)
    7f80:	aa05      	add	r2, sp, #20
    7f82:	ab04      	add	r3, sp, #16
    7f84:	4c0a      	ldr	r4, [pc, #40]	; (7fb0 <AJ_GUID_HandleNameOwnerChanged+0x3c>)
    7f86:	47a0      	blx	r4
    7f88:	1e04      	subs	r4, r0, #0
 //   AJ_InfoPrintf(("AJ_GUID_HandleNameOwnerChanged(name=%s,oldOwner=%s,newOwner=%s)\n", name, oldOwner, newOwner));
    if ((status == AJ_OK) && newOwner && oldOwner && newOwner[0] == '\0') 
    7f8a:	d10b      	bne.n	7fa4 <AJ_GUID_HandleNameOwnerChanged+0x30>
    7f8c:	9b03      	ldr	r3, [sp, #12]
    7f8e:	2b00      	cmp	r3, #0
    7f90:	d008      	beq.n	7fa4 <AJ_GUID_HandleNameOwnerChanged+0x30>
    7f92:	9904      	ldr	r1, [sp, #16]
    7f94:	2900      	cmp	r1, #0
    7f96:	d005      	beq.n	7fa4 <AJ_GUID_HandleNameOwnerChanged+0x30>
    7f98:	781b      	ldrb	r3, [r3, #0]
    7f9a:	2b00      	cmp	r3, #0
    7f9c:	d102      	bne.n	7fa4 <AJ_GUID_HandleNameOwnerChanged+0x30>
	{
        AJ_GUID_DeleteNameMapping(msg->bus, oldOwner);
    7f9e:	6b28      	ldr	r0, [r5, #48]	; 0x30
    7fa0:	4b04      	ldr	r3, [pc, #16]	; (7fb4 <AJ_GUID_HandleNameOwnerChanged+0x40>)
    7fa2:	4798      	blx	r3
    }
    return status;
}
    7fa4:	1c20      	adds	r0, r4, #0
    7fa6:	b007      	add	sp, #28
    7fa8:	bd30      	pop	{r4, r5, pc}
    7faa:	46c0      	nop			; (mov r8, r8)
    7fac:	0001c97c 	.word	0x0001c97c
    7fb0:	0000b5f5 	.word	0x0000b5f5
    7fb4:	00007b9d 	.word	0x00007b9d

00007fb8 <AJ_GUID_HandleRemoveMatchReply>:

AJ_Status AJ_GUID_HandleRemoveMatchReply(AJ_Message* msg)
{
    if (msg->hdr->msgType == AJ_MSG_ERROR) 
    7fb8:	6843      	ldr	r3, [r0, #4]
    7fba:	785b      	ldrb	r3, [r3, #1]
	{
    //    AJ_WarnPrintf(("AJ_GUID_HandleRemoveMatchReply(msg=0x%p): error=%s.\n", msg, msg->error));
        return AJ_ERR_FAILURE;
    7fbc:	2013      	movs	r0, #19
    }
    return AJ_OK;
    7fbe:	3b03      	subs	r3, #3
    7fc0:	425a      	negs	r2, r3
    7fc2:	4153      	adcs	r3, r2
    7fc4:	425b      	negs	r3, r3
    7fc6:	4018      	ands	r0, r3
}
    7fc8:	4770      	bx	lr
    7fca:	46c0      	nop			; (mov r8, r8)

00007fcc <AJ_Initialize>:
#endif

static uint8_t initialized = FALSE;

void AJ_Initialize(void)
{
    7fcc:	b500      	push	{lr}
    7fce:	b085      	sub	sp, #20
    AJ_GUID localGuid;
    if (!initialized)
    7fd0:	4b09      	ldr	r3, [pc, #36]	; (7ff8 <AJ_Initialize+0x2c>)
    7fd2:	781b      	ldrb	r3, [r3, #0]
    7fd4:	2b00      	cmp	r3, #0
    7fd6:	d10d      	bne.n	7ff4 <AJ_Initialize+0x28>
	{
        initialized = TRUE;
    7fd8:	2201      	movs	r2, #1
    7fda:	4b07      	ldr	r3, [pc, #28]	; (7ff8 <AJ_Initialize+0x2c>)
    7fdc:	701a      	strb	r2, [r3, #0]
        //  AJ_NVRAM_Init();
        //  This will seed the random number generator
          AJ_RandBytes(NULL, 0);
    7fde:	2000      	movs	r0, #0
    7fe0:	2100      	movs	r1, #0
    7fe2:	4b06      	ldr	r3, [pc, #24]	; (7ffc <AJ_Initialize+0x30>)
    7fe4:	4798      	blx	r3
        //  This will initialize credentials if needed
          AJ_GetLocalGUID(&localGuid);
    7fe6:	4668      	mov	r0, sp
    7fe8:	4b05      	ldr	r3, [pc, #20]	; (8000 <AJ_Initialize+0x34>)
    7fea:	4798      	blx	r3
        //  Clear the Routing Node black list
        AJ_InitRoutingNodeBlacklist();
    7fec:	4b05      	ldr	r3, [pc, #20]	; (8004 <AJ_Initialize+0x38>)
    7fee:	4798      	blx	r3
        AJ_InitRoutingNodeResponselist();
    7ff0:	4b05      	ldr	r3, [pc, #20]	; (8008 <AJ_Initialize+0x3c>)
    7ff2:	4798      	blx	r3
    }
}
    7ff4:	b005      	add	sp, #20
    7ff6:	bd00      	pop	{pc}
    7ff8:	20000890 	.word	0x20000890
    7ffc:	0000d6a9 	.word	0x0000d6a9
    8000:	00004431 	.word	0x00004431
    8004:	00004229 	.word	0x00004229
    8008:	00003e85 	.word	0x00003e85

0000800c <ExpandAttribute>:
static const char secureTrue[] = "true\"/>\n";
static const char secureOff[] = "off\"/>\n";


static char ExpandAttribute(XMLWriterFunc XMLWriter, void* context, const char** str, const char* pre, const char* post)
{
    800c:	b5f0      	push	{r4, r5, r6, r7, lr}
    800e:	464f      	mov	r7, r9
    8010:	b480      	push	{r7}
    8012:	b082      	sub	sp, #8
    8014:	4681      	mov	r9, r0
    8016:	9101      	str	r1, [sp, #4]
    8018:	1c16      	adds	r6, r2, #0
    uint32_t len = 0;
    char next = 0;
    const char* s = *str;
    801a:	6817      	ldr	r7, [r2, #0]

    XMLWriter(context, pre, 0);
    801c:	1c08      	adds	r0, r1, #0
    801e:	1c19      	adds	r1, r3, #0
    8020:	2200      	movs	r2, #0
    8022:	47c8      	blx	r9
    while (*s) 
    8024:	783c      	ldrb	r4, [r7, #0]
    8026:	2c00      	cmp	r4, #0
    8028:	d018      	beq.n	805c <ExpandAttribute+0x50>
	{
        char c = *s++;
    802a:	1c7d      	adds	r5, r7, #1
        if (IS_DIRECTION(c) || (c == SEPARATOR)) 
    802c:	1c23      	adds	r3, r4, #0
    802e:	3b3c      	subs	r3, #60	; 0x3c
    8030:	2b02      	cmp	r3, #2
    8032:	d90a      	bls.n	804a <ExpandAttribute+0x3e>
    8034:	2c20      	cmp	r4, #32
    8036:	d10c      	bne.n	8052 <ExpandAttribute+0x46>
    8038:	e009      	b.n	804e <ExpandAttribute+0x42>
    const char* s = *str;

    XMLWriter(context, pre, 0);
    while (*s) 
	{
        char c = *s++;
    803a:	3501      	adds	r5, #1
        if (IS_DIRECTION(c) || (c == SEPARATOR)) 
    803c:	1c23      	adds	r3, r4, #0
    803e:	3b3c      	subs	r3, #60	; 0x3c
    8040:	2b02      	cmp	r3, #2
    8042:	d90d      	bls.n	8060 <ExpandAttribute+0x54>
    8044:	2c20      	cmp	r4, #32
    8046:	d104      	bne.n	8052 <ExpandAttribute+0x46>
    8048:	e00a      	b.n	8060 <ExpandAttribute+0x54>
static const char secureOff[] = "off\"/>\n";


static char ExpandAttribute(XMLWriterFunc XMLWriter, void* context, const char** str, const char* pre, const char* post)
{
    uint32_t len = 0;
    804a:	2200      	movs	r2, #0
    804c:	e008      	b.n	8060 <ExpandAttribute+0x54>
    804e:	2200      	movs	r2, #0
	{
        char c = *s++;
        if (IS_DIRECTION(c) || (c == SEPARATOR)) 
		{
            next = c;
            break;
    8050:	e006      	b.n	8060 <ExpandAttribute+0x54>
    8052:	1bea      	subs	r2, r5, r7
    uint32_t len = 0;
    char next = 0;
    const char* s = *str;

    XMLWriter(context, pre, 0);
    while (*s) 
    8054:	782c      	ldrb	r4, [r5, #0]
    8056:	2c00      	cmp	r4, #0
    8058:	d1ef      	bne.n	803a <ExpandAttribute+0x2e>
    805a:	e001      	b.n	8060 <ExpandAttribute+0x54>

static char ExpandAttribute(XMLWriterFunc XMLWriter, void* context, const char** str, const char* pre, const char* post)
{
    uint32_t len = 0;
    char next = 0;
    const char* s = *str;
    805c:	1c3d      	adds	r5, r7, #0
static const char secureOff[] = "off\"/>\n";


static char ExpandAttribute(XMLWriterFunc XMLWriter, void* context, const char** str, const char* pre, const char* post)
{
    uint32_t len = 0;
    805e:	2200      	movs	r2, #0
            next = c;
            break;
        }
        ++len;
    }
    XMLWriter(context, *str, len);
    8060:	9f01      	ldr	r7, [sp, #4]
    8062:	1c38      	adds	r0, r7, #0
    8064:	6831      	ldr	r1, [r6, #0]
    8066:	47c8      	blx	r9
    XMLWriter(context, post, 0);
    8068:	1c38      	adds	r0, r7, #0
    806a:	9908      	ldr	r1, [sp, #32]
    806c:	2200      	movs	r2, #0
    806e:	47c8      	blx	r9
    *str = s;
    8070:	6035      	str	r5, [r6, #0]

    return next;
}
    8072:	1c20      	adds	r0, r4, #0
    8074:	b002      	add	sp, #8
    8076:	bc04      	pop	{r2}
    8078:	4691      	mov	r9, r2
    807a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000807c <XMLWriteTag>:

static void XMLWriteTag(XMLWriterFunc XMLWriter, void* context, const char* tag, const char* attr, const char* val, uint32_t valLen, uint8_t atom)
{
    807c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    807e:	1c04      	adds	r4, r0, #0
    8080:	1c0d      	adds	r5, r1, #0
    8082:	1c1e      	adds	r6, r3, #0
    8084:	ab08      	add	r3, sp, #32
    8086:	781f      	ldrb	r7, [r3, #0]
    XMLWriter(context, tag, 0);
    8088:	1c08      	adds	r0, r1, #0
    808a:	1c11      	adds	r1, r2, #0
    808c:	2200      	movs	r2, #0
    808e:	47a0      	blx	r4
    if (attr != NULL) 
    8090:	2e00      	cmp	r6, #0
    8092:	d00b      	beq.n	80ac <XMLWriteTag+0x30>
	{
        XMLWriter(context, attr, 0);
    8094:	1c28      	adds	r0, r5, #0
    8096:	1c31      	adds	r1, r6, #0
    8098:	2200      	movs	r2, #0
    809a:	47a0      	blx	r4
        XMLWriter(context, val, valLen);
    809c:	1c28      	adds	r0, r5, #0
    809e:	9906      	ldr	r1, [sp, #24]
    80a0:	9a07      	ldr	r2, [sp, #28]
    80a2:	47a0      	blx	r4
        XMLWriter(context, "\"", 1);
    80a4:	1c28      	adds	r0, r5, #0
    80a6:	4907      	ldr	r1, [pc, #28]	; (80c4 <XMLWriteTag+0x48>)
    80a8:	2201      	movs	r2, #1
    80aa:	47a0      	blx	r4
    }
    if (atom) 
    80ac:	2f00      	cmp	r7, #0
    80ae:	d004      	beq.n	80ba <XMLWriteTag+0x3e>
	{
        XMLWriter(context, "/>\n", 3);
    80b0:	1c28      	adds	r0, r5, #0
    80b2:	4905      	ldr	r1, [pc, #20]	; (80c8 <XMLWriteTag+0x4c>)
    80b4:	2203      	movs	r2, #3
    80b6:	47a0      	blx	r4
    80b8:	e003      	b.n	80c2 <XMLWriteTag+0x46>
    }
	else 
	{
        XMLWriter(context, ">\n", 2);
    80ba:	1c28      	adds	r0, r5, #0
    80bc:	4903      	ldr	r1, [pc, #12]	; (80cc <XMLWriteTag+0x50>)
    80be:	2202      	movs	r2, #2
    80c0:	47a0      	blx	r4
    }
}
    80c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    80c4:	0001ca14 	.word	0x0001ca14
    80c8:	0001d044 	.word	0x0001d044
    80cc:	0001d070 	.word	0x0001d070

000080d0 <GetDescription>:

static const char* GetDescription(AJ_DescriptionLookupFunc descLookup, uint32_t descId, const char* languageTag)
{
    80d0:	b508      	push	{r3, lr}
    80d2:	1e03      	subs	r3, r0, #0
    if (descLookup == NULL) 
    80d4:	d003      	beq.n	80de <GetDescription+0xe>
    80d6:	1c08      	adds	r0, r1, #0
	{
        return NULL;
    }

    return descLookup(descId, languageTag);
    80d8:	1c11      	adds	r1, r2, #0
    80da:	4798      	blx	r3
    80dc:	e000      	b.n	80e0 <GetDescription+0x10>

static const char* GetDescription(AJ_DescriptionLookupFunc descLookup, uint32_t descId, const char* languageTag)
{
    if (descLookup == NULL) 
	{
        return NULL;
    80de:	2000      	movs	r0, #0
    }

    return descLookup(descId, languageTag);
}
    80e0:	bd08      	pop	{r3, pc}
    80e2:	46c0      	nop			; (mov r8, r8)

000080e4 <XMLWriteDescription>:

static void XMLWriteDescription(XMLWriterFunc XMLWriter, void* context, uint8_t level, const char* description, const char* languageTag) 
{
    80e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    80e6:	b083      	sub	sp, #12
    if (description != NULL) 
    80e8:	2b00      	cmp	r3, #0
    80ea:	d033      	beq.n	8154 <XMLWriteDescription+0x70>
    80ec:	9301      	str	r3, [sp, #4]
    80ee:	1c15      	adds	r5, r2, #0
    80f0:	9100      	str	r1, [sp, #0]
    80f2:	1c07      	adds	r7, r0, #0
	{
        uint8_t i;
        for (i = 0; i < level; i++) 
    80f4:	2a00      	cmp	r2, #0
    80f6:	d009      	beq.n	810c <XMLWriteDescription+0x28>
    80f8:	2400      	movs	r4, #0
		{
            XMLWriter(context, "    ", 4);
    80fa:	4e17      	ldr	r6, [pc, #92]	; (8158 <XMLWriteDescription+0x74>)
    80fc:	9800      	ldr	r0, [sp, #0]
    80fe:	1c31      	adds	r1, r6, #0
    8100:	2204      	movs	r2, #4
    8102:	47b8      	blx	r7
static void XMLWriteDescription(XMLWriterFunc XMLWriter, void* context, uint8_t level, const char* description, const char* languageTag) 
{
    if (description != NULL) 
	{
        uint8_t i;
        for (i = 0; i < level; i++) 
    8104:	3401      	adds	r4, #1
    8106:	b2e4      	uxtb	r4, r4
    8108:	42ac      	cmp	r4, r5
    810a:	d1f7      	bne.n	80fc <XMLWriteDescription+0x18>
		{
            XMLWriter(context, "    ", 4);
        }
        XMLWriter(context, "<description", 12);
    810c:	9800      	ldr	r0, [sp, #0]
    810e:	4913      	ldr	r1, [pc, #76]	; (815c <XMLWriteDescription+0x78>)
    8110:	220c      	movs	r2, #12
    8112:	47b8      	blx	r7
        if (languageTag != NULL && strlen(languageTag) > 0) 
    8114:	9b08      	ldr	r3, [sp, #32]
    8116:	2b00      	cmp	r3, #0
    8118:	d00f      	beq.n	813a <XMLWriteDescription+0x56>
    811a:	781b      	ldrb	r3, [r3, #0]
    811c:	2b00      	cmp	r3, #0
    811e:	d00c      	beq.n	813a <XMLWriteDescription+0x56>
		{
            XMLWriter(context, " language=\"", 11);
    8120:	9c00      	ldr	r4, [sp, #0]
    8122:	1c20      	adds	r0, r4, #0
    8124:	490e      	ldr	r1, [pc, #56]	; (8160 <XMLWriteDescription+0x7c>)
    8126:	220b      	movs	r2, #11
    8128:	47b8      	blx	r7
            XMLWriter(context, languageTag, 0);
    812a:	1c20      	adds	r0, r4, #0
    812c:	9908      	ldr	r1, [sp, #32]
    812e:	2200      	movs	r2, #0
    8130:	47b8      	blx	r7
            XMLWriter(context, "\"", 1);
    8132:	1c20      	adds	r0, r4, #0
    8134:	490b      	ldr	r1, [pc, #44]	; (8164 <XMLWriteDescription+0x80>)
    8136:	2201      	movs	r2, #1
    8138:	47b8      	blx	r7
        }
        XMLWriter(context, ">", 1);
    813a:	9c00      	ldr	r4, [sp, #0]
    813c:	1c20      	adds	r0, r4, #0
    813e:	490a      	ldr	r1, [pc, #40]	; (8168 <XMLWriteDescription+0x84>)
    8140:	2201      	movs	r2, #1
    8142:	47b8      	blx	r7
        XMLWriter(context, description, 0);
    8144:	1c20      	adds	r0, r4, #0
    8146:	9901      	ldr	r1, [sp, #4]
    8148:	2200      	movs	r2, #0
    814a:	47b8      	blx	r7
        XMLWriter(context, "</description>\n", 15);
    814c:	1c20      	adds	r0, r4, #0
    814e:	4907      	ldr	r1, [pc, #28]	; (816c <XMLWriteDescription+0x88>)
    8150:	220f      	movs	r2, #15
    8152:	47b8      	blx	r7
    }
    return;
}
    8154:	b003      	add	sp, #12
    8156:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8158:	0001ca18 	.word	0x0001ca18
    815c:	0001ca20 	.word	0x0001ca20
    8160:	0001ca30 	.word	0x0001ca30
    8164:	0001ca14 	.word	0x0001ca14
    8168:	0001bf4c 	.word	0x0001bf4c
    816c:	0001ca3c 	.word	0x0001ca3c

00008170 <ChildPath>:
/*
 * Check if the path c is child of path p if so return pointer to the start of the child path
 * relative to the parent.
 */
static const char* ChildPath(const char* p, const char* c, uint32_t* sz)
{
    8170:	b510      	push	{r4, lr}
    // Special case for parent == root (all nodes are children of root)
    if ((p[0] == '/') && (p[1] == 0)) 
    8172:	7803      	ldrb	r3, [r0, #0]
    8174:	2b2f      	cmp	r3, #47	; 0x2f
    8176:	d103      	bne.n	8180 <ChildPath+0x10>
    8178:	7844      	ldrb	r4, [r0, #1]
    817a:	2c00      	cmp	r4, #0
    817c:	d103      	bne.n	8186 <ChildPath+0x16>
	{
        ++p;
    817e:	3001      	adds	r0, #1
    }
    while (*p && (*p == *c)) 
    8180:	7803      	ldrb	r3, [r0, #0]
    8182:	2b00      	cmp	r3, #0
    8184:	d024      	beq.n	81d0 <ChildPath+0x60>
    8186:	780c      	ldrb	r4, [r1, #0]
    8188:	429c      	cmp	r4, r3
    818a:	d11f      	bne.n	81cc <ChildPath+0x5c>
	{
        ++p;
    818c:	3001      	adds	r0, #1
        ++c;
    818e:	3101      	adds	r1, #1
    // Special case for parent == root (all nodes are children of root)
    if ((p[0] == '/') && (p[1] == 0)) 
	{
        ++p;
    }
    while (*p && (*p == *c)) 
    8190:	7803      	ldrb	r3, [r0, #0]
    8192:	2b00      	cmp	r3, #0
    8194:	d01c      	beq.n	81d0 <ChildPath+0x60>
    8196:	780c      	ldrb	r4, [r1, #0]
    8198:	429c      	cmp	r4, r3
    819a:	d0f7      	beq.n	818c <ChildPath+0x1c>
        // Return then isolated node name of the child
        return len ? c : NULL;
    } 
	else 
	{
        return NULL;
    819c:	2000      	movs	r0, #0
    819e:	e020      	b.n	81e2 <ChildPath+0x72>
        ++c;
    }
    if ((*p == '\0') && (*c == '/'))
	{
        uint32_t len = 0;
        ++c;
    81a0:	1c4c      	adds	r4, r1, #1
        while (c[len] && c[len] != '/') 
    81a2:	784b      	ldrb	r3, [r1, #1]
    81a4:	2b00      	cmp	r3, #0
    81a6:	d018      	beq.n	81da <ChildPath+0x6a>
    81a8:	2b2f      	cmp	r3, #47	; 0x2f
    81aa:	d016      	beq.n	81da <ChildPath+0x6a>
    81ac:	2300      	movs	r3, #0
		{
            ++len;
    81ae:	3301      	adds	r3, #1
    81b0:	18c8      	adds	r0, r1, r3
    }
    if ((*p == '\0') && (*c == '/'))
	{
        uint32_t len = 0;
        ++c;
        while (c[len] && c[len] != '/') 
    81b2:	7840      	ldrb	r0, [r0, #1]
    81b4:	2800      	cmp	r0, #0
    81b6:	d001      	beq.n	81bc <ChildPath+0x4c>
    81b8:	282f      	cmp	r0, #47	; 0x2f
    81ba:	d1f8      	bne.n	81ae <ChildPath+0x3e>
		{
            ++len;
        }
        if (sz) 
    81bc:	2a00      	cmp	r2, #0
    81be:	d000      	beq.n	81c2 <ChildPath+0x52>
		{
            *sz = len;
    81c0:	6013      	str	r3, [r2, #0]
        }
        // Return then isolated node name of the child
        return len ? c : NULL;
    81c2:	2000      	movs	r0, #0
    81c4:	2b00      	cmp	r3, #0
    81c6:	d00c      	beq.n	81e2 <ChildPath+0x72>
    81c8:	1c20      	adds	r0, r4, #0
    81ca:	e00a      	b.n	81e2 <ChildPath+0x72>
    } 
	else 
	{
        return NULL;
    81cc:	2000      	movs	r0, #0
    81ce:	e008      	b.n	81e2 <ChildPath+0x72>
    while (*p && (*p == *c)) 
	{
        ++p;
        ++c;
    }
    if ((*p == '\0') && (*c == '/'))
    81d0:	780b      	ldrb	r3, [r1, #0]
        // Return then isolated node name of the child
        return len ? c : NULL;
    } 
	else 
	{
        return NULL;
    81d2:	2000      	movs	r0, #0
    while (*p && (*p == *c)) 
	{
        ++p;
        ++c;
    }
    if ((*p == '\0') && (*c == '/'))
    81d4:	2b2f      	cmp	r3, #47	; 0x2f
    81d6:	d104      	bne.n	81e2 <ChildPath+0x72>
    81d8:	e7e2      	b.n	81a0 <ChildPath+0x30>
        ++c;
        while (c[len] && c[len] != '/') 
		{
            ++len;
        }
        if (sz) 
    81da:	2300      	movs	r3, #0
    81dc:	2a00      	cmp	r2, #0
    81de:	d1ef      	bne.n	81c0 <ChildPath+0x50>
		{
            *sz = len;
        }
        // Return then isolated node name of the child
        return len ? c : NULL;
    81e0:	2000      	movs	r0, #0
    } 
	else 
	{
        return NULL;
    }
}
    81e2:	bd10      	pop	{r4, pc}

000081e4 <FindInterface>:
    }
    return (*encoding == '\0') || (*encoding == ' ');
}

static AJ_InterfaceDescription FindInterface(const AJ_InterfaceDescription* interfaces, const char* iface, uint8_t* index)
{
    81e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    81e6:	4657      	mov	r7, sl
    81e8:	4646      	mov	r6, r8
    81ea:	b4c0      	push	{r6, r7}
    81ec:	b083      	sub	sp, #12
    81ee:	1c05      	adds	r5, r0, #0
    81f0:	9101      	str	r1, [sp, #4]
    81f2:	1c17      	adds	r7, r2, #0
    *index = 0;
    81f4:	2300      	movs	r3, #0
    81f6:	7013      	strb	r3, [r2, #0]
    if (interfaces) 
    81f8:	2800      	cmp	r0, #0
    81fa:	d01f      	beq.n	823c <FindInterface+0x58>
	{
        while (*interfaces) 
    81fc:	6804      	ldr	r4, [r0, #0]
    81fe:	2c00      	cmp	r4, #0
    8200:	d01e      	beq.n	8240 <FindInterface+0x5c>
            if (desc) 
			{
                // Skip security specifier when comparing the interface name
                if ((*intfName == SECURE_TRUE) || (*intfName == SECURE_OFF)) 
				{
                    ++intfName;
    8202:	3301      	adds	r3, #1
    8204:	469a      	mov	sl, r3
    8206:	2600      	movs	r6, #0
                }
                if (strcmp(intfName, iface) == 0) 
    8208:	4b11      	ldr	r3, [pc, #68]	; (8250 <FindInterface+0x6c>)
    820a:	4698      	mov	r8, r3
    *index = 0;
    if (interfaces) 
	{
        while (*interfaces) 
		{
            AJ_InterfaceDescription desc = *interfaces++;
    820c:	3504      	adds	r5, #4
            const char* intfName = *desc;
    820e:	6820      	ldr	r0, [r4, #0]

            if (desc) 
    8210:	2c00      	cmp	r4, #0
    8212:	d00b      	beq.n	822c <FindInterface+0x48>
			{
                // Skip security specifier when comparing the interface name
                if ((*intfName == SECURE_TRUE) || (*intfName == SECURE_OFF)) 
    8214:	7803      	ldrb	r3, [r0, #0]
    8216:	3b23      	subs	r3, #35	; 0x23
    8218:	b2db      	uxtb	r3, r3
				{
                    ++intfName;
    821a:	1c32      	adds	r2, r6, #0
    821c:	4651      	mov	r1, sl
    821e:	4299      	cmp	r1, r3
    8220:	4172      	adcs	r2, r6
    8222:	1880      	adds	r0, r0, r2
                }
                if (strcmp(intfName, iface) == 0) 
    8224:	9901      	ldr	r1, [sp, #4]
    8226:	47c0      	blx	r8
    8228:	2800      	cmp	r0, #0
    822a:	d00b      	beq.n	8244 <FindInterface+0x60>
				{
                    return desc;
                }
            }
            *index += 1;
    822c:	783b      	ldrb	r3, [r7, #0]
    822e:	3301      	adds	r3, #1
    8230:	703b      	strb	r3, [r7, #0]
static AJ_InterfaceDescription FindInterface(const AJ_InterfaceDescription* interfaces, const char* iface, uint8_t* index)
{
    *index = 0;
    if (interfaces) 
	{
        while (*interfaces) 
    8232:	682c      	ldr	r4, [r5, #0]
    8234:	2c00      	cmp	r4, #0
    8236:	d1e9      	bne.n	820c <FindInterface+0x28>
                }
            }
            *index += 1;
        }
    }
    return NULL;
    8238:	2000      	movs	r0, #0
    823a:	e004      	b.n	8246 <FindInterface+0x62>
    823c:	2000      	movs	r0, #0
    823e:	e002      	b.n	8246 <FindInterface+0x62>
    8240:	2000      	movs	r0, #0
    8242:	e000      	b.n	8246 <FindInterface+0x62>
    8244:	1c20      	adds	r0, r4, #0
}
    8246:	b003      	add	sp, #12
    8248:	bc0c      	pop	{r2, r3}
    824a:	4690      	mov	r8, r2
    824c:	469a      	mov	sl, r3
    824e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8250:	00017137 	.word	0x00017137

00008254 <CheckSignature>:

/*
 * Check that the signature in the message matches the encoded signature in the string
 */
static AJ_Status CheckSignature(const char* encoding, const AJ_Message* msg)
{
    8254:	b510      	push	{r4, lr}
    const char* sig = msg->signature ? msg->signature : "";
    8256:	69ca      	ldr	r2, [r1, #28]
    8258:	2a00      	cmp	r2, #0
    825a:	d100      	bne.n	825e <CheckSignature+0xa>
    825c:	4a20      	ldr	r2, [pc, #128]	; (82e0 <CheckSignature+0x8c>)
    char direction = (msg->hdr->msgType == AJ_MSG_METHOD_CALL) ? IN_ARG : OUT_ARG;
    825e:	684b      	ldr	r3, [r1, #4]
    8260:	785b      	ldrb	r3, [r3, #1]
    8262:	2b01      	cmp	r3, #1
    8264:	d001      	beq.n	826a <CheckSignature+0x16>
    8266:	243e      	movs	r4, #62	; 0x3e
    8268:	e000      	b.n	826c <CheckSignature+0x18>
    826a:	243c      	movs	r4, #60	; 0x3c

    //Wild card in the message is ok.
    if (*sig == '*') 
    826c:	7813      	ldrb	r3, [r2, #0]
    826e:	2b2a      	cmp	r3, #42	; 0x2a
    8270:	d126      	bne.n	82c0 <CheckSignature+0x6c>
    8272:	e02d      	b.n	82d0 <CheckSignature+0x7c>
        return AJ_OK;
    }
    while (*encoding) 
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction)) 
    8274:	7803      	ldrb	r3, [r0, #0]
    8276:	2b00      	cmp	r3, #0
    8278:	d104      	bne.n	8284 <CheckSignature+0x30>
    827a:	e021      	b.n	82c0 <CheckSignature+0x6c>
		{
        }
        // Match a single arg to the signature
        while (*encoding && (*sig == *encoding)) 
    827c:	7811      	ldrb	r1, [r2, #0]
    827e:	4299      	cmp	r1, r3
    8280:	d007      	beq.n	8292 <CheckSignature+0x3e>
    8282:	e029      	b.n	82d8 <CheckSignature+0x84>
        return AJ_OK;
    }
    while (*encoding) 
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction)) 
    8284:	3001      	adds	r0, #1
    8286:	429c      	cmp	r4, r3
    8288:	d1f4      	bne.n	8274 <CheckSignature+0x20>
		{
        }
        // Match a single arg to the signature
        while (*encoding && (*sig == *encoding)) 
    828a:	7803      	ldrb	r3, [r0, #0]
    828c:	2b00      	cmp	r3, #0
    828e:	d1f5      	bne.n	827c <CheckSignature+0x28>
    8290:	e016      	b.n	82c0 <CheckSignature+0x6c>
		{
            ++sig;
    8292:	3201      	adds	r2, #1
            ++encoding;
    8294:	3001      	adds	r0, #1
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction)) 
		{
        }
        // Match a single arg to the signature
        while (*encoding && (*sig == *encoding)) 
    8296:	7803      	ldrb	r3, [r0, #0]
    8298:	2b00      	cmp	r3, #0
    829a:	d011      	beq.n	82c0 <CheckSignature+0x6c>
    829c:	7811      	ldrb	r1, [r2, #0]
    829e:	4299      	cmp	r1, r3
    82a0:	d0f7      	beq.n	8292 <CheckSignature+0x3e>
    82a2:	e019      	b.n	82d8 <CheckSignature+0x84>
            ++sig;
            ++encoding;
        }
        if (*encoding && (*encoding != ' ')) 
		{
            AJ_ErrPrintf(("CheckSignature(): AJ_ERR_SIGNATURE\n"));
    82a4:	2001      	movs	r0, #1
    82a6:	490f      	ldr	r1, [pc, #60]	; (82e4 <CheckSignature+0x90>)
    82a8:	4a0f      	ldr	r2, [pc, #60]	; (82e8 <CheckSignature+0x94>)
    82aa:	4b10      	ldr	r3, [pc, #64]	; (82ec <CheckSignature+0x98>)
    82ac:	4798      	blx	r3
    82ae:	1c03      	adds	r3, r0, #0
            return AJ_ERR_SIGNATURE;
    82b0:	2011      	movs	r0, #17
            ++sig;
            ++encoding;
        }
        if (*encoding && (*encoding != ' ')) 
		{
            AJ_ErrPrintf(("CheckSignature(): AJ_ERR_SIGNATURE\n"));
    82b2:	2b00      	cmp	r3, #0
    82b4:	d013      	beq.n	82de <CheckSignature+0x8a>
    82b6:	480e      	ldr	r0, [pc, #56]	; (82f0 <CheckSignature+0x9c>)
    82b8:	4b0e      	ldr	r3, [pc, #56]	; (82f4 <CheckSignature+0xa0>)
    82ba:	4798      	blx	r3
            return AJ_ERR_SIGNATURE;
    82bc:	2011      	movs	r0, #17
    82be:	e00e      	b.n	82de <CheckSignature+0x8a>
    //Wild card in the message is ok.
    if (*sig == '*') 
	{
        return AJ_OK;
    }
    while (*encoding) 
    82c0:	7803      	ldrb	r3, [r0, #0]
    82c2:	2b00      	cmp	r3, #0
    82c4:	d1de      	bne.n	8284 <CheckSignature+0x30>
            AJ_ErrPrintf(("CheckSignature(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    // On a match we should have consumed both strings
    return (*encoding == *sig) ? AJ_OK : AJ_ERR_SIGNATURE;
    82c6:	7813      	ldrb	r3, [r2, #0]
    82c8:	2b00      	cmp	r3, #0
    82ca:	d003      	beq.n	82d4 <CheckSignature+0x80>
    82cc:	2011      	movs	r0, #17
    82ce:	e006      	b.n	82de <CheckSignature+0x8a>
    char direction = (msg->hdr->msgType == AJ_MSG_METHOD_CALL) ? IN_ARG : OUT_ARG;

    //Wild card in the message is ok.
    if (*sig == '*') 
	{
        return AJ_OK;
    82d0:	2000      	movs	r0, #0
    82d2:	e004      	b.n	82de <CheckSignature+0x8a>
            AJ_ErrPrintf(("CheckSignature(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    // On a match we should have consumed both strings
    return (*encoding == *sig) ? AJ_OK : AJ_ERR_SIGNATURE;
    82d4:	2000      	movs	r0, #0
    82d6:	e002      	b.n	82de <CheckSignature+0x8a>
        while (*encoding && (*sig == *encoding)) 
		{
            ++sig;
            ++encoding;
        }
        if (*encoding && (*encoding != ' ')) 
    82d8:	2b20      	cmp	r3, #32
    82da:	d0f1      	beq.n	82c0 <CheckSignature+0x6c>
    82dc:	e7e2      	b.n	82a4 <CheckSignature+0x50>
            return AJ_ERR_SIGNATURE;
        }
    }
    // On a match we should have consumed both strings
    return (*encoding == *sig) ? AJ_OK : AJ_ERR_SIGNATURE;
}
    82de:	bd10      	pop	{r4, pc}
    82e0:	0001d368 	.word	0x0001d368
    82e4:	0001ca4c 	.word	0x0001ca4c
    82e8:	00000379 	.word	0x00000379
    82ec:	0000636d 	.word	0x0000636d
    82f0:	0001ca7c 	.word	0x0001ca7c
    82f4:	00016f5d 	.word	0x00016f5d

000082f8 <CheckIndex>:

#ifndef NDEBUG
//Validates an index into a NULL terminated array

static uint8_t CheckIndex(const void* ptr, uint8_t index, size_t stride)
{
    82f8:	b508      	push	{r3, lr}
    if (!ptr) 
    82fa:	2800      	cmp	r0, #0
    82fc:	d101      	bne.n	8302 <CheckIndex+0xa>
    82fe:	e018      	b.n	8332 <CheckIndex+0x3a>
		{
            AJ_ErrPrintf(("\n!!!Invalid msg identifier indicates programming error!!!\n"));
            return FALSE;
        }
        ptr = (((uint8_t*)ptr) + stride);
    } while (index--);
    8300:	1c19      	adds	r1, r3, #0
    if (!ptr) 
	{
        return FALSE;
    }
    do {
        if (*((void**)ptr) == NULL) 
    8302:	6803      	ldr	r3, [r0, #0]
    8304:	2b00      	cmp	r3, #0
    8306:	d10d      	bne.n	8324 <CheckIndex+0x2c>
		{
            AJ_ErrPrintf(("\n!!!Invalid msg identifier indicates programming error!!!\n"));
    8308:	2001      	movs	r0, #1
    830a:	490b      	ldr	r1, [pc, #44]	; (8338 <CheckIndex+0x40>)
    830c:	4a0b      	ldr	r2, [pc, #44]	; (833c <CheckIndex+0x44>)
    830e:	4b0c      	ldr	r3, [pc, #48]	; (8340 <CheckIndex+0x48>)
    8310:	4798      	blx	r3
    8312:	1c03      	adds	r3, r0, #0
            return FALSE;
    8314:	2000      	movs	r0, #0
        return FALSE;
    }
    do {
        if (*((void**)ptr) == NULL) 
		{
            AJ_ErrPrintf(("\n!!!Invalid msg identifier indicates programming error!!!\n"));
    8316:	2b00      	cmp	r3, #0
    8318:	d00c      	beq.n	8334 <CheckIndex+0x3c>
    831a:	480a      	ldr	r0, [pc, #40]	; (8344 <CheckIndex+0x4c>)
    831c:	4b0a      	ldr	r3, [pc, #40]	; (8348 <CheckIndex+0x50>)
    831e:	4798      	blx	r3
            return FALSE;
    8320:	2000      	movs	r0, #0
    8322:	e007      	b.n	8334 <CheckIndex+0x3c>
        }
        ptr = (((uint8_t*)ptr) + stride);
    8324:	1880      	adds	r0, r0, r2
    } while (index--);
    8326:	1e4b      	subs	r3, r1, #1
    8328:	b2db      	uxtb	r3, r3
    832a:	2900      	cmp	r1, #0
    832c:	d1e8      	bne.n	8300 <CheckIndex+0x8>
    return TRUE;
    832e:	2001      	movs	r0, #1
    8330:	e000      	b.n	8334 <CheckIndex+0x3c>

static uint8_t CheckIndex(const void* ptr, uint8_t index, size_t stride)
{
    if (!ptr) 
	{
        return FALSE;
    8332:	2000      	movs	r0, #0
            return FALSE;
        }
        ptr = (((uint8_t*)ptr) + stride);
    } while (index--);
    return TRUE;
}
    8334:	bd08      	pop	{r3, pc}
    8336:	46c0      	nop			; (mov r8, r8)
    8338:	0001ca4c 	.word	0x0001ca4c
    833c:	00000436 	.word	0x00000436
    8340:	0000636d 	.word	0x0000636d
    8344:	0001caa0 	.word	0x0001caa0
    8348:	00016f5d 	.word	0x00016f5d

0000834c <ComposeSignature>:
    return (*encoding == *sig) ? AJ_OK : AJ_ERR_SIGNATURE;
}

// Composes a signature from the member encoding from an interface description.
static AJ_Status ComposeSignature(const char* encoding, char direction, char* sig, size_t len)
{
    834c:	b570      	push	{r4, r5, r6, lr}
    while (*encoding) 
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction));
        // Match a single arg to the signature
        while (*encoding && (*encoding != ' ')) 
    834e:	2620      	movs	r6, #32
}

// Composes a signature from the member encoding from an interface description.
static AJ_Status ComposeSignature(const char* encoding, char direction, char* sig, size_t len)
{
    while (*encoding) 
    8350:	e027      	b.n	83a2 <ComposeSignature+0x56>
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction));
    8352:	7804      	ldrb	r4, [r0, #0]
    8354:	2c00      	cmp	r4, #0
    8356:	d104      	bne.n	8362 <ComposeSignature+0x16>
    8358:	e023      	b.n	83a2 <ComposeSignature+0x56>
        // Match a single arg to the signature
        while (*encoding && (*encoding != ' ')) 
		{
            if (--len == 0) 
    835a:	3b01      	subs	r3, #1
    835c:	2b00      	cmp	r3, #0
    835e:	d00b      	beq.n	8378 <ComposeSignature+0x2c>
    8360:	e017      	b.n	8392 <ComposeSignature+0x46>
static AJ_Status ComposeSignature(const char* encoding, char direction, char* sig, size_t len)
{
    while (*encoding) 
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction));
    8362:	3001      	adds	r0, #1
    8364:	428c      	cmp	r4, r1
    8366:	d1f4      	bne.n	8352 <ComposeSignature+0x6>
        // Match a single arg to the signature
        while (*encoding && (*encoding != ' ')) 
    8368:	7804      	ldrb	r4, [r0, #0]
    836a:	1c25      	adds	r5, r4, #0
    836c:	43b5      	bics	r5, r6
    836e:	d1f4      	bne.n	835a <ComposeSignature+0xe>
    8370:	e017      	b.n	83a2 <ComposeSignature+0x56>
		{
            if (--len == 0) 
    8372:	3b01      	subs	r3, #1
    8374:	2b00      	cmp	r3, #0
    8376:	d10c      	bne.n	8392 <ComposeSignature+0x46>
			{
                AJ_ErrPrintf(("ComposeSignature(): AJ_ERR_RESOURCES\n"));
    8378:	2001      	movs	r0, #1
    837a:	490d      	ldr	r1, [pc, #52]	; (83b0 <ComposeSignature+0x64>)
    837c:	4a0d      	ldr	r2, [pc, #52]	; (83b4 <ComposeSignature+0x68>)
    837e:	4b0e      	ldr	r3, [pc, #56]	; (83b8 <ComposeSignature+0x6c>)
    8380:	4798      	blx	r3
                return AJ_ERR_RESOURCES;
    8382:	230b      	movs	r3, #11
        // Match a single arg to the signature
        while (*encoding && (*encoding != ' ')) 
		{
            if (--len == 0) 
			{
                AJ_ErrPrintf(("ComposeSignature(): AJ_ERR_RESOURCES\n"));
    8384:	2800      	cmp	r0, #0
    8386:	d011      	beq.n	83ac <ComposeSignature+0x60>
    8388:	480c      	ldr	r0, [pc, #48]	; (83bc <ComposeSignature+0x70>)
    838a:	4b0d      	ldr	r3, [pc, #52]	; (83c0 <ComposeSignature+0x74>)
    838c:	4798      	blx	r3
                return AJ_ERR_RESOURCES;
    838e:	230b      	movs	r3, #11
    8390:	e00c      	b.n	83ac <ComposeSignature+0x60>
            }
            *sig++ = *encoding++;
    8392:	3201      	adds	r2, #1
    8394:	3001      	adds	r0, #1
    8396:	1e55      	subs	r5, r2, #1
    8398:	702c      	strb	r4, [r5, #0]
    while (*encoding) 
	{
        // Skip until we find a direction character
        while (*encoding && (*encoding++ != direction));
        // Match a single arg to the signature
        while (*encoding && (*encoding != ' ')) 
    839a:	7804      	ldrb	r4, [r0, #0]
    839c:	1c25      	adds	r5, r4, #0
    839e:	43b5      	bics	r5, r6
    83a0:	d1e7      	bne.n	8372 <ComposeSignature+0x26>
}

// Composes a signature from the member encoding from an interface description.
static AJ_Status ComposeSignature(const char* encoding, char direction, char* sig, size_t len)
{
    while (*encoding) 
    83a2:	7804      	ldrb	r4, [r0, #0]
    83a4:	2c00      	cmp	r4, #0
    83a6:	d1dc      	bne.n	8362 <ComposeSignature+0x16>
                return AJ_ERR_RESOURCES;
            }
            *sig++ = *encoding++;
        }
    }
    *sig = '\0';
    83a8:	2300      	movs	r3, #0
    83aa:	7013      	strb	r3, [r2, #0]
    return AJ_OK;
}
    83ac:	1c18      	adds	r0, r3, #0
    83ae:	bd70      	pop	{r4, r5, r6, pc}
    83b0:	0001ca4c 	.word	0x0001ca4c
    83b4:	0000038d 	.word	0x0000038d
    83b8:	0000636d 	.word	0x0000636d
    83bc:	0001cadc 	.word	0x0001cadc
    83c0:	00016f5d 	.word	0x00016f5d

000083c4 <PrintXML>:
 * in a debug build.
 */
#ifndef NDEBUG

static void PrintXML(void* context, const char* str, uint32_t len)
{
    83c4:	b570      	push	{r4, r5, r6, lr}
    if (len) 
    83c6:	2a00      	cmp	r2, #0
    83c8:	d009      	beq.n	83de <PrintXML+0x1a>
    83ca:	1c0d      	adds	r5, r1, #0
    83cc:	1c14      	adds	r4, r2, #0
	{
        while (len--) 
		{
            AJ_AlwaysPrintf(("%c", *str++));
    83ce:	4e06      	ldr	r6, [pc, #24]	; (83e8 <PrintXML+0x24>)
    83d0:	7828      	ldrb	r0, [r5, #0]
    83d2:	47b0      	blx	r6
    83d4:	3501      	adds	r5, #1
    83d6:	3c01      	subs	r4, #1

static void PrintXML(void* context, const char* str, uint32_t len)
{
    if (len) 
	{
        while (len--) 
    83d8:	2c00      	cmp	r4, #0
    83da:	d1f9      	bne.n	83d0 <PrintXML+0xc>
    83dc:	e002      	b.n	83e4 <PrintXML+0x20>
            AJ_AlwaysPrintf(("%c", *str++));
        }
    } 
	else 
	{
        AJ_AlwaysPrintf(("%s", str));
    83de:	4803      	ldr	r0, [pc, #12]	; (83ec <PrintXML+0x28>)
    83e0:	4b03      	ldr	r3, [pc, #12]	; (83f0 <PrintXML+0x2c>)
    83e2:	4798      	blx	r3
    }
}
    83e4:	bd70      	pop	{r4, r5, r6, pc}
    83e6:	46c0      	nop			; (mov r8, r8)
    83e8:	00016e71 	.word	0x00016e71
    83ec:	0001cb18 	.word	0x0001cb18
    83f0:	00016e3d 	.word	0x00016e3d

000083f4 <ExpandInterfaces>:
    }
    return;
}

static AJ_Status ExpandInterfaces(XMLWriterFunc XMLWriter, void* context, const AJ_InterfaceDescription* iface, AJ_DescriptionLookupFunc descLookup, uint32_t descObjId, const char* languageTag)
{
    83f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    83f6:	465f      	mov	r7, fp
    83f8:	4656      	mov	r6, sl
    83fa:	464d      	mov	r5, r9
    83fc:	4644      	mov	r4, r8
    83fe:	b4f0      	push	{r4, r5, r6, r7}
    8400:	b08d      	sub	sp, #52	; 0x34
    8402:	1c07      	adds	r7, r0, #0
    8404:	9104      	str	r1, [sp, #16]
    8406:	9209      	str	r2, [sp, #36]	; 0x24
    8408:	9305      	str	r3, [sp, #20]
    uint32_t descId;
    uint8_t ifaceIndex = 0;
    if (!iface) 
    840a:	2a00      	cmp	r2, #0
    840c:	d100      	bne.n	8410 <ExpandInterfaces+0x1c>
    840e:	e17d      	b.n	870c <ExpandInterfaces+0x318>
	{
        return AJ_OK;
    }
    while (*iface) 
    8410:	6814      	ldr	r4, [r2, #0]
    8412:	2c00      	cmp	r4, #0
    8414:	d100      	bne.n	8418 <ExpandInterfaces+0x24>
    8416:	e17b      	b.n	8710 <ExpandInterfaces+0x31c>
    8418:	2300      	movs	r3, #0
    841a:	9308      	str	r3, [sp, #32]
                }
            }
        } 
		else
		{
            XMLWriteTag(XMLWriter, context, interfaceOpen, nameAttr, entries[0], 0, FALSE);
    841c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    841e:	4698      	mov	r8, r3
    }
    while (*iface) 
	{
        uint8_t memberIndex = 0;
        const char* const* entries = *iface;
        char flag = entries[0][0];
    8420:	6825      	ldr	r5, [r4, #0]
    8422:	782e      	ldrb	r6, [r5, #0]
        uint8_t dBus_std_iface = FALSE;
        const char* description = NULL;

        //Increase the interface index since we start at 1 
        ++ifaceIndex;
    8424:	9b08      	ldr	r3, [sp, #32]
    8426:	3301      	adds	r3, #1
    8428:	b2db      	uxtb	r3, r3
    842a:	9308      	str	r3, [sp, #32]
        descId = descObjId | (((uint32_t)(ifaceIndex)) << 16);
    842c:	041b      	lsls	r3, r3, #16
    842e:	9a16      	ldr	r2, [sp, #88]	; 0x58
    8430:	431a      	orrs	r2, r3
    8432:	4691      	mov	r9, r2

        if ((flag == SECURE_TRUE) || (flag == SECURE_OFF)) 
    8434:	1c33      	adds	r3, r6, #0
    8436:	3b23      	subs	r3, #35	; 0x23
    8438:	2b01      	cmp	r3, #1
    843a:	d828      	bhi.n	848e <ExpandInterfaces+0x9a>
		{

            // If it is a common standard interface, do not add any annotations.
            if ((strcmp(entries[0], AJ_IntrospectionIface[0]) == 0) ||
    843c:	4bd7      	ldr	r3, [pc, #860]	; (879c <ExpandInterfaces+0x3a8>)
    843e:	6819      	ldr	r1, [r3, #0]
    8440:	1c28      	adds	r0, r5, #0
    8442:	4bd7      	ldr	r3, [pc, #860]	; (87a0 <ExpandInterfaces+0x3ac>)
    8444:	4798      	blx	r3
    8446:	2800      	cmp	r0, #0
    8448:	d100      	bne.n	844c <ExpandInterfaces+0x58>
    844a:	e163      	b.n	8714 <ExpandInterfaces+0x320>
                (strcmp(entries[0], AJ_PropertiesIface[0]) == 0) ||
    844c:	4bd5      	ldr	r3, [pc, #852]	; (87a4 <ExpandInterfaces+0x3b0>)
    844e:	6819      	ldr	r1, [r3, #0]
    8450:	1c28      	adds	r0, r5, #0
    8452:	4bd3      	ldr	r3, [pc, #844]	; (87a0 <ExpandInterfaces+0x3ac>)
    8454:	4798      	blx	r3

        if ((flag == SECURE_TRUE) || (flag == SECURE_OFF)) 
		{

            // If it is a common standard interface, do not add any annotations.
            if ((strcmp(entries[0], AJ_IntrospectionIface[0]) == 0) ||
    8456:	2800      	cmp	r0, #0
    8458:	d100      	bne.n	845c <ExpandInterfaces+0x68>
    845a:	e15b      	b.n	8714 <ExpandInterfaces+0x320>
                (strcmp(entries[0], AJ_PropertiesIface[0]) == 0) ||
                (strcmp(entries[0], DBusPeerInterface) == 0) ||
    845c:	1c28      	adds	r0, r5, #0
    845e:	49d2      	ldr	r1, [pc, #840]	; (87a8 <ExpandInterfaces+0x3b4>)
    8460:	4bcf      	ldr	r3, [pc, #828]	; (87a0 <ExpandInterfaces+0x3ac>)
    8462:	4798      	blx	r3
        if ((flag == SECURE_TRUE) || (flag == SECURE_OFF)) 
		{

            // If it is a common standard interface, do not add any annotations.
            if ((strcmp(entries[0], AJ_IntrospectionIface[0]) == 0) ||
                (strcmp(entries[0], AJ_PropertiesIface[0]) == 0) ||
    8464:	2800      	cmp	r0, #0
    8466:	d100      	bne.n	846a <ExpandInterfaces+0x76>
    8468:	e154      	b.n	8714 <ExpandInterfaces+0x320>
                (strcmp(entries[0], DBusPeerInterface) == 0) ||
                (strcmp(entries[0], AllSeenIntrospectableInterface) == 0)) 
    846a:	1c28      	adds	r0, r5, #0
    846c:	49cf      	ldr	r1, [pc, #828]	; (87ac <ExpandInterfaces+0x3b8>)
    846e:	4bcc      	ldr	r3, [pc, #816]	; (87a0 <ExpandInterfaces+0x3ac>)
    8470:	4798      	blx	r3
		{

            // If it is a common standard interface, do not add any annotations.
            if ((strcmp(entries[0], AJ_IntrospectionIface[0]) == 0) ||
                (strcmp(entries[0], AJ_PropertiesIface[0]) == 0) ||
                (strcmp(entries[0], DBusPeerInterface) == 0) ||
    8472:	2800      	cmp	r0, #0
    8474:	d100      	bne.n	8478 <ExpandInterfaces+0x84>
    8476:	e14d      	b.n	8714 <ExpandInterfaces+0x320>
    8478:	e158      	b.n	872c <ExpandInterfaces+0x338>
            if (!dBus_std_iface)
			{
                XMLWriter(context, annotateSecure, sizeof(annotateSecure) - 1);
                if (flag == SECURE_TRUE) 
				{
                    XMLWriter(context, secureTrue, sizeof(secureTrue) - 1);
    847a:	9804      	ldr	r0, [sp, #16]
    847c:	49cc      	ldr	r1, [pc, #816]	; (87b0 <ExpandInterfaces+0x3bc>)
    847e:	2208      	movs	r2, #8
    8480:	47b8      	blx	r7
    8482:	e00e      	b.n	84a2 <ExpandInterfaces+0xae>
                } 
				else 
				{
                    XMLWriter(context, secureOff, sizeof(secureOff) - 1);
    8484:	9804      	ldr	r0, [sp, #16]
    8486:	49cb      	ldr	r1, [pc, #812]	; (87b4 <ExpandInterfaces+0x3c0>)
    8488:	2207      	movs	r2, #7
    848a:	47b8      	blx	r7
    848c:	e009      	b.n	84a2 <ExpandInterfaces+0xae>
                }
            }
        } 
		else
		{
            XMLWriteTag(XMLWriter, context, interfaceOpen, nameAttr, entries[0], 0, FALSE);
    848e:	9500      	str	r5, [sp, #0]
    8490:	2300      	movs	r3, #0
    8492:	9301      	str	r3, [sp, #4]
    8494:	9302      	str	r3, [sp, #8]
    8496:	1c38      	adds	r0, r7, #0
    8498:	9904      	ldr	r1, [sp, #16]
    849a:	4ac7      	ldr	r2, [pc, #796]	; (87b8 <ExpandInterfaces+0x3c4>)
    849c:	4bc7      	ldr	r3, [pc, #796]	; (87bc <ExpandInterfaces+0x3c8>)
    849e:	4dc8      	ldr	r5, [pc, #800]	; (87c0 <ExpandInterfaces+0x3cc>)
    84a0:	47a8      	blx	r5
        }
        description = GetDescription(descLookup, descId, languageTag);
    84a2:	9805      	ldr	r0, [sp, #20]
    84a4:	4649      	mov	r1, r9
    84a6:	4642      	mov	r2, r8
    84a8:	4bc6      	ldr	r3, [pc, #792]	; (87c4 <ExpandInterfaces+0x3d0>)
    84aa:	4798      	blx	r3
    84ac:	1e03      	subs	r3, r0, #0
        if (description != NULL) 
    84ae:	d006      	beq.n	84be <ExpandInterfaces+0xca>
		{
            XMLWriteDescription(XMLWriter, context, 0, description, languageTag);
    84b0:	4642      	mov	r2, r8
    84b2:	9200      	str	r2, [sp, #0]
    84b4:	1c38      	adds	r0, r7, #0
    84b6:	9904      	ldr	r1, [sp, #16]
    84b8:	2200      	movs	r2, #0
    84ba:	4dc3      	ldr	r5, [pc, #780]	; (87c8 <ExpandInterfaces+0x3d4>)
    84bc:	47a8      	blx	r5
        }

        while (*(++entries)) 
    84be:	1d23      	adds	r3, r4, #4
    84c0:	9307      	str	r3, [sp, #28]
    84c2:	6863      	ldr	r3, [r4, #4]
    84c4:	2b00      	cmp	r3, #0
    84c6:	d000      	beq.n	84ca <ExpandInterfaces+0xd6>
    84c8:	e106      	b.n	86d8 <ExpandInterfaces+0x2e4>
    84ca:	e112      	b.n	86f2 <ExpandInterfaces+0x2fe>
		{
            uint8_t argIndex = 0;
            const char* member = *entries;
            uint8_t memberType = MEMBER_TYPE(*member++);
    84cc:	1c5a      	adds	r2, r3, #1
    84ce:	920b      	str	r2, [sp, #44]	; 0x2c
    84d0:	781d      	ldrb	r5, [r3, #0]
    84d2:	092d      	lsrs	r5, r5, #4
    84d4:	1eab      	subs	r3, r5, #2
    84d6:	b2db      	uxtb	r3, r3
    84d8:	469a      	mov	sl, r3
            uint8_t attr;
            uint8_t isSessionless = FALSE;

            // Increase index since we start at 1
            ++memberIndex;
    84da:	9b06      	ldr	r3, [sp, #24]
    84dc:	3301      	adds	r3, #1
    84de:	b2db      	uxtb	r3, r3
    84e0:	9306      	str	r3, [sp, #24]
            if (memberType > 2) 
    84e2:	4653      	mov	r3, sl
    84e4:	2b02      	cmp	r3, #2
    84e6:	d910      	bls.n	850a <ExpandInterfaces+0x116>
			{
                AJ_ErrPrintf(("ExpandInterfaces(): %s", AJ_StatusText(AJ_ERR_UNEXPECTED)));
    84e8:	2001      	movs	r0, #1
    84ea:	49b8      	ldr	r1, [pc, #736]	; (87cc <ExpandInterfaces+0x3d8>)
    84ec:	2222      	movs	r2, #34	; 0x22
    84ee:	32ff      	adds	r2, #255	; 0xff
    84f0:	4bb7      	ldr	r3, [pc, #732]	; (87d0 <ExpandInterfaces+0x3dc>)
    84f2:	4798      	blx	r3
    84f4:	2800      	cmp	r0, #0
    84f6:	d100      	bne.n	84fa <ExpandInterfaces+0x106>
    84f8:	e0ec      	b.n	86d4 <ExpandInterfaces+0x2e0>
    84fa:	2002      	movs	r0, #2
    84fc:	4bb5      	ldr	r3, [pc, #724]	; (87d4 <ExpandInterfaces+0x3e0>)
    84fe:	4798      	blx	r3
    8500:	1c01      	adds	r1, r0, #0
    8502:	48b5      	ldr	r0, [pc, #724]	; (87d8 <ExpandInterfaces+0x3e4>)
    8504:	4bb5      	ldr	r3, [pc, #724]	; (87dc <ExpandInterfaces+0x3e8>)
    8506:	4798      	blx	r3
    8508:	e0e4      	b.n	86d4 <ExpandInterfaces+0x2e0>
                return AJ_ERR_UNEXPECTED;
            }
            XMLWriter(context, MemberOpen[memberType], 0);
    850a:	4653      	mov	r3, sl
    850c:	009b      	lsls	r3, r3, #2
    850e:	4ab4      	ldr	r2, [pc, #720]	; (87e0 <ExpandInterfaces+0x3ec>)
    8510:	5899      	ldr	r1, [r3, r2]
    8512:	9804      	ldr	r0, [sp, #16]
    8514:	2200      	movs	r2, #0
    8516:	47b8      	blx	r7
            if (memberType == SIGNAL && IS_SESSIONLESS(*member)) 
    8518:	4653      	mov	r3, sl
    851a:	2b00      	cmp	r3, #0
    851c:	d10c      	bne.n	8538 <ExpandInterfaces+0x144>
    851e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8520:	781a      	ldrb	r2, [r3, #0]
		{
            uint8_t argIndex = 0;
            const char* member = *entries;
            uint8_t memberType = MEMBER_TYPE(*member++);
            uint8_t attr;
            uint8_t isSessionless = FALSE;
    8522:	2500      	movs	r5, #0
			{
                AJ_ErrPrintf(("ExpandInterfaces(): %s", AJ_StatusText(AJ_ERR_UNEXPECTED)));
                return AJ_ERR_UNEXPECTED;
            }
            XMLWriter(context, MemberOpen[memberType], 0);
            if (memberType == SIGNAL && IS_SESSIONLESS(*member)) 
    8524:	2a26      	cmp	r2, #38	; 0x26
    8526:	d000      	beq.n	852a <ExpandInterfaces+0x136>
    8528:	e113      	b.n	8752 <ExpandInterfaces+0x35e>
			{
                // Advance so that we do not return a '&' character
                member++;
    852a:	3301      	adds	r3, #1
    852c:	930b      	str	r3, [sp, #44]	; 0x2c
                if (descLookup != NULL) 
    852e:	9d05      	ldr	r5, [sp, #20]
    8530:	1e6b      	subs	r3, r5, #1
    8532:	419d      	sbcs	r5, r3
		{
            uint8_t argIndex = 0;
            const char* member = *entries;
            uint8_t memberType = MEMBER_TYPE(*member++);
            uint8_t attr;
            uint8_t isSessionless = FALSE;
    8534:	b2ed      	uxtb	r5, r5
    8536:	e10c      	b.n	8752 <ExpandInterfaces+0x35e>
                  * through the org.allseen.Introspect interface
                  */
                    isSessionless = TRUE;
                }
            }
            attr = ExpandAttribute(XMLWriter, context, &member, nameAttr, "\"");
    8538:	4baa      	ldr	r3, [pc, #680]	; (87e4 <ExpandInterfaces+0x3f0>)
    853a:	9300      	str	r3, [sp, #0]
    853c:	1c38      	adds	r0, r7, #0
    853e:	9904      	ldr	r1, [sp, #16]
    8540:	aa0b      	add	r2, sp, #44	; 0x2c
    8542:	4b9e      	ldr	r3, [pc, #632]	; (87bc <ExpandInterfaces+0x3c8>)
    8544:	4ca8      	ldr	r4, [pc, #672]	; (87e8 <ExpandInterfaces+0x3f4>)
    8546:	47a0      	blx	r4
    8548:	1c04      	adds	r4, r0, #0
            if (memberType == PROPERTY) 
    854a:	4653      	mov	r3, sl
    854c:	2b02      	cmp	r3, #2
    854e:	d13e      	bne.n	85ce <ExpandInterfaces+0x1da>
			{
                uint8_t acc;
                if (attr == SEPARATOR) 
    8550:	2820      	cmp	r0, #32
    8552:	d103      	bne.n	855c <ExpandInterfaces+0x168>
				{
                    attr = member++[0];
    8554:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8556:	1c5a      	adds	r2, r3, #1
    8558:	920b      	str	r2, [sp, #44]	; 0x2c
    855a:	781c      	ldrb	r4, [r3, #0]
                }
                acc = attr - WRITE_ONLY;
    855c:	3c3c      	subs	r4, #60	; 0x3c
    855e:	b2e4      	uxtb	r4, r4
                if (acc > 2) 
    8560:	2c02      	cmp	r4, #2
    8562:	d910      	bls.n	8586 <ExpandInterfaces+0x192>
				{
                    AJ_ErrPrintf(("ExpandInterfaces(): %s", AJ_StatusText(AJ_ERR_UNEXPECTED)));
    8564:	2001      	movs	r0, #1
    8566:	4999      	ldr	r1, [pc, #612]	; (87cc <ExpandInterfaces+0x3d8>)
    8568:	223e      	movs	r2, #62	; 0x3e
    856a:	32ff      	adds	r2, #255	; 0xff
    856c:	4b98      	ldr	r3, [pc, #608]	; (87d0 <ExpandInterfaces+0x3dc>)
    856e:	4798      	blx	r3
    8570:	2800      	cmp	r0, #0
    8572:	d100      	bne.n	8576 <ExpandInterfaces+0x182>
    8574:	e0ae      	b.n	86d4 <ExpandInterfaces+0x2e0>
    8576:	2002      	movs	r0, #2
    8578:	4b96      	ldr	r3, [pc, #600]	; (87d4 <ExpandInterfaces+0x3e0>)
    857a:	4798      	blx	r3
    857c:	1c01      	adds	r1, r0, #0
    857e:	4896      	ldr	r0, [pc, #600]	; (87d8 <ExpandInterfaces+0x3e4>)
    8580:	4b96      	ldr	r3, [pc, #600]	; (87dc <ExpandInterfaces+0x3e8>)
    8582:	4798      	blx	r3
    8584:	e0a6      	b.n	86d4 <ExpandInterfaces+0x2e0>
                    return AJ_ERR_UNEXPECTED;
                }
                ExpandAttribute(XMLWriter, context, &member, typeAttr, Access[acc]);
    8586:	00a4      	lsls	r4, r4, #2
    8588:	4b98      	ldr	r3, [pc, #608]	; (87ec <ExpandInterfaces+0x3f8>)
    858a:	58e3      	ldr	r3, [r4, r3]
    858c:	9300      	str	r3, [sp, #0]
    858e:	1c38      	adds	r0, r7, #0
    8590:	9904      	ldr	r1, [sp, #16]
    8592:	aa0b      	add	r2, sp, #44	; 0x2c
    8594:	4b96      	ldr	r3, [pc, #600]	; (87f0 <ExpandInterfaces+0x3fc>)
    8596:	4c94      	ldr	r4, [pc, #592]	; (87e8 <ExpandInterfaces+0x3f4>)
    8598:	47a0      	blx	r4
                        XMLWriter(context, argClose, sizeof(argClose) - 1);
                    }
                }
            }
		//	printf("description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8)), languageTag);\n");
            description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8)), languageTag);
    859a:	9b06      	ldr	r3, [sp, #24]
    859c:	0219      	lsls	r1, r3, #8
    859e:	464b      	mov	r3, r9
    85a0:	4319      	orrs	r1, r3
    85a2:	9805      	ldr	r0, [sp, #20]
    85a4:	4642      	mov	r2, r8
    85a6:	4b87      	ldr	r3, [pc, #540]	; (87c4 <ExpandInterfaces+0x3d0>)
    85a8:	4798      	blx	r3
    85aa:	1e04      	subs	r4, r0, #0
            if (description != NULL) 
    85ac:	d174      	bne.n	8698 <ExpandInterfaces+0x2a4>
    85ae:	e082      	b.n	86b6 <ExpandInterfaces+0x2c2>
			{
                // If we are using the AllSeen introspection then add isSessionless

                if (languageTag != NULL && memberType == SIGNAL) 
				{
                    XMLWriter(context, sessionlessAttr, sizeof(sessionlessAttr) - 1);
    85b0:	9804      	ldr	r0, [sp, #16]
    85b2:	4990      	ldr	r1, [pc, #576]	; (87f4 <ExpandInterfaces+0x400>)
    85b4:	220e      	movs	r2, #14
    85b6:	47b8      	blx	r7
                    if (isSessionless) 
    85b8:	2d00      	cmp	r5, #0
    85ba:	d004      	beq.n	85c6 <ExpandInterfaces+0x1d2>
					{
                        XMLWriter(context, trueVal, sizeof(trueVal) - 1);
    85bc:	9804      	ldr	r0, [sp, #16]
    85be:	498e      	ldr	r1, [pc, #568]	; (87f8 <ExpandInterfaces+0x404>)
    85c0:	2205      	movs	r2, #5
    85c2:	47b8      	blx	r7
    85c4:	e003      	b.n	85ce <ExpandInterfaces+0x1da>
                    } 
					else
					{
                        XMLWriter(context, falseVal, sizeof(falseVal) - 1);
    85c6:	9804      	ldr	r0, [sp, #16]
    85c8:	498c      	ldr	r1, [pc, #560]	; (87fc <ExpandInterfaces+0x408>)
    85ca:	2206      	movs	r2, #6
    85cc:	47b8      	blx	r7
                    }
                }
                XMLWriter(context, ">\n", 2);
    85ce:	9804      	ldr	r0, [sp, #16]
    85d0:	498b      	ldr	r1, [pc, #556]	; (8800 <ExpandInterfaces+0x40c>)
    85d2:	2202      	movs	r2, #2
    85d4:	47b8      	blx	r7
                while (attr) 
    85d6:	2c00      	cmp	r4, #0
    85d8:	d100      	bne.n	85dc <ExpandInterfaces+0x1e8>
    85da:	e0d4      	b.n	8786 <ExpandInterfaces+0x392>
                    if (memberType == SIGNAL)
					{
                        dir = 1;
                    }
                    // If we have a description then wait to close the tag until after adding in a description tag
                    description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8) | ((uint32_t)argIndex)), languageTag);
    85dc:	9b06      	ldr	r3, [sp, #24]
    85de:	021b      	lsls	r3, r3, #8
    85e0:	469b      	mov	fp, r3
    85e2:	2500      	movs	r5, #0
                while (attr) 
				{
                    uint8_t dir;

                    // increase arg index since we start at 1
                    ++argIndex;
    85e4:	3501      	adds	r5, #1
    85e6:	b2ed      	uxtb	r5, r5

                    XMLWriter(context, argOpen, sizeof(argOpen) - 1);
    85e8:	9804      	ldr	r0, [sp, #16]
    85ea:	4986      	ldr	r1, [pc, #536]	; (8804 <ExpandInterfaces+0x410>)
    85ec:	2208      	movs	r2, #8
    85ee:	47b8      	blx	r7
                    if (IS_DIRECTION(*member)) 
    85f0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    85f2:	7813      	ldrb	r3, [r2, #0]
    85f4:	3b3c      	subs	r3, #60	; 0x3c
    85f6:	2b02      	cmp	r3, #2
    85f8:	d805      	bhi.n	8606 <ExpandInterfaces+0x212>
					{
                        dir = *member++ - IN_ARG;
    85fa:	1c53      	adds	r3, r2, #1
    85fc:	930b      	str	r3, [sp, #44]	; 0x2c
    85fe:	7814      	ldrb	r4, [r2, #0]
    8600:	3c3c      	subs	r4, #60	; 0x3c
    8602:	b2e4      	uxtb	r4, r4
    8604:	e009      	b.n	861a <ExpandInterfaces+0x226>
                    }
					else
					{
                        dir = ExpandAttribute(XMLWriter, context, &member, nameAttr, "\"") - IN_ARG;
    8606:	4b77      	ldr	r3, [pc, #476]	; (87e4 <ExpandInterfaces+0x3f0>)
    8608:	9300      	str	r3, [sp, #0]
    860a:	1c38      	adds	r0, r7, #0
    860c:	9904      	ldr	r1, [sp, #16]
    860e:	aa0b      	add	r2, sp, #44	; 0x2c
    8610:	4b6a      	ldr	r3, [pc, #424]	; (87bc <ExpandInterfaces+0x3c8>)
    8612:	4c75      	ldr	r4, [pc, #468]	; (87e8 <ExpandInterfaces+0x3f4>)
    8614:	47a0      	blx	r4
    8616:	383c      	subs	r0, #60	; 0x3c
    8618:	b2c4      	uxtb	r4, r0
                    }
                    if ((dir != 0) && (dir != 2))
    861a:	2302      	movs	r3, #2
    861c:	1c22      	adds	r2, r4, #0
    861e:	439a      	bics	r2, r3
    8620:	d00f      	beq.n	8642 <ExpandInterfaces+0x24e>
					{
                        AJ_ErrPrintf(("ExpandInterfaces(): %s", AJ_StatusText(AJ_ERR_UNEXPECTED)));
    8622:	2001      	movs	r0, #1
    8624:	4969      	ldr	r1, [pc, #420]	; (87cc <ExpandInterfaces+0x3d8>)
    8626:	2266      	movs	r2, #102	; 0x66
    8628:	32ff      	adds	r2, #255	; 0xff
    862a:	4b69      	ldr	r3, [pc, #420]	; (87d0 <ExpandInterfaces+0x3dc>)
    862c:	4798      	blx	r3
    862e:	2800      	cmp	r0, #0
    8630:	d050      	beq.n	86d4 <ExpandInterfaces+0x2e0>
    8632:	2002      	movs	r0, #2
    8634:	4b67      	ldr	r3, [pc, #412]	; (87d4 <ExpandInterfaces+0x3e0>)
    8636:	4798      	blx	r3
    8638:	1c01      	adds	r1, r0, #0
    863a:	4867      	ldr	r0, [pc, #412]	; (87d8 <ExpandInterfaces+0x3e4>)
    863c:	4b67      	ldr	r3, [pc, #412]	; (87dc <ExpandInterfaces+0x3e8>)
    863e:	4798      	blx	r3
    8640:	e048      	b.n	86d4 <ExpandInterfaces+0x2e0>
                        return AJ_ERR_UNEXPECTED;
                    }
                    if (memberType == SIGNAL)
    8642:	4653      	mov	r3, sl
    8644:	2b00      	cmp	r3, #0
    8646:	d100      	bne.n	864a <ExpandInterfaces+0x256>
					{
                        dir = 1;
    8648:	2401      	movs	r4, #1
    864a:	4649      	mov	r1, r9
    864c:	4329      	orrs	r1, r5
                    }
                    // If we have a description then wait to close the tag until after adding in a description tag
                    description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8) | ((uint32_t)argIndex)), languageTag);
    864e:	465b      	mov	r3, fp
    8650:	4319      	orrs	r1, r3
    8652:	9805      	ldr	r0, [sp, #20]
    8654:	4642      	mov	r2, r8
    8656:	4b5b      	ldr	r3, [pc, #364]	; (87c4 <ExpandInterfaces+0x3d0>)
    8658:	4798      	blx	r3
    865a:	1e06      	subs	r6, r0, #0
                    if (description != NULL) 
    865c:	d100      	bne.n	8660 <ExpandInterfaces+0x26c>
    865e:	e086      	b.n	876e <ExpandInterfaces+0x37a>
					{
                        dir += 3;
    8660:	3403      	adds	r4, #3
                    }
				//	printf("attr = ExpandAttribute(XMLWriter, context, &member, typeAttr, Direction[dir])\n");					
                    attr = ExpandAttribute(XMLWriter, context, &member, typeAttr, Direction[dir]);
    8662:	b2e4      	uxtb	r4, r4
    8664:	00a4      	lsls	r4, r4, #2
    8666:	4b68      	ldr	r3, [pc, #416]	; (8808 <ExpandInterfaces+0x414>)
    8668:	58e3      	ldr	r3, [r4, r3]
    866a:	9300      	str	r3, [sp, #0]
    866c:	1c38      	adds	r0, r7, #0
    866e:	9904      	ldr	r1, [sp, #16]
    8670:	aa0b      	add	r2, sp, #44	; 0x2c
    8672:	4b5f      	ldr	r3, [pc, #380]	; (87f0 <ExpandInterfaces+0x3fc>)
    8674:	4c5c      	ldr	r4, [pc, #368]	; (87e8 <ExpandInterfaces+0x3f4>)
    8676:	47a0      	blx	r4
    8678:	1c04      	adds	r4, r0, #0
				//	printf("attr= %d\n", attr);
                    if (description != NULL) 
					{
                        XMLWriteDescription(XMLWriter, context, 2, description, languageTag);
    867a:	4643      	mov	r3, r8
    867c:	9300      	str	r3, [sp, #0]
    867e:	1c38      	adds	r0, r7, #0
    8680:	9904      	ldr	r1, [sp, #16]
    8682:	2202      	movs	r2, #2
    8684:	1c33      	adds	r3, r6, #0
    8686:	4e50      	ldr	r6, [pc, #320]	; (87c8 <ExpandInterfaces+0x3d4>)
    8688:	47b0      	blx	r6
                        XMLWriter(context, argClose, sizeof(argClose) - 1);
    868a:	9804      	ldr	r0, [sp, #16]
    868c:	495f      	ldr	r1, [pc, #380]	; (880c <ExpandInterfaces+0x418>)
    868e:	220b      	movs	r2, #11
    8690:	47b8      	blx	r7
					{
                        XMLWriter(context, falseVal, sizeof(falseVal) - 1);
                    }
                }
                XMLWriter(context, ">\n", 2);
                while (attr) 
    8692:	2c00      	cmp	r4, #0
    8694:	d1a6      	bne.n	85e4 <ExpandInterfaces+0x1f0>
    8696:	e076      	b.n	8786 <ExpandInterfaces+0x392>
            description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8)), languageTag);
            if (description != NULL) 
			{
                if (memberType == PROPERTY) 
				{
                    XMLWriter(context, ">\n", 2);
    8698:	9804      	ldr	r0, [sp, #16]
    869a:	4959      	ldr	r1, [pc, #356]	; (8800 <ExpandInterfaces+0x40c>)
    869c:	2202      	movs	r2, #2
    869e:	47b8      	blx	r7
                    /*
                      * Move to the alternate close for a propety
                      * which is in the memberClose table of entry 4
                    */
                    memberType++;
    86a0:	3d01      	subs	r5, #1
    86a2:	b2eb      	uxtb	r3, r5
    86a4:	469a      	mov	sl, r3
                }
                XMLWriteDescription(XMLWriter, context, 1, description, languageTag);
    86a6:	4643      	mov	r3, r8
    86a8:	9300      	str	r3, [sp, #0]
    86aa:	1c38      	adds	r0, r7, #0
    86ac:	9904      	ldr	r1, [sp, #16]
    86ae:	2201      	movs	r2, #1
    86b0:	1c23      	adds	r3, r4, #0
    86b2:	4c45      	ldr	r4, [pc, #276]	; (87c8 <ExpandInterfaces+0x3d4>)
    86b4:	47a0      	blx	r4
            }
            XMLWriter(context, MemberClose[memberType], 0);
    86b6:	4653      	mov	r3, sl
    86b8:	009a      	lsls	r2, r3, #2
    86ba:	4b55      	ldr	r3, [pc, #340]	; (8810 <ExpandInterfaces+0x41c>)
    86bc:	58d1      	ldr	r1, [r2, r3]
    86be:	9804      	ldr	r0, [sp, #16]
    86c0:	2200      	movs	r2, #0
    86c2:	47b8      	blx	r7
        if (description != NULL) 
		{
            XMLWriteDescription(XMLWriter, context, 0, description, languageTag);
        }

        while (*(++entries)) 
    86c4:	9b07      	ldr	r3, [sp, #28]
    86c6:	3304      	adds	r3, #4
    86c8:	9307      	str	r3, [sp, #28]
    86ca:	681b      	ldr	r3, [r3, #0]
    86cc:	2b00      	cmp	r3, #0
    86ce:	d000      	beq.n	86d2 <ExpandInterfaces+0x2de>
    86d0:	e6fc      	b.n	84cc <ExpandInterfaces+0xd8>
    86d2:	e00e      	b.n	86f2 <ExpandInterfaces+0x2fe>
            // Increase index since we start at 1
            ++memberIndex;
            if (memberType > 2) 
			{
                AJ_ErrPrintf(("ExpandInterfaces(): %s", AJ_StatusText(AJ_ERR_UNEXPECTED)));
                return AJ_ERR_UNEXPECTED;
    86d4:	2002      	movs	r0, #2
    86d6:	e0a1      	b.n	881c <ExpandInterfaces+0x428>

        while (*(++entries)) 
		{
            uint8_t argIndex = 0;
            const char* member = *entries;
            uint8_t memberType = MEMBER_TYPE(*member++);
    86d8:	1c5a      	adds	r2, r3, #1
    86da:	920b      	str	r2, [sp, #44]	; 0x2c
    86dc:	781d      	ldrb	r5, [r3, #0]
    86de:	092d      	lsrs	r5, r5, #4
    86e0:	1eab      	subs	r3, r5, #2
    86e2:	b2db      	uxtb	r3, r3
    86e4:	469a      	mov	sl, r3
            uint8_t attr;
            uint8_t isSessionless = FALSE;

            // Increase index since we start at 1
            ++memberIndex;
            if (memberType > 2) 
    86e6:	2b02      	cmp	r3, #2
    86e8:	d900      	bls.n	86ec <ExpandInterfaces+0x2f8>
    86ea:	e6fd      	b.n	84e8 <ExpandInterfaces+0xf4>
    86ec:	2301      	movs	r3, #1
    86ee:	9306      	str	r3, [sp, #24]
    86f0:	e70b      	b.n	850a <ExpandInterfaces+0x116>
                }
                XMLWriteDescription(XMLWriter, context, 1, description, languageTag);
            }
            XMLWriter(context, MemberClose[memberType], 0);
        }
        XMLWriter(context, interfaceClose, sizeof(interfaceClose) - 1);
    86f2:	9804      	ldr	r0, [sp, #16]
    86f4:	4947      	ldr	r1, [pc, #284]	; (8814 <ExpandInterfaces+0x420>)
    86f6:	220d      	movs	r2, #13
    86f8:	47b8      	blx	r7
        ++iface;
    86fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
    86fc:	3304      	adds	r3, #4
    86fe:	9309      	str	r3, [sp, #36]	; 0x24
    uint8_t ifaceIndex = 0;
    if (!iface) 
	{
        return AJ_OK;
    }
    while (*iface) 
    8700:	681c      	ldr	r4, [r3, #0]
    8702:	2c00      	cmp	r4, #0
    8704:	d000      	beq.n	8708 <ExpandInterfaces+0x314>
    8706:	e68b      	b.n	8420 <ExpandInterfaces+0x2c>
            XMLWriter(context, MemberClose[memberType], 0);
        }
        XMLWriter(context, interfaceClose, sizeof(interfaceClose) - 1);
        ++iface;
    }
    return AJ_OK;
    8708:	2000      	movs	r0, #0
    870a:	e087      	b.n	881c <ExpandInterfaces+0x428>
{
    uint32_t descId;
    uint8_t ifaceIndex = 0;
    if (!iface) 
	{
        return AJ_OK;
    870c:	2000      	movs	r0, #0
    870e:	e085      	b.n	881c <ExpandInterfaces+0x428>
            XMLWriter(context, MemberClose[memberType], 0);
        }
        XMLWriter(context, interfaceClose, sizeof(interfaceClose) - 1);
        ++iface;
    }
    return AJ_OK;
    8710:	2000      	movs	r0, #0
    8712:	e083      	b.n	881c <ExpandInterfaces+0x428>
                (strcmp(entries[0], AllSeenIntrospectableInterface) == 0)) 
			{
                dBus_std_iface = TRUE;
            }
            // If flagged as secure or not secure, skip the first char (the '$' or '#') of the name
            XMLWriteTag(XMLWriter, context, interfaceOpen, nameAttr, entries[0] + 1, 0, FALSE);
    8714:	3501      	adds	r5, #1
    8716:	9500      	str	r5, [sp, #0]
    8718:	2300      	movs	r3, #0
    871a:	9301      	str	r3, [sp, #4]
    871c:	9302      	str	r3, [sp, #8]
    871e:	1c38      	adds	r0, r7, #0
    8720:	9904      	ldr	r1, [sp, #16]
    8722:	4a25      	ldr	r2, [pc, #148]	; (87b8 <ExpandInterfaces+0x3c4>)
    8724:	4b25      	ldr	r3, [pc, #148]	; (87bc <ExpandInterfaces+0x3c8>)
    8726:	4d26      	ldr	r5, [pc, #152]	; (87c0 <ExpandInterfaces+0x3cc>)
    8728:	47a8      	blx	r5
    872a:	e6ba      	b.n	84a2 <ExpandInterfaces+0xae>
    872c:	3501      	adds	r5, #1
    872e:	9500      	str	r5, [sp, #0]
    8730:	2300      	movs	r3, #0
    8732:	9301      	str	r3, [sp, #4]
    8734:	9302      	str	r3, [sp, #8]
    8736:	1c38      	adds	r0, r7, #0
    8738:	9904      	ldr	r1, [sp, #16]
    873a:	4a1f      	ldr	r2, [pc, #124]	; (87b8 <ExpandInterfaces+0x3c4>)
    873c:	4b1f      	ldr	r3, [pc, #124]	; (87bc <ExpandInterfaces+0x3c8>)
    873e:	4d20      	ldr	r5, [pc, #128]	; (87c0 <ExpandInterfaces+0x3cc>)
    8740:	47a8      	blx	r5
            if (!dBus_std_iface)
			{
                XMLWriter(context, annotateSecure, sizeof(annotateSecure) - 1);
    8742:	9804      	ldr	r0, [sp, #16]
    8744:	4934      	ldr	r1, [pc, #208]	; (8818 <ExpandInterfaces+0x424>)
    8746:	2233      	movs	r2, #51	; 0x33
    8748:	47b8      	blx	r7
                if (flag == SECURE_TRUE) 
    874a:	2e24      	cmp	r6, #36	; 0x24
    874c:	d000      	beq.n	8750 <ExpandInterfaces+0x35c>
    874e:	e699      	b.n	8484 <ExpandInterfaces+0x90>
    8750:	e693      	b.n	847a <ExpandInterfaces+0x86>
                  * through the org.allseen.Introspect interface
                  */
                    isSessionless = TRUE;
                }
            }
            attr = ExpandAttribute(XMLWriter, context, &member, nameAttr, "\"");
    8752:	4b24      	ldr	r3, [pc, #144]	; (87e4 <ExpandInterfaces+0x3f0>)
    8754:	9300      	str	r3, [sp, #0]
    8756:	1c38      	adds	r0, r7, #0
    8758:	9904      	ldr	r1, [sp, #16]
    875a:	aa0b      	add	r2, sp, #44	; 0x2c
    875c:	4b17      	ldr	r3, [pc, #92]	; (87bc <ExpandInterfaces+0x3c8>)
    875e:	4c22      	ldr	r4, [pc, #136]	; (87e8 <ExpandInterfaces+0x3f4>)
    8760:	47a0      	blx	r4
    8762:	1c04      	adds	r4, r0, #0
            }
			else
			{
                // If we are using the AllSeen introspection then add isSessionless

                if (languageTag != NULL && memberType == SIGNAL) 
    8764:	4643      	mov	r3, r8
    8766:	2b00      	cmp	r3, #0
    8768:	d000      	beq.n	876c <ExpandInterfaces+0x378>
    876a:	e721      	b.n	85b0 <ExpandInterfaces+0x1bc>
    876c:	e72f      	b.n	85ce <ExpandInterfaces+0x1da>
                    if (description != NULL) 
					{
                        dir += 3;
                    }
				//	printf("attr = ExpandAttribute(XMLWriter, context, &member, typeAttr, Direction[dir])\n");					
                    attr = ExpandAttribute(XMLWriter, context, &member, typeAttr, Direction[dir]);
    876e:	00a4      	lsls	r4, r4, #2
    8770:	4b25      	ldr	r3, [pc, #148]	; (8808 <ExpandInterfaces+0x414>)
    8772:	58e3      	ldr	r3, [r4, r3]
    8774:	9300      	str	r3, [sp, #0]
    8776:	1c38      	adds	r0, r7, #0
    8778:	9904      	ldr	r1, [sp, #16]
    877a:	aa0b      	add	r2, sp, #44	; 0x2c
    877c:	4b1c      	ldr	r3, [pc, #112]	; (87f0 <ExpandInterfaces+0x3fc>)
    877e:	4c1a      	ldr	r4, [pc, #104]	; (87e8 <ExpandInterfaces+0x3f4>)
    8780:	47a0      	blx	r4
    8782:	1c04      	adds	r4, r0, #0
    8784:	e785      	b.n	8692 <ExpandInterfaces+0x29e>
                        XMLWriter(context, argClose, sizeof(argClose) - 1);
                    }
                }
            }
		//	printf("description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8)), languageTag);\n");
            description = GetDescription(descLookup, (descId | (((uint32_t)memberIndex) << 8)), languageTag);
    8786:	9b06      	ldr	r3, [sp, #24]
    8788:	0219      	lsls	r1, r3, #8
    878a:	464b      	mov	r3, r9
    878c:	4319      	orrs	r1, r3
    878e:	9805      	ldr	r0, [sp, #20]
    8790:	4642      	mov	r2, r8
    8792:	4b0c      	ldr	r3, [pc, #48]	; (87c4 <ExpandInterfaces+0x3d0>)
    8794:	4798      	blx	r3
    8796:	1e04      	subs	r4, r0, #0
            if (description != NULL) 
    8798:	d185      	bne.n	86a6 <ExpandInterfaces+0x2b2>
    879a:	e78c      	b.n	86b6 <ExpandInterfaces+0x2c2>
    879c:	0001eb94 	.word	0x0001eb94
    87a0:	00017137 	.word	0x00017137
    87a4:	0001e8d4 	.word	0x0001e8d4
    87a8:	0001e6f0 	.word	0x0001e6f0
    87ac:	0001e990 	.word	0x0001e990
    87b0:	0001ca08 	.word	0x0001ca08
    87b4:	0001ca00 	.word	0x0001ca00
    87b8:	0001d154 	.word	0x0001d154
    87bc:	0001c9e0 	.word	0x0001c9e0
    87c0:	0000807d 	.word	0x0000807d
    87c4:	000080d1 	.word	0x000080d1
    87c8:	000080e5 	.word	0x000080e5
    87cc:	0001ca4c 	.word	0x0001ca4c
    87d0:	0000636d 	.word	0x0000636d
    87d4:	000063c5 	.word	0x000063c5
    87d8:	0001cb04 	.word	0x0001cb04
    87dc:	00016e3d 	.word	0x00016e3d
    87e0:	0001d12c 	.word	0x0001d12c
    87e4:	0001ca14 	.word	0x0001ca14
    87e8:	0000800d 	.word	0x0000800d
    87ec:	0001d178 	.word	0x0001d178
    87f0:	0001c9d8 	.word	0x0001c9d8
    87f4:	0001d144 	.word	0x0001d144
    87f8:	0001d124 	.word	0x0001d124
    87fc:	0001d194 	.word	0x0001d194
    8800:	0001d070 	.word	0x0001d070
    8804:	0001c9cc 	.word	0x0001c9cc
    8808:	0001c9e8 	.word	0x0001c9e8
    880c:	0001d118 	.word	0x0001d118
    8810:	0001d184 	.word	0x0001d184
    8814:	0001d168 	.word	0x0001d168
    8818:	0001c980 	.word	0x0001c980
        }
        XMLWriter(context, interfaceClose, sizeof(interfaceClose) - 1);
        ++iface;
    }
    return AJ_OK;
}
    881c:	b00d      	add	sp, #52	; 0x34
    881e:	bc3c      	pop	{r2, r3, r4, r5}
    8820:	4690      	mov	r8, r2
    8822:	4699      	mov	r9, r3
    8824:	46a2      	mov	sl, r4
    8826:	46ab      	mov	fp, r5
    8828:	bdf0      	pop	{r4, r5, r6, r7, pc}
    882a:	46c0      	nop			; (mov r8, r8)

0000882c <SizeXML>:
}
#endif

// Function to accumulate the length of the XML that will be generated
void SizeXML(void* context, const char* str, uint32_t len)
{
    882c:	b510      	push	{r4, lr}
    882e:	1c04      	adds	r4, r0, #0
    if (!len) 
    8830:	2a00      	cmp	r2, #0
    8832:	d103      	bne.n	883c <SizeXML+0x10>
	{
        len = (uint32_t)strlen(str);
    8834:	1c08      	adds	r0, r1, #0
    8836:	4b04      	ldr	r3, [pc, #16]	; (8848 <SizeXML+0x1c>)
    8838:	4798      	blx	r3
    883a:	1c02      	adds	r2, r0, #0
    }
    *((uint32_t*)context) += len;
    883c:	6823      	ldr	r3, [r4, #0]
    883e:	469c      	mov	ip, r3
    8840:	4462      	add	r2, ip
    8842:	6022      	str	r2, [r4, #0]
}
    8844:	bd10      	pop	{r4, pc}
    8846:	46c0      	nop			; (mov r8, r8)
    8848:	0001715b 	.word	0x0001715b

0000884c <WriteXML>:
    uint32_t len;
    AJ_Status status;
} WriteContext;

void WriteXML(void* context, const char* str, uint32_t len)
{
    884c:	b538      	push	{r3, r4, r5, lr}
    884e:	1c04      	adds	r4, r0, #0
    8850:	1c0d      	adds	r5, r1, #0
    WriteContext* wctx = (WriteContext*)context;
//	printf("WriteXML started\n");
    if (wctx->status == AJ_OK)
    8852:	7a03      	ldrb	r3, [r0, #8]
    8854:	2b00      	cmp	r3, #0
    8856:	d10a      	bne.n	886e <WriteXML+0x22>
	{
		//printf("WriteXML wctx->status == AJ_OK\n");
        if (!len) 
    8858:	2a00      	cmp	r2, #0
    885a:	d103      	bne.n	8864 <WriteXML+0x18>
		{
		//	printf("WriteXML if (!len)\n");
            len = (uint32_t)strlen(str);
    885c:	1c08      	adds	r0, r1, #0
    885e:	4b04      	ldr	r3, [pc, #16]	; (8870 <WriteXML+0x24>)
    8860:	4798      	blx	r3
    8862:	1c02      	adds	r2, r0, #0
        }
        wctx->status = AJ_MarshalRaw(wctx->reply, str, len);
    8864:	6820      	ldr	r0, [r4, #0]
    8866:	1c29      	adds	r1, r5, #0
    8868:	4b02      	ldr	r3, [pc, #8]	; (8874 <WriteXML+0x28>)
    886a:	4798      	blx	r3
    886c:	7220      	strb	r0, [r4, #8]
    }
}
    886e:	bd38      	pop	{r3, r4, r5, pc}
    8870:	0001715b 	.word	0x0001715b
    8874:	0000b82d 	.word	0x0000b82d

00008878 <AJ_HandleGetDescriptionLanguages>:
    }
    return status;
}

AJ_Status AJ_HandleGetDescriptionLanguages(const AJ_Message* msg, AJ_Message* reply) 
{
    8878:	b5f0      	push	{r4, r5, r6, r7, lr}
    887a:	b085      	sub	sp, #20
    887c:	1c0c      	adds	r4, r1, #0
    AJ_Status status = AJ_OK;
    AJ_Arg languageListArray;
    const char* const* languageTag;

    status = AJ_MarshalReplyMsg(msg, reply);
    887e:	4b12      	ldr	r3, [pc, #72]	; (88c8 <AJ_HandleGetDescriptionLanguages+0x50>)
    8880:	4798      	blx	r3

    if (status == AJ_OK) 
    8882:	2800      	cmp	r0, #0
    8884:	d11d      	bne.n	88c2 <AJ_HandleGetDescriptionLanguages+0x4a>
	{
        status = AJ_MarshalContainer(reply, &languageListArray, AJ_ARG_ARRAY);
    8886:	1c20      	adds	r0, r4, #0
    8888:	4669      	mov	r1, sp
    888a:	2261      	movs	r2, #97	; 0x61
    888c:	4b0f      	ldr	r3, [pc, #60]	; (88cc <AJ_HandleGetDescriptionLanguages+0x54>)
    888e:	4798      	blx	r3
    }
    if (status == AJ_OK) 
    8890:	2800      	cmp	r0, #0
    8892:	d116      	bne.n	88c2 <AJ_HandleGetDescriptionLanguages+0x4a>
	{
        languageTag = languageList;
    8894:	4b0e      	ldr	r3, [pc, #56]	; (88d0 <AJ_HandleGetDescriptionLanguages+0x58>)
    8896:	681e      	ldr	r6, [r3, #0]

        while ((NULL != *languageTag) && status == AJ_OK) 
    8898:	6832      	ldr	r2, [r6, #0]
    889a:	2a00      	cmp	r2, #0
    889c:	d00d      	beq.n	88ba <AJ_HandleGetDescriptionLanguages+0x42>
		{
            status = AJ_MarshalArgs(reply, "s", *languageTag);
    889e:	4d0d      	ldr	r5, [pc, #52]	; (88d4 <AJ_HandleGetDescriptionLanguages+0x5c>)
    88a0:	4f0d      	ldr	r7, [pc, #52]	; (88d8 <AJ_HandleGetDescriptionLanguages+0x60>)
    88a2:	1c20      	adds	r0, r4, #0
    88a4:	1c29      	adds	r1, r5, #0
    88a6:	47b8      	blx	r7
            languageTag++;
    88a8:	3604      	adds	r6, #4
    }
    if (status == AJ_OK) 
	{
        languageTag = languageList;

        while ((NULL != *languageTag) && status == AJ_OK) 
    88aa:	6832      	ldr	r2, [r6, #0]
    88ac:	2a00      	cmp	r2, #0
    88ae:	d002      	beq.n	88b6 <AJ_HandleGetDescriptionLanguages+0x3e>
    88b0:	2800      	cmp	r0, #0
    88b2:	d0f6      	beq.n	88a2 <AJ_HandleGetDescriptionLanguages+0x2a>
    88b4:	e005      	b.n	88c2 <AJ_HandleGetDescriptionLanguages+0x4a>
		{
            status = AJ_MarshalArgs(reply, "s", *languageTag);
            languageTag++;
        }
    }
    if (status == AJ_OK) 
    88b6:	2800      	cmp	r0, #0
    88b8:	d103      	bne.n	88c2 <AJ_HandleGetDescriptionLanguages+0x4a>
	{
        status = AJ_MarshalCloseContainer(reply, &languageListArray);
    88ba:	1c20      	adds	r0, r4, #0
    88bc:	4669      	mov	r1, sp
    88be:	4b07      	ldr	r3, [pc, #28]	; (88dc <AJ_HandleGetDescriptionLanguages+0x64>)
    88c0:	4798      	blx	r3
    }

    return status;
}
    88c2:	b005      	add	sp, #20
    88c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    88c6:	46c0      	nop			; (mov r8, r8)
    88c8:	0000bd45 	.word	0x0000bd45
    88cc:	0000b8a1 	.word	0x0000b8a1
    88d0:	20000960 	.word	0x20000960
    88d4:	0001f054 	.word	0x0001f054
    88d8:	0000bc85 	.word	0x0000bc85
    88dc:	0000b8d1 	.word	0x0000b8d1

000088e0 <AJ_RegisterObjects>:
}

void AJ_RegisterObjects(const AJ_Object* localObjects, const AJ_Object* proxyObjects)
{
    AJ_ASSERT(AJ_PRX_ID_FLAG < ArraySize(objectLists));
    objectLists[AJ_APP_ID_FLAG] = localObjects;
    88e0:	4b01      	ldr	r3, [pc, #4]	; (88e8 <AJ_RegisterObjects+0x8>)
    88e2:	6058      	str	r0, [r3, #4]
    objectLists[AJ_PRX_ID_FLAG] = proxyObjects;
    88e4:	6099      	str	r1, [r3, #8]
}
    88e6:	4770      	bx	lr
    88e8:	20000138 	.word	0x20000138

000088ec <AJ_RegisterObjectList>:

AJ_Status AJ_RegisterObjectListWithDescriptions(const AJ_Object* objList, uint8_t index, AJ_DescriptionLookupFunc descLookup)
{
    if (index >= ArraySize(objectLists)) 
	{
        return AJ_ERR_RANGE;
    88ec:	2321      	movs	r3, #33	; 0x21
    languageList = languages;
}

AJ_Status AJ_RegisterObjectListWithDescriptions(const AJ_Object* objList, uint8_t index, AJ_DescriptionLookupFunc descLookup)
{
    if (index >= ArraySize(objectLists)) 
    88ee:	2908      	cmp	r1, #8
    88f0:	d806      	bhi.n	8900 <AJ_RegisterObjectList+0x14>
	{
        return AJ_ERR_RANGE;
    }
    objectLists[index] = objList;
    88f2:	0089      	lsls	r1, r1, #2
    88f4:	4b03      	ldr	r3, [pc, #12]	; (8904 <AJ_RegisterObjectList+0x18>)
    88f6:	50c8      	str	r0, [r1, r3]
    descriptionLookups[index] = descLookup;
    88f8:	2200      	movs	r2, #0
    88fa:	4b03      	ldr	r3, [pc, #12]	; (8908 <AJ_RegisterObjectList+0x1c>)
    88fc:	50ca      	str	r2, [r1, r3]
    return AJ_OK;
    88fe:	2300      	movs	r3, #0
}

AJ_Status AJ_RegisterObjectList(const AJ_Object* objList, uint8_t index)
{
    return AJ_RegisterObjectListWithDescriptions(objList, index, NULL);
}
    8900:	1c18      	adds	r0, r3, #0
    8902:	4770      	bx	lr
    8904:	20000138 	.word	0x20000138
    8908:	2000091c 	.word	0x2000091c

0000890c <AJ_AllocReplyContext>:
    proxyObjects[pIndex].path = objPath;
    return AJ_OK;
}

AJ_Status AJ_AllocReplyContext(AJ_Message* msg, uint32_t timeout)
{
    890c:	b530      	push	{r4, r5, lr}
    890e:	b083      	sub	sp, #12
    if (msg->hdr->flags & AJ_FLAG_NO_REPLY_EXPECTED) 
    8910:	6843      	ldr	r3, [r0, #4]
    8912:	789a      	ldrb	r2, [r3, #2]
    8914:	07d2      	lsls	r2, r2, #31
    8916:	d45a      	bmi.n	89ce <AJ_AllocReplyContext+0xc2>
    8918:	1c04      	adds	r4, r0, #0
static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
	{
        if (replyContexts[i].serial == serial)
    891a:	4a2e      	ldr	r2, [pc, #184]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    891c:	68d2      	ldr	r2, [r2, #12]
    891e:	2a00      	cmp	r2, #0
    8920:	d00b      	beq.n	893a <AJ_AllocReplyContext+0x2e>
    8922:	4a2c      	ldr	r2, [pc, #176]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    8924:	6b92      	ldr	r2, [r2, #56]	; 0x38
    8926:	2a00      	cmp	r2, #0
    8928:	d005      	beq.n	8936 <AJ_AllocReplyContext+0x2a>
    892a:	4a2a      	ldr	r2, [pc, #168]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    892c:	6e52      	ldr	r2, [r2, #100]	; 0x64
}

static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
    892e:	2502      	movs	r5, #2
	{
        if (replyContexts[i].serial == serial)
    8930:	2a00      	cmp	r2, #0
    8932:	d003      	beq.n	893c <AJ_AllocReplyContext+0x30>
    8934:	e006      	b.n	8944 <AJ_AllocReplyContext+0x38>
}

static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
    8936:	2501      	movs	r5, #1
    8938:	e000      	b.n	893c <AJ_AllocReplyContext+0x30>
	{
        if (replyContexts[i].serial == serial)
    893a:	2500      	movs	r5, #0
    } 
	else 
	{
        ReplyContext* repCtx = FindReplyContext(0);

        AJ_ASSERT(msg->hdr->msgType == AJ_MSG_METHOD_CALL);
    893c:	785a      	ldrb	r2, [r3, #1]
    893e:	2a01      	cmp	r2, #1
    8940:	d009      	beq.n	8956 <AJ_AllocReplyContext+0x4a>
    8942:	e002      	b.n	894a <AJ_AllocReplyContext+0x3e>
    8944:	785b      	ldrb	r3, [r3, #1]
    8946:	2b01      	cmp	r3, #1
    8948:	d033      	beq.n	89b2 <AJ_AllocReplyContext+0xa6>
    894a:	4823      	ldr	r0, [pc, #140]	; (89d8 <AJ_AllocReplyContext+0xcc>)
    894c:	4923      	ldr	r1, [pc, #140]	; (89dc <AJ_AllocReplyContext+0xd0>)
    894e:	4a24      	ldr	r2, [pc, #144]	; (89e0 <AJ_AllocReplyContext+0xd4>)
    8950:	4b24      	ldr	r3, [pc, #144]	; (89e4 <AJ_AllocReplyContext+0xd8>)
    8952:	4c25      	ldr	r4, [pc, #148]	; (89e8 <AJ_AllocReplyContext+0xdc>)
    8954:	47a0      	blx	r4
        if (repCtx) 
		{
            AJ_Status status;
            const char* unique;

            repCtx->serial = msg->hdr->serialNum;
    8956:	689a      	ldr	r2, [r3, #8]
    8958:	232c      	movs	r3, #44	; 0x2c
    895a:	436b      	muls	r3, r5
    895c:	481d      	ldr	r0, [pc, #116]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    895e:	18c3      	adds	r3, r0, r3
    8960:	60da      	str	r2, [r3, #12]
            repCtx->messageId = msg->msgId;
    8962:	6822      	ldr	r2, [r4, #0]
    8964:	611a      	str	r2, [r3, #16]
            repCtx->timeout = timeout ? timeout : AJ_DEFAULT_REPLY_TIMEOUT;
    8966:	2900      	cmp	r1, #0
    8968:	d100      	bne.n	896c <AJ_AllocReplyContext+0x60>
    896a:	4920      	ldr	r1, [pc, #128]	; (89ec <AJ_AllocReplyContext+0xe0>)
    896c:	202c      	movs	r0, #44	; 0x2c
    896e:	4368      	muls	r0, r5
    8970:	4b18      	ldr	r3, [pc, #96]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    8972:	1818      	adds	r0, r3, r0
    8974:	6081      	str	r1, [r0, #8]
            AJ_InitTimer(&repCtx->callTime);
    8976:	4b1e      	ldr	r3, [pc, #120]	; (89f0 <AJ_AllocReplyContext+0xe4>)
    8978:	4798      	blx	r3

            status = AJ_GetRemoteUniqueName(msg->destination, &unique);
    897a:	69a0      	ldr	r0, [r4, #24]
    897c:	a901      	add	r1, sp, #4
    897e:	4b1d      	ldr	r3, [pc, #116]	; (89f4 <AJ_AllocReplyContext+0xe8>)
    8980:	4798      	blx	r3
            if (AJ_OK == status)
    8982:	2800      	cmp	r0, #0
    8984:	d10d      	bne.n	89a2 <AJ_AllocReplyContext+0x96>
			{
                strncpy(repCtx->uniqueName, unique, AJ_MAX_NAME_SIZE);
    8986:	4c13      	ldr	r4, [pc, #76]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    8988:	232c      	movs	r3, #44	; 0x2c
    898a:	435d      	muls	r5, r3
    898c:	1960      	adds	r0, r4, r5
    898e:	3014      	adds	r0, #20
    8990:	9901      	ldr	r1, [sp, #4]
    8992:	2214      	movs	r2, #20
    8994:	4b18      	ldr	r3, [pc, #96]	; (89f8 <AJ_AllocReplyContext+0xec>)
    8996:	4798      	blx	r3
                repCtx->uniqueName[AJ_MAX_NAME_SIZE] = '\0';
    8998:	1965      	adds	r5, r4, r5
    899a:	3524      	adds	r5, #36	; 0x24
    899c:	2300      	movs	r3, #0
    899e:	712b      	strb	r3, [r5, #4]
    89a0:	e005      	b.n	89ae <AJ_AllocReplyContext+0xa2>
            } 
			else 
			{
                //Lookup failed, but that doesn't matter for unencrypted messages 
                repCtx->uniqueName[0] = '\0';
    89a2:	232c      	movs	r3, #44	; 0x2c
    89a4:	436b      	muls	r3, r5
    89a6:	4a0b      	ldr	r2, [pc, #44]	; (89d4 <AJ_AllocReplyContext+0xc8>)
    89a8:	18d3      	adds	r3, r2, r3
    89aa:	2200      	movs	r2, #0
    89ac:	751a      	strb	r2, [r3, #20]
            }
            return AJ_OK;
    89ae:	2000      	movs	r0, #0
    89b0:	e00e      	b.n	89d0 <AJ_AllocReplyContext+0xc4>
        } 
		else
		{
            AJ_ErrPrintf(("AJ_AllocReplyContext(): Failed to allocate reply context.  status=AJ_ERR_RESOURCES\n"));
    89b2:	2001      	movs	r0, #1
    89b4:	4908      	ldr	r1, [pc, #32]	; (89d8 <AJ_AllocReplyContext+0xcc>)
    89b6:	4a11      	ldr	r2, [pc, #68]	; (89fc <AJ_AllocReplyContext+0xf0>)
    89b8:	4b11      	ldr	r3, [pc, #68]	; (8a00 <AJ_AllocReplyContext+0xf4>)
    89ba:	4798      	blx	r3
    89bc:	1c03      	adds	r3, r0, #0
            return AJ_ERR_RESOURCES;
    89be:	200b      	movs	r0, #11
            }
            return AJ_OK;
        } 
		else
		{
            AJ_ErrPrintf(("AJ_AllocReplyContext(): Failed to allocate reply context.  status=AJ_ERR_RESOURCES\n"));
    89c0:	2b00      	cmp	r3, #0
    89c2:	d005      	beq.n	89d0 <AJ_AllocReplyContext+0xc4>
    89c4:	480f      	ldr	r0, [pc, #60]	; (8a04 <AJ_AllocReplyContext+0xf8>)
    89c6:	4b10      	ldr	r3, [pc, #64]	; (8a08 <AJ_AllocReplyContext+0xfc>)
    89c8:	4798      	blx	r3
            return AJ_ERR_RESOURCES;
    89ca:	200b      	movs	r0, #11
    89cc:	e000      	b.n	89d0 <AJ_AllocReplyContext+0xc4>
{
    if (msg->hdr->flags & AJ_FLAG_NO_REPLY_EXPECTED) 
	{
        // Not expecting a reply so don't allocate a reply context

        return AJ_OK;
    89ce:	2000      	movs	r0, #0
		{
            AJ_ErrPrintf(("AJ_AllocReplyContext(): Failed to allocate reply context.  status=AJ_ERR_RESOURCES\n"));
            return AJ_ERR_RESOURCES;
        }
    }
}
    89d0:	b003      	add	sp, #12
    89d2:	bd30      	pop	{r4, r5, pc}
    89d4:	20000894 	.word	0x20000894
    89d8:	0001ca4c 	.word	0x0001ca4c
    89dc:	0000065a 	.word	0x0000065a
    89e0:	0001c9b4 	.word	0x0001c9b4
    89e4:	0001cb44 	.word	0x0001cb44
    89e8:	00016629 	.word	0x00016629
    89ec:	00004e20 	.word	0x00004e20
    89f0:	0000d7ad 	.word	0x0000d7ad
    89f4:	00007cbd 	.word	0x00007cbd
    89f8:	00017191 	.word	0x00017191
    89fc:	00000675 	.word	0x00000675
    8a00:	0000636d 	.word	0x0000636d
    8a04:	0001cb5c 	.word	0x0001cb5c
    8a08:	00016f5d 	.word	0x00016f5d

00008a0c <AJ_ReleaseReplyContext>:

void AJ_ReleaseReplyContext(AJ_Message* msg)
{
    if (msg->hdr->msgType == AJ_MSG_METHOD_CALL) 
    8a0c:	6843      	ldr	r3, [r0, #4]
    8a0e:	785a      	ldrb	r2, [r3, #1]
    8a10:	2a01      	cmp	r2, #1
    8a12:	d117      	bne.n	8a44 <AJ_ReleaseReplyContext+0x38>
	{
        ReplyContext* repCtx = FindReplyContext(msg->hdr->serialNum);
    8a14:	689b      	ldr	r3, [r3, #8]
static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
	{
        if (replyContexts[i].serial == serial)
    8a16:	4a0c      	ldr	r2, [pc, #48]	; (8a48 <AJ_ReleaseReplyContext+0x3c>)
    8a18:	68d2      	ldr	r2, [r2, #12]
    8a1a:	4293      	cmp	r3, r2
    8a1c:	d00b      	beq.n	8a36 <AJ_ReleaseReplyContext+0x2a>
    8a1e:	4a0a      	ldr	r2, [pc, #40]	; (8a48 <AJ_ReleaseReplyContext+0x3c>)
    8a20:	6b92      	ldr	r2, [r2, #56]	; 0x38
    8a22:	4293      	cmp	r3, r2
    8a24:	d005      	beq.n	8a32 <AJ_ReleaseReplyContext+0x26>
    8a26:	4a08      	ldr	r2, [pc, #32]	; (8a48 <AJ_ReleaseReplyContext+0x3c>)
    8a28:	6e52      	ldr	r2, [r2, #100]	; 0x64
    8a2a:	4293      	cmp	r3, r2
    8a2c:	d10a      	bne.n	8a44 <AJ_ReleaseReplyContext+0x38>
}

static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
    8a2e:	2202      	movs	r2, #2
    8a30:	e002      	b.n	8a38 <AJ_ReleaseReplyContext+0x2c>
    8a32:	2201      	movs	r2, #1
    8a34:	e000      	b.n	8a38 <AJ_ReleaseReplyContext+0x2c>
    8a36:	2200      	movs	r2, #0
    if (msg->hdr->msgType == AJ_MSG_METHOD_CALL) 
	{
        ReplyContext* repCtx = FindReplyContext(msg->hdr->serialNum);
        if (repCtx) 
		{
            repCtx->serial = 0;
    8a38:	232c      	movs	r3, #44	; 0x2c
    8a3a:	4353      	muls	r3, r2
    8a3c:	4a02      	ldr	r2, [pc, #8]	; (8a48 <AJ_ReleaseReplyContext+0x3c>)
    8a3e:	18d3      	adds	r3, r2, r3
    8a40:	2200      	movs	r2, #0
    8a42:	60da      	str	r2, [r3, #12]
        }
    }
}
    8a44:	4770      	bx	lr
    8a46:	46c0      	nop			; (mov r8, r8)
    8a48:	20000894 	.word	0x20000894

00008a4c <AJ_TimedOutMethodCall>:

uint8_t AJ_TimedOutMethodCall(AJ_Message* msg)
{
    8a4c:	b570      	push	{r4, r5, r6, lr}
    8a4e:	1c06      	adds	r6, r0, #0
    ReplyContext* repCtx = replyContexts;
    8a50:	4c0e      	ldr	r4, [pc, #56]	; (8a8c <AJ_TimedOutMethodCall+0x40>)
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i, ++repCtx) 
    8a52:	1c25      	adds	r5, r4, #0
    8a54:	3584      	adds	r5, #132	; 0x84
	{
        if (repCtx->serial && (AJ_GetElapsedTime(&repCtx->callTime, TRUE) > repCtx->timeout))
    8a56:	68e3      	ldr	r3, [r4, #12]
    8a58:	2b00      	cmp	r3, #0
    8a5a:	d011      	beq.n	8a80 <AJ_TimedOutMethodCall+0x34>
    8a5c:	1c20      	adds	r0, r4, #0
    8a5e:	2101      	movs	r1, #1
    8a60:	4b0b      	ldr	r3, [pc, #44]	; (8a90 <AJ_TimedOutMethodCall+0x44>)
    8a62:	4798      	blx	r3
    8a64:	68a3      	ldr	r3, [r4, #8]
    8a66:	4298      	cmp	r0, r3
    8a68:	d90a      	bls.n	8a80 <AJ_TimedOutMethodCall+0x34>
		{
            // Set the reply serial and message id for the timeout error
            msg->replySerial = repCtx->serial;
    8a6a:	68e3      	ldr	r3, [r4, #12]
    8a6c:	60b3      	str	r3, [r6, #8]
            msg->msgId = AJ_REPLY_ID(repCtx->messageId);
    8a6e:	2380      	movs	r3, #128	; 0x80
    8a70:	061b      	lsls	r3, r3, #24
    8a72:	6922      	ldr	r2, [r4, #16]
    8a74:	4313      	orrs	r3, r2
    8a76:	6033      	str	r3, [r6, #0]
            // Release the reply context
            repCtx->serial = 0;
    8a78:	2300      	movs	r3, #0
    8a7a:	60e3      	str	r3, [r4, #12]
            return TRUE;
    8a7c:	2001      	movs	r0, #1
    8a7e:	e003      	b.n	8a88 <AJ_TimedOutMethodCall+0x3c>

uint8_t AJ_TimedOutMethodCall(AJ_Message* msg)
{
    ReplyContext* repCtx = replyContexts;
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i, ++repCtx) 
    8a80:	342c      	adds	r4, #44	; 0x2c
    8a82:	42ac      	cmp	r4, r5
    8a84:	d1e7      	bne.n	8a56 <AJ_TimedOutMethodCall+0xa>
            // Release the reply context
            repCtx->serial = 0;
            return TRUE;
        }
    }
    return FALSE;
    8a86:	2000      	movs	r0, #0
}
    8a88:	bd70      	pop	{r4, r5, r6, pc}
    8a8a:	46c0      	nop			; (mov r8, r8)
    8a8c:	20000894 	.word	0x20000894
    8a90:	0000d769 	.word	0x0000d769

00008a94 <AJ_ReleaseReplyContexts>:

void AJ_ReleaseReplyContexts(void)
{
    8a94:	b508      	push	{r3, lr}
    memset(replyContexts, 0, sizeof(replyContexts));
    8a96:	4803      	ldr	r0, [pc, #12]	; (8aa4 <AJ_ReleaseReplyContexts+0x10>)
    8a98:	2100      	movs	r1, #0
    8a9a:	2284      	movs	r2, #132	; 0x84
    8a9c:	4b02      	ldr	r3, [pc, #8]	; (8aa8 <AJ_ReleaseReplyContexts+0x14>)
    8a9e:	4798      	blx	r3
}
    8aa0:	bd08      	pop	{r3, pc}
    8aa2:	46c0      	nop			; (mov r8, r8)
    8aa4:	20000894 	.word	0x20000894
    8aa8:	00016773 	.word	0x00016773

00008aac <AJ_NextObject>:
    iter->n = 0;
    return AJ_NextObject(iter);
}

const AJ_Object* AJ_NextObject(AJ_ObjectIterator* iter)
{
    8aac:	b5f0      	push	{r4, r5, r6, r7, lr}
    while (iter->l < ArraySize(objectLists)) 
    8aae:	7884      	ldrb	r4, [r0, #2]
    8ab0:	2c08      	cmp	r4, #8
    8ab2:	d828      	bhi.n	8b06 <AJ_NextObject+0x5a>
	{
        const AJ_Object* list = objectLists[iter->l];
    8ab4:	4f17      	ldr	r7, [pc, #92]	; (8b14 <AJ_NextObject+0x68>)
					* For backwards compatibility the third entry is reserved for proxy objects. Going forward
					* proxy objects are identified in the object list by the AJ_OBJ_FLAG_IS_PROXY.
				*/
                if (iter->l == AJ_PRX_ID_FLAG) 
				{
                    objFlags &= AJ_OBJ_FLAG_IS_PROXY;
    8ab6:	2610      	movs	r6, #16
				{
                    return obj;
                }
            }
        }
        iter->n = 0;
    8ab8:	2300      	movs	r3, #0
    8aba:	469c      	mov	ip, r3

const AJ_Object* AJ_NextObject(AJ_ObjectIterator* iter)
{
    while (iter->l < ArraySize(objectLists)) 
	{
        const AJ_Object* list = objectLists[iter->l];
    8abc:	00a3      	lsls	r3, r4, #2
    8abe:	59dd      	ldr	r5, [r3, r7]
        if (list)
    8ac0:	2d00      	cmp	r5, #0
    8ac2:	d111      	bne.n	8ae8 <AJ_NextObject+0x3c>
    8ac4:	e016      	b.n	8af4 <AJ_NextObject+0x48>
		{
            while (list[iter->n].path) 
			{
                const AJ_Object* obj = &list[iter->n++];
    8ac6:	3201      	adds	r2, #1
    8ac8:	8082      	strh	r2, [r0, #4]
                uint8_t objFlags = obj->flags;
    8aca:	7a1a      	ldrb	r2, [r3, #8]
                /*
					* For backwards compatibility the third entry is reserved for proxy objects. Going forward
					* proxy objects are identified in the object list by the AJ_OBJ_FLAG_IS_PROXY.
				*/
                if (iter->l == AJ_PRX_ID_FLAG) 
    8acc:	2c02      	cmp	r4, #2
    8ace:	d100      	bne.n	8ad2 <AJ_NextObject+0x26>
				{
                    objFlags &= AJ_OBJ_FLAG_IS_PROXY;
    8ad0:	4032      	ands	r2, r6
                }
                if ((objFlags & iter->fin || (objFlags == 0 && iter->fin == AJ_OBJ_FLAGS_ALL_INCLUDE_MASK)) && !(objFlags & iter->fex)) 
    8ad2:	7801      	ldrb	r1, [r0, #0]
    8ad4:	4211      	tst	r1, r2
    8ad6:	d104      	bne.n	8ae2 <AJ_NextObject+0x36>
    8ad8:	2a00      	cmp	r2, #0
    8ada:	d105      	bne.n	8ae8 <AJ_NextObject+0x3c>
    8adc:	29ff      	cmp	r1, #255	; 0xff
    8ade:	d103      	bne.n	8ae8 <AJ_NextObject+0x3c>
    8ae0:	e013      	b.n	8b0a <AJ_NextObject+0x5e>
    8ae2:	7841      	ldrb	r1, [r0, #1]
    8ae4:	4211      	tst	r1, r2
    8ae6:	d012      	beq.n	8b0e <AJ_NextObject+0x62>
    while (iter->l < ArraySize(objectLists)) 
	{
        const AJ_Object* list = objectLists[iter->l];
        if (list)
		{
            while (list[iter->n].path) 
    8ae8:	8882      	ldrh	r2, [r0, #4]
    8aea:	0113      	lsls	r3, r2, #4
    8aec:	18eb      	adds	r3, r5, r3
    8aee:	6819      	ldr	r1, [r3, #0]
    8af0:	2900      	cmp	r1, #0
    8af2:	d1e8      	bne.n	8ac6 <AJ_NextObject+0x1a>
				{
                    return obj;
                }
            }
        }
        iter->n = 0;
    8af4:	4663      	mov	r3, ip
    8af6:	8083      	strh	r3, [r0, #4]
        ++iter->l;
    8af8:	3401      	adds	r4, #1
    8afa:	b2e4      	uxtb	r4, r4
    8afc:	7084      	strb	r4, [r0, #2]
    return AJ_NextObject(iter);
}

const AJ_Object* AJ_NextObject(AJ_ObjectIterator* iter)
{
    while (iter->l < ArraySize(objectLists)) 
    8afe:	2c09      	cmp	r4, #9
    8b00:	d1dc      	bne.n	8abc <AJ_NextObject+0x10>
            }
        }
        iter->n = 0;
        ++iter->l;
    }
    return NULL;
    8b02:	2000      	movs	r0, #0
    8b04:	e004      	b.n	8b10 <AJ_NextObject+0x64>
    8b06:	2000      	movs	r0, #0
    8b08:	e002      	b.n	8b10 <AJ_NextObject+0x64>
    while (iter->l < ArraySize(objectLists)) 
	{
        const AJ_Object* list = objectLists[iter->l];
        if (list)
		{
            while (list[iter->n].path) 
    8b0a:	1c18      	adds	r0, r3, #0
    8b0c:	e000      	b.n	8b10 <AJ_NextObject+0x64>
    8b0e:	1c18      	adds	r0, r3, #0
        }
        iter->n = 0;
        ++iter->l;
    }
    return NULL;
}
    8b10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8b12:	46c0      	nop			; (mov r8, r8)
    8b14:	20000138 	.word	0x20000138

00008b18 <AJ_InitObjectIterator>:
        return AJ_INVALID_MEMBER;
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    8b18:	b508      	push	{r3, lr}
    iter->fin = inFlags;
    8b1a:	7001      	strb	r1, [r0, #0]
    iter->fex = exFlags;
    8b1c:	7042      	strb	r2, [r0, #1]
    iter->l = 0;
    8b1e:	2300      	movs	r3, #0
    8b20:	7083      	strb	r3, [r0, #2]
    iter->n = 0;
    8b22:	8083      	strh	r3, [r0, #4]
    return AJ_NextObject(iter);
    8b24:	4b01      	ldr	r3, [pc, #4]	; (8b2c <AJ_InitObjectIterator+0x14>)
    8b26:	4798      	blx	r3
}
    8b28:	bd08      	pop	{r3, pc}
    8b2a:	46c0      	nop			; (mov r8, r8)
    8b2c:	00008aad 	.word	0x00008aad

00008b30 <SecurityApplies>:
/*
 * Security applies if the interface is secure or if the object or it's parent object is flagged as
 * secure and the security is not explicitly OFF for the interface.
 */
static uint32_t SecurityApplies(const char* ifc, const AJ_Object* obj)
{
    8b30:	b5f0      	push	{r4, r5, r6, r7, lr}
    8b32:	b083      	sub	sp, #12
    AJ_ObjectIterator iter;
    const AJ_Object* lookup;

    if (ifc) 
    8b34:	2800      	cmp	r0, #0
    8b36:	d004      	beq.n	8b42 <SecurityApplies+0x12>
	{
        if (*ifc == SECURE_TRUE)
    8b38:	7803      	ldrb	r3, [r0, #0]
    8b3a:	2b24      	cmp	r3, #36	; 0x24
    8b3c:	d024      	beq.n	8b88 <SecurityApplies+0x58>
		{
            return TRUE;
        }
        if (*ifc == SECURE_OFF) 
    8b3e:	2b23      	cmp	r3, #35	; 0x23
    8b40:	d024      	beq.n	8b8c <SecurityApplies+0x5c>
		{
            return FALSE;
        }
    }
    if (obj->flags & AJ_OBJ_FLAG_SECURE) 
    8b42:	7a0b      	ldrb	r3, [r1, #8]
	{
        return TRUE;
    8b44:	2001      	movs	r0, #1
        if (*ifc == SECURE_OFF) 
		{
            return FALSE;
        }
    }
    if (obj->flags & AJ_OBJ_FLAG_SECURE) 
    8b46:	07db      	lsls	r3, r3, #31
    8b48:	d425      	bmi.n	8b96 <SecurityApplies+0x66>
    8b4a:	1c0c      	adds	r4, r1, #0
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    iter->fin = inFlags;
    8b4c:	23ff      	movs	r3, #255	; 0xff
    8b4e:	466a      	mov	r2, sp
    8b50:	7013      	strb	r3, [r2, #0]
    iter->fex = exFlags;
    8b52:	3bef      	subs	r3, #239	; 0xef
    8b54:	7053      	strb	r3, [r2, #1]
    iter->l = 0;
    8b56:	2300      	movs	r3, #0
    8b58:	7093      	strb	r3, [r2, #2]
    iter->n = 0;
    8b5a:	8093      	strh	r3, [r2, #4]
    return AJ_NextObject(iter);
    8b5c:	4668      	mov	r0, sp
    8b5e:	4b0f      	ldr	r3, [pc, #60]	; (8b9c <SecurityApplies+0x6c>)
    8b60:	4798      	blx	r3
        return TRUE;
    }
    // Check that obj is not a child of a secure parent object
    // -   
    lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAG_IS_PROXY);
    while (lookup != NULL)
    8b62:	2800      	cmp	r0, #0
    8b64:	d014      	beq.n	8b90 <SecurityApplies+0x60>
	{
        if ((lookup->flags & AJ_OBJ_FLAG_SECURE) && ChildPath(lookup->path, obj->path, NULL)) 
    8b66:	2501      	movs	r5, #1
    8b68:	4f0d      	ldr	r7, [pc, #52]	; (8ba0 <SecurityApplies+0x70>)
		{
            return TRUE;
        }
		//-   
        lookup = AJ_NextObject(&iter);
    8b6a:	4e0c      	ldr	r6, [pc, #48]	; (8b9c <SecurityApplies+0x6c>)
    // Check that obj is not a child of a secure parent object
    // -   
    lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAG_IS_PROXY);
    while (lookup != NULL)
	{
        if ((lookup->flags & AJ_OBJ_FLAG_SECURE) && ChildPath(lookup->path, obj->path, NULL)) 
    8b6c:	7a03      	ldrb	r3, [r0, #8]
    8b6e:	421d      	tst	r5, r3
    8b70:	d005      	beq.n	8b7e <SecurityApplies+0x4e>
    8b72:	6800      	ldr	r0, [r0, #0]
    8b74:	6821      	ldr	r1, [r4, #0]
    8b76:	2200      	movs	r2, #0
    8b78:	47b8      	blx	r7
    8b7a:	2800      	cmp	r0, #0
    8b7c:	d10a      	bne.n	8b94 <SecurityApplies+0x64>
		{
            return TRUE;
        }
		//-   
        lookup = AJ_NextObject(&iter);
    8b7e:	4668      	mov	r0, sp
    8b80:	47b0      	blx	r6
        return TRUE;
    }
    // Check that obj is not a child of a secure parent object
    // -   
    lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAG_IS_PROXY);
    while (lookup != NULL)
    8b82:	2800      	cmp	r0, #0
    8b84:	d1f2      	bne.n	8b6c <SecurityApplies+0x3c>
    8b86:	e006      	b.n	8b96 <SecurityApplies+0x66>

    if (ifc) 
	{
        if (*ifc == SECURE_TRUE)
		{
            return TRUE;
    8b88:	2001      	movs	r0, #1
    8b8a:	e004      	b.n	8b96 <SecurityApplies+0x66>
        }
        if (*ifc == SECURE_OFF) 
		{
            return FALSE;
    8b8c:	2000      	movs	r0, #0
    8b8e:	e002      	b.n	8b96 <SecurityApplies+0x66>
            return TRUE;
        }
		//-   
        lookup = AJ_NextObject(&iter);
    }
    return FALSE;
    8b90:	2000      	movs	r0, #0
    8b92:	e000      	b.n	8b96 <SecurityApplies+0x66>
    lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAG_IS_PROXY);
    while (lookup != NULL)
	{
        if ((lookup->flags & AJ_OBJ_FLAG_SECURE) && ChildPath(lookup->path, obj->path, NULL)) 
		{
            return TRUE;
    8b94:	2001      	movs	r0, #1
        }
		//-   
        lookup = AJ_NextObject(&iter);
    }
    return FALSE;
}
    8b96:	b003      	add	sp, #12
    8b98:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8b9a:	46c0      	nop			; (mov r8, r8)
    8b9c:	00008aad 	.word	0x00008aad
    8ba0:	00008171 	.word	0x00008171

00008ba4 <AJ_LookupMessageId>:
    }
    return strcmp(path, msg->objPath) == 0;
}

AJ_Status AJ_LookupMessageId(AJ_Message* msg, uint8_t* secure)
{
    8ba4:	b5f0      	push	{r4, r5, r6, r7, lr}
    8ba6:	465f      	mov	r7, fp
    8ba8:	4656      	mov	r6, sl
    8baa:	464d      	mov	r5, r9
    8bac:	4644      	mov	r4, r8
    8bae:	b4f0      	push	{r4, r5, r6, r7}
    8bb0:	b089      	sub	sp, #36	; 0x24
    8bb2:	1c07      	adds	r7, r0, #0
    8bb4:	9105      	str	r1, [sp, #20]
    8bb6:	2300      	movs	r3, #0
    8bb8:	9303      	str	r3, [sp, #12]
    uint8_t oIndex = 0;

    for (oIndex = 0; oIndex < ArraySize(objectLists); ++oIndex) 
	{
        uint8_t pIndex = 0;
        const AJ_Object* obj = objectLists[oIndex];
    8bba:	9b03      	ldr	r3, [sp, #12]
    8bbc:	9304      	str	r3, [sp, #16]
    8bbe:	009b      	lsls	r3, r3, #2
    8bc0:	4a4c      	ldr	r2, [pc, #304]	; (8cf4 <AJ_LookupMessageId+0x150>)
    8bc2:	589c      	ldr	r4, [r3, r2]
        if (!obj) 
    8bc4:	2c00      	cmp	r4, #0
    8bc6:	d06a      	beq.n	8c9e <AJ_LookupMessageId+0xfa>
		{
            continue;
        }
        for (; obj->path; ++pIndex, ++obj)
    8bc8:	6820      	ldr	r0, [r4, #0]
    8bca:	2800      	cmp	r0, #0
    8bcc:	d067      	beq.n	8c9e <AJ_LookupMessageId+0xfa>
    8bce:	2300      	movs	r3, #0
    8bd0:	9301      	str	r3, [sp, #4]
		{
            // Skip objects that are currently disabled
            if (obj->flags & AJ_OBJ_FLAG_DISABLED) 
    8bd2:	7a23      	ldrb	r3, [r4, #8]
    8bd4:	075b      	lsls	r3, r3, #29
    8bd6:	d45a      	bmi.n	8c8e <AJ_LookupMessageId+0xea>
 * signal emitted by any object. Note that these wildcards are expected to provide unique matches,
 * i.e. there should be no non-wildcarded entry in any object table that would also match.
 */
static uint8_t inline MatchPath(const char* path, AJ_Message* msg) 
{
    if ((*path == '?') && (msg->hdr->msgType == AJ_MSG_METHOD_CALL)) 
    8bd8:	7803      	ldrb	r3, [r0, #0]
    8bda:	2b3f      	cmp	r3, #63	; 0x3f
    8bdc:	d104      	bne.n	8be8 <AJ_LookupMessageId+0x44>
    8bde:	687b      	ldr	r3, [r7, #4]
    8be0:	785b      	ldrb	r3, [r3, #1]
    8be2:	2b01      	cmp	r3, #1
    8be4:	d106      	bne.n	8bf4 <AJ_LookupMessageId+0x50>
    8be6:	e00a      	b.n	8bfe <AJ_LookupMessageId+0x5a>
	{
        return TRUE;
    }
    if ((*path == '!') && (msg->hdr->msgType == AJ_MSG_SIGNAL))
    8be8:	2b21      	cmp	r3, #33	; 0x21
    8bea:	d103      	bne.n	8bf4 <AJ_LookupMessageId+0x50>
    8bec:	687b      	ldr	r3, [r7, #4]
    8bee:	785b      	ldrb	r3, [r3, #1]
    8bf0:	2b04      	cmp	r3, #4
    8bf2:	d004      	beq.n	8bfe <AJ_LookupMessageId+0x5a>
	{
        return TRUE;
    }
    return strcmp(path, msg->objPath) == 0;
    8bf4:	68b9      	ldr	r1, [r7, #8]
    8bf6:	4b40      	ldr	r3, [pc, #256]	; (8cf8 <AJ_LookupMessageId+0x154>)
    8bf8:	4798      	blx	r3
            // Skip objects that are currently disabled
            if (obj->flags & AJ_OBJ_FLAG_DISABLED) 
			{
                continue;
            }
            if (MatchPath(obj->path, msg)) 
    8bfa:	2800      	cmp	r0, #0
    8bfc:	d147      	bne.n	8c8e <AJ_LookupMessageId+0xea>
			{
                uint8_t iIndex;
                AJ_InterfaceDescription desc = FindInterface(obj->interfaces, msg->iface, &iIndex);
    8bfe:	6860      	ldr	r0, [r4, #4]
    8c00:	6939      	ldr	r1, [r7, #16]
    8c02:	ab06      	add	r3, sp, #24
    8c04:	1dda      	adds	r2, r3, #7
    8c06:	4b3d      	ldr	r3, [pc, #244]	; (8cfc <AJ_LookupMessageId+0x158>)
    8c08:	4798      	blx	r3
    8c0a:	4680      	mov	r8, r0
                if (desc) 
    8c0c:	2800      	cmp	r0, #0
    8c0e:	d03e      	beq.n	8c8e <AJ_LookupMessageId+0xea>
				{
                    uint8_t mIndex = 0;
                    *secure = SecurityApplies(*desc, obj);
    8c10:	1c06      	adds	r6, r0, #0
    8c12:	ce01      	ldmia	r6!, {r0}
    8c14:	1c21      	adds	r1, r4, #0
    8c16:	4b3a      	ldr	r3, [pc, #232]	; (8d00 <AJ_LookupMessageId+0x15c>)
    8c18:	4798      	blx	r3
    8c1a:	9b05      	ldr	r3, [sp, #20]
    8c1c:	7018      	strb	r0, [r3, #0]
                    // Skip the interface name and iterate over the members of the interface
                    while (*(++desc)) 
    8c1e:	4643      	mov	r3, r8
    8c20:	6859      	ldr	r1, [r3, #4]
    8c22:	2900      	cmp	r1, #0
    8c24:	d033      	beq.n	8c8e <AJ_LookupMessageId+0xea>
    return AJ_OK;
}

static uint32_t MatchMember(const char* encoding, const AJ_Message* msg)
{
    const char* member = msg->member;
    8c26:	68fb      	ldr	r3, [r7, #12]
    8c28:	9302      	str	r3, [sp, #8]
    uint8_t memberType = (msg->hdr->msgType == AJ_MSG_METHOD_CALL) ? METHOD : SIGNAL;
    8c2a:	687b      	ldr	r3, [r7, #4]
    8c2c:	785b      	ldrb	r3, [r3, #1]
    8c2e:	3b01      	subs	r3, #1
    8c30:	4258      	negs	r0, r3
    8c32:	4158      	adcs	r0, r3
    8c34:	b2c3      	uxtb	r3, r0
    8c36:	469a      	mov	sl, r3
    if (MEMBER_TYPE(*encoding++) != memberType) 
    8c38:	2000      	movs	r0, #0
	{
        if (*encoding++ != *member++) {
            return FALSE;
        }
    }
    return (*encoding == '\0') || (*encoding == ' ');
    8c3a:	2320      	movs	r3, #32
    8c3c:	469b      	mov	fp, r3
    8c3e:	46a4      	mov	ip, r4
    8c40:	4654      	mov	r4, sl
    8c42:	46b8      	mov	r8, r7
    8c44:	4657      	mov	r7, sl

static uint32_t MatchMember(const char* encoding, const AJ_Message* msg)
{
    const char* member = msg->member;
    uint8_t memberType = (msg->hdr->msgType == AJ_MSG_METHOD_CALL) ? METHOD : SIGNAL;
    if (MEMBER_TYPE(*encoding++) != memberType) 
    8c46:	1c4b      	adds	r3, r1, #1
    8c48:	780a      	ldrb	r2, [r1, #0]
    8c4a:	0912      	lsrs	r2, r2, #4
    8c4c:	3a02      	subs	r2, #2
    8c4e:	42a2      	cmp	r2, r4
    8c50:	d115      	bne.n	8c7e <AJ_LookupMessageId+0xda>
	{
        return FALSE;
    }
    if (memberType == SIGNAL && IS_SESSIONLESS(*encoding)) 
    8c52:	2f00      	cmp	r7, #0
    8c54:	d10a      	bne.n	8c6c <AJ_LookupMessageId+0xc8>
    8c56:	784a      	ldrb	r2, [r1, #1]
    8c58:	2a26      	cmp	r2, #38	; 0x26
    8c5a:	d107      	bne.n	8c6c <AJ_LookupMessageId+0xc8>
	{
        // Advance so that we do not return a '&' character
        encoding++;
    8c5c:	1c8b      	adds	r3, r1, #2
    8c5e:	e005      	b.n	8c6c <AJ_LookupMessageId+0xc8>
    }
    while (*member) 
	{
        if (*encoding++ != *member++) {
    8c60:	3201      	adds	r2, #1
    8c62:	3301      	adds	r3, #1
    8c64:	782d      	ldrb	r5, [r5, #0]
    8c66:	428d      	cmp	r5, r1
    8c68:	d001      	beq.n	8c6e <AJ_LookupMessageId+0xca>
    8c6a:	e008      	b.n	8c7e <AJ_LookupMessageId+0xda>

static uint32_t MatchMember(const char* encoding, const AJ_Message* msg)
{
    const char* member = msg->member;
    uint8_t memberType = (msg->hdr->msgType == AJ_MSG_METHOD_CALL) ? METHOD : SIGNAL;
    if (MEMBER_TYPE(*encoding++) != memberType) 
    8c6c:	9a02      	ldr	r2, [sp, #8]
    8c6e:	1c1d      	adds	r5, r3, #0
    if (memberType == SIGNAL && IS_SESSIONLESS(*encoding)) 
	{
        // Advance so that we do not return a '&' character
        encoding++;
    }
    while (*member) 
    8c70:	7811      	ldrb	r1, [r2, #0]
    8c72:	2900      	cmp	r1, #0
    8c74:	d1f4      	bne.n	8c60 <AJ_LookupMessageId+0xbc>
	{
        if (*encoding++ != *member++) {
            return FALSE;
        }
    }
    return (*encoding == '\0') || (*encoding == ' ');
    8c76:	781b      	ldrb	r3, [r3, #0]
    8c78:	465a      	mov	r2, fp
    8c7a:	4393      	bics	r3, r2
    8c7c:	d022      	beq.n	8cc4 <AJ_LookupMessageId+0x120>
						{
                            msg->msgId = (oIndex << 24) | (pIndex << 16) | (iIndex << 8) | mIndex;
                            AJ_InfoPrintf(("Identified message %x\n", msg->msgId));
                            return CheckSignature(*desc, msg);
                        }
                        ++mIndex;
    8c7e:	3001      	adds	r0, #1
    8c80:	b2c0      	uxtb	r0, r0
                if (desc) 
				{
                    uint8_t mIndex = 0;
                    *secure = SecurityApplies(*desc, obj);
                    // Skip the interface name and iterate over the members of the interface
                    while (*(++desc)) 
    8c82:	3604      	adds	r6, #4
    8c84:	6831      	ldr	r1, [r6, #0]
    8c86:	2900      	cmp	r1, #0
    8c88:	d1dd      	bne.n	8c46 <AJ_LookupMessageId+0xa2>
    8c8a:	4664      	mov	r4, ip
    8c8c:	4647      	mov	r7, r8
        const AJ_Object* obj = objectLists[oIndex];
        if (!obj) 
		{
            continue;
        }
        for (; obj->path; ++pIndex, ++obj)
    8c8e:	9d01      	ldr	r5, [sp, #4]
    8c90:	3501      	adds	r5, #1
    8c92:	b2eb      	uxtb	r3, r5
    8c94:	9301      	str	r3, [sp, #4]
    8c96:	3410      	adds	r4, #16
    8c98:	6820      	ldr	r0, [r4, #0]
    8c9a:	2800      	cmp	r0, #0
    8c9c:	d199      	bne.n	8bd2 <AJ_LookupMessageId+0x2e>
    8c9e:	9b03      	ldr	r3, [sp, #12]
    8ca0:	3301      	adds	r3, #1
    8ca2:	9303      	str	r3, [sp, #12]

AJ_Status AJ_LookupMessageId(AJ_Message* msg, uint8_t* secure)
{
    uint8_t oIndex = 0;

    for (oIndex = 0; oIndex < ArraySize(objectLists); ++oIndex) 
    8ca4:	2b09      	cmp	r3, #9
    8ca6:	d188      	bne.n	8bba <AJ_LookupMessageId+0x16>
                    }
                }
            }
        }
    }
    AJ_ErrPrintf(("LookupMessageId(): AJ_ERR_NO_MATCH\n"));
    8ca8:	2001      	movs	r0, #1
    8caa:	4916      	ldr	r1, [pc, #88]	; (8d04 <AJ_LookupMessageId+0x160>)
    8cac:	4a16      	ldr	r2, [pc, #88]	; (8d08 <AJ_LookupMessageId+0x164>)
    8cae:	4b17      	ldr	r3, [pc, #92]	; (8d0c <AJ_LookupMessageId+0x168>)
    8cb0:	4798      	blx	r3
    8cb2:	1c03      	adds	r3, r0, #0
    return AJ_ERR_NO_MATCH;
    8cb4:	2010      	movs	r0, #16
                    }
                }
            }
        }
    }
    AJ_ErrPrintf(("LookupMessageId(): AJ_ERR_NO_MATCH\n"));
    8cb6:	2b00      	cmp	r3, #0
    8cb8:	d015      	beq.n	8ce6 <AJ_LookupMessageId+0x142>
    8cba:	4815      	ldr	r0, [pc, #84]	; (8d10 <AJ_LookupMessageId+0x16c>)
    8cbc:	4b15      	ldr	r3, [pc, #84]	; (8d14 <AJ_LookupMessageId+0x170>)
    8cbe:	4798      	blx	r3
    return AJ_ERR_NO_MATCH;
    8cc0:	2010      	movs	r0, #16
    8cc2:	e010      	b.n	8ce6 <AJ_LookupMessageId+0x142>
    8cc4:	4647      	mov	r7, r8
                    // Skip the interface name and iterate over the members of the interface
                    while (*(++desc)) 
					{
                        if (MatchMember(*desc, msg)) 
						{
                            msg->msgId = (oIndex << 24) | (pIndex << 16) | (iIndex << 8) | mIndex;
    8cc6:	9b04      	ldr	r3, [sp, #16]
    8cc8:	061a      	lsls	r2, r3, #24
    8cca:	4302      	orrs	r2, r0
    8ccc:	ab06      	add	r3, sp, #24
    8cce:	3307      	adds	r3, #7
    8cd0:	781b      	ldrb	r3, [r3, #0]
    8cd2:	021b      	lsls	r3, r3, #8
    8cd4:	4313      	orrs	r3, r2
    8cd6:	9a01      	ldr	r2, [sp, #4]
    8cd8:	0412      	lsls	r2, r2, #16
    8cda:	4313      	orrs	r3, r2
    8cdc:	603b      	str	r3, [r7, #0]
                            AJ_InfoPrintf(("Identified message %x\n", msg->msgId));
                            return CheckSignature(*desc, msg);
    8cde:	6830      	ldr	r0, [r6, #0]
    8ce0:	4641      	mov	r1, r8
    8ce2:	4b0d      	ldr	r3, [pc, #52]	; (8d18 <AJ_LookupMessageId+0x174>)
    8ce4:	4798      	blx	r3
            }
        }
    }
    AJ_ErrPrintf(("LookupMessageId(): AJ_ERR_NO_MATCH\n"));
    return AJ_ERR_NO_MATCH;
}
    8ce6:	b009      	add	sp, #36	; 0x24
    8ce8:	bc3c      	pop	{r2, r3, r4, r5}
    8cea:	4690      	mov	r8, r2
    8cec:	4699      	mov	r9, r3
    8cee:	46a2      	mov	sl, r4
    8cf0:	46ab      	mov	fp, r5
    8cf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8cf4:	20000138 	.word	0x20000138
    8cf8:	00017137 	.word	0x00017137
    8cfc:	000081e5 	.word	0x000081e5
    8d00:	00008b31 	.word	0x00008b31
    8d04:	0001ca4c 	.word	0x0001ca4c
    8d08:	00000426 	.word	0x00000426
    8d0c:	0000636d 	.word	0x0000636d
    8d10:	0001cbb0 	.word	0x0001cbb0
    8d14:	00016f5d 	.word	0x00016f5d
    8d18:	00008255 	.word	0x00008255

00008d1c <UnpackMsgId>:
    return TRUE;
}
#endif

static AJ_Status UnpackMsgId(uint32_t msgId, const char** objPath, const char** iface, const char** member, uint8_t* secure)
{
    8d1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8d1e:	4647      	mov	r7, r8
    8d20:	b480      	push	{r7}
    8d22:	b084      	sub	sp, #16
    8d24:	1c04      	adds	r4, r0, #0
    8d26:	9103      	str	r1, [sp, #12]
    8d28:	9202      	str	r2, [sp, #8]
    8d2a:	9301      	str	r3, [sp, #4]
    uint8_t oIndex = (msgId >> 24);
    8d2c:	0e05      	lsrs	r5, r0, #24
    uint8_t mIndex = (uint8_t)(msgId) + 1;
    const AJ_Object* obj;
    AJ_InterfaceDescription ifc;

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object)))
    8d2e:	b2eb      	uxtb	r3, r5
    8d30:	2b08      	cmp	r3, #8
    8d32:	d809      	bhi.n	8d48 <UnpackMsgId+0x2c>
#endif

static AJ_Status UnpackMsgId(uint32_t msgId, const char** objPath, const char** iface, const char** member, uint8_t* secure)
{
    uint8_t oIndex = (msgId >> 24);
    uint8_t pIndex = (msgId >> 16);
    8d34:	0c07      	lsrs	r7, r0, #16
    uint8_t mIndex = (uint8_t)(msgId) + 1;
    const AJ_Object* obj;
    AJ_InterfaceDescription ifc;

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object)))
    8d36:	00ab      	lsls	r3, r5, #2
    8d38:	4a44      	ldr	r2, [pc, #272]	; (8e4c <UnpackMsgId+0x130>)
    8d3a:	5898      	ldr	r0, [r3, r2]
    8d3c:	b2f9      	uxtb	r1, r7
    8d3e:	2210      	movs	r2, #16
    8d40:	4b43      	ldr	r3, [pc, #268]	; (8e50 <UnpackMsgId+0x134>)
    8d42:	4798      	blx	r3
    8d44:	2800      	cmp	r0, #0
    8d46:	d10c      	bne.n	8d62 <UnpackMsgId+0x46>
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8d48:	2001      	movs	r0, #1
    8d4a:	4942      	ldr	r1, [pc, #264]	; (8e54 <UnpackMsgId+0x138>)
    8d4c:	4a42      	ldr	r2, [pc, #264]	; (8e58 <UnpackMsgId+0x13c>)
    8d4e:	4b43      	ldr	r3, [pc, #268]	; (8e5c <UnpackMsgId+0x140>)
    8d50:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8d52:	2303      	movs	r3, #3
    AJ_InterfaceDescription ifc;

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object)))
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8d54:	2800      	cmp	r0, #0
    8d56:	d073      	beq.n	8e40 <UnpackMsgId+0x124>
    8d58:	4841      	ldr	r0, [pc, #260]	; (8e60 <UnpackMsgId+0x144>)
    8d5a:	4b42      	ldr	r3, [pc, #264]	; (8e64 <UnpackMsgId+0x148>)
    8d5c:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8d5e:	2303      	movs	r3, #3
    8d60:	e06e      	b.n	8e40 <UnpackMsgId+0x124>

static AJ_Status UnpackMsgId(uint32_t msgId, const char** objPath, const char** iface, const char** member, uint8_t* secure)
{
    uint8_t oIndex = (msgId >> 24);
    uint8_t pIndex = (msgId >> 16);
    uint8_t iIndex = (msgId >> 8);
    8d62:	0a26      	lsrs	r6, r4, #8
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object)))
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
        return AJ_ERR_INVALID;
    }
    obj = &objectLists[oIndex][pIndex];
    8d64:	00ab      	lsls	r3, r5, #2
    8d66:	22ff      	movs	r2, #255	; 0xff
    8d68:	403a      	ands	r2, r7
    8d6a:	0112      	lsls	r2, r2, #4
    8d6c:	4937      	ldr	r1, [pc, #220]	; (8e4c <UnpackMsgId+0x130>)
    8d6e:	585b      	ldr	r3, [r3, r1]
    8d70:	189f      	adds	r7, r3, r2
    if (!CheckIndex(obj->interfaces, iIndex, sizeof(AJ_InterfaceDescription))) 
    8d72:	b2f1      	uxtb	r1, r6
    8d74:	6878      	ldr	r0, [r7, #4]
    8d76:	2204      	movs	r2, #4
    8d78:	4b35      	ldr	r3, [pc, #212]	; (8e50 <UnpackMsgId+0x134>)
    8d7a:	4798      	blx	r3
    8d7c:	2800      	cmp	r0, #0
    8d7e:	d10c      	bne.n	8d9a <UnpackMsgId+0x7e>
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8d80:	3001      	adds	r0, #1
    8d82:	4934      	ldr	r1, [pc, #208]	; (8e54 <UnpackMsgId+0x138>)
    8d84:	4a38      	ldr	r2, [pc, #224]	; (8e68 <UnpackMsgId+0x14c>)
    8d86:	4b35      	ldr	r3, [pc, #212]	; (8e5c <UnpackMsgId+0x140>)
    8d88:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8d8a:	2303      	movs	r3, #3
        return AJ_ERR_INVALID;
    }
    obj = &objectLists[oIndex][pIndex];
    if (!CheckIndex(obj->interfaces, iIndex, sizeof(AJ_InterfaceDescription))) 
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8d8c:	2800      	cmp	r0, #0
    8d8e:	d057      	beq.n	8e40 <UnpackMsgId+0x124>
    8d90:	4833      	ldr	r0, [pc, #204]	; (8e60 <UnpackMsgId+0x144>)
    8d92:	4b34      	ldr	r3, [pc, #208]	; (8e64 <UnpackMsgId+0x148>)
    8d94:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8d96:	2303      	movs	r3, #3
    8d98:	e052      	b.n	8e40 <UnpackMsgId+0x124>
static AJ_Status UnpackMsgId(uint32_t msgId, const char** objPath, const char** iface, const char** member, uint8_t* secure)
{
    uint8_t oIndex = (msgId >> 24);
    uint8_t pIndex = (msgId >> 16);
    uint8_t iIndex = (msgId >> 8);
    uint8_t mIndex = (uint8_t)(msgId) + 1;
    8d9a:	3401      	adds	r4, #1
    8d9c:	b2e4      	uxtb	r4, r4
    if (!CheckIndex(obj->interfaces, iIndex, sizeof(AJ_InterfaceDescription))) 
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
        return AJ_ERR_INVALID;
    }
    ifc = obj->interfaces[iIndex];
    8d9e:	23ff      	movs	r3, #255	; 0xff
    8da0:	4033      	ands	r3, r6
    8da2:	009b      	lsls	r3, r3, #2
    8da4:	687a      	ldr	r2, [r7, #4]
    8da6:	589b      	ldr	r3, [r3, r2]
    8da8:	4698      	mov	r8, r3
    if (!CheckIndex(ifc, mIndex, sizeof(AJ_InterfaceDescription)))
    8daa:	1c18      	adds	r0, r3, #0
    8dac:	1c21      	adds	r1, r4, #0
    8dae:	2204      	movs	r2, #4
    8db0:	4b27      	ldr	r3, [pc, #156]	; (8e50 <UnpackMsgId+0x134>)
    8db2:	4798      	blx	r3
    8db4:	2800      	cmp	r0, #0
    8db6:	d10c      	bne.n	8dd2 <UnpackMsgId+0xb6>
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8db8:	3001      	adds	r0, #1
    8dba:	4926      	ldr	r1, [pc, #152]	; (8e54 <UnpackMsgId+0x138>)
    8dbc:	4a2b      	ldr	r2, [pc, #172]	; (8e6c <UnpackMsgId+0x150>)
    8dbe:	4b27      	ldr	r3, [pc, #156]	; (8e5c <UnpackMsgId+0x140>)
    8dc0:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8dc2:	2303      	movs	r3, #3
        return AJ_ERR_INVALID;
    }
    ifc = obj->interfaces[iIndex];
    if (!CheckIndex(ifc, mIndex, sizeof(AJ_InterfaceDescription)))
	{
        AJ_ErrPrintf(("UnpackMsgId(): AJ_ERR_INVALID\n"));
    8dc4:	2800      	cmp	r0, #0
    8dc6:	d03b      	beq.n	8e40 <UnpackMsgId+0x124>
    8dc8:	4825      	ldr	r0, [pc, #148]	; (8e60 <UnpackMsgId+0x144>)
    8dca:	4b26      	ldr	r3, [pc, #152]	; (8e64 <UnpackMsgId+0x148>)
    8dcc:	4798      	blx	r3
        return AJ_ERR_INVALID;
    8dce:	2303      	movs	r3, #3
    8dd0:	e036      	b.n	8e40 <UnpackMsgId+0x124>
    }
#else
    obj = &objectLists[oIndex][pIndex];
    ifc = obj->interfaces[iIndex];
#endif
    if (obj->flags & AJ_OBJ_FLAG_DISABLED) 
    8dd2:	7a3a      	ldrb	r2, [r7, #8]
	{
        return AJ_ERR_INVALID;
    8dd4:	2303      	movs	r3, #3
    }
#else
    obj = &objectLists[oIndex][pIndex];
    ifc = obj->interfaces[iIndex];
#endif
    if (obj->flags & AJ_OBJ_FLAG_DISABLED) 
    8dd6:	0752      	lsls	r2, r2, #29
    8dd8:	d432      	bmi.n	8e40 <UnpackMsgId+0x124>
	{
        return AJ_ERR_INVALID;
    }
    if (objPath) 
    8dda:	9b03      	ldr	r3, [sp, #12]
    8ddc:	2b00      	cmp	r3, #0
    8dde:	d001      	beq.n	8de4 <UnpackMsgId+0xc8>
	{
        *objPath = obj->path;
    8de0:	683a      	ldr	r2, [r7, #0]
    8de2:	601a      	str	r2, [r3, #0]
    }
	//  
    *secure = SecurityApplies(*ifc, obj);
    8de4:	4643      	mov	r3, r8
    8de6:	6818      	ldr	r0, [r3, #0]
    8de8:	1c39      	adds	r1, r7, #0
    8dea:	4b21      	ldr	r3, [pc, #132]	; (8e70 <UnpackMsgId+0x154>)
    8dec:	4798      	blx	r3
    8dee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8df0:	7018      	strb	r0, [r3, #0]
    if (iface) 
    8df2:	9b02      	ldr	r3, [sp, #8]
    8df4:	2b00      	cmp	r3, #0
    8df6:	d00b      	beq.n	8e10 <UnpackMsgId+0xf4>
	{
        // Skip over security specifier if there is one
        if ((ifc[0][0] == SECURE_TRUE) || (ifc[0][0] == SECURE_OFF))
    8df8:	4643      	mov	r3, r8
    8dfa:	681a      	ldr	r2, [r3, #0]
    8dfc:	7813      	ldrb	r3, [r2, #0]
    8dfe:	3b23      	subs	r3, #35	; 0x23
    8e00:	2b01      	cmp	r3, #1
    8e02:	d803      	bhi.n	8e0c <UnpackMsgId+0xf0>
		{
            *iface = *ifc + 1;
    8e04:	3201      	adds	r2, #1
    8e06:	9b02      	ldr	r3, [sp, #8]
    8e08:	601a      	str	r2, [r3, #0]
    8e0a:	e001      	b.n	8e10 <UnpackMsgId+0xf4>
        } 
		else
		{
            *iface = *ifc;
    8e0c:	9b02      	ldr	r3, [sp, #8]
    8e0e:	601a      	str	r2, [r3, #0]
        }
    }
    if (member) 
    8e10:	9b01      	ldr	r3, [sp, #4]
    8e12:	2b00      	cmp	r3, #0
    8e14:	d013      	beq.n	8e3e <UnpackMsgId+0x122>
	{
        // Skip over sessionless signal specifier if there is one

        if (MEMBER_TYPE(ifc[mIndex][0]) == SIGNAL && IS_SESSIONLESS(ifc[mIndex][1]))
    8e16:	00a4      	lsls	r4, r4, #2
    8e18:	4643      	mov	r3, r8
    8e1a:	58e3      	ldr	r3, [r4, r3]
    8e1c:	781a      	ldrb	r2, [r3, #0]
    8e1e:	0912      	lsrs	r2, r2, #4
    8e20:	2a02      	cmp	r2, #2
    8e22:	d107      	bne.n	8e34 <UnpackMsgId+0x118>
    8e24:	785a      	ldrb	r2, [r3, #1]
    8e26:	2a26      	cmp	r2, #38	; 0x26
    8e28:	d104      	bne.n	8e34 <UnpackMsgId+0x118>
		{
            *member = ifc[mIndex] + 2;
    8e2a:	3302      	adds	r3, #2
    8e2c:	9a01      	ldr	r2, [sp, #4]
    8e2e:	6013      	str	r3, [r2, #0]
		else
		{
            *member = ifc[mIndex] + 1;
        }
    }
    return AJ_OK;
    8e30:	2300      	movs	r3, #0
	{
        // Skip over sessionless signal specifier if there is one

        if (MEMBER_TYPE(ifc[mIndex][0]) == SIGNAL && IS_SESSIONLESS(ifc[mIndex][1]))
		{
            *member = ifc[mIndex] + 2;
    8e32:	e005      	b.n	8e40 <UnpackMsgId+0x124>
        } 
		else
		{
            *member = ifc[mIndex] + 1;
    8e34:	3301      	adds	r3, #1
    8e36:	9a01      	ldr	r2, [sp, #4]
    8e38:	6013      	str	r3, [r2, #0]
        }
    }
    return AJ_OK;
    8e3a:	2300      	movs	r3, #0
    8e3c:	e000      	b.n	8e40 <UnpackMsgId+0x124>
    8e3e:	2300      	movs	r3, #0
}
    8e40:	1c18      	adds	r0, r3, #0
    8e42:	b004      	add	sp, #16
    8e44:	bc04      	pop	{r2}
    8e46:	4690      	mov	r8, r2
    8e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8e4a:	46c0      	nop			; (mov r8, r8)
    8e4c:	20000138 	.word	0x20000138
    8e50:	000082f9 	.word	0x000082f9
    8e54:	0001ca4c 	.word	0x0001ca4c
    8e58:	0000044b 	.word	0x0000044b
    8e5c:	0000636d 	.word	0x0000636d
    8e60:	0001cbd4 	.word	0x0001cbd4
    8e64:	00016f5d 	.word	0x00016f5d
    8e68:	00000451 	.word	0x00000451
    8e6c:	00000457 	.word	0x00000457
    8e70:	00008b31 	.word	0x00008b31

00008e74 <AJ_InitMessageFromMsgId>:
#ifndef NDEBUG
AJ_MutterHook MutterHook = NULL;
#endif

AJ_Status AJ_InitMessageFromMsgId(AJ_Message* msg, uint32_t msgId, uint8_t msgType, uint8_t* secure)
{
    8e74:	b570      	push	{r4, r5, r6, lr}
    8e76:	b084      	sub	sp, #16
    8e78:	1c04      	adds	r4, r0, #0
	{
        return MutterHook(msg, msgId, msgType);
    }
#endif
*/
    if (msgType == AJ_MSG_ERROR) 
    8e7a:	2a03      	cmp	r2, #3
    8e7c:	d10e      	bne.n	8e9c <AJ_InitMessageFromMsgId+0x28>
	{
        // The only thing to initialize for errors is the msgId
        msg->msgId = AJ_REPLY_ID(msgId);
    8e7e:	2280      	movs	r2, #128	; 0x80
    8e80:	0612      	lsls	r2, r2, #24
    8e82:	430a      	orrs	r2, r1
    8e84:	6002      	str	r2, [r0, #0]
     * size of the buffer dictates the maximum size signature we can marshal. The wire protocol
     * allows up to 255 characters in a signature but that would represent an outgrageously complex
     * message argument list.
     */
    static char msgSignature[32];
    AJ_Status status = AJ_OK;
    8e86:	2000      	movs	r0, #0
        msg->msgId = AJ_REPLY_ID(msgId);
        /*
               * Get the secure flag if we have a valid message id this will ensure that the error
               * response is encrypted if that is what is expected.
              */
        if (msg->msgId != AJ_INVALID_MSG_ID)
    8e88:	3201      	adds	r2, #1
    8e8a:	d045      	beq.n	8f18 <AJ_InitMessageFromMsgId+0xa4>
		{
            status = UnpackMsgId(msgId, NULL, NULL, NULL, secure);
    8e8c:	9300      	str	r3, [sp, #0]
    8e8e:	1c08      	adds	r0, r1, #0
    8e90:	2100      	movs	r1, #0
    8e92:	2200      	movs	r2, #0
    8e94:	2300      	movs	r3, #0
    8e96:	4c21      	ldr	r4, [pc, #132]	; (8f1c <AJ_InitMessageFromMsgId+0xa8>)
    8e98:	47a0      	blx	r4
    8e9a:	e03d      	b.n	8f18 <AJ_InitMessageFromMsgId+0xa4>
        }
    }
	else
	{
        const char* member = NULL;
    8e9c:	2000      	movs	r0, #0
    8e9e:	9003      	str	r0, [sp, #12]
        char direction = (msgType == AJ_MSG_METHOD_CALL) ? IN_ARG : OUT_ARG;
    8ea0:	2a01      	cmp	r2, #1
    8ea2:	d00f      	beq.n	8ec4 <AJ_InitMessageFromMsgId+0x50>
    8ea4:	253e      	movs	r5, #62	; 0x3e
        // The rest is just indexing into the object and interface descriptions.
        if (msgType == AJ_MSG_METHOD_RET)
    8ea6:	2a02      	cmp	r2, #2
    8ea8:	d10d      	bne.n	8ec6 <AJ_InitMessageFromMsgId+0x52>
		{
            msg->msgId = AJ_REPLY_ID(msgId);
    8eaa:	2280      	movs	r2, #128	; 0x80
    8eac:	0612      	lsls	r2, r2, #24
    8eae:	430a      	orrs	r2, r1
    8eb0:	6022      	str	r2, [r4, #0]
            status = UnpackMsgId(msgId, NULL, NULL, &member, secure);
    8eb2:	9300      	str	r3, [sp, #0]
    8eb4:	1c08      	adds	r0, r1, #0
    8eb6:	2100      	movs	r1, #0
    8eb8:	2200      	movs	r2, #0
    8eba:	ab03      	add	r3, sp, #12
    8ebc:	4d17      	ldr	r5, [pc, #92]	; (8f1c <AJ_InitMessageFromMsgId+0xa8>)
    8ebe:	47a8      	blx	r5
        }
    }
	else
	{
        const char* member = NULL;
        char direction = (msgType == AJ_MSG_METHOD_CALL) ? IN_ARG : OUT_ARG;
    8ec0:	253e      	movs	r5, #62	; 0x3e
    8ec2:	e01d      	b.n	8f00 <AJ_InitMessageFromMsgId+0x8c>
    8ec4:	253c      	movs	r5, #60	; 0x3c
            msg->msgId = AJ_REPLY_ID(msgId);
            status = UnpackMsgId(msgId, NULL, NULL, &member, secure);
        }
		else
		{
            msg->msgId = msgId;
    8ec6:	6021      	str	r1, [r4, #0]
            status = UnpackMsgId(msgId, &msg->objPath, &msg->iface, &member, secure);
    8ec8:	1c26      	adds	r6, r4, #0
    8eca:	3608      	adds	r6, #8
    8ecc:	1c22      	adds	r2, r4, #0
    8ece:	3210      	adds	r2, #16
    8ed0:	9300      	str	r3, [sp, #0]
    8ed2:	1c08      	adds	r0, r1, #0
    8ed4:	1c31      	adds	r1, r6, #0
    8ed6:	ab03      	add	r3, sp, #12
    8ed8:	4e10      	ldr	r6, [pc, #64]	; (8f1c <AJ_InitMessageFromMsgId+0xa8>)
    8eda:	47b0      	blx	r6
            if (status == AJ_OK)
    8edc:	2800      	cmp	r0, #0
    8ede:	d11b      	bne.n	8f18 <AJ_InitMessageFromMsgId+0xa4>
			{
                // Validate the object path
                if (!msg->objPath)
    8ee0:	68a3      	ldr	r3, [r4, #8]
    8ee2:	2b00      	cmp	r3, #0
    8ee4:	d009      	beq.n	8efa <AJ_InitMessageFromMsgId+0x86>
				{
                    status = AJ_ERR_OBJECT_PATH;
                }
				else 
				   if (*msg->objPath == '?')
    8ee6:	781b      	ldrb	r3, [r3, #0]
    8ee8:	2b3f      	cmp	r3, #63	; 0x3f
    8eea:	d102      	bne.n	8ef2 <AJ_InitMessageFromMsgId+0x7e>
                    /*
					 * The wildcard object path is a special for case methods implemented by all
					 * objects. In the message header need a valid object path, it doesn't matter
					 * which one by definition so use the root object because it is always valid.
					 */
                    msg->objPath = "/";
    8eec:	4b0c      	ldr	r3, [pc, #48]	; (8f20 <AJ_InitMessageFromMsgId+0xac>)
    8eee:	60a3      	str	r3, [r4, #8]
    8ef0:	e004      	b.n	8efc <AJ_InitMessageFromMsgId+0x88>
                } 
				else 
				   if (*msg->objPath != '/')
    8ef2:	2b2f      	cmp	r3, #47	; 0x2f
    8ef4:	d002      	beq.n	8efc <AJ_InitMessageFromMsgId+0x88>
				   {
                     status = AJ_ERR_OBJECT_PATH;
    8ef6:	2017      	movs	r0, #23
    8ef8:	e000      	b.n	8efc <AJ_InitMessageFromMsgId+0x88>
            if (status == AJ_OK)
			{
                // Validate the object path
                if (!msg->objPath)
				{
                    status = AJ_ERR_OBJECT_PATH;
    8efa:	2017      	movs	r0, #23
				else 
				   if (*msg->objPath != '/')
				   {
                     status = AJ_ERR_OBJECT_PATH;
                   }
                msg->member = member;
    8efc:	9b03      	ldr	r3, [sp, #12]
    8efe:	60e3      	str	r3, [r4, #12]
            }
        }
        // Compose the signature from information in the member encoding.
        if (status == AJ_OK)
    8f00:	2800      	cmp	r0, #0
    8f02:	d109      	bne.n	8f18 <AJ_InitMessageFromMsgId+0xa4>
		{
			//  
            status = ComposeSignature(member, direction, msgSignature, sizeof(msgSignature));
    8f04:	9803      	ldr	r0, [sp, #12]
    8f06:	1c29      	adds	r1, r5, #0
    8f08:	4a06      	ldr	r2, [pc, #24]	; (8f24 <AJ_InitMessageFromMsgId+0xb0>)
    8f0a:	2320      	movs	r3, #32
    8f0c:	4d06      	ldr	r5, [pc, #24]	; (8f28 <AJ_InitMessageFromMsgId+0xb4>)
    8f0e:	47a8      	blx	r5
            if (status == AJ_OK) 
    8f10:	2800      	cmp	r0, #0
    8f12:	d101      	bne.n	8f18 <AJ_InitMessageFromMsgId+0xa4>
			{
                msg->signature = msgSignature;
    8f14:	4b03      	ldr	r3, [pc, #12]	; (8f24 <AJ_InitMessageFromMsgId+0xb0>)
    8f16:	61e3      	str	r3, [r4, #28]
            }
        }
    }

    return status;
}
    8f18:	b004      	add	sp, #16
    8f1a:	bd70      	pop	{r4, r5, r6, pc}
    8f1c:	00008d1d 	.word	0x00008d1d
    8f20:	0001cc20 	.word	0x0001cc20
    8f24:	20000940 	.word	0x20000940
    8f28:	0000834d 	.word	0x0000834d

00008f2c <AJ_IdentifyMessage>:
Exit:
    return status;
}

AJ_Status AJ_IdentifyMessage(AJ_Message* msg)
{
    8f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8f2e:	b097      	sub	sp, #92	; 0x5c
    AJ_Status status = AJ_ERR_NO_MATCH;
    uint8_t secure = FALSE;
    8f30:	2200      	movs	r2, #0
    8f32:	234f      	movs	r3, #79	; 0x4f
    8f34:	a902      	add	r1, sp, #8
    8f36:	468c      	mov	ip, r1
    8f38:	4463      	add	r3, ip
    8f3a:	701a      	strb	r2, [r3, #0]
#ifndef NDEBUG
    if (MutterHook) 
    8f3c:	4b5c      	ldr	r3, [pc, #368]	; (90b0 <AJ_IdentifyMessage+0x184>)
    8f3e:	681a      	ldr	r2, [r3, #0]
	{
        return AJ_OK;
    8f40:	2300      	movs	r3, #0
AJ_Status AJ_IdentifyMessage(AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_NO_MATCH;
    uint8_t secure = FALSE;
#ifndef NDEBUG
    if (MutterHook) 
    8f42:	2a00      	cmp	r2, #0
    8f44:	d000      	beq.n	8f48 <AJ_IdentifyMessage+0x1c>
    8f46:	e0b0      	b.n	90aa <AJ_IdentifyMessage+0x17e>
    8f48:	1c05      	adds	r5, r0, #0
	{
        return AJ_OK;
    }
#endif
    msg->msgId = AJ_INVALID_MSG_ID;
    8f4a:	3b01      	subs	r3, #1
    8f4c:	6003      	str	r3, [r0, #0]
    if ((msg->hdr->msgType == AJ_MSG_METHOD_CALL) || (msg->hdr->msgType == AJ_MSG_SIGNAL)) 
    8f4e:	6843      	ldr	r3, [r0, #4]
    8f50:	785b      	ldrb	r3, [r3, #1]
    8f52:	2b01      	cmp	r3, #1
    8f54:	d001      	beq.n	8f5a <AJ_IdentifyMessage+0x2e>
    8f56:	2b04      	cmp	r3, #4
    8f58:	d136      	bne.n	8fc8 <AJ_IdentifyMessage+0x9c>
	{
        // Methods and signals
        status = AJ_LookupMessageId(msg, &secure);
    8f5a:	1c28      	adds	r0, r5, #0
    8f5c:	214f      	movs	r1, #79	; 0x4f
    8f5e:	ab02      	add	r3, sp, #8
    8f60:	469c      	mov	ip, r3
    8f62:	4461      	add	r1, ip
    8f64:	4b53      	ldr	r3, [pc, #332]	; (90b4 <AJ_IdentifyMessage+0x188>)
    8f66:	4798      	blx	r3
    8f68:	1e02      	subs	r2, r0, #0
        if ((status == AJ_OK) && secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
    8f6a:	d000      	beq.n	8f6e <AJ_IdentifyMessage+0x42>
    8f6c:	e093      	b.n	9096 <AJ_IdentifyMessage+0x16a>
    8f6e:	234f      	movs	r3, #79	; 0x4f
    8f70:	aa02      	add	r2, sp, #8
    8f72:	4694      	mov	ip, r2
    8f74:	4463      	add	r3, ip
    8f76:	781a      	ldrb	r2, [r3, #0]
    8f78:	2300      	movs	r3, #0
    8f7a:	2a00      	cmp	r2, #0
    8f7c:	d100      	bne.n	8f80 <AJ_IdentifyMessage+0x54>
    8f7e:	e094      	b.n	90aa <AJ_IdentifyMessage+0x17e>
    8f80:	686b      	ldr	r3, [r5, #4]
    8f82:	789a      	ldrb	r2, [r3, #2]
    8f84:	2300      	movs	r3, #0
    8f86:	2a7f      	cmp	r2, #127	; 0x7f
    8f88:	d900      	bls.n	8f8c <AJ_IdentifyMessage+0x60>
    8f8a:	e08e      	b.n	90aa <AJ_IdentifyMessage+0x17e>
		{
            AJ_ErrPrintf(("AJ_IdentifyMessage(): AJ_ERR_SECURITY\n"));
    8f8c:	2001      	movs	r0, #1
    8f8e:	494a      	ldr	r1, [pc, #296]	; (90b8 <AJ_IdentifyMessage+0x18c>)
    8f90:	4a4a      	ldr	r2, [pc, #296]	; (90bc <AJ_IdentifyMessage+0x190>)
    8f92:	4b4b      	ldr	r3, [pc, #300]	; (90c0 <AJ_IdentifyMessage+0x194>)
    8f94:	4798      	blx	r3
            status = AJ_ERR_SECURITY;
    8f96:	220d      	movs	r2, #13
	{
        // Methods and signals
        status = AJ_LookupMessageId(msg, &secure);
        if ((status == AJ_OK) && secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
		{
            AJ_ErrPrintf(("AJ_IdentifyMessage(): AJ_ERR_SECURITY\n"));
    8f98:	2800      	cmp	r0, #0
    8f9a:	d07c      	beq.n	9096 <AJ_IdentifyMessage+0x16a>
    8f9c:	4849      	ldr	r0, [pc, #292]	; (90c4 <AJ_IdentifyMessage+0x198>)
    8f9e:	4b4a      	ldr	r3, [pc, #296]	; (90c8 <AJ_IdentifyMessage+0x19c>)
    8fa0:	4798      	blx	r3
            status = AJ_ERR_SECURITY;
    8fa2:	220d      	movs	r2, #13
    8fa4:	e077      	b.n	9096 <AJ_IdentifyMessage+0x16a>
        }
        /*
               * Generate an error response for an invalid method call rather than reporting an invalid
               * message id to the application.
              */
        if ((status != AJ_OK) && (msg->hdr->msgType == AJ_MSG_METHOD_CALL) && !(msg->hdr->flags & AJ_FLAG_NO_REPLY_EXPECTED)) 
    8fa6:	7899      	ldrb	r1, [r3, #2]
    8fa8:	1c13      	adds	r3, r2, #0
    8faa:	07c9      	lsls	r1, r1, #31
    8fac:	d47d      	bmi.n	90aa <AJ_IdentifyMessage+0x17e>
		{
            AJ_Message reply;

            AJ_DumpMsg("Rejecting unidentified method call", msg, FALSE);
            AJ_MarshalStatusMsg(msg, &reply, status);
    8fae:	1c28      	adds	r0, r5, #0
    8fb0:	a905      	add	r1, sp, #20
    8fb2:	4b46      	ldr	r3, [pc, #280]	; (90cc <AJ_IdentifyMessage+0x1a0>)
    8fb4:	4798      	blx	r3
            status = AJ_DeliverMsg(&reply);
    8fb6:	a805      	add	r0, sp, #20
    8fb8:	4b45      	ldr	r3, [pc, #276]	; (90d0 <AJ_IdentifyMessage+0x1a4>)
    8fba:	4798      	blx	r3
    8fbc:	1c04      	adds	r4, r0, #0
            // Cleanup the message we are ignoring.
            AJ_CloseMsg(msg);
    8fbe:	1c28      	adds	r0, r5, #0
    8fc0:	4b44      	ldr	r3, [pc, #272]	; (90d4 <AJ_IdentifyMessage+0x1a8>)
    8fc2:	4798      	blx	r3
		{
            AJ_Message reply;

            AJ_DumpMsg("Rejecting unidentified method call", msg, FALSE);
            AJ_MarshalStatusMsg(msg, &reply, status);
            status = AJ_DeliverMsg(&reply);
    8fc4:	1c23      	adds	r3, r4, #0
    8fc6:	e070      	b.n	90aa <AJ_IdentifyMessage+0x17e>
            AJ_CloseMsg(msg);
        }
    } 
	else
	{
        ReplyContext* repCtx = FindReplyContext(msg->replySerial);
    8fc8:	6882      	ldr	r2, [r0, #8]
static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
	{
        if (replyContexts[i].serial == serial)
    8fca:	4b43      	ldr	r3, [pc, #268]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    8fcc:	68db      	ldr	r3, [r3, #12]
    8fce:	429a      	cmp	r2, r3
    8fd0:	d00c      	beq.n	8fec <AJ_IdentifyMessage+0xc0>
    8fd2:	4b41      	ldr	r3, [pc, #260]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    8fd4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    8fd6:	429a      	cmp	r2, r3
    8fd8:	d006      	beq.n	8fe8 <AJ_IdentifyMessage+0xbc>
    8fda:	4b3f      	ldr	r3, [pc, #252]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    8fdc:	6e59      	ldr	r1, [r3, #100]	; 0x64
    return status;
}

AJ_Status AJ_IdentifyMessage(AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_NO_MATCH;
    8fde:	2310      	movs	r3, #16
}

static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
    8fe0:	2602      	movs	r6, #2
	{
        if (replyContexts[i].serial == serial)
    8fe2:	428a      	cmp	r2, r1
    8fe4:	d003      	beq.n	8fee <AJ_IdentifyMessage+0xc2>
    8fe6:	e060      	b.n	90aa <AJ_IdentifyMessage+0x17e>
}

static ReplyContext* FindReplyContext(uint32_t serial) 
{
    size_t i;
    for (i = 0; i < ArraySize(replyContexts); ++i)
    8fe8:	2601      	movs	r6, #1
    8fea:	e000      	b.n	8fee <AJ_IdentifyMessage+0xc2>
    8fec:	2600      	movs	r6, #0
	else
	{
        ReplyContext* repCtx = FindReplyContext(msg->replySerial);
        if (repCtx) 
		{
            status = CheckReturnSignature(msg, repCtx->messageId);
    8fee:	232c      	movs	r3, #44	; 0x2c
    8ff0:	4373      	muls	r3, r6
    8ff2:	4a39      	ldr	r2, [pc, #228]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    8ff4:	18d3      	adds	r3, r2, r3
    8ff6:	691f      	ldr	r7, [r3, #16]
}

static AJ_Status CheckReturnSignature(AJ_Message* msg, uint32_t msgId)
{
    AJ_Status status;
    uint8_t secure = FALSE;
    8ff8:	230b      	movs	r3, #11
    8ffa:	aa02      	add	r2, sp, #8
    8ffc:	4694      	mov	ip, r2
    8ffe:	4463      	add	r3, ip
    9000:	2200      	movs	r2, #0
    9002:	701a      	strb	r2, [r3, #0]
    const char* member;

    status = UnpackMsgId(msgId, NULL, NULL, &member, &secure);
    9004:	9300      	str	r3, [sp, #0]
    9006:	1c38      	adds	r0, r7, #0
    9008:	2100      	movs	r1, #0
    900a:	ab05      	add	r3, sp, #20
    900c:	4c33      	ldr	r4, [pc, #204]	; (90dc <AJ_IdentifyMessage+0x1b0>)
    900e:	47a0      	blx	r4
    9010:	9003      	str	r0, [sp, #12]
    9012:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    9014:	d00e      	beq.n	9034 <AJ_IdentifyMessage+0x108>
	{
        AJ_ErrPrintf(("CheckReturnSignature(): status=%s\n", AJ_StatusText(status)));
    9016:	2001      	movs	r0, #1
    9018:	4927      	ldr	r1, [pc, #156]	; (90b8 <AJ_IdentifyMessage+0x18c>)
    901a:	4a31      	ldr	r2, [pc, #196]	; (90e0 <AJ_IdentifyMessage+0x1b4>)
    901c:	4b28      	ldr	r3, [pc, #160]	; (90c0 <AJ_IdentifyMessage+0x194>)
    901e:	4798      	blx	r3
    9020:	2800      	cmp	r0, #0
    9022:	d030      	beq.n	9086 <AJ_IdentifyMessage+0x15a>
    9024:	9803      	ldr	r0, [sp, #12]
    9026:	4b2f      	ldr	r3, [pc, #188]	; (90e4 <AJ_IdentifyMessage+0x1b8>)
    9028:	4798      	blx	r3
    902a:	1c01      	adds	r1, r0, #0
    902c:	482e      	ldr	r0, [pc, #184]	; (90e8 <AJ_IdentifyMessage+0x1bc>)
    902e:	4b2f      	ldr	r3, [pc, #188]	; (90ec <AJ_IdentifyMessage+0x1c0>)
    9030:	4798      	blx	r3
    9032:	e028      	b.n	9086 <AJ_IdentifyMessage+0x15a>
        return status;
    }
    // Check that if the interface was flagged secure that the reply was encrypted
    if (secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
    9034:	230b      	movs	r3, #11
    9036:	aa02      	add	r2, sp, #8
    9038:	4694      	mov	ip, r2
    903a:	4463      	add	r3, ip
    903c:	781b      	ldrb	r3, [r3, #0]
    903e:	2b00      	cmp	r3, #0
    9040:	d003      	beq.n	904a <AJ_IdentifyMessage+0x11e>
    9042:	686b      	ldr	r3, [r5, #4]
    9044:	789b      	ldrb	r3, [r3, #2]
    9046:	2b7f      	cmp	r3, #127	; 0x7f
    9048:	d92b      	bls.n	90a2 <AJ_IdentifyMessage+0x176>
	{
        return AJ_ERR_SECURITY;
    }
    // Nothing to check for error messages
    if (msg->hdr->msgType != AJ_MSG_ERROR) 
    904a:	686b      	ldr	r3, [r5, #4]
    904c:	785b      	ldrb	r3, [r3, #1]
    904e:	2b03      	cmp	r3, #3
    9050:	d005      	beq.n	905e <AJ_IdentifyMessage+0x132>
	{
        status = CheckSignature(member, msg);
    9052:	9805      	ldr	r0, [sp, #20]
    9054:	1c29      	adds	r1, r5, #0
    9056:	4b26      	ldr	r3, [pc, #152]	; (90f0 <AJ_IdentifyMessage+0x1c4>)
    9058:	4798      	blx	r3
    }
    if (status == AJ_OK) 
    905a:	2800      	cmp	r0, #0
    905c:	d123      	bne.n	90a6 <AJ_IdentifyMessage+0x17a>
	{
        msg->msgId = AJ_REPLY_ID(msgId);
    905e:	2380      	movs	r3, #128	; 0x80
    9060:	061b      	lsls	r3, r3, #24
    9062:	433b      	orrs	r3, r7
    9064:	602b      	str	r3, [r5, #0]
        ReplyContext* repCtx = FindReplyContext(msg->replySerial);
        if (repCtx) 
		{
            status = CheckReturnSignature(msg, repCtx->messageId);

            if (AJ_OK == status && (msg->hdr->flags & AJ_FLAG_ENCRYPTED))
    9066:	686b      	ldr	r3, [r5, #4]
    9068:	789b      	ldrb	r3, [r3, #2]
    906a:	2b7f      	cmp	r3, #127	; 0x7f
    906c:	d90b      	bls.n	9086 <AJ_IdentifyMessage+0x15a>
			{
                /* Make sure the authenticated sender was the expected recipient
                             * of the method call.
                            */
                if (0 != strncmp(msg->sender, repCtx->uniqueName, AJ_MAX_NAME_SIZE))
    906e:	6968      	ldr	r0, [r5, #20]
    9070:	212c      	movs	r1, #44	; 0x2c
    9072:	4371      	muls	r1, r6
    9074:	4b18      	ldr	r3, [pc, #96]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    9076:	1859      	adds	r1, r3, r1
    9078:	3114      	adds	r1, #20
    907a:	2214      	movs	r2, #20
    907c:	4b1d      	ldr	r3, [pc, #116]	; (90f4 <AJ_IdentifyMessage+0x1c8>)
    907e:	4798      	blx	r3
    9080:	2800      	cmp	r0, #0
    9082:	d000      	beq.n	9086 <AJ_IdentifyMessage+0x15a>
				{
                    status = AJ_ERR_NO_MATCH;
    9084:	2410      	movs	r4, #16
                }
            }
            // Release the reply context
            repCtx->serial = 0;
    9086:	232c      	movs	r3, #44	; 0x2c
    9088:	4373      	muls	r3, r6
    908a:	4a13      	ldr	r2, [pc, #76]	; (90d8 <AJ_IdentifyMessage+0x1ac>)
    908c:	18d3      	adds	r3, r2, r3
    908e:	2200      	movs	r2, #0
    9090:	60da      	str	r2, [r3, #12]
    9092:	1c23      	adds	r3, r4, #0
    9094:	e009      	b.n	90aa <AJ_IdentifyMessage+0x17e>
        }
        /*
               * Generate an error response for an invalid method call rather than reporting an invalid
               * message id to the application.
              */
        if ((status != AJ_OK) && (msg->hdr->msgType == AJ_MSG_METHOD_CALL) && !(msg->hdr->flags & AJ_FLAG_NO_REPLY_EXPECTED)) 
    9096:	686b      	ldr	r3, [r5, #4]
    9098:	7859      	ldrb	r1, [r3, #1]
    909a:	2901      	cmp	r1, #1
    909c:	d083      	beq.n	8fa6 <AJ_IdentifyMessage+0x7a>
    909e:	1c13      	adds	r3, r2, #0
    90a0:	e003      	b.n	90aa <AJ_IdentifyMessage+0x17e>
        return status;
    }
    // Check that if the interface was flagged secure that the reply was encrypted
    if (secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
	{
        return AJ_ERR_SECURITY;
    90a2:	240d      	movs	r4, #13
    90a4:	e7ef      	b.n	9086 <AJ_IdentifyMessage+0x15a>
    }
    // Nothing to check for error messages
    if (msg->hdr->msgType != AJ_MSG_ERROR) 
	{
        status = CheckSignature(member, msg);
    90a6:	1c04      	adds	r4, r0, #0
    90a8:	e7ed      	b.n	9086 <AJ_IdentifyMessage+0x15a>
            // Release the reply context
            repCtx->serial = 0;
        }
    }
    return status;
}
    90aa:	1c18      	adds	r0, r3, #0
    90ac:	b017      	add	sp, #92	; 0x5c
    90ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    90b0:	20000918 	.word	0x20000918
    90b4:	00008ba5 	.word	0x00008ba5
    90b8:	0001ca4c 	.word	0x0001ca4c
    90bc:	000005f1 	.word	0x000005f1
    90c0:	0000636d 	.word	0x0000636d
    90c4:	0001cc24 	.word	0x0001cc24
    90c8:	00016f5d 	.word	0x00016f5d
    90cc:	0000be65 	.word	0x0000be65
    90d0:	0000a539 	.word	0x0000a539
    90d4:	0000a77d 	.word	0x0000a77d
    90d8:	20000894 	.word	0x20000894
    90dc:	00008d1d 	.word	0x00008d1d
    90e0:	0000050c 	.word	0x0000050c
    90e4:	000063c5 	.word	0x000063c5
    90e8:	0001cc4c 	.word	0x0001cc4c
    90ec:	00016e3d 	.word	0x00016e3d
    90f0:	00008255 	.word	0x00008255
    90f4:	00017169 	.word	0x00017169

000090f8 <AJ_IdentifyProperty>:
    }
    return NULL;
}

AJ_Status AJ_IdentifyProperty(AJ_Message* msg, const char* iface, const char* prop, uint32_t* propId, const char** sigPtr, uint8_t* secure)
{
    90f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    90fa:	4647      	mov	r7, r8
    90fc:	b480      	push	{r7}
    90fe:	b086      	sub	sp, #24
    9100:	1c05      	adds	r5, r0, #0
    9102:	1c0f      	adds	r7, r1, #0
    9104:	9202      	str	r2, [sp, #8]
    9106:	9301      	str	r3, [sp, #4]
    AJ_Status status = AJ_OK;
    uint8_t oIndex = (msg->msgId >> 24);
    9108:	6804      	ldr	r4, [r0, #0]
    910a:	0e26      	lsrs	r6, r4, #24
    uint8_t iIndex;
    const AJ_Object* obj;
    AJ_InterfaceDescription desc;

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object))) 
    910c:	b2f3      	uxtb	r3, r6
    910e:	2b08      	cmp	r3, #8
    9110:	d809      	bhi.n	9126 <AJ_IdentifyProperty+0x2e>

AJ_Status AJ_IdentifyProperty(AJ_Message* msg, const char* iface, const char* prop, uint32_t* propId, const char** sigPtr, uint8_t* secure)
{
    AJ_Status status = AJ_OK;
    uint8_t oIndex = (msg->msgId >> 24);
    uint8_t pIndex = (msg->msgId >> 16);
    9112:	0c24      	lsrs	r4, r4, #16
    uint8_t iIndex;
    const AJ_Object* obj;
    AJ_InterfaceDescription desc;

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object))) 
    9114:	00b3      	lsls	r3, r6, #2
    9116:	4a58      	ldr	r2, [pc, #352]	; (9278 <AJ_IdentifyProperty+0x180>)
    9118:	5898      	ldr	r0, [r3, r2]
    911a:	b2e1      	uxtb	r1, r4
    911c:	2210      	movs	r2, #16
    911e:	4b57      	ldr	r3, [pc, #348]	; (927c <AJ_IdentifyProperty+0x184>)
    9120:	4798      	blx	r3
    9122:	2800      	cmp	r0, #0
    9124:	d111      	bne.n	914a <AJ_IdentifyProperty+0x52>
	{
        status = AJ_ERR_INVALID;
        AJ_ErrPrintf(("AJ_IdentifyProperty(): %s\n", AJ_StatusText(status)));
    9126:	2001      	movs	r0, #1
    9128:	4955      	ldr	r1, [pc, #340]	; (9280 <AJ_IdentifyProperty+0x188>)
    912a:	4a56      	ldr	r2, [pc, #344]	; (9284 <AJ_IdentifyProperty+0x18c>)
    912c:	4b56      	ldr	r3, [pc, #344]	; (9288 <AJ_IdentifyProperty+0x190>)
    912e:	4798      	blx	r3
        return status;
    9130:	2303      	movs	r3, #3

#ifndef NDEBUG
    if ((oIndex >= ArraySize(objectLists)) || !CheckIndex(objectLists[oIndex], pIndex, sizeof(AJ_Object))) 
	{
        status = AJ_ERR_INVALID;
        AJ_ErrPrintf(("AJ_IdentifyProperty(): %s\n", AJ_StatusText(status)));
    9132:	2800      	cmp	r0, #0
    9134:	d100      	bne.n	9138 <AJ_IdentifyProperty+0x40>
    9136:	e099      	b.n	926c <AJ_IdentifyProperty+0x174>
    9138:	2003      	movs	r0, #3
    913a:	4b54      	ldr	r3, [pc, #336]	; (928c <AJ_IdentifyProperty+0x194>)
    913c:	4798      	blx	r3
    913e:	1c01      	adds	r1, r0, #0
    9140:	4853      	ldr	r0, [pc, #332]	; (9290 <AJ_IdentifyProperty+0x198>)
    9142:	4b54      	ldr	r3, [pc, #336]	; (9294 <AJ_IdentifyProperty+0x19c>)
    9144:	4798      	blx	r3
        return status;
    9146:	2303      	movs	r3, #3
    9148:	e090      	b.n	926c <AJ_IdentifyProperty+0x174>
    }
#endif
    obj = &objectLists[oIndex][pIndex];
    914a:	23ff      	movs	r3, #255	; 0xff
    914c:	4023      	ands	r3, r4
    914e:	4698      	mov	r8, r3
    9150:	00b3      	lsls	r3, r6, #2
    9152:	4642      	mov	r2, r8
    9154:	0112      	lsls	r2, r2, #4
    9156:	4948      	ldr	r1, [pc, #288]	; (9278 <AJ_IdentifyProperty+0x180>)
    9158:	585b      	ldr	r3, [r3, r1]
    915a:	189c      	adds	r4, r3, r2

    *propId = AJ_INVALID_PROP_ID;
    915c:	2301      	movs	r3, #1
    915e:	425b      	negs	r3, r3
    9160:	9a01      	ldr	r2, [sp, #4]
    9162:	6013      	str	r3, [r2, #0]

    desc = FindInterface(obj->interfaces, iface, &iIndex);
    9164:	6860      	ldr	r0, [r4, #4]
    9166:	1c39      	adds	r1, r7, #0
    9168:	ab04      	add	r3, sp, #16
    916a:	1dda      	adds	r2, r3, #7
    916c:	4b4a      	ldr	r3, [pc, #296]	; (9298 <AJ_IdentifyProperty+0x1a0>)
    916e:	4798      	blx	r3
    9170:	1e07      	subs	r7, r0, #0
    if (desc) 
    9172:	d077      	beq.n	9264 <AJ_IdentifyProperty+0x16c>
	{
        uint8_t mIndex = 0;
        // Security is based on the interface the property is defined on.
        *secure = SecurityApplies(*desc, obj);
    9174:	6800      	ldr	r0, [r0, #0]
    9176:	1c21      	adds	r1, r4, #0
    9178:	4b48      	ldr	r3, [pc, #288]	; (929c <AJ_IdentifyProperty+0x1a4>)
    917a:	4798      	blx	r3
    917c:	b2c0      	uxtb	r0, r0
    917e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    9180:	7018      	strb	r0, [r3, #0]
        if (*secure == FALSE)
    9182:	2800      	cmp	r0, #0
    9184:	d005      	beq.n	9192 <AJ_IdentifyProperty+0x9a>
                AJ_ErrPrintf(("AJ_IdentifyProperty(): %s\n", AJ_StatusText(status)));
                return status;
            }
        }
        // Iterate over the interface members to locate the property that is being accessed.
        while (*(++desc))
    9186:	1d3c      	adds	r4, r7, #4
    9188:	687b      	ldr	r3, [r7, #4]
    918a:	2700      	movs	r7, #0
    918c:	2b00      	cmp	r3, #0
    918e:	d12d      	bne.n	91ec <AJ_IdentifyProperty+0xf4>
    9190:	e06c      	b.n	926c <AJ_IdentifyProperty+0x174>
        // Security is based on the interface the property is defined on.
        *secure = SecurityApplies(*desc, obj);
        if (*secure == FALSE)
		{
            // For Properties interface security is based on the interface supplied
            if (strcmp(*desc, AJ_PropertiesIface[0]) == 0) 
    9192:	4b43      	ldr	r3, [pc, #268]	; (92a0 <AJ_IdentifyProperty+0x1a8>)
    9194:	6819      	ldr	r1, [r3, #0]
    9196:	6838      	ldr	r0, [r7, #0]
    9198:	4b42      	ldr	r3, [pc, #264]	; (92a4 <AJ_IdentifyProperty+0x1ac>)
    919a:	4798      	blx	r3
    919c:	2800      	cmp	r0, #0
    919e:	d1f2      	bne.n	9186 <AJ_IdentifyProperty+0x8e>
			{
                const char* actualIface;
                status = AJ_UnmarshalArgs(msg, "s", &actualIface);
    91a0:	1c28      	adds	r0, r5, #0
    91a2:	4941      	ldr	r1, [pc, #260]	; (92a8 <AJ_IdentifyProperty+0x1b0>)
    91a4:	aa04      	add	r2, sp, #16
    91a6:	4b41      	ldr	r3, [pc, #260]	; (92ac <AJ_IdentifyProperty+0x1b4>)
    91a8:	4798      	blx	r3
    91aa:	9003      	str	r0, [sp, #12]
                if (status == AJ_OK) 
    91ac:	2800      	cmp	r0, #0
    91ae:	d10b      	bne.n	91c8 <AJ_IdentifyProperty+0xd0>
				{
                    *secure = SecurityApplies(actualIface, obj);
    91b0:	9804      	ldr	r0, [sp, #16]
    91b2:	1c21      	adds	r1, r4, #0
    91b4:	4b39      	ldr	r3, [pc, #228]	; (929c <AJ_IdentifyProperty+0x1a4>)
    91b6:	4798      	blx	r3
    91b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    91ba:	7018      	strb	r0, [r3, #0]
                    status = AJ_ResetArgs(msg);
    91bc:	1c28      	adds	r0, r5, #0
    91be:	4b3c      	ldr	r3, [pc, #240]	; (92b0 <AJ_IdentifyProperty+0x1b8>)
    91c0:	4798      	blx	r3
    91c2:	9003      	str	r0, [sp, #12]
                }
            }
            if (status != AJ_OK) 
    91c4:	2800      	cmp	r0, #0
    91c6:	d0de      	beq.n	9186 <AJ_IdentifyProperty+0x8e>
			{
                AJ_ErrPrintf(("AJ_IdentifyProperty(): %s\n", AJ_StatusText(status)));
    91c8:	2001      	movs	r0, #1
    91ca:	492d      	ldr	r1, [pc, #180]	; (9280 <AJ_IdentifyProperty+0x188>)
    91cc:	4a39      	ldr	r2, [pc, #228]	; (92b4 <AJ_IdentifyProperty+0x1bc>)
    91ce:	4b2e      	ldr	r3, [pc, #184]	; (9288 <AJ_IdentifyProperty+0x190>)
    91d0:	4798      	blx	r3
    91d2:	9b03      	ldr	r3, [sp, #12]
    91d4:	2800      	cmp	r0, #0
    91d6:	d049      	beq.n	926c <AJ_IdentifyProperty+0x174>
    91d8:	1c1c      	adds	r4, r3, #0
    91da:	1c18      	adds	r0, r3, #0
    91dc:	4b2b      	ldr	r3, [pc, #172]	; (928c <AJ_IdentifyProperty+0x194>)
    91de:	4798      	blx	r3
    91e0:	1c01      	adds	r1, r0, #0
    91e2:	482b      	ldr	r0, [pc, #172]	; (9290 <AJ_IdentifyProperty+0x198>)
    91e4:	4b2b      	ldr	r3, [pc, #172]	; (9294 <AJ_IdentifyProperty+0x19c>)
    91e6:	4798      	blx	r3
    91e8:	1c23      	adds	r3, r4, #0
    91ea:	e03f      	b.n	926c <AJ_IdentifyProperty+0x174>
            }
        }
        // Iterate over the interface members to locate the property that is being accessed.
        while (*(++desc))
		{
            status = MatchProp(*desc, prop, msg->msgId & 0xFF, sigPtr);
    91ec:	682a      	ldr	r2, [r5, #0]
    91ee:	4694      	mov	ip, r2

static AJ_Status MatchProp(const char* member, const char* prop, uint8_t op, const char** sig)
{
    const char* encoding = member;

    if (*encoding++ != '@') 
    91f0:	781a      	ldrb	r2, [r3, #0]
    91f2:	2a40      	cmp	r2, #64	; 0x40
    91f4:	d12e      	bne.n	9254 <AJ_IdentifyProperty+0x15c>
    91f6:	3301      	adds	r3, #1
    91f8:	9a02      	ldr	r2, [sp, #8]
    91fa:	e004      	b.n	9206 <AJ_IdentifyProperty+0x10e>
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
    while (*prop) 
	{
        if (*encoding++ != *prop++) 
    91fc:	3201      	adds	r2, #1
    91fe:	3301      	adds	r3, #1
    9200:	7800      	ldrb	r0, [r0, #0]
    9202:	4288      	cmp	r0, r1
    9204:	d126      	bne.n	9254 <AJ_IdentifyProperty+0x15c>
    9206:	1c18      	adds	r0, r3, #0
    if (*encoding++ != '@') 
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_NO_MATCH\n"));
        return AJ_ERR_NO_MATCH;
    }
    while (*prop) 
    9208:	7811      	ldrb	r1, [r2, #0]
    920a:	2900      	cmp	r1, #0
    920c:	d1f6      	bne.n	91fc <AJ_IdentifyProperty+0x104>
            }
        }
        // Iterate over the interface members to locate the property that is being accessed.
        while (*(++desc))
		{
            status = MatchProp(*desc, prop, msg->msgId & 0xFF, sigPtr);
    920e:	4663      	mov	r3, ip
    9210:	466a      	mov	r2, sp
    9212:	7213      	strb	r3, [r2, #8]
    9214:	7a13      	ldrb	r3, [r2, #8]
		{
            AJ_InfoPrintf(("MatchProp(): AJ_ERR_NO_MATCH\n"));
            return AJ_ERR_NO_MATCH;
        }
    }
    if ((op == AJ_PROP_GET) && (*encoding == WRITE_ONLY)) 
    9216:	2b00      	cmp	r3, #0
    9218:	d104      	bne.n	9224 <AJ_IdentifyProperty+0x12c>
    921a:	7802      	ldrb	r2, [r0, #0]
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_DISALLOWED\n"));
        return AJ_ERR_DISALLOWED;
    921c:	3312      	adds	r3, #18
		{
            AJ_InfoPrintf(("MatchProp(): AJ_ERR_NO_MATCH\n"));
            return AJ_ERR_NO_MATCH;
        }
    }
    if ((op == AJ_PROP_GET) && (*encoding == WRITE_ONLY)) 
    921e:	2a3c      	cmp	r2, #60	; 0x3c
    9220:	d106      	bne.n	9230 <AJ_IdentifyProperty+0x138>
    9222:	e021      	b.n	9268 <AJ_IdentifyProperty+0x170>
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_DISALLOWED\n"));
        return AJ_ERR_DISALLOWED;
    }
    if ((op == AJ_PROP_SET) && (*encoding == READ_ONLY)) 
    9224:	2b01      	cmp	r3, #1
    9226:	d103      	bne.n	9230 <AJ_IdentifyProperty+0x138>
    9228:	7802      	ldrb	r2, [r0, #0]
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_DISALLOWED\n"));
        return AJ_ERR_DISALLOWED;
    922a:	3311      	adds	r3, #17
    if ((op == AJ_PROP_GET) && (*encoding == WRITE_ONLY)) 
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_DISALLOWED\n"));
        return AJ_ERR_DISALLOWED;
    }
    if ((op == AJ_PROP_SET) && (*encoding == READ_ONLY)) 
    922c:	2a3e      	cmp	r2, #62	; 0x3e
    922e:	d01b      	beq.n	9268 <AJ_IdentifyProperty+0x170>
	{
        AJ_InfoPrintf(("MatchProp(): AJ_ERR_DISALLOWED\n"));
        return AJ_ERR_DISALLOWED;
    }
    *sig = ++encoding;
    9230:	1c43      	adds	r3, r0, #1
    9232:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9234:	6013      	str	r3, [r2, #0]
    return AJ_OK;
    9236:	2300      	movs	r3, #0
    9238:	e016      	b.n	9268 <AJ_IdentifyProperty+0x170>
            status = MatchProp(*desc, prop, msg->msgId & 0xFF, sigPtr);
            if (status != AJ_ERR_NO_MATCH)
			{
                if (status == AJ_OK) 
				{
                    *propId = (oIndex << 24) | (pIndex << 16) | (iIndex << 8) | mIndex;
    923a:	0631      	lsls	r1, r6, #24
    923c:	aa04      	add	r2, sp, #16
    923e:	3207      	adds	r2, #7
    9240:	7812      	ldrb	r2, [r2, #0]
    9242:	0212      	lsls	r2, r2, #8
    9244:	430a      	orrs	r2, r1
    9246:	4641      	mov	r1, r8
    9248:	040c      	lsls	r4, r1, #16
    924a:	4314      	orrs	r4, r2
    924c:	4327      	orrs	r7, r4
    924e:	9a01      	ldr	r2, [sp, #4]
    9250:	6017      	str	r7, [r2, #0]
    9252:	e00b      	b.n	926c <AJ_IdentifyProperty+0x174>
                    AJ_InfoPrintf(("Identified property %s:%s id=%x sig=\"%s\"\n", iface, prop, *propId, *sigPtr));
                }
                break;
            }
            ++mIndex;
    9254:	3701      	adds	r7, #1
    9256:	b2ff      	uxtb	r7, r7
                AJ_ErrPrintf(("AJ_IdentifyProperty(): %s\n", AJ_StatusText(status)));
                return status;
            }
        }
        // Iterate over the interface members to locate the property that is being accessed.
        while (*(++desc))
    9258:	3404      	adds	r4, #4
    925a:	6823      	ldr	r3, [r4, #0]
    925c:	2b00      	cmp	r3, #0
    925e:	d1c5      	bne.n	91ec <AJ_IdentifyProperty+0xf4>
		{
            status = MatchProp(*desc, prop, msg->msgId & 0xFF, sigPtr);
    9260:	3310      	adds	r3, #16
    9262:	e003      	b.n	926c <AJ_IdentifyProperty+0x174>
    return NULL;
}

AJ_Status AJ_IdentifyProperty(AJ_Message* msg, const char* iface, const char* prop, uint32_t* propId, const char** sigPtr, uint8_t* secure)
{
    AJ_Status status = AJ_OK;
    9264:	2300      	movs	r3, #0
    9266:	e001      	b.n	926c <AJ_IdentifyProperty+0x174>
        while (*(++desc))
		{
            status = MatchProp(*desc, prop, msg->msgId & 0xFF, sigPtr);
            if (status != AJ_ERR_NO_MATCH)
			{
                if (status == AJ_OK) 
    9268:	2b00      	cmp	r3, #0
    926a:	d0e6      	beq.n	923a <AJ_IdentifyProperty+0x142>
            }
            ++mIndex;
        }
    }
    return status;
}
    926c:	1c18      	adds	r0, r3, #0
    926e:	b006      	add	sp, #24
    9270:	bc04      	pop	{r2}
    9272:	4690      	mov	r8, r2
    9274:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9276:	46c0      	nop			; (mov r8, r8)
    9278:	20000138 	.word	0x20000138
    927c:	000082f9 	.word	0x000082f9
    9280:	0001ca4c 	.word	0x0001ca4c
    9284:	0000053a 	.word	0x0000053a
    9288:	0000636d 	.word	0x0000636d
    928c:	000063c5 	.word	0x000063c5
    9290:	0001cc70 	.word	0x0001cc70
    9294:	00016e3d 	.word	0x00016e3d
    9298:	000081e5 	.word	0x000081e5
    929c:	00008b31 	.word	0x00008b31
    92a0:	0001e8d4 	.word	0x0001e8d4
    92a4:	00017137 	.word	0x00017137
    92a8:	0001f054 	.word	0x0001f054
    92ac:	0000b5f5 	.word	0x0000b5f5
    92b0:	0000abd5 	.word	0x0000abd5
    92b4:	00000557 	.word	0x00000557

000092b8 <AJ_UnmarshalPropertyArgs>:

AJ_Status AJ_UnmarshalPropertyArgs(AJ_Message* msg, uint32_t* propId, const char** sig)
{
    92b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    92ba:	b087      	sub	sp, #28
    92bc:	1c04      	adds	r4, r0, #0
    92be:	1c0d      	adds	r5, r1, #0
    92c0:	1c16      	adds	r6, r2, #0
    AJ_Status status;
    uint8_t secure = FALSE;
    92c2:	2200      	movs	r2, #0
    92c4:	2317      	movs	r3, #23
    92c6:	446b      	add	r3, sp
    92c8:	701a      	strb	r2, [r3, #0]
    char* iface;
    char* prop;

    status = AJ_UnmarshalArgs(msg, "ss", &iface, &prop);
    92ca:	4915      	ldr	r1, [pc, #84]	; (9320 <AJ_UnmarshalPropertyArgs+0x68>)
    92cc:	aa04      	add	r2, sp, #16
    92ce:	ab03      	add	r3, sp, #12
    92d0:	4f14      	ldr	r7, [pc, #80]	; (9324 <AJ_UnmarshalPropertyArgs+0x6c>)
    92d2:	47b8      	blx	r7
    if (status == AJ_OK) 
    92d4:	2800      	cmp	r0, #0
    92d6:	d121      	bne.n	931c <AJ_UnmarshalPropertyArgs+0x64>
	{
        status = AJ_IdentifyProperty(msg, iface, prop, propId, sig, &secure);
    92d8:	9600      	str	r6, [sp, #0]
    92da:	2317      	movs	r3, #23
    92dc:	446b      	add	r3, sp
    92de:	9301      	str	r3, [sp, #4]
    92e0:	1c20      	adds	r0, r4, #0
    92e2:	9904      	ldr	r1, [sp, #16]
    92e4:	9a03      	ldr	r2, [sp, #12]
    92e6:	1c2b      	adds	r3, r5, #0
    92e8:	4d0f      	ldr	r5, [pc, #60]	; (9328 <AJ_UnmarshalPropertyArgs+0x70>)
    92ea:	47a8      	blx	r5
        //If the interface is secure check the message must be encrypted

        if ((status == AJ_OK) && secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
    92ec:	2800      	cmp	r0, #0
    92ee:	d115      	bne.n	931c <AJ_UnmarshalPropertyArgs+0x64>
    92f0:	2317      	movs	r3, #23
    92f2:	446b      	add	r3, sp
    92f4:	781b      	ldrb	r3, [r3, #0]
    92f6:	2b00      	cmp	r3, #0
    92f8:	d010      	beq.n	931c <AJ_UnmarshalPropertyArgs+0x64>
    92fa:	6863      	ldr	r3, [r4, #4]
    92fc:	789b      	ldrb	r3, [r3, #2]
    92fe:	2b7f      	cmp	r3, #127	; 0x7f
    9300:	d80c      	bhi.n	931c <AJ_UnmarshalPropertyArgs+0x64>
		{
            status = AJ_ERR_SECURITY;
            AJ_WarnPrintf(("Security violation accessing property\n"));
    9302:	3002      	adds	r0, #2
    9304:	4909      	ldr	r1, [pc, #36]	; (932c <AJ_UnmarshalPropertyArgs+0x74>)
    9306:	4a0a      	ldr	r2, [pc, #40]	; (9330 <AJ_UnmarshalPropertyArgs+0x78>)
    9308:	4b0a      	ldr	r3, [pc, #40]	; (9334 <AJ_UnmarshalPropertyArgs+0x7c>)
    930a:	4798      	blx	r3
    930c:	1c03      	adds	r3, r0, #0
        status = AJ_IdentifyProperty(msg, iface, prop, propId, sig, &secure);
        //If the interface is secure check the message must be encrypted

        if ((status == AJ_OK) && secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
		{
            status = AJ_ERR_SECURITY;
    930e:	200d      	movs	r0, #13
            AJ_WarnPrintf(("Security violation accessing property\n"));
    9310:	2b00      	cmp	r3, #0
    9312:	d003      	beq.n	931c <AJ_UnmarshalPropertyArgs+0x64>
    9314:	4808      	ldr	r0, [pc, #32]	; (9338 <AJ_UnmarshalPropertyArgs+0x80>)
    9316:	4b09      	ldr	r3, [pc, #36]	; (933c <AJ_UnmarshalPropertyArgs+0x84>)
    9318:	4798      	blx	r3
        status = AJ_IdentifyProperty(msg, iface, prop, propId, sig, &secure);
        //If the interface is secure check the message must be encrypted

        if ((status == AJ_OK) && secure && !(msg->hdr->flags & AJ_FLAG_ENCRYPTED)) 
		{
            status = AJ_ERR_SECURITY;
    931a:	200d      	movs	r0, #13
            AJ_WarnPrintf(("Security violation accessing property\n"));
        }
    }
    return status;
}
    931c:	b007      	add	sp, #28
    931e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9320:	00018490 	.word	0x00018490
    9324:	0000b5f5 	.word	0x0000b5f5
    9328:	000090f9 	.word	0x000090f9
    932c:	0001ca4c 	.word	0x0001ca4c
    9330:	0000057e 	.word	0x0000057e
    9334:	0000636d 	.word	0x0000636d
    9338:	0001cc8c 	.word	0x0001cc8c
    933c:	00016f5d 	.word	0x00016f5d

00009340 <GenXML>:
    }
    return FALSE;
}

static AJ_Status GenXML(XMLWriterFunc XMLWriter, void* context, const AJ_ObjectIterator* objIter, const AJ_Object* virtualObject, const char* languageTag)
{
    9340:	b5f0      	push	{r4, r5, r6, r7, lr}
    9342:	465f      	mov	r7, fp
    9344:	4656      	mov	r6, sl
    9346:	464d      	mov	r5, r9
    9348:	4644      	mov	r4, r8
    934a:	b4f0      	push	{r4, r5, r6, r7}
    934c:	b091      	sub	sp, #68	; 0x44
    934e:	9008      	str	r0, [sp, #32]
    9350:	9107      	str	r1, [sp, #28]
    9352:	1c15      	adds	r5, r2, #0
    9354:	1c1f      	adds	r7, r3, #0
    AJ_Status status = AJ_OK;
    const AJ_Object* obj;
    AJ_DescriptionLookupFunc descLookup = NULL;
    printf("Gen XML started\n");
    9356:	48a7      	ldr	r0, [pc, #668]	; (95f4 <GenXML+0x2b4>)
    9358:	4ba7      	ldr	r3, [pc, #668]	; (95f8 <GenXML+0x2b8>)
    935a:	4798      	blx	r3
    if (objIter == NULL)
    935c:	2d00      	cmp	r5, #0
    935e:	d00e      	beq.n	937e <GenXML+0x3e>
        obj = virtualObject;
    } 
	else
	 {
	//	 printf("Gen XML: objIter != NULL\n");
        if (objIter->l >= ArraySize(objectLists) && virtualObject == NULL) 
    9360:	78ab      	ldrb	r3, [r5, #2]
    9362:	2b08      	cmp	r3, #8
    9364:	d902      	bls.n	936c <GenXML+0x2c>
    9366:	2f00      	cmp	r7, #0
    9368:	d100      	bne.n	936c <GenXML+0x2c>
    936a:	e12e      	b.n	95ca <GenXML+0x28a>
		{
	//		printf("Gen XML: objIter != NULL  return AJ_OK\n");
            return AJ_OK;
        }
        obj = &(objectLists[objIter->l][objIter->n - 1]);
    936c:	009a      	lsls	r2, r3, #2
    936e:	88ab      	ldrh	r3, [r5, #4]
    9370:	49a2      	ldr	r1, [pc, #648]	; (95fc <GenXML+0x2bc>)
    9372:	468c      	mov	ip, r1
    9374:	4463      	add	r3, ip
    9376:	011b      	lsls	r3, r3, #4
    9378:	49a1      	ldr	r1, [pc, #644]	; (9600 <GenXML+0x2c0>)
    937a:	5852      	ldr	r2, [r2, r1]
    937c:	18d7      	adds	r7, r2, r3
    }
    if (obj != NULL && obj->path != NULL) 
    937e:	2f00      	cmp	r7, #0
    9380:	d100      	bne.n	9384 <GenXML+0x44>
    9382:	e124      	b.n	95ce <GenXML+0x28e>
    9384:	683b      	ldr	r3, [r7, #0]
    9386:	2b00      	cmp	r3, #0
    9388:	d100      	bne.n	938c <GenXML+0x4c>
    938a:	e122      	b.n	95d2 <GenXML+0x292>
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    iter->fin = inFlags;
    938c:	a80c      	add	r0, sp, #48	; 0x30
    938e:	23ff      	movs	r3, #255	; 0xff
    9390:	7003      	strb	r3, [r0, #0]
    iter->fex = exFlags;
    9392:	3be9      	subs	r3, #233	; 0xe9
    9394:	7043      	strb	r3, [r0, #1]
    iter->l = 0;
    9396:	2300      	movs	r3, #0
    9398:	7083      	strb	r3, [r0, #2]
    iter->n = 0;
    939a:	8083      	strh	r3, [r0, #4]
    return AJ_NextObject(iter);
    939c:	4b99      	ldr	r3, [pc, #612]	; (9604 <GenXML+0x2c4>)
    939e:	4798      	blx	r3
    93a0:	4681      	mov	r9, r0
        AJ_ObjectIterator childObjectIter;
        const AJ_Object* childObj = AJ_InitObjectIterator(&childObjectIter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
        const char* description = NULL;

        // Ignore objects that are hidden or disabled or proxy
        if (obj->flags & (AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK)) 
    93a2:	7a3b      	ldrb	r3, [r7, #8]
    93a4:	2216      	movs	r2, #22
		{
		//	printf("Gen XML:  if (obj != NULL && obj->path != NULL)  return AJ_OK \n");
            return AJ_OK;
    93a6:	2000      	movs	r0, #0
        AJ_ObjectIterator childObjectIter;
        const AJ_Object* childObj = AJ_InitObjectIterator(&childObjectIter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
        const char* description = NULL;

        // Ignore objects that are hidden or disabled or proxy
        if (obj->flags & (AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK)) 
    93a8:	421a      	tst	r2, r3
    93aa:	d000      	beq.n	93ae <GenXML+0x6e>
    93ac:	e11b      	b.n	95e6 <GenXML+0x2a6>
		{
		//	printf("Gen XML:  if (obj != NULL && obj->path != NULL)  return AJ_OK \n");
            return AJ_OK;
        }
        // Find matching description lookup function. NULL indicates no descriptions
        if (languageTag != NULL) 
    93ae:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    93b0:	2b00      	cmp	r3, #0
    93b2:	d017      	beq.n	93e4 <GenXML+0xa4>
		{
		//	printf("Gen XML:  languageTag != NULL \n");
            if (objIter != NULL) 
    93b4:	2d00      	cmp	r5, #0
    93b6:	d015      	beq.n	93e4 <GenXML+0xa4>
			{
		//		printf("Gen XML:  languageTag != NULL  if (objIter != NULL) \n");
                descLookup = descriptionLookups[objIter->l];
    93b8:	78ab      	ldrb	r3, [r5, #2]
    93ba:	009b      	lsls	r3, r3, #2
    93bc:	4a92      	ldr	r2, [pc, #584]	; (9608 <GenXML+0x2c8>)
    93be:	589c      	ldr	r4, [r3, r2]
            }
        }
        // Generate object's XML
	//	printf("Gen XML:   XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, obj->path, 0, FALSE) \n");
        XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, obj->path, 0, FALSE);
    93c0:	683b      	ldr	r3, [r7, #0]
    93c2:	9300      	str	r3, [sp, #0]
    93c4:	2300      	movs	r3, #0
    93c6:	9301      	str	r3, [sp, #4]
    93c8:	9302      	str	r3, [sp, #8]
    93ca:	9808      	ldr	r0, [sp, #32]
    93cc:	9907      	ldr	r1, [sp, #28]
    93ce:	4a8f      	ldr	r2, [pc, #572]	; (960c <GenXML+0x2cc>)
    93d0:	4b8f      	ldr	r3, [pc, #572]	; (9610 <GenXML+0x2d0>)
    93d2:	4e90      	ldr	r6, [pc, #576]	; (9614 <GenXML+0x2d4>)
    93d4:	47b0      	blx	r6
        if (SecurityApplies(NULL, obj))
    93d6:	2000      	movs	r0, #0
    93d8:	1c39      	adds	r1, r7, #0
    93da:	4b8f      	ldr	r3, [pc, #572]	; (9618 <GenXML+0x2d8>)
    93dc:	4798      	blx	r3
    93de:	2800      	cmp	r0, #0
    93e0:	d01d      	beq.n	941e <GenXML+0xde>
    93e2:	e011      	b.n	9408 <GenXML+0xc8>
                descLookup = descriptionLookups[objIter->l];
            }
        }
        // Generate object's XML
	//	printf("Gen XML:   XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, obj->path, 0, FALSE) \n");
        XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, obj->path, 0, FALSE);
    93e4:	683b      	ldr	r3, [r7, #0]
    93e6:	9300      	str	r3, [sp, #0]
    93e8:	2300      	movs	r3, #0
    93ea:	9301      	str	r3, [sp, #4]
    93ec:	9302      	str	r3, [sp, #8]
    93ee:	9808      	ldr	r0, [sp, #32]
    93f0:	9907      	ldr	r1, [sp, #28]
    93f2:	4a86      	ldr	r2, [pc, #536]	; (960c <GenXML+0x2cc>)
    93f4:	4b86      	ldr	r3, [pc, #536]	; (9610 <GenXML+0x2d0>)
    93f6:	4c87      	ldr	r4, [pc, #540]	; (9614 <GenXML+0x2d4>)
    93f8:	47a0      	blx	r4
        if (SecurityApplies(NULL, obj))
    93fa:	2000      	movs	r0, #0
    93fc:	1c39      	adds	r1, r7, #0
    93fe:	4b86      	ldr	r3, [pc, #536]	; (9618 <GenXML+0x2d8>)
    9400:	4798      	blx	r3
    9402:	2400      	movs	r4, #0
    9404:	2800      	cmp	r0, #0
    9406:	d008      	beq.n	941a <GenXML+0xda>
		{
		//	printf("Gen XML:  if (SecurityApplies(NULL, obj) \n");
            XMLWriter(context, annotateSecure, 51);
    9408:	9807      	ldr	r0, [sp, #28]
    940a:	4984      	ldr	r1, [pc, #528]	; (961c <GenXML+0x2dc>)
    940c:	2233      	movs	r2, #51	; 0x33
    940e:	9e08      	ldr	r6, [sp, #32]
    9410:	47b0      	blx	r6
            XMLWriter(context, secureTrue, 8);
    9412:	9807      	ldr	r0, [sp, #28]
    9414:	4982      	ldr	r1, [pc, #520]	; (9620 <GenXML+0x2e0>)
    9416:	2208      	movs	r2, #8
    9418:	47b0      	blx	r6
        }
        if (objIter != NULL) 
    941a:	2d00      	cmp	r5, #0
    941c:	d024      	beq.n	9468 <GenXML+0x128>
		{
	//		printf("Gen XML:  if (objIter != NULL)\n");
            description = GetDescription(descLookup, (objIter->n - 1) << 24, languageTag);
    941e:	88a9      	ldrh	r1, [r5, #4]
    9420:	3901      	subs	r1, #1
    9422:	0609      	lsls	r1, r1, #24
    9424:	1c20      	adds	r0, r4, #0
    9426:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    9428:	4b7e      	ldr	r3, [pc, #504]	; (9624 <GenXML+0x2e4>)
    942a:	4798      	blx	r3
    942c:	1e03      	subs	r3, r0, #0
        }
        if (description != NULL) 
    942e:	d008      	beq.n	9442 <GenXML+0x102>
		{
	//		printf("Gen XML:  if (description != NULL) \n");
            XMLWriteDescription(XMLWriter, context, 0, description, languageTag);
    9430:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    9432:	9200      	str	r2, [sp, #0]
    9434:	9808      	ldr	r0, [sp, #32]
    9436:	9907      	ldr	r1, [sp, #28]
    9438:	2200      	movs	r2, #0
    943a:	4e7b      	ldr	r6, [pc, #492]	; (9628 <GenXML+0x2e8>)
    943c:	47b0      	blx	r6
        }
        if (status == AJ_OK) 
		{
	//		printf("Gen XML:  status == AJ_OK \n");
            if (objIter != NULL) 
    943e:	2d00      	cmp	r5, #0
    9440:	d012      	beq.n	9468 <GenXML+0x128>
			{
				printf("Gen XML:   ExpandInterfaces\n");
    9442:	487a      	ldr	r0, [pc, #488]	; (962c <GenXML+0x2ec>)
    9444:	4e6c      	ldr	r6, [pc, #432]	; (95f8 <GenXML+0x2b8>)
    9446:	47b0      	blx	r6
                status = ExpandInterfaces(XMLWriter, context, obj->interfaces, descLookup, (objIter->n - 1) << 24, languageTag);
    9448:	687a      	ldr	r2, [r7, #4]
    944a:	88ab      	ldrh	r3, [r5, #4]
    944c:	3b01      	subs	r3, #1
    944e:	061b      	lsls	r3, r3, #24
    9450:	9300      	str	r3, [sp, #0]
    9452:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    9454:	9301      	str	r3, [sp, #4]
    9456:	9808      	ldr	r0, [sp, #32]
    9458:	9907      	ldr	r1, [sp, #28]
    945a:	1c23      	adds	r3, r4, #0
    945c:	4c74      	ldr	r4, [pc, #464]	; (9630 <GenXML+0x2f0>)
    945e:	47a0      	blx	r4
    9460:	9009      	str	r0, [sp, #36]	; 0x24
				printf("Gen XML:   ExpandInterfaces end\n");
    9462:	4874      	ldr	r0, [pc, #464]	; (9634 <GenXML+0x2f4>)
    9464:	47b0      	blx	r6
    9466:	e00d      	b.n	9484 <GenXML+0x144>
            } 
			else 
			{
				printf("Gen XML:   if (objIter == NULL) \n");
    9468:	4873      	ldr	r0, [pc, #460]	; (9638 <GenXML+0x2f8>)
    946a:	4b63      	ldr	r3, [pc, #396]	; (95f8 <GenXML+0x2b8>)
    946c:	4798      	blx	r3
                status = ExpandInterfaces(XMLWriter, context, obj->interfaces, descLookup, 0, languageTag);
    946e:	687a      	ldr	r2, [r7, #4]
    9470:	2300      	movs	r3, #0
    9472:	9300      	str	r3, [sp, #0]
    9474:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    9476:	9301      	str	r3, [sp, #4]
    9478:	9808      	ldr	r0, [sp, #32]
    947a:	9907      	ldr	r1, [sp, #28]
    947c:	1c23      	adds	r3, r4, #0
    947e:	4c6c      	ldr	r4, [pc, #432]	; (9630 <GenXML+0x2f0>)
    9480:	47a0      	blx	r4
    9482:	9009      	str	r0, [sp, #36]	; 0x24
            }
        }
        if (status == AJ_OK) 
    9484:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9486:	2b00      	cmp	r3, #0
    9488:	d000      	beq.n	948c <GenXML+0x14c>
    948a:	e0a4      	b.n	95d6 <GenXML+0x296>
		{
			printf("Gen XML:   if (status == AJ_OK) \n");
    948c:	486b      	ldr	r0, [pc, #428]	; (963c <GenXML+0x2fc>)
    948e:	4b5a      	ldr	r3, [pc, #360]	; (95f8 <GenXML+0x2b8>)
    9490:	4798      	blx	r3
            while (childObj != NULL) 
    9492:	464b      	mov	r3, r9
    9494:	2b00      	cmp	r3, #0
    9496:	d100      	bne.n	949a <GenXML+0x15a>
    9498:	e088      	b.n	95ac <GenXML+0x26c>
			{
			//	printf("Gen XML:  while (childObj != NULL)  \n");
                uint32_t len;
                //Find immediate descendants
                const char* child = ChildPath(obj->path, childObj->path, &len);
    949a:	4b69      	ldr	r3, [pc, #420]	; (9640 <GenXML+0x300>)
    949c:	469b      	mov	fp, r3
{
    iter->fin = inFlags;
    iter->fex = exFlags;
    iter->l = 0;
    iter->n = 0;
    return AJ_NextObject(iter);
    949e:	4b59      	ldr	r3, [pc, #356]	; (9604 <GenXML+0x2c4>)
    94a0:	469a      	mov	sl, r3
    const AJ_Object* obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);

    while (obj != NULL) 
	{
        uint32_t len;
        const char* c = ChildPath(path, obj->path, &len);
    94a2:	465e      	mov	r6, fp
    94a4:	46b8      	mov	r8, r7
            while (childObj != NULL) 
			{
			//	printf("Gen XML:  while (childObj != NULL)  \n");
                uint32_t len;
                //Find immediate descendants
                const char* child = ChildPath(obj->path, childObj->path, &len);
    94a6:	4643      	mov	r3, r8
    94a8:	6818      	ldr	r0, [r3, #0]
    94aa:	464b      	mov	r3, r9
    94ac:	6819      	ldr	r1, [r3, #0]
    94ae:	aa0a      	add	r2, sp, #40	; 0x28
    94b0:	47d8      	blx	fp
    94b2:	9006      	str	r0, [sp, #24]
                // If there is a child check that this is the first instance of this child.
                if (child && (FirstInstance(obj->path, child, len) == childObj)) 
    94b4:	2800      	cmp	r0, #0
    94b6:	d072      	beq.n	959e <GenXML+0x25e>
    94b8:	4643      	mov	r3, r8
    94ba:	681b      	ldr	r3, [r3, #0]
    94bc:	9305      	str	r3, [sp, #20]
    94be:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    iter->fin = inFlags;
    94c0:	a80e      	add	r0, sp, #56	; 0x38
    94c2:	23ff      	movs	r3, #255	; 0xff
    94c4:	7003      	strb	r3, [r0, #0]
    iter->fex = exFlags;
    94c6:	3be9      	subs	r3, #233	; 0xe9
    94c8:	7043      	strb	r3, [r0, #1]
    iter->l = 0;
    94ca:	2300      	movs	r3, #0
    94cc:	7083      	strb	r3, [r0, #2]
    iter->n = 0;
    94ce:	8083      	strh	r3, [r0, #4]
    return AJ_NextObject(iter);
    94d0:	47d0      	blx	sl
    94d2:	1e04      	subs	r4, r0, #0
static const AJ_Object* FirstInstance(const char* path, const char* child, uint32_t sz)
{
    AJ_ObjectIterator iter;
    const AJ_Object* obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);

    while (obj != NULL) 
    94d4:	d013      	beq.n	94fe <GenXML+0x1be>
        const char* c = ChildPath(path, obj->path, &len);
        if (c && (len == sz) && (memcmp(c, child, sz) == 0))
		{
            return obj;
        }
        obj = AJ_NextObject(&iter);
    94d6:	4f4b      	ldr	r7, [pc, #300]	; (9604 <GenXML+0x2c4>)
    const AJ_Object* obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);

    while (obj != NULL) 
	{
        uint32_t len;
        const char* c = ChildPath(path, obj->path, &len);
    94d8:	9805      	ldr	r0, [sp, #20]
    94da:	6821      	ldr	r1, [r4, #0]
    94dc:	aa0b      	add	r2, sp, #44	; 0x2c
    94de:	47b0      	blx	r6
        if (c && (len == sz) && (memcmp(c, child, sz) == 0))
    94e0:	2800      	cmp	r0, #0
    94e2:	d008      	beq.n	94f6 <GenXML+0x1b6>
    94e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    94e6:	429d      	cmp	r5, r3
    94e8:	d105      	bne.n	94f6 <GenXML+0x1b6>
    94ea:	9906      	ldr	r1, [sp, #24]
    94ec:	1c2a      	adds	r2, r5, #0
    94ee:	4b55      	ldr	r3, [pc, #340]	; (9644 <GenXML+0x304>)
    94f0:	4798      	blx	r3
    94f2:	2800      	cmp	r0, #0
    94f4:	d003      	beq.n	94fe <GenXML+0x1be>
		{
            return obj;
        }
        obj = AJ_NextObject(&iter);
    94f6:	a80e      	add	r0, sp, #56	; 0x38
    94f8:	47b8      	blx	r7
    94fa:	1e04      	subs	r4, r0, #0
static const AJ_Object* FirstInstance(const char* path, const char* child, uint32_t sz)
{
    AJ_ObjectIterator iter;
    const AJ_Object* obj = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);

    while (obj != NULL) 
    94fc:	d1ec      	bne.n	94d8 <GenXML+0x198>
			//	printf("Gen XML:  while (childObj != NULL)  \n");
                uint32_t len;
                //Find immediate descendants
                const char* child = ChildPath(obj->path, childObj->path, &len);
                // If there is a child check that this is the first instance of this child.
                if (child && (FirstInstance(obj->path, child, len) == childObj)) 
    94fe:	45a1      	cmp	r9, r4
    9500:	d14d      	bne.n	959e <GenXML+0x25e>
				{
					printf("Gen XML:  if (child && (FirstInstance(obj->path, child, len) == childObj))  \n");
    9502:	4851      	ldr	r0, [pc, #324]	; (9648 <GenXML+0x308>)
    9504:	4b3c      	ldr	r3, [pc, #240]	; (95f8 <GenXML+0x2b8>)
    9506:	4798      	blx	r3
                    if (languageTag != NULL && childObjectIter.l < AJ_MAX_OBJECT_LISTS) 
    9508:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    950a:	2b00      	cmp	r3, #0
    950c:	d00c      	beq.n	9528 <GenXML+0x1e8>
    950e:	ab0c      	add	r3, sp, #48	; 0x30
    9510:	789b      	ldrb	r3, [r3, #2]
    9512:	2b08      	cmp	r3, #8
    9514:	d808      	bhi.n	9528 <GenXML+0x1e8>
					{
						printf("Gen XML:   if (languageTag != NULL && childObjectIter.l < AJ_MAX_OBJECT_LISTS)   \n");
    9516:	484d      	ldr	r0, [pc, #308]	; (964c <GenXML+0x30c>)
    9518:	4b37      	ldr	r3, [pc, #220]	; (95f8 <GenXML+0x2b8>)
    951a:	4798      	blx	r3
                        descLookup = descriptionLookups[childObjectIter.l];
    951c:	ab0c      	add	r3, sp, #48	; 0x30
    951e:	789b      	ldrb	r3, [r3, #2]
    9520:	009b      	lsls	r3, r3, #2
    9522:	4a39      	ldr	r2, [pc, #228]	; (9608 <GenXML+0x2c8>)
    9524:	5898      	ldr	r0, [r3, r2]
    9526:	e003      	b.n	9530 <GenXML+0x1f0>
                    }
					else
					{
						printf("Gen XML:   descLookup = NULL \n");
    9528:	4849      	ldr	r0, [pc, #292]	; (9650 <GenXML+0x310>)
    952a:	4b33      	ldr	r3, [pc, #204]	; (95f8 <GenXML+0x2b8>)
    952c:	4798      	blx	r3
                        descLookup = NULL;
    952e:	2000      	movs	r0, #0
                    }
                    description = GetDescription(descLookup, (childObjectIter.n - 1) << 24, languageTag);
    9530:	ab0c      	add	r3, sp, #48	; 0x30
    9532:	8899      	ldrh	r1, [r3, #4]
    9534:	3901      	subs	r1, #1
    9536:	0609      	lsls	r1, r1, #24
    9538:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    953a:	4b3a      	ldr	r3, [pc, #232]	; (9624 <GenXML+0x2e4>)
    953c:	4798      	blx	r3
    953e:	1e04      	subs	r4, r0, #0
                    if (description != NULL) 
    9540:	d01e      	beq.n	9580 <GenXML+0x240>
					{
						printf("Gen XML:    if (description != NULL)  \n");
    9542:	4844      	ldr	r0, [pc, #272]	; (9654 <GenXML+0x314>)
    9544:	4b2c      	ldr	r3, [pc, #176]	; (95f8 <GenXML+0x2b8>)
    9546:	4798      	blx	r3
                        XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, child, len, FALSE);
    9548:	9b06      	ldr	r3, [sp, #24]
    954a:	9300      	str	r3, [sp, #0]
    954c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    954e:	9301      	str	r3, [sp, #4]
    9550:	2300      	movs	r3, #0
    9552:	9302      	str	r3, [sp, #8]
    9554:	9f08      	ldr	r7, [sp, #32]
    9556:	1c38      	adds	r0, r7, #0
    9558:	9907      	ldr	r1, [sp, #28]
    955a:	4a2c      	ldr	r2, [pc, #176]	; (960c <GenXML+0x2cc>)
    955c:	4b2c      	ldr	r3, [pc, #176]	; (9610 <GenXML+0x2d0>)
    955e:	4d2d      	ldr	r5, [pc, #180]	; (9614 <GenXML+0x2d4>)
    9560:	47a8      	blx	r5
                        XMLWriteDescription(XMLWriter, context, 0, description, languageTag);
    9562:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    9564:	9300      	str	r3, [sp, #0]
    9566:	1c3d      	adds	r5, r7, #0
    9568:	1c38      	adds	r0, r7, #0
    956a:	9f07      	ldr	r7, [sp, #28]
    956c:	1c39      	adds	r1, r7, #0
    956e:	2200      	movs	r2, #0
    9570:	1c23      	adds	r3, r4, #0
    9572:	4c2d      	ldr	r4, [pc, #180]	; (9628 <GenXML+0x2e8>)
    9574:	47a0      	blx	r4
                        XMLWriter(context, nodeClose, 8);
    9576:	1c38      	adds	r0, r7, #0
    9578:	4937      	ldr	r1, [pc, #220]	; (9658 <GenXML+0x318>)
    957a:	2208      	movs	r2, #8
    957c:	47a8      	blx	r5
    957e:	e00e      	b.n	959e <GenXML+0x25e>
                    }
					else
					{
						printf("Gen XML:    XMLWriteTag  \n");
    9580:	4836      	ldr	r0, [pc, #216]	; (965c <GenXML+0x31c>)
    9582:	4b1d      	ldr	r3, [pc, #116]	; (95f8 <GenXML+0x2b8>)
    9584:	4798      	blx	r3
                        XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, child, len, TRUE);
    9586:	9b06      	ldr	r3, [sp, #24]
    9588:	9300      	str	r3, [sp, #0]
    958a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    958c:	9301      	str	r3, [sp, #4]
    958e:	2301      	movs	r3, #1
    9590:	9302      	str	r3, [sp, #8]
    9592:	9808      	ldr	r0, [sp, #32]
    9594:	9907      	ldr	r1, [sp, #28]
    9596:	4a1d      	ldr	r2, [pc, #116]	; (960c <GenXML+0x2cc>)
    9598:	4b1d      	ldr	r3, [pc, #116]	; (9610 <GenXML+0x2d0>)
    959a:	4c1e      	ldr	r4, [pc, #120]	; (9614 <GenXML+0x2d4>)
    959c:	47a0      	blx	r4
                    }
                }
                childObj = AJ_NextObject(&childObjectIter);
    959e:	a80c      	add	r0, sp, #48	; 0x30
    95a0:	4b18      	ldr	r3, [pc, #96]	; (9604 <GenXML+0x2c4>)
    95a2:	4798      	blx	r3
    95a4:	4681      	mov	r9, r0
            }
        }
        if (status == AJ_OK) 
		{
			printf("Gen XML:   if (status == AJ_OK) \n");
            while (childObj != NULL) 
    95a6:	2800      	cmp	r0, #0
    95a8:	d000      	beq.n	95ac <GenXML+0x26c>
    95aa:	e77c      	b.n	94a6 <GenXML+0x166>
                        XMLWriteTag(XMLWriter, context, nodeOpen, nameAttr, child, len, TRUE);
                    }
                }
                childObj = AJ_NextObject(&childObjectIter);
            }
			printf("Gen XML:    XMLWriter  \n");
    95ac:	482c      	ldr	r0, [pc, #176]	; (9660 <GenXML+0x320>)
    95ae:	4b12      	ldr	r3, [pc, #72]	; (95f8 <GenXML+0x2b8>)
    95b0:	4798      	blx	r3
            XMLWriter(context, nodeClose, 8);
    95b2:	9807      	ldr	r0, [sp, #28]
    95b4:	4928      	ldr	r1, [pc, #160]	; (9658 <GenXML+0x318>)
    95b6:	2208      	movs	r2, #8
    95b8:	9b08      	ldr	r3, [sp, #32]
    95ba:	4798      	blx	r3
    95bc:	e003      	b.n	95c6 <GenXML+0x286>
        }
        if (status != AJ_OK) 
		{
            AJ_ErrPrintf(("\nFailed to generate XML - check interface descriptions of %s for errors\n", obj->path));
    95be:	6839      	ldr	r1, [r7, #0]
    95c0:	4828      	ldr	r0, [pc, #160]	; (9664 <GenXML+0x324>)
    95c2:	4b29      	ldr	r3, [pc, #164]	; (9668 <GenXML+0x328>)
    95c4:	4798      	blx	r3
    95c6:	9809      	ldr	r0, [sp, #36]	; 0x24
    95c8:	e00d      	b.n	95e6 <GenXML+0x2a6>
	 {
	//	 printf("Gen XML: objIter != NULL\n");
        if (objIter->l >= ArraySize(objectLists) && virtualObject == NULL) 
		{
	//		printf("Gen XML: objIter != NULL  return AJ_OK\n");
            return AJ_OK;
    95ca:	2000      	movs	r0, #0
    95cc:	e00b      	b.n	95e6 <GenXML+0x2a6>
    return FALSE;
}

static AJ_Status GenXML(XMLWriterFunc XMLWriter, void* context, const AJ_ObjectIterator* objIter, const AJ_Object* virtualObject, const char* languageTag)
{
    AJ_Status status = AJ_OK;
    95ce:	2000      	movs	r0, #0
    95d0:	e009      	b.n	95e6 <GenXML+0x2a6>
    95d2:	2000      	movs	r0, #0
    95d4:	e007      	b.n	95e6 <GenXML+0x2a6>
			printf("Gen XML:    XMLWriter  \n");
            XMLWriter(context, nodeClose, 8);
        }
        if (status != AJ_OK) 
		{
            AJ_ErrPrintf(("\nFailed to generate XML - check interface descriptions of %s for errors\n", obj->path));
    95d6:	2001      	movs	r0, #1
    95d8:	4924      	ldr	r1, [pc, #144]	; (966c <GenXML+0x32c>)
    95da:	4a25      	ldr	r2, [pc, #148]	; (9670 <GenXML+0x330>)
    95dc:	4b25      	ldr	r3, [pc, #148]	; (9674 <GenXML+0x334>)
    95de:	4798      	blx	r3
    95e0:	2800      	cmp	r0, #0
    95e2:	d0f0      	beq.n	95c6 <GenXML+0x286>
    95e4:	e7eb      	b.n	95be <GenXML+0x27e>
        }
    }
    return status;
}
    95e6:	b011      	add	sp, #68	; 0x44
    95e8:	bc3c      	pop	{r2, r3, r4, r5}
    95ea:	4690      	mov	r8, r2
    95ec:	4699      	mov	r9, r3
    95ee:	46a2      	mov	sl, r4
    95f0:	46ab      	mov	fp, r5
    95f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    95f4:	0001ccb4 	.word	0x0001ccb4
    95f8:	00016f5d 	.word	0x00016f5d
    95fc:	0fffffff 	.word	0x0fffffff
    9600:	20000138 	.word	0x20000138
    9604:	00008aad 	.word	0x00008aad
    9608:	2000091c 	.word	0x2000091c
    960c:	0001d160 	.word	0x0001d160
    9610:	0001c9e0 	.word	0x0001c9e0
    9614:	0000807d 	.word	0x0000807d
    9618:	00008b31 	.word	0x00008b31
    961c:	0001c980 	.word	0x0001c980
    9620:	0001ca08 	.word	0x0001ca08
    9624:	000080d1 	.word	0x000080d1
    9628:	000080e5 	.word	0x000080e5
    962c:	0001ccc4 	.word	0x0001ccc4
    9630:	000083f5 	.word	0x000083f5
    9634:	0001cce0 	.word	0x0001cce0
    9638:	0001cd00 	.word	0x0001cd00
    963c:	0001cd24 	.word	0x0001cd24
    9640:	00008171 	.word	0x00008171
    9644:	0001671b 	.word	0x0001671b
    9648:	0001cd48 	.word	0x0001cd48
    964c:	0001cd98 	.word	0x0001cd98
    9650:	0001cdec 	.word	0x0001cdec
    9654:	0001ce0c 	.word	0x0001ce0c
    9658:	0001d138 	.word	0x0001d138
    965c:	0001ce34 	.word	0x0001ce34
    9660:	0001ce50 	.word	0x0001ce50
    9664:	0001ce68 	.word	0x0001ce68
    9668:	00016e3d 	.word	0x00016e3d
    966c:	0001ca4c 	.word	0x0001ca4c
    9670:	0000026b 	.word	0x0000026b
    9674:	0000636d 	.word	0x0000636d

00009678 <AJ_PrintXMLWithDescriptions>:
{
    AJ_PrintXMLWithDescriptions(objs, NULL); // without descriptions
}

void AJ_PrintXMLWithDescriptions(const AJ_Object* objs, const char* languageTag)
{
    9678:	b5f0      	push	{r4, r5, r6, r7, lr}
    967a:	464f      	mov	r7, r9
    967c:	4646      	mov	r6, r8
    967e:	b4c0      	push	{r6, r7}
    9680:	b085      	sub	sp, #20
    9682:	1e05      	subs	r5, r0, #0
    9684:	4689      	mov	r9, r1
    AJ_Status status;

    while (objs && objs->path) 
    9686:	d060      	beq.n	974a <AJ_PrintXMLWithDescriptions+0xd2>
    9688:	6800      	ldr	r0, [r0, #0]
    968a:	2800      	cmp	r0, #0
    968c:	d05d      	beq.n	974a <AJ_PrintXMLWithDescriptions+0xd2>
	{
        if (strcmp(objs->path, "/") == 0)  //  path == '/'
    968e:	4b31      	ldr	r3, [pc, #196]	; (9754 <AJ_PrintXMLWithDescriptions+0xdc>)
    9690:	4698      	mov	r8, r3
    9692:	4931      	ldr	r1, [pc, #196]	; (9758 <AJ_PrintXMLWithDescriptions+0xe0>)
    9694:	47c0      	blx	r8
    9696:	2800      	cmp	r0, #0
    9698:	d116      	bne.n	96c8 <AJ_PrintXMLWithDescriptions+0x50>
		{
            status = GenXML(PrintXML, NULL, NULL, objs, languageTag); // with descriptions in the given language
    969a:	464b      	mov	r3, r9
    969c:	9300      	str	r3, [sp, #0]
    969e:	482f      	ldr	r0, [pc, #188]	; (975c <AJ_PrintXMLWithDescriptions+0xe4>)
    96a0:	2100      	movs	r1, #0
    96a2:	2200      	movs	r2, #0
    96a4:	1c2b      	adds	r3, r5, #0
    96a6:	4c2e      	ldr	r4, [pc, #184]	; (9760 <AJ_PrintXMLWithDescriptions+0xe8>)
    96a8:	47a0      	blx	r4
            if (status != AJ_OK) 
    96aa:	2800      	cmp	r0, #0
    96ac:	d047      	beq.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
			{
                AJ_ErrPrintf(("\nFailed to generate XML - check interface descriptions of %s for errors\n", objs->path));
    96ae:	2001      	movs	r0, #1
    96b0:	492c      	ldr	r1, [pc, #176]	; (9764 <AJ_PrintXMLWithDescriptions+0xec>)
    96b2:	22a6      	movs	r2, #166	; 0xa6
    96b4:	0092      	lsls	r2, r2, #2
    96b6:	4b2c      	ldr	r3, [pc, #176]	; (9768 <AJ_PrintXMLWithDescriptions+0xf0>)
    96b8:	4798      	blx	r3
    96ba:	2800      	cmp	r0, #0
    96bc:	d03f      	beq.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
    96be:	482b      	ldr	r0, [pc, #172]	; (976c <AJ_PrintXMLWithDescriptions+0xf4>)
    96c0:	6829      	ldr	r1, [r5, #0]
    96c2:	4b2b      	ldr	r3, [pc, #172]	; (9770 <AJ_PrintXMLWithDescriptions+0xf8>)
    96c4:	4798      	blx	r3
    96c6:	e03a      	b.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    iter->fin = inFlags;
    96c8:	a802      	add	r0, sp, #8
    96ca:	23ff      	movs	r3, #255	; 0xff
    96cc:	7003      	strb	r3, [r0, #0]
    iter->fex = exFlags;
    96ce:	3be9      	subs	r3, #233	; 0xe9
    96d0:	7043      	strb	r3, [r0, #1]
    iter->l = 0;
    96d2:	2300      	movs	r3, #0
    96d4:	7083      	strb	r3, [r0, #2]
    iter->n = 0;
    96d6:	8083      	strh	r3, [r0, #4]
    return AJ_NextObject(iter);
    96d8:	4b26      	ldr	r3, [pc, #152]	; (9774 <AJ_PrintXMLWithDescriptions+0xfc>)
    96da:	4798      	blx	r3
    96dc:	1e04      	subs	r4, r0, #0
		else
		{
            AJ_ObjectIterator iter;
            const AJ_Object* lookup;
            lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
            while (lookup != NULL) 
    96de:	d023      	beq.n	9728 <AJ_PrintXMLWithDescriptions+0xb0>
			{
                if (strcmp(lookup->path, objs->path) == 0) //  lookup->path==objs->path
    96e0:	4f1c      	ldr	r7, [pc, #112]	; (9754 <AJ_PrintXMLWithDescriptions+0xdc>)
				{
                    break;
                }
                lookup = AJ_NextObject(&iter);
    96e2:	4e24      	ldr	r6, [pc, #144]	; (9774 <AJ_PrintXMLWithDescriptions+0xfc>)
            AJ_ObjectIterator iter;
            const AJ_Object* lookup;
            lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
            while (lookup != NULL) 
			{
                if (strcmp(lookup->path, objs->path) == 0) //  lookup->path==objs->path
    96e4:	6820      	ldr	r0, [r4, #0]
    96e6:	6829      	ldr	r1, [r5, #0]
    96e8:	47b8      	blx	r7
    96ea:	2800      	cmp	r0, #0
    96ec:	d004      	beq.n	96f8 <AJ_PrintXMLWithDescriptions+0x80>
				{
                    break;
                }
                lookup = AJ_NextObject(&iter);
    96ee:	a802      	add	r0, sp, #8
    96f0:	47b0      	blx	r6
    96f2:	1e04      	subs	r4, r0, #0
		else
		{
            AJ_ObjectIterator iter;
            const AJ_Object* lookup;
            lookup = AJ_InitObjectIterator(&iter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
            while (lookup != NULL) 
    96f4:	d1f6      	bne.n	96e4 <AJ_PrintXMLWithDescriptions+0x6c>
    96f6:	e017      	b.n	9728 <AJ_PrintXMLWithDescriptions+0xb0>
				{
                    break;
                }
                lookup = AJ_NextObject(&iter);
            }
            if (lookup != NULL)
    96f8:	2c00      	cmp	r4, #0
    96fa:	d015      	beq.n	9728 <AJ_PrintXMLWithDescriptions+0xb0>
			{
                status = GenXML(PrintXML, NULL, &iter, NULL, languageTag); // with descriptions in the given language
    96fc:	464b      	mov	r3, r9
    96fe:	9300      	str	r3, [sp, #0]
    9700:	4816      	ldr	r0, [pc, #88]	; (975c <AJ_PrintXMLWithDescriptions+0xe4>)
    9702:	2100      	movs	r1, #0
    9704:	aa02      	add	r2, sp, #8
    9706:	2300      	movs	r3, #0
    9708:	4c15      	ldr	r4, [pc, #84]	; (9760 <AJ_PrintXMLWithDescriptions+0xe8>)
    970a:	47a0      	blx	r4
                if (status != AJ_OK)
    970c:	2800      	cmp	r0, #0
    970e:	d016      	beq.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
				{
                    AJ_ErrPrintf(("\nFailed to generate XML - check interface descriptions of %s for errors\n", objs->path));
    9710:	2001      	movs	r0, #1
    9712:	4914      	ldr	r1, [pc, #80]	; (9764 <AJ_PrintXMLWithDescriptions+0xec>)
    9714:	4a18      	ldr	r2, [pc, #96]	; (9778 <AJ_PrintXMLWithDescriptions+0x100>)
    9716:	4b14      	ldr	r3, [pc, #80]	; (9768 <AJ_PrintXMLWithDescriptions+0xf0>)
    9718:	4798      	blx	r3
    971a:	2800      	cmp	r0, #0
    971c:	d00f      	beq.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
    971e:	4813      	ldr	r0, [pc, #76]	; (976c <AJ_PrintXMLWithDescriptions+0xf4>)
    9720:	6829      	ldr	r1, [r5, #0]
    9722:	4b13      	ldr	r3, [pc, #76]	; (9770 <AJ_PrintXMLWithDescriptions+0xf8>)
    9724:	4798      	blx	r3
    9726:	e00a      	b.n	973e <AJ_PrintXMLWithDescriptions+0xc6>
                }
            } 
			else
			{
                AJ_AlwaysPrintf(("Reminder: Object not yet added to the ObjectList, do not forget to call RegisterObjects\n"));
    9728:	4814      	ldr	r0, [pc, #80]	; (977c <AJ_PrintXMLWithDescriptions+0x104>)
    972a:	4b15      	ldr	r3, [pc, #84]	; (9780 <AJ_PrintXMLWithDescriptions+0x108>)
    972c:	4798      	blx	r3
                status = GenXML(PrintXML, NULL, NULL, objs, languageTag);
    972e:	464b      	mov	r3, r9
    9730:	9300      	str	r3, [sp, #0]
    9732:	480a      	ldr	r0, [pc, #40]	; (975c <AJ_PrintXMLWithDescriptions+0xe4>)
    9734:	2100      	movs	r1, #0
    9736:	2200      	movs	r2, #0
    9738:	1c2b      	adds	r3, r5, #0
    973a:	4c09      	ldr	r4, [pc, #36]	; (9760 <AJ_PrintXMLWithDescriptions+0xe8>)
    973c:	47a0      	blx	r4
            }
        }
        objs++;
    973e:	3510      	adds	r5, #16

void AJ_PrintXMLWithDescriptions(const AJ_Object* objs, const char* languageTag)
{
    AJ_Status status;

    while (objs && objs->path) 
    9740:	2d00      	cmp	r5, #0
    9742:	d002      	beq.n	974a <AJ_PrintXMLWithDescriptions+0xd2>
    9744:	6828      	ldr	r0, [r5, #0]
    9746:	2800      	cmp	r0, #0
    9748:	d1a3      	bne.n	9692 <AJ_PrintXMLWithDescriptions+0x1a>
                status = GenXML(PrintXML, NULL, NULL, objs, languageTag);
            }
        }
        objs++;
    }
}
    974a:	b005      	add	sp, #20
    974c:	bc0c      	pop	{r2, r3}
    974e:	4690      	mov	r8, r2
    9750:	4699      	mov	r9, r3
    9752:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9754:	00017137 	.word	0x00017137
    9758:	0001cc20 	.word	0x0001cc20
    975c:	000083c5 	.word	0x000083c5
    9760:	00009341 	.word	0x00009341
    9764:	0001ca4c 	.word	0x0001ca4c
    9768:	0000636d 	.word	0x0000636d
    976c:	0001ce68 	.word	0x0001ce68
    9770:	00016e3d 	.word	0x00016e3d
    9774:	00008aad 	.word	0x00008aad
    9778:	000002ad 	.word	0x000002ad
    977c:	0001ceb4 	.word	0x0001ceb4
    9780:	00016f5d 	.word	0x00016f5d

00009784 <AJ_PrintXML>:
        AJ_AlwaysPrintf(("%s", str));
    }
}

void AJ_PrintXML(const AJ_Object* objs)
{
    9784:	b508      	push	{r3, lr}
    AJ_PrintXMLWithDescriptions(objs, NULL); // without descriptions
    9786:	2100      	movs	r1, #0
    9788:	4b01      	ldr	r3, [pc, #4]	; (9790 <AJ_PrintXML+0xc>)
    978a:	4798      	blx	r3
}
    978c:	bd08      	pop	{r3, pc}
    978e:	46c0      	nop			; (mov r8, r8)
    9790:	00009679 	.word	0x00009679

00009794 <AJ_HandleIntrospectRequest>:
        wctx->status = AJ_MarshalRaw(wctx->reply, str, len);
    }
}

AJ_Status AJ_HandleIntrospectRequest(const AJ_Message* msg, AJ_Message* reply, const char* languageTag)
{
    9794:	b5f0      	push	{r4, r5, r6, r7, lr}
    9796:	465f      	mov	r7, fp
    9798:	4656      	mov	r6, sl
    979a:	464d      	mov	r5, r9
    979c:	b4e0      	push	{r5, r6, r7}
    979e:	b090      	sub	sp, #64	; 0x40
    97a0:	1c07      	adds	r7, r0, #0
    97a2:	9103      	str	r1, [sp, #12]
    97a4:	9204      	str	r2, [sp, #16]
    }
}

const AJ_Object* AJ_InitObjectIterator(AJ_ObjectIterator* iter, uint8_t inFlags, uint8_t exFlags)
{
    iter->fin = inFlags;
    97a6:	a80e      	add	r0, sp, #56	; 0x38
    97a8:	23ff      	movs	r3, #255	; 0xff
    97aa:	7003      	strb	r3, [r0, #0]
    iter->fex = exFlags;
    97ac:	3be9      	subs	r3, #233	; 0xe9
    97ae:	7043      	strb	r3, [r0, #1]
    iter->l = 0;
    97b0:	2500      	movs	r5, #0
    97b2:	7085      	strb	r5, [r0, #2]
    iter->n = 0;
    97b4:	8085      	strh	r5, [r0, #4]
    return AJ_NextObject(iter);
    97b6:	4b65      	ldr	r3, [pc, #404]	; (994c <AJ_HandleIntrospectRequest+0x1b8>)
    97b8:	4798      	blx	r3
    97ba:	1c04      	adds	r4, r0, #0
AJ_Status AJ_HandleIntrospectRequest(const AJ_Message* msg, AJ_Message* reply, const char* languageTag)
{
    AJ_Status status = AJ_OK;
    AJ_ObjectIterator objIter;
    const AJ_Object* obj = AJ_InitObjectIterator(&objIter, AJ_OBJ_FLAGS_ALL_INCLUDE_MASK, AJ_OBJ_FLAGS_INTROSPECTABLE_EXCLUDE_MASK);
    const AJ_Object virtualObject = { msg->objPath, NULL, 0, NULL };
    97bc:	ab0a      	add	r3, sp, #40	; 0x28
    97be:	68ba      	ldr	r2, [r7, #8]
    97c0:	920a      	str	r2, [sp, #40]	; 0x28
    97c2:	950b      	str	r5, [sp, #44]	; 0x2c
    97c4:	2200      	movs	r2, #0
    97c6:	721a      	strb	r2, [r3, #8]
    97c8:	950d      	str	r5, [sp, #52]	; 0x34
    WriteContext context;
    uint32_t children = 0;

    // Find the requested object in the registered object lists
    while (obj != NULL) 
    97ca:	2800      	cmp	r0, #0
    97cc:	d100      	bne.n	97d0 <AJ_HandleIntrospectRequest+0x3c>
    97ce:	e08a      	b.n	98e6 <AJ_HandleIntrospectRequest+0x152>
        *
        * - The request has a complete object path to one of the application objects.
        * - The request has a path to a parent object of one or more application objects where the
        *   parent itself is just a place-holder in the object hierarchy.
        */
        if (strcmp(msg->objPath, obj->path) == 0) 
    97d0:	4b5f      	ldr	r3, [pc, #380]	; (9950 <AJ_HandleIntrospectRequest+0x1bc>)
    97d2:	4699      	mov	r9, r3
		{
            break;
        }
        if (ChildPath(msg->objPath, obj->path, NULL))
    97d4:	4b5f      	ldr	r3, [pc, #380]	; (9954 <AJ_HandleIntrospectRequest+0x1c0>)
    97d6:	469a      	mov	sl, r3
        if (children) 
		{
            obj = &virtualObject;
            break;
        }
        obj = AJ_NextObject(&objIter);
    97d8:	4b5c      	ldr	r3, [pc, #368]	; (994c <AJ_HandleIntrospectRequest+0x1b8>)
    97da:	469b      	mov	fp, r3
        *
        * - The request has a complete object path to one of the application objects.
        * - The request has a path to a parent object of one or more application objects where the
        *   parent itself is just a place-holder in the object hierarchy.
        */
        if (strcmp(msg->objPath, obj->path) == 0) 
    97dc:	68be      	ldr	r6, [r7, #8]
    97de:	6825      	ldr	r5, [r4, #0]
    97e0:	1c30      	adds	r0, r6, #0
    97e2:	1c29      	adds	r1, r5, #0
    97e4:	47c8      	blx	r9
    97e6:	2800      	cmp	r0, #0
    97e8:	d00e      	beq.n	9808 <AJ_HandleIntrospectRequest+0x74>
		{
            break;
        }
        if (ChildPath(msg->objPath, obj->path, NULL))
    97ea:	1c30      	adds	r0, r6, #0
    97ec:	1c29      	adds	r1, r5, #0
    97ee:	2200      	movs	r2, #0
    97f0:	47d0      	blx	sl
		{
            ++children;
    97f2:	1c05      	adds	r5, r0, #0
    97f4:	1e68      	subs	r0, r5, #1
    97f6:	4185      	sbcs	r5, r0
        }
        /*
        * If there was not a direct match but the requested node has children we create
        * a temporary AJ_Object for the parent and introspect that object.
        */
        if (children) 
    97f8:	2d00      	cmp	r5, #0
    97fa:	d000      	beq.n	97fe <AJ_HandleIntrospectRequest+0x6a>
    97fc:	e08a      	b.n	9914 <AJ_HandleIntrospectRequest+0x180>
		{
            obj = &virtualObject;
            break;
        }
        obj = AJ_NextObject(&objIter);
    97fe:	a80e      	add	r0, sp, #56	; 0x38
    9800:	47d8      	blx	fp
    9802:	1e04      	subs	r4, r0, #0
    const AJ_Object virtualObject = { msg->objPath, NULL, 0, NULL };
    WriteContext context;
    uint32_t children = 0;

    // Find the requested object in the registered object lists
    while (obj != NULL) 
    9804:	d1ea      	bne.n	97dc <AJ_HandleIntrospectRequest+0x48>
    9806:	e06e      	b.n	98e6 <AJ_HandleIntrospectRequest+0x152>
            obj = &virtualObject;
            break;
        }
        obj = AJ_NextObject(&objIter);
    }
    if (obj != NULL && obj->path != NULL) 
    9808:	2c00      	cmp	r4, #0
    980a:	d000      	beq.n	980e <AJ_HandleIntrospectRequest+0x7a>
    980c:	e093      	b.n	9936 <AJ_HandleIntrospectRequest+0x1a2>
    980e:	e06a      	b.n	98e6 <AJ_HandleIntrospectRequest+0x152>
        } 
		else 
		{
            status = GenXML(SizeXML, &context.len, &objIter, NULL, languageTag);
        }
		printf("AJ_HandleIntrospectRequest(): 1 status=%s\n", AJ_StatusText(status));
    9810:	1c20      	adds	r0, r4, #0
    9812:	4b51      	ldr	r3, [pc, #324]	; (9958 <AJ_HandleIntrospectRequest+0x1c4>)
    9814:	4798      	blx	r3
    9816:	1c01      	adds	r1, r0, #0
    9818:	4850      	ldr	r0, [pc, #320]	; (995c <AJ_HandleIntrospectRequest+0x1c8>)
    981a:	4b51      	ldr	r3, [pc, #324]	; (9960 <AJ_HandleIntrospectRequest+0x1cc>)
    981c:	4798      	blx	r3
        if (status != AJ_OK) 
    981e:	2c00      	cmp	r4, #0
    9820:	d012      	beq.n	9848 <AJ_HandleIntrospectRequest+0xb4>
		{
            AJ_ErrPrintf(("AJ_HandleIntrospectRequest(): Failed to generate XML. status=%s\n", AJ_StatusText(status)));
    9822:	2001      	movs	r0, #1
    9824:	494f      	ldr	r1, [pc, #316]	; (9964 <AJ_HandleIntrospectRequest+0x1d0>)
    9826:	22c4      	movs	r2, #196	; 0xc4
    9828:	0092      	lsls	r2, r2, #2
    982a:	4b4f      	ldr	r3, [pc, #316]	; (9968 <AJ_HandleIntrospectRequest+0x1d4>)
    982c:	4798      	blx	r3
            return status;
    982e:	1c23      	adds	r3, r4, #0
            status = GenXML(SizeXML, &context.len, &objIter, NULL, languageTag);
        }
		printf("AJ_HandleIntrospectRequest(): 1 status=%s\n", AJ_StatusText(status));
        if (status != AJ_OK) 
		{
            AJ_ErrPrintf(("AJ_HandleIntrospectRequest(): Failed to generate XML. status=%s\n", AJ_StatusText(status)));
    9830:	2800      	cmp	r0, #0
    9832:	d100      	bne.n	9836 <AJ_HandleIntrospectRequest+0xa2>
    9834:	e083      	b.n	993e <AJ_HandleIntrospectRequest+0x1aa>
    9836:	1c20      	adds	r0, r4, #0
    9838:	4b47      	ldr	r3, [pc, #284]	; (9958 <AJ_HandleIntrospectRequest+0x1c4>)
    983a:	4798      	blx	r3
    983c:	1c01      	adds	r1, r0, #0
    983e:	484b      	ldr	r0, [pc, #300]	; (996c <AJ_HandleIntrospectRequest+0x1d8>)
    9840:	4b47      	ldr	r3, [pc, #284]	; (9960 <AJ_HandleIntrospectRequest+0x1cc>)
    9842:	4798      	blx	r3
            return status;
    9844:	1c23      	adds	r3, r4, #0
    9846:	e07a      	b.n	993e <AJ_HandleIntrospectRequest+0x1aa>
        }
        // Second pass marshals the XML
        printf("AJ_HandleIntrospectRequest() %d bytes of XML\n", context.len);
    9848:	9b08      	ldr	r3, [sp, #32]
    984a:	9305      	str	r3, [sp, #20]
    984c:	4848      	ldr	r0, [pc, #288]	; (9970 <AJ_HandleIntrospectRequest+0x1dc>)
    984e:	1c19      	adds	r1, r3, #0
    9850:	4b43      	ldr	r3, [pc, #268]	; (9960 <AJ_HandleIntrospectRequest+0x1cc>)
    9852:	4798      	blx	r3
        AJ_MarshalReplyMsg(msg, reply);
    9854:	1c38      	adds	r0, r7, #0
    9856:	9c03      	ldr	r4, [sp, #12]
    9858:	1c21      	adds	r1, r4, #0
    985a:	4b46      	ldr	r3, [pc, #280]	; (9974 <AJ_HandleIntrospectRequest+0x1e0>)
    985c:	4798      	blx	r3
        // Do a partial delivery
        status = AJ_DeliverMsgPartial(reply, context.len + 5);
    985e:	9908      	ldr	r1, [sp, #32]
    9860:	3105      	adds	r1, #5
    9862:	1c20      	adds	r0, r4, #0
    9864:	4b44      	ldr	r3, [pc, #272]	; (9978 <AJ_HandleIntrospectRequest+0x1e4>)
    9866:	4798      	blx	r3
    9868:	1e03      	subs	r3, r0, #0
        // Marshal the string length
        if (status == AJ_OK) 
    986a:	d168      	bne.n	993e <AJ_HandleIntrospectRequest+0x1aa>
		{
            status = AJ_MarshalRaw(reply, &context.len, 4);
    986c:	9c03      	ldr	r4, [sp, #12]
    986e:	1c20      	adds	r0, r4, #0
    9870:	a908      	add	r1, sp, #32
    9872:	2204      	movs	r2, #4
    9874:	4b41      	ldr	r3, [pc, #260]	; (997c <AJ_HandleIntrospectRequest+0x1e8>)
    9876:	4798      	blx	r3
    9878:	1e03      	subs	r3, r0, #0
        }
	//	printf("AJ_HandleIntrospectRequest(): AJ_MarshalRaw end\n");
        if (status == AJ_OK) 
    987a:	d160      	bne.n	993e <AJ_HandleIntrospectRequest+0x1aa>
		{
            uint8_t nul = 0;
    987c:	2300      	movs	r3, #0
    987e:	220b      	movs	r2, #11
    9880:	a904      	add	r1, sp, #16
    9882:	468c      	mov	ip, r1
    9884:	4462      	add	r2, ip
    9886:	7013      	strb	r3, [r2, #0]
            context.status = AJ_OK;
    9888:	aa07      	add	r2, sp, #28
    988a:	7213      	strb	r3, [r2, #8]
            context.reply = reply;
    988c:	9407      	str	r4, [sp, #28]

            if (children > 0) 
    988e:	2d00      	cmp	r5, #0
    9890:	d00b      	beq.n	98aa <AJ_HandleIntrospectRequest+0x116>
			{
				printf("AJ_HandleIntrospectRequest(): children > 0\n");
    9892:	483b      	ldr	r0, [pc, #236]	; (9980 <AJ_HandleIntrospectRequest+0x1ec>)
    9894:	4b3b      	ldr	r3, [pc, #236]	; (9984 <AJ_HandleIntrospectRequest+0x1f0>)
    9896:	4798      	blx	r3
                GenXML(WriteXML, &context, NULL, &virtualObject, languageTag);
    9898:	9b04      	ldr	r3, [sp, #16]
    989a:	9300      	str	r3, [sp, #0]
    989c:	483a      	ldr	r0, [pc, #232]	; (9988 <AJ_HandleIntrospectRequest+0x1f4>)
    989e:	a907      	add	r1, sp, #28
    98a0:	2200      	movs	r2, #0
    98a2:	ab0a      	add	r3, sp, #40	; 0x28
    98a4:	4c39      	ldr	r4, [pc, #228]	; (998c <AJ_HandleIntrospectRequest+0x1f8>)
    98a6:	47a0      	blx	r4
    98a8:	e007      	b.n	98ba <AJ_HandleIntrospectRequest+0x126>
            } 
			else 
			{
		//		printf("AJ_HandleIntrospectRequest(): children == 0\n");
                GenXML(WriteXML, &context, &objIter, NULL, languageTag);
    98aa:	9b04      	ldr	r3, [sp, #16]
    98ac:	9300      	str	r3, [sp, #0]
    98ae:	4836      	ldr	r0, [pc, #216]	; (9988 <AJ_HandleIntrospectRequest+0x1f4>)
    98b0:	a907      	add	r1, sp, #28
    98b2:	aa0e      	add	r2, sp, #56	; 0x38
    98b4:	2300      	movs	r3, #0
    98b6:	4c35      	ldr	r4, [pc, #212]	; (998c <AJ_HandleIntrospectRequest+0x1f8>)
    98b8:	47a0      	blx	r4
            }
            status = context.status;
    98ba:	ab07      	add	r3, sp, #28
    98bc:	7a1c      	ldrb	r4, [r3, #8]
			printf("AJ_HandleIntrospectRequest(): 2 status=%s\n", AJ_StatusText(status));
    98be:	1c20      	adds	r0, r4, #0
    98c0:	4b25      	ldr	r3, [pc, #148]	; (9958 <AJ_HandleIntrospectRequest+0x1c4>)
    98c2:	4798      	blx	r3
    98c4:	1c01      	adds	r1, r0, #0
    98c6:	4832      	ldr	r0, [pc, #200]	; (9990 <AJ_HandleIntrospectRequest+0x1fc>)
    98c8:	4b25      	ldr	r3, [pc, #148]	; (9960 <AJ_HandleIntrospectRequest+0x1cc>)
    98ca:	4798      	blx	r3
            if (status == AJ_OK) 
    98cc:	2c00      	cmp	r4, #0
    98ce:	d108      	bne.n	98e2 <AJ_HandleIntrospectRequest+0x14e>
			{
                // Marshal the terminating NUL
                status = AJ_MarshalRaw(reply, &nul, 1);
    98d0:	9803      	ldr	r0, [sp, #12]
    98d2:	210b      	movs	r1, #11
    98d4:	ab04      	add	r3, sp, #16
    98d6:	469c      	mov	ip, r3
    98d8:	4461      	add	r1, ip
    98da:	2201      	movs	r2, #1
    98dc:	4b27      	ldr	r3, [pc, #156]	; (997c <AJ_HandleIntrospectRequest+0x1e8>)
    98de:	4798      	blx	r3
    98e0:	1c04      	adds	r4, r0, #0
    98e2:	1c23      	adds	r3, r4, #0
    98e4:	e02b      	b.n	993e <AJ_HandleIntrospectRequest+0x1aa>
        }
    } 
	else
	{
        // Return a ServiceUnknown error response
        printf("AJ_HandleIntrospectRequest() NO MATCH for %s\n", msg->objPath);
    98e6:	482b      	ldr	r0, [pc, #172]	; (9994 <AJ_HandleIntrospectRequest+0x200>)
    98e8:	68b9      	ldr	r1, [r7, #8]
    98ea:	4b1d      	ldr	r3, [pc, #116]	; (9960 <AJ_HandleIntrospectRequest+0x1cc>)
    98ec:	4798      	blx	r3
        AJ_MarshalErrorMsg(msg, reply, AJ_ErrServiceUnknown);
    98ee:	1c38      	adds	r0, r7, #0
    98f0:	9903      	ldr	r1, [sp, #12]
    98f2:	4a29      	ldr	r2, [pc, #164]	; (9998 <AJ_HandleIntrospectRequest+0x204>)
    98f4:	4b29      	ldr	r3, [pc, #164]	; (999c <AJ_HandleIntrospectRequest+0x208>)
    98f6:	4798      	blx	r3
    }
}

AJ_Status AJ_HandleIntrospectRequest(const AJ_Message* msg, AJ_Message* reply, const char* languageTag)
{
    AJ_Status status = AJ_OK;
    98f8:	2300      	movs	r3, #0
    98fa:	e020      	b.n	993e <AJ_HandleIntrospectRequest+0x1aa>
        obj = AJ_NextObject(&objIter);
    }
    if (obj != NULL && obj->path != NULL) 
	{
        // First pass computes the size of the XML string
        context.len = 0;
    98fc:	2300      	movs	r3, #0
    98fe:	9308      	str	r3, [sp, #32]
        if (children > 0) 
		{
            status = GenXML(SizeXML, &context.len, NULL, &virtualObject, languageTag);
    9900:	9b04      	ldr	r3, [sp, #16]
    9902:	9300      	str	r3, [sp, #0]
    9904:	4826      	ldr	r0, [pc, #152]	; (99a0 <AJ_HandleIntrospectRequest+0x20c>)
    9906:	a908      	add	r1, sp, #32
    9908:	2200      	movs	r2, #0
    990a:	ab0a      	add	r3, sp, #40	; 0x28
    990c:	4c1f      	ldr	r4, [pc, #124]	; (998c <AJ_HandleIntrospectRequest+0x1f8>)
    990e:	47a0      	blx	r4
    9910:	1c04      	adds	r4, r0, #0
    9912:	e77d      	b.n	9810 <AJ_HandleIntrospectRequest+0x7c>
            obj = &virtualObject;
            break;
        }
        obj = AJ_NextObject(&objIter);
    }
    if (obj != NULL && obj->path != NULL) 
    9914:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9916:	2b00      	cmp	r3, #0
    9918:	d1f0      	bne.n	98fc <AJ_HandleIntrospectRequest+0x168>
    991a:	e7e4      	b.n	98e6 <AJ_HandleIntrospectRequest+0x152>
	{
        // First pass computes the size of the XML string
        context.len = 0;
    991c:	2300      	movs	r3, #0
    991e:	9308      	str	r3, [sp, #32]
		{
            status = GenXML(SizeXML, &context.len, NULL, &virtualObject, languageTag);
        } 
		else 
		{
            status = GenXML(SizeXML, &context.len, &objIter, NULL, languageTag);
    9920:	9b04      	ldr	r3, [sp, #16]
    9922:	9300      	str	r3, [sp, #0]
    9924:	481e      	ldr	r0, [pc, #120]	; (99a0 <AJ_HandleIntrospectRequest+0x20c>)
    9926:	a908      	add	r1, sp, #32
    9928:	aa0e      	add	r2, sp, #56	; 0x38
    992a:	2300      	movs	r3, #0
    992c:	4c17      	ldr	r4, [pc, #92]	; (998c <AJ_HandleIntrospectRequest+0x1f8>)
    992e:	47a0      	blx	r4
    9930:	1c04      	adds	r4, r0, #0
    9932:	2500      	movs	r5, #0
    9934:	e76c      	b.n	9810 <AJ_HandleIntrospectRequest+0x7c>
            obj = &virtualObject;
            break;
        }
        obj = AJ_NextObject(&objIter);
    }
    if (obj != NULL && obj->path != NULL) 
    9936:	6823      	ldr	r3, [r4, #0]
    9938:	2b00      	cmp	r3, #0
    993a:	d1ef      	bne.n	991c <AJ_HandleIntrospectRequest+0x188>
    993c:	e7d3      	b.n	98e6 <AJ_HandleIntrospectRequest+0x152>
        // Return a ServiceUnknown error response
        printf("AJ_HandleIntrospectRequest() NO MATCH for %s\n", msg->objPath);
        AJ_MarshalErrorMsg(msg, reply, AJ_ErrServiceUnknown);
    }
    return status;
}
    993e:	1c18      	adds	r0, r3, #0
    9940:	b010      	add	sp, #64	; 0x40
    9942:	bc1c      	pop	{r2, r3, r4}
    9944:	4691      	mov	r9, r2
    9946:	469a      	mov	sl, r3
    9948:	46a3      	mov	fp, r4
    994a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    994c:	00008aad 	.word	0x00008aad
    9950:	00017137 	.word	0x00017137
    9954:	00008171 	.word	0x00008171
    9958:	000063c5 	.word	0x000063c5
    995c:	0001cf0c 	.word	0x0001cf0c
    9960:	00016e3d 	.word	0x00016e3d
    9964:	0001ca4c 	.word	0x0001ca4c
    9968:	0000636d 	.word	0x0000636d
    996c:	0001cf38 	.word	0x0001cf38
    9970:	0001cf7c 	.word	0x0001cf7c
    9974:	0000bd45 	.word	0x0000bd45
    9978:	0000b701 	.word	0x0000b701
    997c:	0000b82d 	.word	0x0000b82d
    9980:	0001cfac 	.word	0x0001cfac
    9984:	00016f5d 	.word	0x00016f5d
    9988:	0000884d 	.word	0x0000884d
    998c:	00009341 	.word	0x00009341
    9990:	0001cfd8 	.word	0x0001cfd8
    9994:	0001d004 	.word	0x0001d004
    9998:	0001eab0 	.word	0x0001eab0
    999c:	0000be55 	.word	0x0000be55
    99a0:	0000882d 	.word	0x0000882d

000099a4 <AJ_SetBusLinkTimeout>:

AJ_Status AJ_SetBusLinkTimeout(AJ_BusAttachment* bus, uint32_t timeout)
{
    if (!timeout) 
	{
        return AJ_ERR_FAILURE;
    99a4:	2013      	movs	r0, #19
static uint32_t busLinkTimeout;          /**< Timeout value for the link to the daemon bus */
static AJ_BusLinkWatcher busLinkWatcher; /**< Data structure that maintains information for tracking the link to the daemon bus */

AJ_Status AJ_SetBusLinkTimeout(AJ_BusAttachment* bus, uint32_t timeout)
{
    if (!timeout) 
    99a6:	2900      	cmp	r1, #0
    99a8:	d008      	beq.n	99bc <AJ_SetBusLinkTimeout+0x18>
	{
        return AJ_ERR_FAILURE;
    }
    timeout = (timeout > AJ_MIN_BUS_LINK_TIMEOUT) ? timeout : AJ_MIN_BUS_LINK_TIMEOUT;
    99aa:	2928      	cmp	r1, #40	; 0x28
    99ac:	d200      	bcs.n	99b0 <AJ_SetBusLinkTimeout+0xc>
    99ae:	2128      	movs	r1, #40	; 0x28
    busLinkTimeout = timeout * 1000;
    99b0:	23fa      	movs	r3, #250	; 0xfa
    99b2:	009b      	lsls	r3, r3, #2
    99b4:	4359      	muls	r1, r3
    99b6:	4b02      	ldr	r3, [pc, #8]	; (99c0 <AJ_SetBusLinkTimeout+0x1c>)
    99b8:	6019      	str	r1, [r3, #0]
    return AJ_OK;
    99ba:	2000      	movs	r0, #0
}
    99bc:	4770      	bx	lr
    99be:	46c0      	nop			; (mov r8, r8)
    99c0:	20000964 	.word	0x20000964

000099c4 <AJ_NotifyLinkActive>:
    return status;
}

void AJ_NotifyLinkActive()
{
    memset(&busLinkWatcher, 0, sizeof(AJ_BusLinkWatcher));
    99c4:	4b03      	ldr	r3, [pc, #12]	; (99d4 <AJ_NotifyLinkActive+0x10>)
    99c6:	2200      	movs	r2, #0
    99c8:	601a      	str	r2, [r3, #0]
    99ca:	605a      	str	r2, [r3, #4]
    99cc:	609a      	str	r2, [r3, #8]
    99ce:	60da      	str	r2, [r3, #12]
    99d0:	611a      	str	r2, [r3, #16]
}
    99d2:	4770      	bx	lr
    99d4:	20000968 	.word	0x20000968

000099d8 <PadForType>:

// Returns the number of bytes of padding to align the type
static uint32_t PadForType(char typeId, AJ_IOBuffer* ioBuf)
{
   uint8_t* base;
   if(ioBuf->direction == AJ_IO_BUF_RX)
    99d8:	780b      	ldrb	r3, [r1, #0]
    99da:	2b01      	cmp	r3, #1
    99dc:	d101      	bne.n	99e2 <PadForType+0xa>
   {
	  base= ioBuf->readPtr;
    99de:	688b      	ldr	r3, [r1, #8]
    99e0:	e000      	b.n	99e4 <PadForType+0xc>
   }
   else
   {
	   base=ioBuf->writePtr;
    99e2:	68cb      	ldr	r3, [r1, #12]
    }
    uint32_t offset = (uint32_t)(base - ioBuf->bufStart);
    99e4:	6849      	ldr	r1, [r1, #4]
    99e6:	1a59      	subs	r1, r3, r1
    uint32_t alignment = ALIGNMENT(typeId);
    99e8:	1c03      	adds	r3, r0, #0
    99ea:	3b28      	subs	r3, #40	; 0x28
    99ec:	2b01      	cmp	r3, #1
    99ee:	d801      	bhi.n	99f4 <PadForType+0x1c>
    99f0:	1c1a      	adds	r2, r3, #0
    99f2:	e006      	b.n	9a02 <PadForType+0x2a>
    99f4:	221e      	movs	r2, #30
    99f6:	1c03      	adds	r3, r0, #0
    99f8:	3b61      	subs	r3, #97	; 0x61
    99fa:	2b1c      	cmp	r3, #28
    99fc:	d801      	bhi.n	9a02 <PadForType+0x2a>
    99fe:	1c02      	adds	r2, r0, #0
    9a00:	3a5f      	subs	r2, #95	; 0x5f
    9a02:	4b04      	ldr	r3, [pc, #16]	; (9a14 <PadForType+0x3c>)
    9a04:	5c9a      	ldrb	r2, [r3, r2]
    9a06:	230f      	movs	r3, #15
    9a08:	4013      	ands	r3, r2
    return (alignment - offset) & (alignment - 1);
    9a0a:	1e58      	subs	r0, r3, #1
    9a0c:	1a5b      	subs	r3, r3, r1
    9a0e:	4018      	ands	r0, r3
}
    9a10:	4770      	bx	lr
    9a12:	46c0      	nop			; (mov r8, r8)
    9a14:	0001dac0 	.word	0x0001dac0

00009a18 <EndianSwap>:

#define ENDSWAP16(v) (((v) >> 8) | ((v) << 8))
#define ENDSWAP32(v) (((v) >> 24) | (((v) & 0xFF0000) >> 8) | (((v) & 0x00FF00) << 8) | ((v) << 24))

static void EndianSwap(AJ_Message* msg, uint8_t typeId, void* data, uint32_t num)
{
    9a18:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (msg->hdr->endianess != HOST_ENDIANESS) 
    9a1a:	6840      	ldr	r0, [r0, #4]
    9a1c:	7800      	ldrb	r0, [r0, #0]
    9a1e:	286c      	cmp	r0, #108	; 0x6c
    9a20:	d05d      	beq.n	9ade <EndianSwap+0xc6>
	{
        switch (SizeOfType(typeId)) 
    9a22:	1c08      	adds	r0, r1, #0
    9a24:	3828      	subs	r0, #40	; 0x28
    9a26:	2801      	cmp	r0, #1
    9a28:	d801      	bhi.n	9a2e <EndianSwap+0x16>
    9a2a:	1c04      	adds	r4, r0, #0
    9a2c:	e006      	b.n	9a3c <EndianSwap+0x24>
    9a2e:	241e      	movs	r4, #30
    9a30:	1c08      	adds	r0, r1, #0
    9a32:	3861      	subs	r0, #97	; 0x61
    9a34:	281c      	cmp	r0, #28
    9a36:	d801      	bhi.n	9a3c <EndianSwap+0x24>
    9a38:	395f      	subs	r1, #95	; 0x5f
    9a3a:	1c0c      	adds	r4, r1, #0
    9a3c:	4928      	ldr	r1, [pc, #160]	; (9ae0 <EndianSwap+0xc8>)
    9a3e:	5d09      	ldrb	r1, [r1, r4]
    9a40:	200f      	movs	r0, #15
    9a42:	4001      	ands	r1, r0
    9a44:	2904      	cmp	r1, #4
    9a46:	d008      	beq.n	9a5a <EndianSwap+0x42>
    9a48:	2908      	cmp	r1, #8
    9a4a:	d002      	beq.n	9a52 <EndianSwap+0x3a>
    9a4c:	2902      	cmp	r1, #2
    9a4e:	d146      	bne.n	9ade <EndianSwap+0xc6>
    9a50:	e007      	b.n	9a62 <EndianSwap+0x4a>
            break;

        case 8:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
    9a52:	1e58      	subs	r0, r3, #1
    9a54:	2b00      	cmp	r3, #0
    9a56:	d123      	bne.n	9aa0 <EndianSwap+0x88>
    9a58:	e041      	b.n	9ade <EndianSwap+0xc6>
            break;

        case 4:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
    9a5a:	1e5c      	subs	r4, r3, #1
    9a5c:	2b00      	cmp	r3, #0
    9a5e:	d10c      	bne.n	9a7a <EndianSwap+0x62>
    9a60:	e03d      	b.n	9ade <EndianSwap+0xc6>
        switch (SizeOfType(typeId)) 
		{
        case 2:
            {
                uint16_t* p = (uint16_t*)data;
                while (num--) 
    9a62:	1e59      	subs	r1, r3, #1
    9a64:	2b00      	cmp	r3, #0
    9a66:	d03a      	beq.n	9ade <EndianSwap+0xc6>
				{
                    uint16_t v = *p;
    9a68:	8813      	ldrh	r3, [r2, #0]
                    *p++ = ENDSWAP16(v);
    9a6a:	0218      	lsls	r0, r3, #8
    9a6c:	0a1b      	lsrs	r3, r3, #8
    9a6e:	4303      	orrs	r3, r0
    9a70:	8013      	strh	r3, [r2, #0]
    9a72:	3202      	adds	r2, #2
        switch (SizeOfType(typeId)) 
		{
        case 2:
            {
                uint16_t* p = (uint16_t*)data;
                while (num--) 
    9a74:	3901      	subs	r1, #1
    9a76:	d2f7      	bcs.n	9a68 <EndianSwap+0x50>
    9a78:	e031      	b.n	9ade <EndianSwap+0xc6>
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
				{
                    uint32_t v = *p;
                    *p++ = ENDSWAP32(v);
    9a7a:	26ff      	movs	r6, #255	; 0xff
    9a7c:	0436      	lsls	r6, r6, #16
    9a7e:	25ff      	movs	r5, #255	; 0xff
    9a80:	022d      	lsls	r5, r5, #8
        case 4:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
				{
                    uint32_t v = *p;
    9a82:	6813      	ldr	r3, [r2, #0]
                    *p++ = ENDSWAP32(v);
    9a84:	0618      	lsls	r0, r3, #24
    9a86:	0e19      	lsrs	r1, r3, #24
    9a88:	4301      	orrs	r1, r0
    9a8a:	1c18      	adds	r0, r3, #0
    9a8c:	4030      	ands	r0, r6
    9a8e:	0a00      	lsrs	r0, r0, #8
    9a90:	4301      	orrs	r1, r0
    9a92:	402b      	ands	r3, r5
    9a94:	021b      	lsls	r3, r3, #8
    9a96:	430b      	orrs	r3, r1
    9a98:	c208      	stmia	r2!, {r3}
            break;

        case 4:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
    9a9a:	3c01      	subs	r4, #1
    9a9c:	d2f1      	bcs.n	9a82 <EndianSwap+0x6a>
    9a9e:	e01e      	b.n	9ade <EndianSwap+0xc6>
                uint32_t* p = (uint32_t*)data;
                while (num--) 
				{
                    uint32_t v = p[0];
                    uint32_t u = p[1];
                    *p++ = ENDSWAP32(u);
    9aa0:	25ff      	movs	r5, #255	; 0xff
    9aa2:	042d      	lsls	r5, r5, #16
    9aa4:	24ff      	movs	r4, #255	; 0xff
    9aa6:	0224      	lsls	r4, r4, #8
        case 8:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
				{
                    uint32_t v = p[0];
    9aa8:	6813      	ldr	r3, [r2, #0]
                    uint32_t u = p[1];
    9aaa:	6851      	ldr	r1, [r2, #4]
                    *p++ = ENDSWAP32(u);
    9aac:	060f      	lsls	r7, r1, #24
    9aae:	0e0e      	lsrs	r6, r1, #24
    9ab0:	433e      	orrs	r6, r7
    9ab2:	1c0f      	adds	r7, r1, #0
    9ab4:	402f      	ands	r7, r5
    9ab6:	0a3f      	lsrs	r7, r7, #8
    9ab8:	433e      	orrs	r6, r7
    9aba:	4021      	ands	r1, r4
    9abc:	0209      	lsls	r1, r1, #8
    9abe:	4331      	orrs	r1, r6
    9ac0:	6011      	str	r1, [r2, #0]
                    *p++ = ENDSWAP32(v);
    9ac2:	061e      	lsls	r6, r3, #24
    9ac4:	0e19      	lsrs	r1, r3, #24
    9ac6:	4331      	orrs	r1, r6
    9ac8:	1c1e      	adds	r6, r3, #0
    9aca:	402e      	ands	r6, r5
    9acc:	0a36      	lsrs	r6, r6, #8
    9ace:	4331      	orrs	r1, r6
    9ad0:	4023      	ands	r3, r4
    9ad2:	021b      	lsls	r3, r3, #8
    9ad4:	430b      	orrs	r3, r1
    9ad6:	6053      	str	r3, [r2, #4]
    9ad8:	3208      	adds	r2, #8
            break;

        case 8:
            {
                uint32_t* p = (uint32_t*)data;
                while (num--) 
    9ada:	3801      	subs	r0, #1
    9adc:	d2e4      	bcs.n	9aa8 <EndianSwap+0x90>
                }
            }
            break;
        }
    }
}
    9ade:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9ae0:	0001dac0 	.word	0x0001dac0

00009ae4 <MessageRequiresLongerCryptoValues>:
    return sizeof(AJ_MsgHeader) + ((msg->hdr->headerLen + 7) & 0xFFFFFFF8) + msg->hdr->bodyLen;
}

static uint32_t MessageRequiresLongerCryptoValues(AJ_Message* msg, uint32_t versionCheck)
{
    return ((versionCheck <= (msg->authVersion >> 16)) &&              // version
    9ae4:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    9ae6:	2300      	movs	r3, #0
    9ae8:	428a      	cmp	r2, r1
    9aea:	d307      	bcc.n	9afc <MessageRequiresLongerCryptoValues+0x18>
    9aec:	6843      	ldr	r3, [r0, #4]
    9aee:	785a      	ldrb	r2, [r3, #1]
    9af0:	2301      	movs	r3, #1
    9af2:	2a04      	cmp	r2, #4
    9af4:	d102      	bne.n	9afc <MessageRequiresLongerCryptoValues+0x18>
            !((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination));  // rollback for multicast/broadcast
    9af6:	6983      	ldr	r3, [r0, #24]
    return sizeof(AJ_MsgHeader) + ((msg->hdr->headerLen + 7) & 0xFFFFFFF8) + msg->hdr->bodyLen;
}

static uint32_t MessageRequiresLongerCryptoValues(AJ_Message* msg, uint32_t versionCheck)
{
    return ((versionCheck <= (msg->authVersion >> 16)) &&              // version
    9af8:	1e58      	subs	r0, r3, #1
    9afa:	4183      	sbcs	r3, r0
            !((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination));  // rollback for multicast/broadcast
}
    9afc:	1c18      	adds	r0, r3, #0
    9afe:	4770      	bx	lr

00009b00 <CompleteTypeSigLen>:
    return status;
}

// Get the length of the signature of the first complete type in sig
static uint8_t CompleteTypeSigLen(const char* sig)
{
    9b00:	1c02      	adds	r2, r0, #0
    9b02:	2100      	movs	r1, #0
    if (sig) 
    9b04:	2800      	cmp	r0, #0
    9b06:	d115      	bne.n	9b34 <CompleteTypeSigLen+0x34>
    9b08:	e01b      	b.n	9b42 <CompleteTypeSigLen+0x42>
	{
        const char* start = sig;
        int32_t open = 0;
        while (*sig) 
		{
            char typeId = *sig++;
    9b0a:	3201      	adds	r2, #1
            if (typeId == AJ_STRUCT_CLOSE || typeId == AJ_DICT_ENTRY_CLOSE) 
    9b0c:	2b29      	cmp	r3, #41	; 0x29
    9b0e:	d001      	beq.n	9b14 <CompleteTypeSigLen+0x14>
    9b10:	2b7d      	cmp	r3, #125	; 0x7d
    9b12:	d105      	bne.n	9b20 <CompleteTypeSigLen+0x20>
			{
                if (!open) 
    9b14:	2900      	cmp	r1, #0
    9b16:	d013      	beq.n	9b40 <CompleteTypeSigLen+0x40>
				{
                    return 0;
                }
                --open;
    9b18:	3901      	subs	r1, #1
                if (!open)
    9b1a:	2900      	cmp	r1, #0
    9b1c:	d10a      	bne.n	9b34 <CompleteTypeSigLen+0x34>
    9b1e:	e00c      	b.n	9b3a <CompleteTypeSigLen+0x3a>
				{
                    break;
                }
            } 
			else 
			   if (typeId == AJ_ARG_STRUCT || typeId == AJ_ARG_DICT_ENTRY) 
    9b20:	2b28      	cmp	r3, #40	; 0x28
    9b22:	d001      	beq.n	9b28 <CompleteTypeSigLen+0x28>
    9b24:	2b7b      	cmp	r3, #123	; 0x7b
    9b26:	d101      	bne.n	9b2c <CompleteTypeSigLen+0x2c>
			   {
                   ++open;
    9b28:	3101      	adds	r1, #1
    9b2a:	e003      	b.n	9b34 <CompleteTypeSigLen+0x34>
               } 
			   else 
			      if (!open && typeId != AJ_ARG_ARRAY) 
    9b2c:	2900      	cmp	r1, #0
    9b2e:	d101      	bne.n	9b34 <CompleteTypeSigLen+0x34>
    9b30:	2b61      	cmp	r3, #97	; 0x61
    9b32:	d102      	bne.n	9b3a <CompleteTypeSigLen+0x3a>
{
    if (sig) 
	{
        const char* start = sig;
        int32_t open = 0;
        while (*sig) 
    9b34:	7813      	ldrb	r3, [r2, #0]
    9b36:	2b00      	cmp	r3, #0
    9b38:	d1e7      	bne.n	9b0a <CompleteTypeSigLen+0xa>
			      if (!open && typeId != AJ_ARG_ARRAY) 
				  {
                     break;
                  }
        }
        return (uint8_t)(sig - start);
    9b3a:	1a10      	subs	r0, r2, r0
    9b3c:	b2c0      	uxtb	r0, r0
    9b3e:	e000      	b.n	9b42 <CompleteTypeSigLen+0x42>
            char typeId = *sig++;
            if (typeId == AJ_STRUCT_CLOSE || typeId == AJ_DICT_ENTRY_CLOSE) 
			{
                if (!open) 
				{
                    return 0;
    9b40:	2000      	movs	r0, #0
    } 
	else
	{
        return 0;
    }
}
    9b42:	4770      	bx	lr

00009b44 <WriteBytes>:

/*
 * Write bytes to an I/O buffer
 */
static AJ_Status WriteBytes(AJ_Message* msg, const void* data, size_t numBytes, size_t pad)
{
    9b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9b46:	465f      	mov	r7, fp
    9b48:	4656      	mov	r6, sl
    9b4a:	464d      	mov	r5, r9
    9b4c:	4644      	mov	r4, r8
    9b4e:	b4f0      	push	{r4, r5, r6, r7}
    9b50:	4681      	mov	r9, r0
    9b52:	468b      	mov	fp, r1
    9b54:	1c15      	adds	r5, r2, #0
    9b56:	1c1e      	adds	r6, r3, #0
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    9b58:	6b04      	ldr	r4, [r0, #48]	; 0x30
    9b5a:	2318      	movs	r3, #24
    9b5c:	469a      	mov	sl, r3
    9b5e:	44a2      	add	sl, r4
    if (numBytes && !data) 
    9b60:	2a00      	cmp	r2, #0
    9b62:	d104      	bne.n	9b6e <WriteBytes+0x2a>
	{
    //    printf("WriteBytes(): AJ_ERR_NULL\n");
        return AJ_ERR_NULL;
    }
//	printf("WriteBytes(): numBytes= %d, pad = %d  \n",numBytes,pad);
    while (numBytes + pad)
    9b64:	19a9      	adds	r1, r5, r6
    9b66:	2000      	movs	r0, #0
    9b68:	2900      	cmp	r1, #0
    9b6a:	d03e      	beq.n	9bea <WriteBytes+0xa6>
    9b6c:	e002      	b.n	9b74 <WriteBytes+0x30>
 */
static AJ_Status WriteBytes(AJ_Message* msg, const void* data, size_t numBytes, size_t pad)
{
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    if (numBytes && !data) 
    9b6e:	2900      	cmp	r1, #0
    9b70:	d1f8      	bne.n	9b64 <WriteBytes+0x20>
    9b72:	e037      	b.n	9be4 <WriteBytes+0xa0>
        }
        if (numBytes < canWrite) 
		{
            canWrite = numBytes;
        }
        memcpy(ioBuf->writePtr, data, canWrite);
    9b74:	4b20      	ldr	r3, [pc, #128]	; (9bf8 <WriteBytes+0xb4>)
    9b76:	4698      	mov	r8, r3
        return AJ_ERR_NULL;
    }
//	printf("WriteBytes(): numBytes= %d, pad = %d  \n",numBytes,pad);
    while (numBytes + pad)
	{
        size_t canWrite = AJ_IO_BUF_SPACE(ioBuf);
    9b78:	8b62      	ldrh	r2, [r4, #26]
    9b7a:	69e3      	ldr	r3, [r4, #28]
    9b7c:	6a60      	ldr	r0, [r4, #36]	; 0x24
    9b7e:	1a1b      	subs	r3, r3, r0
    9b80:	18d2      	adds	r2, r2, r3
	//	printf("WriteBytes(): canWrite = %d, numBytes= %d, pad = %d  \n",canWrite,numBytes,pad);
        if ((numBytes + pad) > canWrite) 
    9b82:	428a      	cmp	r2, r1
    9b84:	d210      	bcs.n	9ba8 <WriteBytes+0x64>
		{
            // If we have already marshaled the header we can write what we have in the buffer
            if (msg->hdr) 
    9b86:	464b      	mov	r3, r9
    9b88:	685b      	ldr	r3, [r3, #4]
    9b8a:	2b00      	cmp	r3, #0
    9b8c:	d12c      	bne.n	9be8 <WriteBytes+0xa4>
                status = AJ_ERR_RESOURCES;
            }
			else
			{
                //#pragma calls = AJ_Net_Send
				printf("-----Send data------\n");
    9b8e:	481b      	ldr	r0, [pc, #108]	; (9bfc <WriteBytes+0xb8>)
    9b90:	4b1b      	ldr	r3, [pc, #108]	; (9c00 <WriteBytes+0xbc>)
    9b92:	4798      	blx	r3
			//	printf("WriteBytes(): canWrite = %d, numBytes= %d, pad = %d  \n",canWrite,numBytes,pad);
                status = ioBuf->send(ioBuf);
    9b94:	4650      	mov	r0, sl
    9b96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b98:	4798      	blx	r3
            }
            if (status != AJ_OK) 
    9b9a:	2800      	cmp	r0, #0
    9b9c:	d125      	bne.n	9bea <WriteBytes+0xa6>
			{
		//		printf("WriteBytes(): break\n");
                break;
            }
            canWrite = AJ_IO_BUF_SPACE(ioBuf);
    9b9e:	8b62      	ldrh	r2, [r4, #26]
    9ba0:	69e3      	ldr	r3, [r4, #28]
    9ba2:	6a61      	ldr	r1, [r4, #36]	; 0x24
    9ba4:	1a5b      	subs	r3, r3, r1
    9ba6:	18d2      	adds	r2, r2, r3
        }
	//	 printf("WriteBytes(): while pad\n");
        // Write pad bytes
        while (pad) 
    9ba8:	2e00      	cmp	r6, #0
    9baa:	d009      	beq.n	9bc0 <WriteBytes+0x7c>
    9bac:	1c33      	adds	r3, r6, #0
		{
            *ioBuf->writePtr++ = 0;
    9bae:	2700      	movs	r7, #0
    9bb0:	6a61      	ldr	r1, [r4, #36]	; 0x24
    9bb2:	1c48      	adds	r0, r1, #1
    9bb4:	6260      	str	r0, [r4, #36]	; 0x24
    9bb6:	700f      	strb	r7, [r1, #0]
            --canWrite;
            --pad;
    9bb8:	3b01      	subs	r3, #1
            }
            canWrite = AJ_IO_BUF_SPACE(ioBuf);
        }
	//	 printf("WriteBytes(): while pad\n");
        // Write pad bytes
        while (pad) 
    9bba:	2b00      	cmp	r3, #0
    9bbc:	d1f8      	bne.n	9bb0 <WriteBytes+0x6c>
    9bbe:	1b92      	subs	r2, r2, r6
    9bc0:	1e16      	subs	r6, r2, #0
    9bc2:	42ae      	cmp	r6, r5
    9bc4:	d900      	bls.n	9bc8 <WriteBytes+0x84>
    9bc6:	1c2e      	adds	r6, r5, #0
        }
        if (numBytes < canWrite) 
		{
            canWrite = numBytes;
        }
        memcpy(ioBuf->writePtr, data, canWrite);
    9bc8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    9bca:	4659      	mov	r1, fp
    9bcc:	1c32      	adds	r2, r6, #0
    9bce:	47c0      	blx	r8
        data = (uint8_t*)data + canWrite;
    9bd0:	44b3      	add	fp, r6
        ioBuf->writePtr += canWrite;
    9bd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    9bd4:	199b      	adds	r3, r3, r6
    9bd6:	6263      	str	r3, [r4, #36]	; 0x24
        numBytes -= canWrite;
    9bd8:	1bad      	subs	r5, r5, r6
    9bda:	2600      	movs	r6, #0
	{
    //    printf("WriteBytes(): AJ_ERR_NULL\n");
        return AJ_ERR_NULL;
    }
//	printf("WriteBytes(): numBytes= %d, pad = %d  \n",numBytes,pad);
    while (numBytes + pad)
    9bdc:	1e29      	subs	r1, r5, #0
    9bde:	d1cb      	bne.n	9b78 <WriteBytes+0x34>
    9be0:	2000      	movs	r0, #0
    9be2:	e002      	b.n	9bea <WriteBytes+0xa6>
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    if (numBytes && !data) 
	{
    //    printf("WriteBytes(): AJ_ERR_NULL\n");
        return AJ_ERR_NULL;
    9be4:	2001      	movs	r0, #1
    9be6:	e000      	b.n	9bea <WriteBytes+0xa6>
		{
            // If we have already marshaled the header we can write what we have in the buffer
            if (msg->hdr) 
			{
     //           printf("WriteBytes(): AJ_ERR_RESOURCES\n");
                status = AJ_ERR_RESOURCES;
    9be8:	200b      	movs	r0, #11
        ioBuf->writePtr += canWrite;
        numBytes -= canWrite;
    }
//	 printf("WriteBytes():return\n");
    return status;
}
    9bea:	bc3c      	pop	{r2, r3, r4, r5}
    9bec:	4690      	mov	r8, r2
    9bee:	4699      	mov	r9, r3
    9bf0:	46a2      	mov	sl, r4
    9bf2:	46ab      	mov	fp, r5
    9bf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9bf6:	46c0      	nop			; (mov r8, r8)
    9bf8:	00016739 	.word	0x00016739
    9bfc:	0001d2c0 	.word	0x0001d2c0
    9c00:	00016f5d 	.word	0x00016f5d

00009c04 <LoadBytes>:
    return status;
}

//Make sure we have the required number of bytes in the I/O buffer
static AJ_Status LoadBytes(AJ_IOBuffer* ioBuf, uint16_t numBytes, uint8_t pad, uint32_t* timeout)
{
    9c04:	b5f0      	push	{r4, r5, r6, r7, lr}
    9c06:	464f      	mov	r7, r9
    9c08:	4646      	mov	r6, r8
    9c0a:	b4c0      	push	{r6, r7}
    9c0c:	b083      	sub	sp, #12
    9c0e:	1c05      	adds	r5, r0, #0
    9c10:	1c0c      	adds	r4, r1, #0
    9c12:	4690      	mov	r8, r2
    9c14:	1c1f      	adds	r7, r3, #0
    AJ_Status status = AJ_OK;
    AJ_Time msgTimer;

    AJ_InitTimer(&msgTimer);
    9c16:	4668      	mov	r0, sp
    9c18:	4b2a      	ldr	r3, [pc, #168]	; (9cc4 <LoadBytes+0xc0>)
    9c1a:	4798      	blx	r3
    numBytes += pad;
    9c1c:	4444      	add	r4, r8
    9c1e:	b2a3      	uxth	r3, r4
    9c20:	4699      	mov	r9, r3
    // Needs to be enough headroom in the buffer to satisfy the read
    if (numBytes > (ioBuf->bufSize - AJ_IO_BUF_CONSUMED(ioBuf))) 
    9c22:	1c1e      	adds	r6, r3, #0
    9c24:	686b      	ldr	r3, [r5, #4]
    9c26:	68aa      	ldr	r2, [r5, #8]
    9c28:	1a9a      	subs	r2, r3, r2
    9c2a:	886b      	ldrh	r3, [r5, #2]
    9c2c:	18d3      	adds	r3, r2, r3
    9c2e:	2400      	movs	r4, #0
    9c30:	4599      	cmp	r9, r3
    9c32:	d936      	bls.n	9ca2 <LoadBytes+0x9e>
	{
        AJ_ErrPrintf(("LoadBytes(): AJ_ERR_RESOURCES\n"));
    9c34:	2001      	movs	r0, #1
    9c36:	4924      	ldr	r1, [pc, #144]	; (9cc8 <LoadBytes+0xc4>)
    9c38:	4a24      	ldr	r2, [pc, #144]	; (9ccc <LoadBytes+0xc8>)
    9c3a:	4b25      	ldr	r3, [pc, #148]	; (9cd0 <LoadBytes+0xcc>)
    9c3c:	4798      	blx	r3
    9c3e:	2800      	cmp	r0, #0
    9c40:	d002      	beq.n	9c48 <LoadBytes+0x44>
    9c42:	4824      	ldr	r0, [pc, #144]	; (9cd4 <LoadBytes+0xd0>)
    9c44:	4b24      	ldr	r3, [pc, #144]	; (9cd8 <LoadBytes+0xd4>)
    9c46:	4798      	blx	r3
		printf("LoadBytes(): numBytes=%d,ioBuf->bufSize - AJ_IO_BUF_CONSUMED(ioBuf)=%d \n",numBytes,(ioBuf->bufSize - AJ_IO_BUF_CONSUMED(ioBuf)));
    9c48:	686b      	ldr	r3, [r5, #4]
    9c4a:	68aa      	ldr	r2, [r5, #8]
    9c4c:	1a9a      	subs	r2, r3, r2
    9c4e:	886b      	ldrh	r3, [r5, #2]
    9c50:	18d2      	adds	r2, r2, r3
    9c52:	4822      	ldr	r0, [pc, #136]	; (9cdc <LoadBytes+0xd8>)
    9c54:	4649      	mov	r1, r9
    9c56:	4b22      	ldr	r3, [pc, #136]	; (9ce0 <LoadBytes+0xdc>)
    9c58:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    9c5a:	200b      	movs	r0, #11
    9c5c:	e02d      	b.n	9cba <LoadBytes+0xb6>
    //AJ_InfoPrintf(("LoadBytes(): Start loop numBytes=%u, ioBufBytes=%u\n", numBytes, AJ_IO_BUF_AVAIL(ioBuf)));
    while (AJ_IO_BUF_AVAIL(ioBuf) < numBytes) 
	{
        //#pragma calls = AJ_Net_Recv
    //    printf("LoadBytes(): numBytes=%u, ioBufBytes=%u\n", numBytes, AJ_IO_BUF_AVAIL(ioBuf));
        status = ioBuf->recv(ioBuf, numBytes - AJ_IO_BUF_AVAIL(ioBuf), *timeout);
    9c5e:	1a51      	subs	r1, r2, r1
    9c60:	1871      	adds	r1, r6, r1
    9c62:	1c28      	adds	r0, r5, #0
    9c64:	683a      	ldr	r2, [r7, #0]
    9c66:	692b      	ldr	r3, [r5, #16]
    9c68:	4798      	blx	r3
    9c6a:	1e04      	subs	r4, r0, #0

        if (status != AJ_OK) 
    9c6c:	d019      	beq.n	9ca2 <LoadBytes+0x9e>
		{
            // Ignore interrupted recv calls for now we can't handle resumption            
            if (status == AJ_ERR_INTERRUPTED)
    9c6e:	281f      	cmp	r0, #31
    9c70:	d017      	beq.n	9ca2 <LoadBytes+0x9e>
			{
                continue;
            }
            // Timeouts after we have started to unmarshal a message are a bad sign.
            if (status == AJ_ERR_TIMEOUT)
    9c72:	2807      	cmp	r0, #7
    9c74:	d120      	bne.n	9cb8 <LoadBytes+0xb4>
			 {
                // Work around recv implementations that return too soon.
                uint32_t elapsed = AJ_GetElapsedTime(&msgTimer, FALSE);
    9c76:	4668      	mov	r0, sp
    9c78:	2100      	movs	r1, #0
    9c7a:	4b1a      	ldr	r3, [pc, #104]	; (9ce4 <LoadBytes+0xe0>)
    9c7c:	4798      	blx	r3
                if (*timeout > elapsed) 
    9c7e:	683b      	ldr	r3, [r7, #0]
    9c80:	4298      	cmp	r0, r3
    9c82:	d202      	bcs.n	9c8a <LoadBytes+0x86>
				{
                    *timeout -= elapsed;
    9c84:	1a1b      	subs	r3, r3, r0
    9c86:	603b      	str	r3, [r7, #0]
                    continue;
    9c88:	e00b      	b.n	9ca2 <LoadBytes+0x9e>
                }
                AJ_ErrPrintf(("LoadBytes(): AJ_ERR_READ\n"));
    9c8a:	2001      	movs	r0, #1
    9c8c:	490e      	ldr	r1, [pc, #56]	; (9cc8 <LoadBytes+0xc4>)
    9c8e:	4a16      	ldr	r2, [pc, #88]	; (9ce8 <LoadBytes+0xe4>)
    9c90:	4b0f      	ldr	r3, [pc, #60]	; (9cd0 <LoadBytes+0xcc>)
    9c92:	4798      	blx	r3
                status = AJ_ERR_READ;
    9c94:	2405      	movs	r4, #5
                if (*timeout > elapsed) 
				{
                    *timeout -= elapsed;
                    continue;
                }
                AJ_ErrPrintf(("LoadBytes(): AJ_ERR_READ\n"));
    9c96:	2800      	cmp	r0, #0
    9c98:	d00e      	beq.n	9cb8 <LoadBytes+0xb4>
    9c9a:	4814      	ldr	r0, [pc, #80]	; (9cec <LoadBytes+0xe8>)
    9c9c:	4b0e      	ldr	r3, [pc, #56]	; (9cd8 <LoadBytes+0xd4>)
    9c9e:	4798      	blx	r3
    9ca0:	e00a      	b.n	9cb8 <LoadBytes+0xb4>
		printf("LoadBytes(): numBytes=%d,ioBuf->bufSize - AJ_IO_BUF_CONSUMED(ioBuf)=%d \n",numBytes,(ioBuf->bufSize - AJ_IO_BUF_CONSUMED(ioBuf)));
        return AJ_ERR_RESOURCES;
    }

    //AJ_InfoPrintf(("LoadBytes(): Start loop numBytes=%u, ioBufBytes=%u\n", numBytes, AJ_IO_BUF_AVAIL(ioBuf)));
    while (AJ_IO_BUF_AVAIL(ioBuf) < numBytes) 
    9ca2:	68e9      	ldr	r1, [r5, #12]
    9ca4:	68aa      	ldr	r2, [r5, #8]
    9ca6:	1a8b      	subs	r3, r1, r2
    9ca8:	429e      	cmp	r6, r3
    9caa:	d8d8      	bhi.n	9c5e <LoadBytes+0x5a>
    9cac:	1e20      	subs	r0, r4, #0
    }
    /*
     * Skip over pad bytes (The wire protocol says these should be zeroes).
     * Only skip if bytes have actually been read.
     */
    if (status == AJ_OK) 
    9cae:	d104      	bne.n	9cba <LoadBytes+0xb6>
	{
        ioBuf->readPtr += pad;
    9cb0:	4442      	add	r2, r8
    9cb2:	60aa      	str	r2, [r5, #8]
    }
    return status;
    9cb4:	2000      	movs	r0, #0
    9cb6:	e000      	b.n	9cba <LoadBytes+0xb6>
    9cb8:	1c20      	adds	r0, r4, #0
}
    9cba:	b003      	add	sp, #12
    9cbc:	bc0c      	pop	{r2, r3}
    9cbe:	4690      	mov	r8, r2
    9cc0:	4699      	mov	r9, r3
    9cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9cc4:	0000d7ad 	.word	0x0000d7ad
    9cc8:	0001d2d8 	.word	0x0001d2d8
    9ccc:	0000026e 	.word	0x0000026e
    9cd0:	0000636d 	.word	0x0000636d
    9cd4:	0001d300 	.word	0x0001d300
    9cd8:	00016f5d 	.word	0x00016f5d
    9cdc:	0001d320 	.word	0x0001d320
    9ce0:	00016e3d 	.word	0x00016e3d
    9ce4:	0000d769 	.word	0x0000d769
    9ce8:	0000028b 	.word	0x0000028b
    9cec:	0001d36c 	.word	0x0001d36c

00009cf0 <Unmarshal>:
    return status;
}

// Unmarshal a single argument
static AJ_Status Unmarshal(AJ_Message* msg, const char** sig, AJ_Arg* arg)
{
    9cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
    9cf2:	465f      	mov	r7, fp
    9cf4:	4656      	mov	r6, sl
    9cf6:	464d      	mov	r5, r9
    9cf8:	4644      	mov	r4, r8
    9cfa:	b4f0      	push	{r4, r5, r6, r7}
    9cfc:	b085      	sub	sp, #20
    9cfe:	1c06      	adds	r6, r0, #0
    9d00:	1c0f      	adds	r7, r1, #0
    9d02:	9200      	str	r2, [sp, #0]
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    9d04:	6b05      	ldr	r5, [r0, #48]	; 0x30
    char typeId;
    uint32_t pad;
    uint32_t sz;

    memset(arg, 0, sizeof(AJ_Arg));
    9d06:	1c10      	adds	r0, r2, #0
    9d08:	2100      	movs	r1, #0
    9d0a:	2210      	movs	r2, #16
    9d0c:	4ba4      	ldr	r3, [pc, #656]	; (9fa0 <Unmarshal+0x2b0>)
    9d0e:	4798      	blx	r3

    if (!*sig || !**sig) 
    9d10:	683b      	ldr	r3, [r7, #0]
    9d12:	469a      	mov	sl, r3
    9d14:	2b00      	cmp	r3, #0
    9d16:	d100      	bne.n	9d1a <Unmarshal+0x2a>
    9d18:	e133      	b.n	9f82 <Unmarshal+0x292>
    9d1a:	781c      	ldrb	r4, [r3, #0]
	{
   //     printf("Unmarshal(): AJ_ERR_END_OF_DATA\n");
        return AJ_ERR_END_OF_DATA;
    9d1c:	200a      	movs	r0, #10
    uint32_t pad;
    uint32_t sz;

    memset(arg, 0, sizeof(AJ_Arg));

    if (!*sig || !**sig) 
    9d1e:	2c00      	cmp	r4, #0
    9d20:	d100      	bne.n	9d24 <Unmarshal+0x34>
    9d22:	e136      	b.n	9f92 <Unmarshal+0x2a2>

// Unmarshal a single argument
static AJ_Status Unmarshal(AJ_Message* msg, const char** sig, AJ_Arg* arg)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    9d24:	2330      	movs	r3, #48	; 0x30
    9d26:	469c      	mov	ip, r3
    9d28:	44ac      	add	ip, r5
    9d2a:	4663      	mov	r3, ip
    9d2c:	4661      	mov	r1, ip
    9d2e:	9301      	str	r3, [sp, #4]
        return AJ_ERR_END_OF_DATA;
    }

    typeId = **sig;
	//printf("typeId = %d\n",typeId);
    *sig += 1;
    9d30:	4653      	mov	r3, sl
    9d32:	3301      	adds	r3, #1
    9d34:	603b      	str	r3, [r7, #0]
    pad = PadForType(typeId, ioBuf);
    9d36:	1c20      	adds	r0, r4, #0
    9d38:	4b9a      	ldr	r3, [pc, #616]	; (9fa4 <Unmarshal+0x2b4>)
    9d3a:	4798      	blx	r3
    9d3c:	1c02      	adds	r2, r0, #0
    if (IsScalarType(typeId))
    9d3e:	1c23      	adds	r3, r4, #0
    9d40:	3b28      	subs	r3, #40	; 0x28
    9d42:	2b01      	cmp	r3, #1
    9d44:	d804      	bhi.n	9d50 <Unmarshal+0x60>
    9d46:	4998      	ldr	r1, [pc, #608]	; (9fa8 <Unmarshal+0x2b8>)
    9d48:	5cc9      	ldrb	r1, [r1, r3]
    9d4a:	06c9      	lsls	r1, r1, #27
    9d4c:	d40c      	bmi.n	9d68 <Unmarshal+0x78>
    9d4e:	e030      	b.n	9db2 <Unmarshal+0xc2>
    9d50:	1c23      	adds	r3, r4, #0
    9d52:	3b61      	subs	r3, #97	; 0x61
    9d54:	2b1c      	cmp	r3, #28
    9d56:	d834      	bhi.n	9dc2 <Unmarshal+0xd2>
    9d58:	4b93      	ldr	r3, [pc, #588]	; (9fa8 <Unmarshal+0x2b8>)
    9d5a:	191b      	adds	r3, r3, r4
    9d5c:	3b5f      	subs	r3, #95	; 0x5f
    9d5e:	781b      	ldrb	r3, [r3, #0]
    9d60:	06db      	lsls	r3, r3, #27
    9d62:	d500      	bpl.n	9d66 <Unmarshal+0x76>
    9d64:	e10f      	b.n	9f86 <Unmarshal+0x296>
    9d66:	e02c      	b.n	9dc2 <Unmarshal+0xd2>
	{
        sz = SizeOfType(typeId);
    9d68:	498f      	ldr	r1, [pc, #572]	; (9fa8 <Unmarshal+0x2b8>)
    9d6a:	5ccb      	ldrb	r3, [r1, r3]
    9d6c:	270f      	movs	r7, #15
    9d6e:	401f      	ands	r7, r3
    9d70:	46b8      	mov	r8, r7
	//	printf("sz=%d---",sz);
        status = LoadBytes(ioBuf, sz, pad, &msg->timeout);
    9d72:	4669      	mov	r1, sp
    9d74:	810f      	strh	r7, [r1, #8]
    9d76:	8909      	ldrh	r1, [r1, #8]
    9d78:	b2d2      	uxtb	r2, r2
    9d7a:	1c33      	adds	r3, r6, #0
    9d7c:	3338      	adds	r3, #56	; 0x38
    9d7e:	9801      	ldr	r0, [sp, #4]
    9d80:	4f8a      	ldr	r7, [pc, #552]	; (9fac <Unmarshal+0x2bc>)
    9d82:	47b8      	blx	r7
    9d84:	1e03      	subs	r3, r0, #0
    9d86:	9001      	str	r0, [sp, #4]
        if (status != AJ_OK) 
    9d88:	d000      	beq.n	9d8c <Unmarshal+0x9c>
    9d8a:	e102      	b.n	9f92 <Unmarshal+0x2a2>
		{
	//		 printf("Unmarshal(): LoadBytes 1 status= %s\n",AJ_StatusText(status));
            return status;
        }
        // For numeric types we just return a pointer into the buffer
        arg->typeId = typeId;
    9d8c:	9a00      	ldr	r2, [sp, #0]
    9d8e:	7014      	strb	r4, [r2, #0]
        arg->val.v_byte = ioBuf->readPtr;
    9d90:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    9d92:	6051      	str	r1, [r2, #4]
        arg->len = 0;
    9d94:	2300      	movs	r3, #0
    9d96:	8053      	strh	r3, [r2, #2]
        ioBuf->readPtr += sz;
    9d98:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9d9a:	469c      	mov	ip, r3
    9d9c:	4647      	mov	r7, r8
    9d9e:	4467      	add	r7, ip
    9da0:	63af      	str	r7, [r5, #56]	; 0x38
        EndianSwap(msg, typeId, (void*)arg->val.v_byte, 1);
    9da2:	6852      	ldr	r2, [r2, #4]
    9da4:	1c30      	adds	r0, r6, #0
    9da6:	1c21      	adds	r1, r4, #0
    9da8:	2301      	movs	r3, #1
    9daa:	4c81      	ldr	r4, [pc, #516]	; (9fb0 <Unmarshal+0x2c0>)
    9dac:	47a0      	blx	r4
    pad = PadForType(typeId, ioBuf);
    if (IsScalarType(typeId))
	{
        sz = SizeOfType(typeId);
	//	printf("sz=%d---",sz);
        status = LoadBytes(ioBuf, sz, pad, &msg->timeout);
    9dae:	9801      	ldr	r0, [sp, #4]
    9db0:	e0ef      	b.n	9f92 <Unmarshal+0x2a2>
        arg->val.v_byte = ioBuf->readPtr;
        arg->len = 0;
        ioBuf->readPtr += sz;
        EndianSwap(msg, typeId, (void*)arg->val.v_byte, 1);
    } 
	else if (TYPE_FLAG(typeId) & (AJ_STRING | AJ_VARIANT))
    9db2:	1c21      	adds	r1, r4, #0
    9db4:	3928      	subs	r1, #40	; 0x28
    9db6:	4b7c      	ldr	r3, [pc, #496]	; (9fa8 <Unmarshal+0x2b8>)
    9db8:	5c5b      	ldrb	r3, [r3, r1]
    9dba:	203f      	movs	r0, #63	; 0x3f
    9dbc:	4383      	bics	r3, r0
    9dbe:	d10d      	bne.n	9ddc <Unmarshal+0xec>
    9dc0:	e057      	b.n	9e72 <Unmarshal+0x182>
    9dc2:	1c23      	adds	r3, r4, #0
    9dc4:	3b61      	subs	r3, #97	; 0x61
    9dc6:	2b1c      	cmp	r3, #28
    9dc8:	d853      	bhi.n	9e72 <Unmarshal+0x182>
    9dca:	4b77      	ldr	r3, [pc, #476]	; (9fa8 <Unmarshal+0x2b8>)
    9dcc:	191b      	adds	r3, r3, r4
    9dce:	3b5f      	subs	r3, #95	; 0x5f
    9dd0:	781b      	ldrb	r3, [r3, #0]
    9dd2:	213f      	movs	r1, #63	; 0x3f
    9dd4:	438b      	bics	r3, r1
    9dd6:	d000      	beq.n	9dda <Unmarshal+0xea>
    9dd8:	e0d8      	b.n	9f8c <Unmarshal+0x29c>
    9dda:	e04a      	b.n	9e72 <Unmarshal+0x182>
	{
         // Length field for a signature is 1 byte, for regular strings its 4 bytes
         uint32_t lenSize = ALIGNMENT(typeId);
    9ddc:	4b72      	ldr	r3, [pc, #456]	; (9fa8 <Unmarshal+0x2b8>)
    9dde:	5c5b      	ldrb	r3, [r3, r1]
    9de0:	210f      	movs	r1, #15
    9de2:	4019      	ands	r1, r3
    9de4:	4688      	mov	r8, r1
        /*
         * Read the string length. Note the length doesn't include the terminating NUL
         * so an empty string in encoded as two zero bytes.
        */
        status = LoadBytes(ioBuf, lenSize, pad, &msg->timeout);
    9de6:	2338      	movs	r3, #56	; 0x38
    9de8:	469c      	mov	ip, r3
    9dea:	44b4      	add	ip, r6
    9dec:	4663      	mov	r3, ip
    9dee:	9303      	str	r3, [sp, #12]
    9df0:	4668      	mov	r0, sp
    9df2:	8101      	strh	r1, [r0, #8]
    9df4:	8901      	ldrh	r1, [r0, #8]
    9df6:	b2d2      	uxtb	r2, r2
    9df8:	9801      	ldr	r0, [sp, #4]
    9dfa:	4f6c      	ldr	r7, [pc, #432]	; (9fac <Unmarshal+0x2bc>)
    9dfc:	47b8      	blx	r7
    9dfe:	1e03      	subs	r3, r0, #0
        if (status != AJ_OK)
    9e00:	d000      	beq.n	9e04 <Unmarshal+0x114>
    9e02:	e0c6      	b.n	9f92 <Unmarshal+0x2a2>
		{
	//		printf("Unmarshal(): LoadBytes 2 status= %s\n",AJ_StatusText(status));
            return status;
        }
        if (lenSize == 4) 
    9e04:	4643      	mov	r3, r8
    9e06:	2b04      	cmp	r3, #4
    9e08:	d109      	bne.n	9e1e <Unmarshal+0x12e>
		{
		//	printf("ioBuf->readPtr=0x%x-----ioBuf->bufStart=0x%x-------",ioBuf->readPtr,ioBuf->bufStart);
            EndianSwap(msg, AJ_ARG_UINT32, ioBuf->readPtr, 1);
    9e0a:	1c30      	adds	r0, r6, #0
    9e0c:	2175      	movs	r1, #117	; 0x75
    9e0e:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9e10:	3b03      	subs	r3, #3
    9e12:	4f67      	ldr	r7, [pc, #412]	; (9fb0 <Unmarshal+0x2c0>)
    9e14:	47b8      	blx	r7
            sz = *((uint32_t*)ioBuf->readPtr);
    9e16:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9e18:	681b      	ldr	r3, [r3, #0]
    9e1a:	469b      	mov	fp, r3
    9e1c:	e002      	b.n	9e24 <Unmarshal+0x134>
        } 
		else
		{
            sz = (uint32_t)(*ioBuf->readPtr);
    9e1e:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9e20:	781b      	ldrb	r3, [r3, #0]
    9e22:	469b      	mov	fp, r3
        }
        ioBuf->readPtr += lenSize;
    9e24:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9e26:	4443      	add	r3, r8
    9e28:	63ab      	str	r3, [r5, #56]	; 0x38
		//!!!!!!!!!!!!!!!
		//printf("lenSize=%d----------",lenSize);
	//	printf("sz=0x%x\n",sz);
        status = LoadBytes(ioBuf, sz + 1, 0, &msg->timeout);
    9e2a:	465b      	mov	r3, fp
    9e2c:	466a      	mov	r2, sp
    9e2e:	8113      	strh	r3, [r2, #8]
    9e30:	8913      	ldrh	r3, [r2, #8]
    9e32:	469a      	mov	sl, r3
    9e34:	1c59      	adds	r1, r3, #1
    9e36:	b289      	uxth	r1, r1
    9e38:	9801      	ldr	r0, [sp, #4]
    9e3a:	2200      	movs	r2, #0
    9e3c:	9b03      	ldr	r3, [sp, #12]
    9e3e:	4f5b      	ldr	r7, [pc, #364]	; (9fac <Unmarshal+0x2bc>)
    9e40:	47b8      	blx	r7
    9e42:	1e03      	subs	r3, r0, #0
        if (status != AJ_OK) 
    9e44:	d000      	beq.n	9e48 <Unmarshal+0x158>
    9e46:	e0a4      	b.n	9f92 <Unmarshal+0x2a2>
		{
	//		printf("Unmarshal(): LoadBytes 3 status= %s\n",AJ_StatusText(status));
            return status;
        }
        arg->typeId = typeId;
    9e48:	9b00      	ldr	r3, [sp, #0]
    9e4a:	701c      	strb	r4, [r3, #0]
        arg->len = sz;
    9e4c:	4652      	mov	r2, sl
    9e4e:	805a      	strh	r2, [r3, #2]
        arg->val.v_string = (char*)ioBuf->readPtr;
    9e50:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9e52:	605a      	str	r2, [r3, #4]
        ioBuf->readPtr += sz + 1;
    9e54:	465b      	mov	r3, fp
    9e56:	3301      	adds	r3, #1
    9e58:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9e5a:	4694      	mov	ip, r2
    9e5c:	4463      	add	r3, ip
    9e5e:	63ab      	str	r3, [r5, #56]	; 0x38
        }
        ioBuf->readPtr += lenSize;
		//!!!!!!!!!!!!!!!
		//printf("lenSize=%d----------",lenSize);
	//	printf("sz=0x%x\n",sz);
        status = LoadBytes(ioBuf, sz + 1, 0, &msg->timeout);
    9e60:	2000      	movs	r0, #0
        arg->typeId = typeId;
        arg->len = sz;
        arg->val.v_string = (char*)ioBuf->readPtr;
        ioBuf->readPtr += sz + 1;
        // If unmarshalling a variant store offset to start of signature
        if (typeId == AJ_ARG_VARIANT) 
    9e62:	2c76      	cmp	r4, #118	; 0x76
    9e64:	d000      	beq.n	9e68 <Unmarshal+0x178>
    9e66:	e094      	b.n	9f92 <Unmarshal+0x2a2>
		{
            msg->varOffset = (uint8_t)(sz + 1);
    9e68:	465b      	mov	r3, fp
    9e6a:	3301      	adds	r3, #1
    9e6c:	222d      	movs	r2, #45	; 0x2d
    9e6e:	54b3      	strb	r3, [r6, r2]
    9e70:	e08f      	b.n	9f92 <Unmarshal+0x2a2>
        }
    } 
	else if (typeId == AJ_ARG_ARRAY) 
    9e72:	2c61      	cmp	r4, #97	; 0x61
    9e74:	d164      	bne.n	9f40 <Unmarshal+0x250>
 * @param arg   Pointer to the structure to return the array
 */
static AJ_Status UnmarshalArray(AJ_Message* msg, const char** sig, AJ_Arg* arg, uint8_t pad)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    9e76:	6b35      	ldr	r5, [r6, #48]	; 0x30
    9e78:	1c2c      	adds	r4, r5, #0
    9e7a:	3430      	adds	r4, #48	; 0x30
    9e7c:	1c20      	adds	r0, r4, #0
    9e7e:	9401      	str	r4, [sp, #4]
    char typeId = **sig;
    9e80:	4653      	mov	r3, sl
    9e82:	785b      	ldrb	r3, [r3, #1]
    9e84:	4699      	mov	r9, r3
    uint32_t numBytes;

    // Get the byte count for the array
    status = LoadBytes(ioBuf, 4, pad, &msg->timeout);
    9e86:	2338      	movs	r3, #56	; 0x38
    9e88:	469c      	mov	ip, r3
    9e8a:	44b4      	add	ip, r6
    9e8c:	4663      	mov	r3, ip
    9e8e:	9302      	str	r3, [sp, #8]
    9e90:	b2d2      	uxtb	r2, r2
    9e92:	2104      	movs	r1, #4
    9e94:	4c45      	ldr	r4, [pc, #276]	; (9fac <Unmarshal+0x2bc>)
    9e96:	47a0      	blx	r4
    9e98:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    9e9a:	d17a      	bne.n	9f92 <Unmarshal+0x2a2>
	{
        return status;
    }
    EndianSwap(msg, AJ_ARG_UINT32, ioBuf->readPtr, 1);
    9e9c:	1c30      	adds	r0, r6, #0
    9e9e:	2175      	movs	r1, #117	; 0x75
    9ea0:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9ea2:	3301      	adds	r3, #1
    9ea4:	4c42      	ldr	r4, [pc, #264]	; (9fb0 <Unmarshal+0x2c0>)
    9ea6:	47a0      	blx	r4
    numBytes = *((uint32_t*)ioBuf->readPtr);
    9ea8:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9eaa:	cb04      	ldmia	r3!, {r2}
    9eac:	4690      	mov	r8, r2
    ioBuf->readPtr += 4;
    9eae:	63ab      	str	r3, [r5, #56]	; 0x38
    /*
        * We are already aligned on 4 byte boundary but there may be padding after the array length if
        * the array element types align on an 8 byte boundary.
     */
    pad = PadForType(typeId, ioBuf);
    9eb0:	4648      	mov	r0, r9
    9eb2:	9c01      	ldr	r4, [sp, #4]
    9eb4:	1c21      	adds	r1, r4, #0
    9eb6:	4b3b      	ldr	r3, [pc, #236]	; (9fa4 <Unmarshal+0x2b4>)
    9eb8:	4798      	blx	r3
    status = LoadBytes(ioBuf, numBytes, pad, &msg->timeout);
    9eba:	4643      	mov	r3, r8
    9ebc:	466a      	mov	r2, sp
    9ebe:	8093      	strh	r3, [r2, #4]
    9ec0:	8893      	ldrh	r3, [r2, #4]
    9ec2:	469b      	mov	fp, r3
    9ec4:	b2c2      	uxtb	r2, r0
    9ec6:	1c20      	adds	r0, r4, #0
    9ec8:	1c19      	adds	r1, r3, #0
    9eca:	9b02      	ldr	r3, [sp, #8]
    9ecc:	4c37      	ldr	r4, [pc, #220]	; (9fac <Unmarshal+0x2bc>)
    9ece:	47a0      	blx	r4
    9ed0:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    9ed2:	d15e      	bne.n	9f92 <Unmarshal+0x2a2>
	{
        return status;
    }
    arg->val.v_data = ioBuf->readPtr;
    9ed4:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9ed6:	9b00      	ldr	r3, [sp, #0]
    9ed8:	605a      	str	r2, [r3, #4]
    arg->sigPtr = *sig;
    9eda:	6839      	ldr	r1, [r7, #0]
    9edc:	6099      	str	r1, [r3, #8]
    arg->len = numBytes;
    9ede:	4659      	mov	r1, fp
    9ee0:	8059      	strh	r1, [r3, #2]
    if (!unmarshalScalarAsElement && IsScalarType(typeId))
    9ee2:	4b34      	ldr	r3, [pc, #208]	; (9fb4 <Unmarshal+0x2c4>)
    9ee4:	781b      	ldrb	r3, [r3, #0]
    9ee6:	2b00      	cmp	r3, #0
    9ee8:	d11f      	bne.n	9f2a <Unmarshal+0x23a>
    9eea:	464b      	mov	r3, r9
    9eec:	3b28      	subs	r3, #40	; 0x28
    9eee:	2b01      	cmp	r3, #1
    9ef0:	d906      	bls.n	9f00 <Unmarshal+0x210>
    9ef2:	231e      	movs	r3, #30
    9ef4:	4649      	mov	r1, r9
    9ef6:	3961      	subs	r1, #97	; 0x61
    9ef8:	291c      	cmp	r1, #28
    9efa:	d801      	bhi.n	9f00 <Unmarshal+0x210>
    9efc:	464b      	mov	r3, r9
    9efe:	3b5f      	subs	r3, #95	; 0x5f
    9f00:	4929      	ldr	r1, [pc, #164]	; (9fa8 <Unmarshal+0x2b8>)
    9f02:	5ccb      	ldrb	r3, [r1, r3]
    9f04:	06db      	lsls	r3, r3, #27
    9f06:	d510      	bpl.n	9f2a <Unmarshal+0x23a>
	{
        // For scalar types we do an inplace endian swap (if needed) and return a pointer into the read buffer.
        EndianSwap(msg, typeId, (void*)arg->val.v_data, arg->len);
    9f08:	4643      	mov	r3, r8
    9f0a:	4669      	mov	r1, sp
    9f0c:	808b      	strh	r3, [r1, #4]
    9f0e:	888b      	ldrh	r3, [r1, #4]
    9f10:	1c30      	adds	r0, r6, #0
    9f12:	4649      	mov	r1, r9
    9f14:	4c26      	ldr	r4, [pc, #152]	; (9fb0 <Unmarshal+0x2c0>)
    9f16:	47a0      	blx	r4
        ioBuf->readPtr += numBytes;
    9f18:	6bab      	ldr	r3, [r5, #56]	; 0x38
    9f1a:	4443      	add	r3, r8
    9f1c:	63ab      	str	r3, [r5, #56]	; 0x38
        arg->typeId = typeId;
    9f1e:	9a00      	ldr	r2, [sp, #0]
    9f20:	4649      	mov	r1, r9
    9f22:	7011      	strb	r1, [r2, #0]
        arg->flags = AJ_ARRAY_FLAG;
    9f24:	2301      	movs	r3, #1
    9f26:	7053      	strb	r3, [r2, #1]
    9f28:	e002      	b.n	9f30 <Unmarshal+0x240>
    }
	else
	{
        // For all other types the elements must be individually unmarshalled.
        arg->typeId = AJ_ARG_ARRAY;
    9f2a:	2361      	movs	r3, #97	; 0x61
    9f2c:	9a00      	ldr	r2, [sp, #0]
    9f2e:	7013      	strb	r3, [r2, #0]
    }
    // Consume the array element signature.
    *sig += CompleteTypeSigLen(*sig);
    9f30:	683c      	ldr	r4, [r7, #0]
    9f32:	1c20      	adds	r0, r4, #0
    9f34:	4b20      	ldr	r3, [pc, #128]	; (9fb8 <Unmarshal+0x2c8>)
    9f36:	4798      	blx	r3
    9f38:	1820      	adds	r0, r4, r0
    9f3a:	6038      	str	r0, [r7, #0]
    return status;
    9f3c:	2000      	movs	r0, #0
    9f3e:	e028      	b.n	9f92 <Unmarshal+0x2a2>
    } 
	else if (typeId == AJ_ARG_ARRAY) 
	{
        status = UnmarshalArray(msg, sig, arg, pad);
    } 
	else if ((typeId == AJ_ARG_STRUCT) || (typeId == AJ_ARG_DICT_ENTRY))
    9f40:	2c28      	cmp	r4, #40	; 0x28
    9f42:	d002      	beq.n	9f4a <Unmarshal+0x25a>
        status = UnmarshalStruct(msg, sig, arg, pad);
    } 
	else 
	{
 //       printf("Unmarshal(): AJ_ERR_UNMARSHAL\n");
        status = AJ_ERR_UNMARSHAL;
    9f44:	2009      	movs	r0, #9
    } 
	else if (typeId == AJ_ARG_ARRAY) 
	{
        status = UnmarshalArray(msg, sig, arg, pad);
    } 
	else if ((typeId == AJ_ARG_STRUCT) || (typeId == AJ_ARG_DICT_ENTRY))
    9f46:	2c7b      	cmp	r4, #123	; 0x7b
    9f48:	d123      	bne.n	9f92 <Unmarshal+0x2a2>
	{
        arg->typeId = typeId;
    9f4a:	9b00      	ldr	r3, [sp, #0]
    9f4c:	701c      	strb	r4, [r3, #0]
 * @param sig      The struct signature
 * @param arg      Pointer to the arg structure to return
 */
static AJ_Status UnmarshalStruct(AJ_Message* msg, const char** sig, AJ_Arg* arg, uint8_t pad)
{
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    9f4e:	6b35      	ldr	r5, [r6, #48]	; 0x30
    9f50:	1c28      	adds	r0, r5, #0
    9f52:	3030      	adds	r0, #48	; 0x30
    AJ_Status status = LoadBytes(ioBuf, 0, pad, &msg->timeout);
    9f54:	b2d2      	uxtb	r2, r2
    9f56:	3638      	adds	r6, #56	; 0x38
    9f58:	1c33      	adds	r3, r6, #0
    9f5a:	2100      	movs	r1, #0
    9f5c:	4c13      	ldr	r4, [pc, #76]	; (9fac <Unmarshal+0x2bc>)
    9f5e:	47a0      	blx	r4
    9f60:	1c04      	adds	r4, r0, #0
    arg->val.v_data = ioBuf->readPtr;
    9f62:	6baa      	ldr	r2, [r5, #56]	; 0x38
    9f64:	9201      	str	r2, [sp, #4]
    9f66:	9b00      	ldr	r3, [sp, #0]
    9f68:	605a      	str	r2, [r3, #4]
    arg->sigPtr = *sig;
    9f6a:	683a      	ldr	r2, [r7, #0]
    9f6c:	609a      	str	r2, [r3, #8]
    // Consume the entire struct signature.
    *sig -= 1;
    9f6e:	683b      	ldr	r3, [r7, #0]
    9f70:	1e5d      	subs	r5, r3, #1
    9f72:	603d      	str	r5, [r7, #0]
    *sig += CompleteTypeSigLen(*sig);
    9f74:	1c28      	adds	r0, r5, #0
    9f76:	4b10      	ldr	r3, [pc, #64]	; (9fb8 <Unmarshal+0x2c8>)
    9f78:	4798      	blx	r3
    9f7a:	182d      	adds	r5, r5, r0
    9f7c:	603d      	str	r5, [r7, #0]
        status = UnmarshalArray(msg, sig, arg, pad);
    } 
	else if ((typeId == AJ_ARG_STRUCT) || (typeId == AJ_ARG_DICT_ENTRY))
	{
        arg->typeId = typeId;
        status = UnmarshalStruct(msg, sig, arg, pad);
    9f7e:	1c20      	adds	r0, r4, #0
    9f80:	e007      	b.n	9f92 <Unmarshal+0x2a2>
    memset(arg, 0, sizeof(AJ_Arg));

    if (!*sig || !**sig) 
	{
   //     printf("Unmarshal(): AJ_ERR_END_OF_DATA\n");
        return AJ_ERR_END_OF_DATA;
    9f82:	200a      	movs	r0, #10
    9f84:	e005      	b.n	9f92 <Unmarshal+0x2a2>
	//printf("typeId = %d\n",typeId);
    *sig += 1;
    pad = PadForType(typeId, ioBuf);
    if (IsScalarType(typeId))
	{
        sz = SizeOfType(typeId);
    9f86:	1c23      	adds	r3, r4, #0
    9f88:	3b5f      	subs	r3, #95	; 0x5f
    9f8a:	e6ed      	b.n	9d68 <Unmarshal+0x78>
        EndianSwap(msg, typeId, (void*)arg->val.v_byte, 1);
    } 
	else if (TYPE_FLAG(typeId) & (AJ_STRING | AJ_VARIANT))
	{
         // Length field for a signature is 1 byte, for regular strings its 4 bytes
         uint32_t lenSize = ALIGNMENT(typeId);
    9f8c:	1c21      	adds	r1, r4, #0
    9f8e:	395f      	subs	r1, #95	; 0x5f
    9f90:	e724      	b.n	9ddc <Unmarshal+0xec>
	{
 //       printf("Unmarshal(): AJ_ERR_UNMARSHAL\n");
        status = AJ_ERR_UNMARSHAL;
    }
    return status;
}
    9f92:	b005      	add	sp, #20
    9f94:	bc3c      	pop	{r2, r3, r4, r5}
    9f96:	4690      	mov	r8, r2
    9f98:	4699      	mov	r9, r3
    9f9a:	46a2      	mov	sl, r4
    9f9c:	46ab      	mov	fp, r5
    9f9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9fa0:	00016773 	.word	0x00016773
    9fa4:	000099d9 	.word	0x000099d9
    9fa8:	0001dac0 	.word	0x0001dac0
    9fac:	00009c05 	.word	0x00009c05
    9fb0:	00009a19 	.word	0x00009a19
    9fb4:	20000980 	.word	0x20000980
    9fb8:	00009b01 	.word	0x00009b01

00009fbc <Marshal>:
    *sig += CompleteTypeSigLen(*sig);
    return status;
}

static AJ_Status Marshal(AJ_Message* msg, const char** sig, AJ_Arg* arg)
{
    9fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    9fbe:	465f      	mov	r7, fp
    9fc0:	4656      	mov	r6, sl
    9fc2:	464d      	mov	r5, r9
    9fc4:	4644      	mov	r4, r8
    9fc6:	b4f0      	push	{r4, r5, r6, r7}
    9fc8:	b085      	sub	sp, #20
    9fca:	4682      	mov	sl, r0
    9fcc:	4689      	mov	r9, r1
    9fce:	1c17      	adds	r7, r2, #0
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    9fd0:	6b05      	ldr	r5, [r0, #48]	; 0x30
    9fd2:	3518      	adds	r5, #24
    char typeId = **sig;
    9fd4:	680e      	ldr	r6, [r1, #0]
    9fd6:	7834      	ldrb	r4, [r6, #0]
    uint32_t pad = PadForType(typeId, ioBuf);
    9fd8:	1c20      	adds	r0, r4, #0
    9fda:	1c29      	adds	r1, r5, #0
    9fdc:	4b8e      	ldr	r3, [pc, #568]	; (a218 <Marshal+0x25c>)
    9fde:	4798      	blx	r3
    9fe0:	9001      	str	r0, [sp, #4]
    size_t sz;
  //   printf("----------Marshal()-------------\n");
    if (!arg) 
    9fe2:	2f00      	cmp	r7, #0
    9fe4:	d104      	bne.n	9ff0 <Marshal+0x34>
	{
        printf("Marshal(): AJ_ERR_NULL\n");
    9fe6:	488d      	ldr	r0, [pc, #564]	; (a21c <Marshal+0x260>)
    9fe8:	4b8d      	ldr	r3, [pc, #564]	; (a220 <Marshal+0x264>)
    9fea:	4798      	blx	r3
        return AJ_ERR_NULL;
    9fec:	2001      	movs	r0, #1
    9fee:	e10c      	b.n	a20a <Marshal+0x24e>
    }
    *sig += 1;
    9ff0:	1c70      	adds	r0, r6, #1
    9ff2:	464b      	mov	r3, r9
    9ff4:	6018      	str	r0, [r3, #0]
    if (IsScalarType(arg->typeId)) 
    9ff6:	783a      	ldrb	r2, [r7, #0]
    9ff8:	1c13      	adds	r3, r2, #0
    9ffa:	3b28      	subs	r3, #40	; 0x28
    9ffc:	2b01      	cmp	r3, #1
    9ffe:	d801      	bhi.n	a004 <Marshal+0x48>
    a000:	1c19      	adds	r1, r3, #0
    a002:	e006      	b.n	a012 <Marshal+0x56>
    a004:	211e      	movs	r1, #30
    a006:	1c13      	adds	r3, r2, #0
    a008:	3b61      	subs	r3, #97	; 0x61
    a00a:	2b1c      	cmp	r3, #28
    a00c:	d801      	bhi.n	a012 <Marshal+0x56>
    a00e:	1c11      	adds	r1, r2, #0
    a010:	395f      	subs	r1, #95	; 0x5f
    a012:	4b84      	ldr	r3, [pc, #528]	; (a224 <Marshal+0x268>)
    a014:	5c5b      	ldrb	r3, [r3, r1]
    a016:	06db      	lsls	r3, r3, #27
    a018:	d53f      	bpl.n	a09a <Marshal+0xde>
	{
        if (arg->flags & AJ_ARRAY_FLAG) 
    a01a:	787b      	ldrb	r3, [r7, #1]
    a01c:	07db      	lsls	r3, r3, #31
    a01e:	d51d      	bpl.n	a05c <Marshal+0xa0>
		{
            uint32_t szu32;
            if ((typeId != AJ_ARG_ARRAY) || (**sig != arg->typeId)) 
    a020:	2c61      	cmp	r4, #97	; 0x61
    a022:	d102      	bne.n	a02a <Marshal+0x6e>
    a024:	7873      	ldrb	r3, [r6, #1]
    a026:	4293      	cmp	r3, r2
    a028:	d004      	beq.n	a034 <Marshal+0x78>
			{
                printf("Marshal(): AJ_ERR_MARSHAL\n");
    a02a:	487f      	ldr	r0, [pc, #508]	; (a228 <Marshal+0x26c>)
    a02c:	4b7c      	ldr	r3, [pc, #496]	; (a220 <Marshal+0x264>)
    a02e:	4798      	blx	r3
                return AJ_ERR_MARSHAL;
    a030:	2008      	movs	r0, #8
    a032:	e0ea      	b.n	a20a <Marshal+0x24e>
            }
            *sig += 1;
    a034:	1cb3      	adds	r3, r6, #2
    a036:	464a      	mov	r2, r9
    a038:	6013      	str	r3, [r2, #0]
            sz = arg->len;
    a03a:	887c      	ldrh	r4, [r7, #2]
            szu32 = (uint32_t)sz;
    a03c:	9403      	str	r4, [sp, #12]
            status = WriteBytes(msg, &szu32, 4, pad);
    a03e:	4650      	mov	r0, sl
    a040:	a903      	add	r1, sp, #12
    a042:	2204      	movs	r2, #4
    a044:	9b01      	ldr	r3, [sp, #4]
    a046:	4e79      	ldr	r6, [pc, #484]	; (a22c <Marshal+0x270>)
    a048:	47b0      	blx	r6
    a04a:	1e03      	subs	r3, r0, #0
            if (status == AJ_OK) 
    a04c:	d000      	beq.n	a050 <Marshal+0x94>
    a04e:	e0dc      	b.n	a20a <Marshal+0x24e>
			{
                // May need to pad if the elements required 8 byte alignment
                pad = PadForType(arg->typeId, ioBuf);
    a050:	7838      	ldrb	r0, [r7, #0]
    a052:	1c29      	adds	r1, r5, #0
    a054:	4b70      	ldr	r3, [pc, #448]	; (a218 <Marshal+0x25c>)
    a056:	4798      	blx	r3
    a058:	9001      	str	r0, [sp, #4]
    a05a:	e017      	b.n	a08c <Marshal+0xd0>
            }
        } 
		else 
		{
            if (typeId != arg->typeId) 
    a05c:	4294      	cmp	r4, r2
    a05e:	d004      	beq.n	a06a <Marshal+0xae>
			{
                printf("Marshal(): AJ_ERR_MARSHAL\n");
    a060:	4871      	ldr	r0, [pc, #452]	; (a228 <Marshal+0x26c>)
    a062:	4b6f      	ldr	r3, [pc, #444]	; (a220 <Marshal+0x264>)
    a064:	4798      	blx	r3
                return AJ_ERR_MARSHAL;
    a066:	2008      	movs	r0, #8
    a068:	e0cf      	b.n	a20a <Marshal+0x24e>
            }
            sz = SizeOfType(typeId);
    a06a:	1c23      	adds	r3, r4, #0
    a06c:	3b28      	subs	r3, #40	; 0x28
    a06e:	2b01      	cmp	r3, #1
    a070:	d801      	bhi.n	a076 <Marshal+0xba>
    a072:	1c1a      	adds	r2, r3, #0
    a074:	e006      	b.n	a084 <Marshal+0xc8>
    a076:	221e      	movs	r2, #30
    a078:	1c23      	adds	r3, r4, #0
    a07a:	3b61      	subs	r3, #97	; 0x61
    a07c:	2b1c      	cmp	r3, #28
    a07e:	d801      	bhi.n	a084 <Marshal+0xc8>
    a080:	1c22      	adds	r2, r4, #0
    a082:	3a5f      	subs	r2, #95	; 0x5f
    a084:	4b67      	ldr	r3, [pc, #412]	; (a224 <Marshal+0x268>)
    a086:	5c9b      	ldrb	r3, [r3, r2]
    a088:	240f      	movs	r4, #15
    a08a:	401c      	ands	r4, r3
        }
		
        if (status == AJ_OK) 
		{
            status = WriteBytes(msg, arg->val.v_data, sz, pad);
    a08c:	6879      	ldr	r1, [r7, #4]
    a08e:	4650      	mov	r0, sl
    a090:	1c22      	adds	r2, r4, #0
    a092:	9b01      	ldr	r3, [sp, #4]
    a094:	4c65      	ldr	r4, [pc, #404]	; (a22c <Marshal+0x270>)
    a096:	47a0      	blx	r4
    a098:	e0b7      	b.n	a20a <Marshal+0x24e>
        }
    } 
	else 
	   if (TYPE_FLAG(typeId) & (AJ_STRING | AJ_VARIANT)) 
    a09a:	1c25      	adds	r5, r4, #0
    a09c:	3d28      	subs	r5, #40	; 0x28
    a09e:	b2ed      	uxtb	r5, r5
    a0a0:	2d01      	cmp	r5, #1
    a0a2:	d808      	bhi.n	a0b6 <Marshal+0xfa>
    a0a4:	1c23      	adds	r3, r4, #0
    a0a6:	3b28      	subs	r3, #40	; 0x28
    a0a8:	469b      	mov	fp, r3
    a0aa:	495e      	ldr	r1, [pc, #376]	; (a224 <Marshal+0x268>)
    a0ac:	5ccb      	ldrb	r3, [r1, r3]
    a0ae:	213f      	movs	r1, #63	; 0x3f
    a0b0:	438b      	bics	r3, r1
    a0b2:	d10c      	bne.n	a0ce <Marshal+0x112>
    a0b4:	e05b      	b.n	a16e <Marshal+0x1b2>
    a0b6:	1c23      	adds	r3, r4, #0
    a0b8:	3b61      	subs	r3, #97	; 0x61
    a0ba:	2b1c      	cmp	r3, #28
    a0bc:	d855      	bhi.n	a16a <Marshal+0x1ae>
    a0be:	4b59      	ldr	r3, [pc, #356]	; (a224 <Marshal+0x268>)
    a0c0:	191b      	adds	r3, r3, r4
    a0c2:	3b5f      	subs	r3, #95	; 0x5f
    a0c4:	781b      	ldrb	r3, [r3, #0]
    a0c6:	213f      	movs	r1, #63	; 0x3f
    a0c8:	438b      	bics	r3, r1
    a0ca:	d100      	bne.n	a0ce <Marshal+0x112>
    a0cc:	e099      	b.n	a202 <Marshal+0x246>
	   {
           if (typeId != arg->typeId) 
    a0ce:	4294      	cmp	r4, r2
    a0d0:	d004      	beq.n	a0dc <Marshal+0x120>
		   {
               printf("Marshal(): AJ_ERR_MARSHAL\n");
    a0d2:	4855      	ldr	r0, [pc, #340]	; (a228 <Marshal+0x26c>)
    a0d4:	4b52      	ldr	r3, [pc, #328]	; (a220 <Marshal+0x264>)
    a0d6:	4798      	blx	r3
               return AJ_ERR_MARSHAL;
    a0d8:	2008      	movs	r0, #8
    a0da:	e096      	b.n	a20a <Marshal+0x24e>
           }
           sz = arg->len ? arg->len : strlen(arg->val.v_string);
    a0dc:	8878      	ldrh	r0, [r7, #2]
    a0de:	1e06      	subs	r6, r0, #0
    a0e0:	d103      	bne.n	a0ea <Marshal+0x12e>
    a0e2:	6878      	ldr	r0, [r7, #4]
    a0e4:	4b52      	ldr	r3, [pc, #328]	; (a230 <Marshal+0x274>)
    a0e6:	4798      	blx	r3
    a0e8:	1c06      	adds	r6, r0, #0
           // Length field for a signature is 1 byte, for regular strings its 4 bytes
           if (ALIGNMENT(typeId) == 1)
    a0ea:	2d01      	cmp	r5, #1
    a0ec:	d802      	bhi.n	a0f4 <Marshal+0x138>
    a0ee:	1c22      	adds	r2, r4, #0
    a0f0:	3a28      	subs	r2, #40	; 0x28
    a0f2:	e006      	b.n	a102 <Marshal+0x146>
    a0f4:	221e      	movs	r2, #30
    a0f6:	1c23      	adds	r3, r4, #0
    a0f8:	3b61      	subs	r3, #97	; 0x61
    a0fa:	2b1c      	cmp	r3, #28
    a0fc:	d801      	bhi.n	a102 <Marshal+0x146>
    a0fe:	1c22      	adds	r2, r4, #0
    a100:	3a5f      	subs	r2, #95	; 0x5f
    a102:	4b48      	ldr	r3, [pc, #288]	; (a224 <Marshal+0x268>)
    a104:	5c9b      	ldrb	r3, [r3, r2]
    a106:	220f      	movs	r2, #15
    a108:	4013      	ands	r3, r2
    a10a:	2b01      	cmp	r3, #1
    a10c:	d10d      	bne.n	a12a <Marshal+0x16e>
		   {
              uint8_t szu8 = (uint8_t)sz;
    a10e:	ab03      	add	r3, sp, #12
    a110:	701e      	strb	r6, [r3, #0]
              if (sz > 255) 
    a112:	2eff      	cmp	r6, #255	; 0xff
    a114:	d901      	bls.n	a11a <Marshal+0x15e>
			  {
                return AJ_ERR_MARSHAL;
    a116:	2008      	movs	r0, #8
    a118:	e077      	b.n	a20a <Marshal+0x24e>
              }
              status = WriteBytes(msg, &szu8, 1, pad);
    a11a:	4650      	mov	r0, sl
    a11c:	a903      	add	r1, sp, #12
    a11e:	2201      	movs	r2, #1
    a120:	9b01      	ldr	r3, [sp, #4]
    a122:	4d42      	ldr	r5, [pc, #264]	; (a22c <Marshal+0x270>)
    a124:	47a8      	blx	r5
    a126:	1c03      	adds	r3, r0, #0
    a128:	e007      	b.n	a13a <Marshal+0x17e>
           } 
		   else
		   {
              uint32_t szu32 = (uint32_t)sz;
    a12a:	9603      	str	r6, [sp, #12]
              status = WriteBytes(msg, &szu32, 4, pad);
    a12c:	4650      	mov	r0, sl
    a12e:	a903      	add	r1, sp, #12
    a130:	2204      	movs	r2, #4
    a132:	9b01      	ldr	r3, [sp, #4]
    a134:	4d3d      	ldr	r5, [pc, #244]	; (a22c <Marshal+0x270>)
    a136:	47a8      	blx	r5
    a138:	1c03      	adds	r3, r0, #0
    a13a:	1e18      	subs	r0, r3, #0
        }
        if (status == AJ_OK) 
    a13c:	d165      	bne.n	a20a <Marshal+0x24e>
		{
            status = WriteBytes(msg, arg->val.v_string, sz, 0);
    a13e:	6879      	ldr	r1, [r7, #4]
    a140:	4650      	mov	r0, sl
    a142:	1c32      	adds	r2, r6, #0
    a144:	4d39      	ldr	r5, [pc, #228]	; (a22c <Marshal+0x270>)
    a146:	47a8      	blx	r5
    a148:	1e02      	subs	r2, r0, #0
            // String must be NUL terminated on the wire
            if (status == AJ_OK) 
    a14a:	d105      	bne.n	a158 <Marshal+0x19c>
			{
                status = WritePad(msg, 1);
    a14c:	4650      	mov	r0, sl
    a14e:	2100      	movs	r1, #0
    a150:	2301      	movs	r3, #1
    a152:	4d36      	ldr	r5, [pc, #216]	; (a22c <Marshal+0x270>)
    a154:	47a8      	blx	r5
    a156:	1c02      	adds	r2, r0, #0
    a158:	1c10      	adds	r0, r2, #0
            }
            // If marshalling a variant store offset to start of signature
            if (typeId == AJ_ARG_VARIANT) 
    a15a:	2c76      	cmp	r4, #118	; 0x76
    a15c:	d155      	bne.n	a20a <Marshal+0x24e>
			{
                msg->varOffset = (uint8_t)(sz + 1);
    a15e:	1c73      	adds	r3, r6, #1
    a160:	212d      	movs	r1, #45	; 0x2d
    a162:	4650      	mov	r0, sl
    a164:	5443      	strb	r3, [r0, r1]
    a166:	1c10      	adds	r0, r2, #0
    a168:	e04f      	b.n	a20a <Marshal+0x24e>
            }
        }
    } 
	else 
	   if (TYPE_FLAG(typeId) & AJ_CONTAINER)
    a16a:	231e      	movs	r3, #30
    a16c:	469b      	mov	fp, r3
    a16e:	492d      	ldr	r1, [pc, #180]	; (a224 <Marshal+0x268>)
    a170:	465b      	mov	r3, fp
    a172:	5ccb      	ldrb	r3, [r1, r3]
    a174:	069b      	lsls	r3, r3, #26
    a176:	d53f      	bpl.n	a1f8 <Marshal+0x23c>
	   {
          if (typeId != arg->typeId) 
    a178:	4294      	cmp	r4, r2
    a17a:	d004      	beq.n	a186 <Marshal+0x1ca>
		  {
            printf("Marshal(): AJ_ERR_MARSHAL\n");
    a17c:	482a      	ldr	r0, [pc, #168]	; (a228 <Marshal+0x26c>)
    a17e:	4b28      	ldr	r3, [pc, #160]	; (a220 <Marshal+0x264>)
    a180:	4798      	blx	r3
            return AJ_ERR_MARSHAL;
    a182:	2008      	movs	r0, #8
    a184:	e041      	b.n	a20a <Marshal+0x24e>
static AJ_Status Marshal(AJ_Message* msg, const char** sig, AJ_Arg* arg);

static AJ_Status MarshalContainer(AJ_Message* msg, const char** sig, AJ_Arg* arg, uint8_t pad)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    a186:	4653      	mov	r3, sl
    a188:	6b1d      	ldr	r5, [r3, #48]	; 0x30

    *sig -= 1;
    a18a:	464b      	mov	r3, r9
    a18c:	601e      	str	r6, [r3, #0]
    arg->sigPtr = *sig + 1;
    a18e:	60b8      	str	r0, [r7, #8]
    if (**sig == AJ_ARG_ARRAY) 
    a190:	681b      	ldr	r3, [r3, #0]
    a192:	781b      	ldrb	r3, [r3, #0]
    a194:	2b61      	cmp	r3, #97	; 0x61
    a196:	d11c      	bne.n	a1d2 <Marshal+0x216>
    a198:	339e      	adds	r3, #158	; 0x9e
    a19a:	9a01      	ldr	r2, [sp, #4]
    a19c:	4013      	ands	r3, r2
	{
        // Reserve space for the length and save a pointer to it
        status = WriteBytes(msg, NULL, 0, pad + 4);
    a19e:	3304      	adds	r3, #4
    a1a0:	4650      	mov	r0, sl
    a1a2:	2100      	movs	r1, #0
    a1a4:	2200      	movs	r2, #0
    a1a6:	4c21      	ldr	r4, [pc, #132]	; (a22c <Marshal+0x270>)
    a1a8:	47a0      	blx	r4
    a1aa:	1c04      	adds	r4, r0, #0
        arg->val.v_data = ioBuf->writePtr - 4;
    a1ac:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a1ae:	3b04      	subs	r3, #4
    a1b0:	607b      	str	r3, [r7, #4]
        //Might need to pad if the elements align on an 8 byte boundary
        if (status == AJ_OK) 
    a1b2:	2800      	cmp	r0, #0
    a1b4:	d116      	bne.n	a1e4 <Marshal+0x228>
		{
            status = WritePad(msg, PadForType(arg->sigPtr[0], ioBuf));
    a1b6:	68bb      	ldr	r3, [r7, #8]
    a1b8:	7818      	ldrb	r0, [r3, #0]
static AJ_Status Marshal(AJ_Message* msg, const char** sig, AJ_Arg* arg);

static AJ_Status MarshalContainer(AJ_Message* msg, const char** sig, AJ_Arg* arg, uint8_t pad)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    a1ba:	1c29      	adds	r1, r5, #0
    a1bc:	3118      	adds	r1, #24
        status = WriteBytes(msg, NULL, 0, pad + 4);
        arg->val.v_data = ioBuf->writePtr - 4;
        //Might need to pad if the elements align on an 8 byte boundary
        if (status == AJ_OK) 
		{
            status = WritePad(msg, PadForType(arg->sigPtr[0], ioBuf));
    a1be:	4b16      	ldr	r3, [pc, #88]	; (a218 <Marshal+0x25c>)
    a1c0:	4798      	blx	r3
    a1c2:	1c03      	adds	r3, r0, #0
    a1c4:	4650      	mov	r0, sl
    a1c6:	2100      	movs	r1, #0
    a1c8:	2200      	movs	r2, #0
    a1ca:	4c18      	ldr	r4, [pc, #96]	; (a22c <Marshal+0x270>)
    a1cc:	47a0      	blx	r4
    a1ce:	1c04      	adds	r4, r0, #0
    a1d0:	e008      	b.n	a1e4 <Marshal+0x228>
        }
    } 
	else
	{
        status = WritePad(msg, pad);
    a1d2:	23ff      	movs	r3, #255	; 0xff
    a1d4:	9a01      	ldr	r2, [sp, #4]
    a1d6:	4013      	ands	r3, r2
    a1d8:	4650      	mov	r0, sl
    a1da:	2100      	movs	r1, #0
    a1dc:	2200      	movs	r2, #0
    a1de:	4c13      	ldr	r4, [pc, #76]	; (a22c <Marshal+0x270>)
    a1e0:	47a0      	blx	r4
    a1e2:	1c04      	adds	r4, r0, #0
    }
    // Consume container signature
    *sig += CompleteTypeSigLen(*sig);
    a1e4:	464b      	mov	r3, r9
    a1e6:	681d      	ldr	r5, [r3, #0]
    a1e8:	1c28      	adds	r0, r5, #0
    a1ea:	4b12      	ldr	r3, [pc, #72]	; (a234 <Marshal+0x278>)
    a1ec:	4798      	blx	r3
    a1ee:	1828      	adds	r0, r5, r0
    a1f0:	464b      	mov	r3, r9
    a1f2:	6018      	str	r0, [r3, #0]
          if (typeId != arg->typeId) 
		  {
            printf("Marshal(): AJ_ERR_MARSHAL\n");
            return AJ_ERR_MARSHAL;
          }
          status = MarshalContainer(msg, sig, arg, pad);
    a1f4:	1c20      	adds	r0, r4, #0
    a1f6:	e008      	b.n	a20a <Marshal+0x24e>
       } 
	   else 
	   {
          printf("Marshal(): AJ_ERR_MARSHAL\n");
    a1f8:	480b      	ldr	r0, [pc, #44]	; (a228 <Marshal+0x26c>)
    a1fa:	4b09      	ldr	r3, [pc, #36]	; (a220 <Marshal+0x264>)
    a1fc:	4798      	blx	r3
          return AJ_ERR_MARSHAL;
    a1fe:	2008      	movs	r0, #8
    a200:	e003      	b.n	a20a <Marshal+0x24e>
                msg->varOffset = (uint8_t)(sz + 1);
            }
        }
    } 
	else 
	   if (TYPE_FLAG(typeId) & AJ_CONTAINER)
    a202:	1c23      	adds	r3, r4, #0
    a204:	3b5f      	subs	r3, #95	; 0x5f
    a206:	469b      	mov	fp, r3
    a208:	e7b1      	b.n	a16e <Marshal+0x1b2>
	   {
          printf("Marshal(): AJ_ERR_MARSHAL\n");
          return AJ_ERR_MARSHAL;
       }
    return status;
}
    a20a:	b005      	add	sp, #20
    a20c:	bc3c      	pop	{r2, r3, r4, r5}
    a20e:	4690      	mov	r8, r2
    a210:	4699      	mov	r9, r3
    a212:	46a2      	mov	sl, r4
    a214:	46ab      	mov	fp, r5
    a216:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a218:	000099d9 	.word	0x000099d9
    a21c:	0001d388 	.word	0x0001d388
    a220:	00016f5d 	.word	0x00016f5d
    a224:	0001dac0 	.word	0x0001dac0
    a228:	0001d3a0 	.word	0x0001d3a0
    a22c:	00009b45 	.word	0x00009b45
    a230:	0001715b 	.word	0x0001715b
    a234:	00009b01 	.word	0x00009b01

0000a238 <MarshalMsg>:

static AJ_Status MarshalMsg(AJ_Message* msg, uint8_t msgType, uint32_t msgId, uint8_t flags)
{
    a238:	b5f0      	push	{r4, r5, r6, r7, lr}
    a23a:	465f      	mov	r7, fp
    a23c:	464e      	mov	r6, r9
    a23e:	4645      	mov	r5, r8
    a240:	b4e0      	push	{r5, r6, r7}
    a242:	b08a      	sub	sp, #40	; 0x28
    a244:	1c06      	adds	r6, r0, #0
    a246:	4689      	mov	r9, r1
    a248:	1c1d      	adds	r5, r3, #0
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    a24a:	6b03      	ldr	r3, [r0, #48]	; 0x30
    a24c:	4698      	mov	r8, r3
    uint8_t fieldId;
    uint8_t secure = FALSE;
    a24e:	2327      	movs	r3, #39	; 0x27
    a250:	446b      	add	r3, sp
    a252:	2100      	movs	r1, #0
    a254:	7019      	strb	r1, [r3, #0]
*/
    /*
     * Use the msgId to lookup information in the object and interface descriptions to
     * initialize the message header fields.
     */
    status = AJ_InitMessageFromMsgId(msg, msgId, msgType, &secure);
    a256:	1c11      	adds	r1, r2, #0
    a258:	464a      	mov	r2, r9
    a25a:	4c73      	ldr	r4, [pc, #460]	; (a428 <MarshalMsg+0x1f0>)
    a25c:	47a0      	blx	r4
    a25e:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK)
    a260:	d006      	beq.n	a270 <MarshalMsg+0x38>
	{
        printf("MarshalMsg(): status=%s\n", AJ_StatusText(status));
    a262:	4b72      	ldr	r3, [pc, #456]	; (a42c <MarshalMsg+0x1f4>)
    a264:	4798      	blx	r3
    a266:	1c01      	adds	r1, r0, #0
    a268:	4871      	ldr	r0, [pc, #452]	; (a430 <MarshalMsg+0x1f8>)
    a26a:	4b72      	ldr	r3, [pc, #456]	; (a434 <MarshalMsg+0x1fc>)
    a26c:	4798      	blx	r3
        return status;
    a26e:	e0d3      	b.n	a418 <MarshalMsg+0x1e0>
    }

    AJ_IO_BUF_RESET(ioBuf);
    a270:	4643      	mov	r3, r8
    a272:	69d8      	ldr	r0, [r3, #28]
    a274:	6218      	str	r0, [r3, #32]
    a276:	6258      	str	r0, [r3, #36]	; 0x24
    a278:	2300      	movs	r3, #0
    a27a:	4642      	mov	r2, r8
    a27c:	7653      	strb	r3, [r2, #25]

    msg->hdr = (AJ_MsgHeader*)ioBuf->bufStart;
    a27e:	6070      	str	r0, [r6, #4]
    memset(msg->hdr, 0, sizeof(AJ_MsgHeader));
    a280:	2100      	movs	r1, #0
    a282:	2210      	movs	r2, #16
    a284:	4b6c      	ldr	r3, [pc, #432]	; (a438 <MarshalMsg+0x200>)
    a286:	4798      	blx	r3
    ioBuf->writePtr += sizeof(AJ_MsgHeader);
    a288:	4643      	mov	r3, r8
    a28a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a28c:	3310      	adds	r3, #16
    a28e:	4642      	mov	r2, r8
    a290:	6253      	str	r3, [r2, #36]	; 0x24

    msg->hdr->endianess = HOST_ENDIANESS;
    a292:	236c      	movs	r3, #108	; 0x6c
    a294:	6872      	ldr	r2, [r6, #4]
    a296:	7013      	strb	r3, [r2, #0]
    msg->hdr->msgType = msgType;
    a298:	6873      	ldr	r3, [r6, #4]
    a29a:	464a      	mov	r2, r9
    a29c:	705a      	strb	r2, [r3, #1]
    msg->hdr->flags = flags;
    a29e:	6873      	ldr	r3, [r6, #4]
    a2a0:	709d      	strb	r5, [r3, #2]
    if (secure) 
    a2a2:	2327      	movs	r3, #39	; 0x27
    a2a4:	446b      	add	r3, sp
    a2a6:	781b      	ldrb	r3, [r3, #0]
    a2a8:	2b00      	cmp	r3, #0
    a2aa:	d005      	beq.n	a2b8 <MarshalMsg+0x80>
	{
        msg->hdr->flags |= AJ_FLAG_ENCRYPTED;
    a2ac:	6872      	ldr	r2, [r6, #4]
    a2ae:	7893      	ldrb	r3, [r2, #2]
    a2b0:	2180      	movs	r1, #128	; 0x80
    a2b2:	4249      	negs	r1, r1
    a2b4:	430b      	orrs	r3, r1
    a2b6:	7093      	strb	r3, [r2, #2]

    /*
     * The wire-protocol calls this flag NO_AUTO_START we toggle the meaning in the API
     * so the default flags value can be zero.
     */
    msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    a2b8:	6872      	ldr	r2, [r6, #4]
    a2ba:	7891      	ldrb	r1, [r2, #2]
    a2bc:	2302      	movs	r3, #2
    a2be:	404b      	eors	r3, r1
    a2c0:	7093      	strb	r3, [r2, #2]
	printf("Serial number = %d\n",msg->bus->serial);
    a2c2:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a2c4:	6c99      	ldr	r1, [r3, #72]	; 0x48
    a2c6:	485d      	ldr	r0, [pc, #372]	; (a43c <MarshalMsg+0x204>)
    a2c8:	4b5a      	ldr	r3, [pc, #360]	; (a434 <MarshalMsg+0x1fc>)
    a2ca:	4798      	blx	r3
    // Serial number cannot be zero (wire-spec weirdness)
    do {
        msg->hdr->serialNum = msg->bus->serial++;
    a2cc:	6871      	ldr	r1, [r6, #4]
    a2ce:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a2d0:	6c93      	ldr	r3, [r2, #72]	; 0x48
    a2d2:	1c58      	adds	r0, r3, #1
    a2d4:	6490      	str	r0, [r2, #72]	; 0x48
    a2d6:	608b      	str	r3, [r1, #8]
    } while (msg->bus->serial == 1);
    a2d8:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a2da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a2dc:	2b01      	cmp	r3, #1
    a2de:	d0f5      	beq.n	a2cc <MarshalMsg+0x94>
    a2e0:	4d57      	ldr	r5, [pc, #348]	; (a440 <MarshalMsg+0x208>)
    a2e2:	3501      	adds	r5, #1
    a2e4:	2401      	movs	r4, #1
		{
            continue;
        }
		//
        InitArg(&hdrVal, typeId, NULL);
        switch (fieldId)
    a2e6:	4b57      	ldr	r3, [pc, #348]	; (a444 <MarshalMsg+0x20c>)
    a2e8:	469b      	mov	fp, r3
        msg->hdr->serialNum = msg->bus->serial++;
    } while (msg->bus->serial == 1);
    // Marshal the header fields
    for (fieldId = AJ_HDR_OBJ_PATH; fieldId <= AJ_HDR_SESSION_ID; ++fieldId) 
	{
        char typeId = TypeForHdr[fieldId];
    a2ea:	782f      	ldrb	r7, [r5, #0]
        char buf[4];
        const char* fieldSig = &buf[2];
    a2ec:	466b      	mov	r3, sp
    a2ee:	3306      	adds	r3, #6
    a2f0:	9302      	str	r3, [sp, #8]
        AJ_Arg hdrVal;
        // Skip field id's that are not currently used.
        if (typeId == AJ_ARG_INVALID) 
    a2f2:	2f00      	cmp	r7, #0
    a2f4:	d077      	beq.n	a3e6 <MarshalMsg+0x1ae>

static void InitArg(AJ_Arg* arg, uint8_t typeId, const void* val)
{
    if (arg) 
	{
        arg->typeId = typeId;
    a2f6:	ab05      	add	r3, sp, #20
    a2f8:	701f      	strb	r7, [r3, #0]
        arg->flags = 0;
    a2fa:	2200      	movs	r2, #0
    a2fc:	705a      	strb	r2, [r3, #1]
        arg->len = 0;
    a2fe:	805a      	strh	r2, [r3, #2]
        arg->val.v_data = (void*)val;
    a300:	9206      	str	r2, [sp, #24]
        arg->sigPtr = NULL;
    a302:	9207      	str	r2, [sp, #28]
        arg->container = NULL;
    a304:	9208      	str	r2, [sp, #32]
		{
            continue;
        }
		//
        InitArg(&hdrVal, typeId, NULL);
        switch (fieldId)
    a306:	2c13      	cmp	r4, #19
    a308:	d86d      	bhi.n	a3e6 <MarshalMsg+0x1ae>
    a30a:	00a3      	lsls	r3, r4, #2
    a30c:	465a      	mov	r2, fp
    a30e:	58d3      	ldr	r3, [r2, r3]
    a310:	469f      	mov	pc, r3
		{
        case AJ_HDR_OBJ_PATH:
            if ((msgType == AJ_MSG_METHOD_CALL) || (msgType == AJ_MSG_SIGNAL))
    a312:	464b      	mov	r3, r9
    a314:	2b01      	cmp	r3, #1
    a316:	d001      	beq.n	a31c <MarshalMsg+0xe4>
    a318:	2b04      	cmp	r3, #4
    a31a:	d149      	bne.n	a3b0 <MarshalMsg+0x178>
			{
                hdrVal.val.v_objPath = msg->objPath;
    a31c:	68b3      	ldr	r3, [r6, #8]
    a31e:	9306      	str	r3, [sp, #24]
    a320:	e046      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_INTERFACE:
            hdrVal.val.v_string = msg->iface;
    a322:	6933      	ldr	r3, [r6, #16]
    a324:	9306      	str	r3, [sp, #24]
            break;
    a326:	e043      	b.n	a3b0 <MarshalMsg+0x178>

        case AJ_HDR_MEMBER:
            if (msgType != AJ_MSG_ERROR) 
    a328:	464b      	mov	r3, r9
    a32a:	2b03      	cmp	r3, #3
    a32c:	d040      	beq.n	a3b0 <MarshalMsg+0x178>
			{
				// -   
                int32_t len = AJ_StringFindFirstOf(msg->member, " ");
    a32e:	68f0      	ldr	r0, [r6, #12]
    a330:	4945      	ldr	r1, [pc, #276]	; (a448 <MarshalMsg+0x210>)
    a332:	4b46      	ldr	r3, [pc, #280]	; (a44c <MarshalMsg+0x214>)
    a334:	4798      	blx	r3
                hdrVal.val.v_string = msg->member;
    a336:	aa05      	add	r2, sp, #20
    a338:	68f3      	ldr	r3, [r6, #12]
    a33a:	9306      	str	r3, [sp, #24]
                hdrVal.len = (len >= 0) ? len : 0;
    a33c:	43c3      	mvns	r3, r0
    a33e:	17db      	asrs	r3, r3, #31
    a340:	4018      	ands	r0, r3
    a342:	8050      	strh	r0, [r2, #2]
    a344:	e034      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_ERROR_NAME:
            if (msgType == AJ_MSG_ERROR)
    a346:	464b      	mov	r3, r9
    a348:	2b03      	cmp	r3, #3
    a34a:	d131      	bne.n	a3b0 <MarshalMsg+0x178>
			{
                hdrVal.val.v_string = msg->error;
    a34c:	68f3      	ldr	r3, [r6, #12]
    a34e:	9306      	str	r3, [sp, #24]
    a350:	e02e      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_REPLY_SERIAL:
            if ((msgType == AJ_MSG_METHOD_RET) || (msgType == AJ_MSG_ERROR)) 
    a352:	464b      	mov	r3, r9
    a354:	3b02      	subs	r3, #2
    a356:	2b01      	cmp	r3, #1
    a358:	d82a      	bhi.n	a3b0 <MarshalMsg+0x178>
			{
                hdrVal.val.v_uint32 = &msg->replySerial;
    a35a:	1c33      	adds	r3, r6, #0
    a35c:	3308      	adds	r3, #8
    a35e:	9306      	str	r3, [sp, #24]
    a360:	e026      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_DESTINATION:
            hdrVal.val.v_string = msg->destination;
    a362:	69b3      	ldr	r3, [r6, #24]
    a364:	9306      	str	r3, [sp, #24]
            break;
    a366:	e023      	b.n	a3b0 <MarshalMsg+0x178>

        case AJ_HDR_SENDER:
		    //  
            hdrVal.val.v_string = AJ_GetUniqueName(msg->bus);
    a368:	6b30      	ldr	r0, [r6, #48]	; 0x30
    a36a:	4b39      	ldr	r3, [pc, #228]	; (a450 <MarshalMsg+0x218>)
    a36c:	4798      	blx	r3
    a36e:	9006      	str	r0, [sp, #24]
            break;
    a370:	e01e      	b.n	a3b0 <MarshalMsg+0x178>

        case AJ_HDR_SIGNATURE:
            hdrVal.val.v_signature = msg->signature;
    a372:	69f3      	ldr	r3, [r6, #28]
    a374:	9306      	str	r3, [sp, #24]
            break;
    a376:	e01b      	b.n	a3b0 <MarshalMsg+0x178>

        case AJ_HDR_TIMESTAMP:
            if (msg->ttl)
    a378:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    a37a:	2b00      	cmp	r3, #0
    a37c:	d018      	beq.n	a3b0 <MarshalMsg+0x178>
			{
                AJ_Time timer;
                timer.seconds = 0;
    a37e:	a803      	add	r0, sp, #12
    a380:	2300      	movs	r3, #0
    a382:	6043      	str	r3, [r0, #4]
                timer.milliseconds = 0;
    a384:	8003      	strh	r3, [r0, #0]
                msg->timestamp = AJ_GetElapsedTime(&timer, FALSE);
    a386:	2100      	movs	r1, #0
    a388:	4b32      	ldr	r3, [pc, #200]	; (a454 <MarshalMsg+0x21c>)
    a38a:	4798      	blx	r3
    a38c:	6270      	str	r0, [r6, #36]	; 0x24
                hdrVal.val.v_uint32 = &msg->timestamp;
    a38e:	1c33      	adds	r3, r6, #0
    a390:	3324      	adds	r3, #36	; 0x24
    a392:	9306      	str	r3, [sp, #24]
    a394:	e00c      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_TIME_TO_LIVE:
            if (msg->ttl)
    a396:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    a398:	2b00      	cmp	r3, #0
    a39a:	d009      	beq.n	a3b0 <MarshalMsg+0x178>
			{
                hdrVal.val.v_uint32 = &msg->ttl;
    a39c:	1c33      	adds	r3, r6, #0
    a39e:	3328      	adds	r3, #40	; 0x28
    a3a0:	9306      	str	r3, [sp, #24]
    a3a2:	e005      	b.n	a3b0 <MarshalMsg+0x178>
            }
            break;

        case AJ_HDR_SESSION_ID:
            if (msg->sessionId)
    a3a4:	6a33      	ldr	r3, [r6, #32]
    a3a6:	2b00      	cmp	r3, #0
    a3a8:	d002      	beq.n	a3b0 <MarshalMsg+0x178>
			{
                hdrVal.val.v_uint32 = &msg->sessionId;
    a3aa:	1c33      	adds	r3, r6, #0
    a3ac:	3320      	adds	r3, #32
    a3ae:	9306      	str	r3, [sp, #24]
        case AJ_HDR_COMPRESSION_TOKEN:
        default:
            continue;
        }
        // Ignore empty fields.
        if (!hdrVal.val.v_data)
    a3b0:	9b06      	ldr	r3, [sp, #24]
    a3b2:	2b00      	cmp	r3, #0
    a3b4:	d017      	beq.n	a3e6 <MarshalMsg+0x1ae>
		{
            continue;
        }
        // Custom marshal the header field - signature is "(yv)" so starts off with STRUCT aligment.
        buf[0] = fieldId;
    a3b6:	466b      	mov	r3, sp
    a3b8:	711c      	strb	r4, [r3, #4]
        buf[1] = 1;
    a3ba:	2301      	movs	r3, #1
    a3bc:	466a      	mov	r2, sp
    a3be:	7153      	strb	r3, [r2, #5]
        buf[2] = typeId;
    a3c0:	7197      	strb	r7, [r2, #6]
        buf[3] = 0;
    a3c2:	2300      	movs	r3, #0
    a3c4:	71d3      	strb	r3, [r2, #7]
}

static AJ_Status MarshalMsg(AJ_Message* msg, uint8_t msgType, uint32_t msgId, uint8_t flags)
{
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    a3c6:	4641      	mov	r1, r8
    a3c8:	3118      	adds	r1, #24
        buf[0] = fieldId;
        buf[1] = 1;
        buf[2] = typeId;
        buf[3] = 0;
	//	printf("MarshalMsg(): WriteBytes\n");
        WriteBytes(msg, buf, 4, PadForType(AJ_ARG_STRUCT, ioBuf));
    a3ca:	2028      	movs	r0, #40	; 0x28
    a3cc:	4b22      	ldr	r3, [pc, #136]	; (a458 <MarshalMsg+0x220>)
    a3ce:	4798      	blx	r3
    a3d0:	1c03      	adds	r3, r0, #0
    a3d2:	1c30      	adds	r0, r6, #0
    a3d4:	a901      	add	r1, sp, #4
    a3d6:	2204      	movs	r2, #4
    a3d8:	4f20      	ldr	r7, [pc, #128]	; (a45c <MarshalMsg+0x224>)
    a3da:	47b8      	blx	r7
        //Now marshal the field value
	//	printf("MarshalMsg(): Marshal\n");
        Marshal(msg, &fieldSig, &hdrVal);
    a3dc:	1c30      	adds	r0, r6, #0
    a3de:	a902      	add	r1, sp, #8
    a3e0:	aa05      	add	r2, sp, #20
    a3e2:	4b1f      	ldr	r3, [pc, #124]	; (a460 <MarshalMsg+0x228>)
    a3e4:	4798      	blx	r3
    // Serial number cannot be zero (wire-spec weirdness)
    do {
        msg->hdr->serialNum = msg->bus->serial++;
    } while (msg->bus->serial == 1);
    // Marshal the header fields
    for (fieldId = AJ_HDR_OBJ_PATH; fieldId <= AJ_HDR_SESSION_ID; ++fieldId) 
    a3e6:	3401      	adds	r4, #1
    a3e8:	b2e4      	uxtb	r4, r4
    a3ea:	3501      	adds	r5, #1
    a3ec:	2c14      	cmp	r4, #20
    a3ee:	d000      	beq.n	a3f2 <MarshalMsg+0x1ba>
    a3f0:	e77b      	b.n	a2ea <MarshalMsg+0xb2>
        Marshal(msg, &fieldSig, &hdrVal);
    }
    if (status == AJ_OK) 
	{
        // Write the header length
        msg->hdr->headerLen = (uint32_t)((ioBuf->writePtr - ioBuf->bufStart) - sizeof(AJ_MsgHeader));
    a3f2:	6872      	ldr	r2, [r6, #4]
    a3f4:	4643      	mov	r3, r8
    a3f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a3f8:	4641      	mov	r1, r8
    a3fa:	69c9      	ldr	r1, [r1, #28]
    a3fc:	1a5b      	subs	r3, r3, r1
    a3fe:	3b10      	subs	r3, #16
    a400:	60d3      	str	r3, [r2, #12]
        // Header must be padded to an 8 byte boundary
	//	printf("MarshalMsg(): WritePad\n");
        status = WritePad(msg, (8 - msg->hdr->headerLen) & 7);
    a402:	6873      	ldr	r3, [r6, #4]
    a404:	68db      	ldr	r3, [r3, #12]
    a406:	425b      	negs	r3, r3
    a408:	2207      	movs	r2, #7
    a40a:	4013      	ands	r3, r2
    a40c:	1c30      	adds	r0, r6, #0
    a40e:	2100      	movs	r1, #0
    a410:	2200      	movs	r2, #0
    a412:	4c12      	ldr	r4, [pc, #72]	; (a45c <MarshalMsg+0x224>)
    a414:	47a0      	blx	r4
    a416:	1c04      	adds	r4, r0, #0
    }
    return status;
}
    a418:	1c20      	adds	r0, r4, #0
    a41a:	b00a      	add	sp, #40	; 0x28
    a41c:	bc1c      	pop	{r2, r3, r4}
    a41e:	4690      	mov	r8, r2
    a420:	4699      	mov	r9, r3
    a422:	46a3      	mov	fp, r4
    a424:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a426:	46c0      	nop			; (mov r8, r8)
    a428:	00008e75 	.word	0x00008e75
    a42c:	000063c5 	.word	0x000063c5
    a430:	0001d3bc 	.word	0x0001d3bc
    a434:	00016e3d 	.word	0x00016e3d
    a438:	00016773 	.word	0x00016773
    a43c:	0001d3d8 	.word	0x0001d3d8
    a440:	0001d23c 	.word	0x0001d23c
    a444:	0001d19c 	.word	0x0001d19c
    a448:	0001cde8 	.word	0x0001cde8
    a44c:	0000d839 	.word	0x0000d839
    a450:	000028e9 	.word	0x000028e9
    a454:	0000d769 	.word	0x0000d769
    a458:	000099d9 	.word	0x000099d9
    a45c:	00009b45 	.word	0x00009b45
    a460:	00009fbd 	.word	0x00009fbd

0000a464 <AJ_CheckIncomingSerial>:
    return offset;
}

// Serial number on incoming methods and signals.
AJ_Status AJ_CheckIncomingSerial(AJ_SerialNum* prev, uint32_t curr)
{
    a464:	b570      	push	{r4, r5, r6, lr}
    uint32_t offset;
    uint64_t mask;

    AJ_ASSERT(prev);
    a466:	2800      	cmp	r0, #0
    a468:	d106      	bne.n	a478 <AJ_CheckIncomingSerial+0x14>
    a46a:	482f      	ldr	r0, [pc, #188]	; (a528 <AJ_CheckIncomingSerial+0xc4>)
    a46c:	219e      	movs	r1, #158	; 0x9e
    a46e:	0049      	lsls	r1, r1, #1
    a470:	4a2e      	ldr	r2, [pc, #184]	; (a52c <AJ_CheckIncomingSerial+0xc8>)
    a472:	4b2f      	ldr	r3, [pc, #188]	; (a530 <AJ_CheckIncomingSerial+0xcc>)
    a474:	4c2f      	ldr	r4, [pc, #188]	; (a534 <AJ_CheckIncomingSerial+0xd0>)
    a476:	47a0      	blx	r4

    if (curr == 0) 
	{
        // 0 is never a valid serial number 
   //     AJ_WarnPrintf(("AJ_CheckIncomingSerial: 0 is invalid\n"));
        return AJ_ERR_INVALID;
    a478:	2303      	movs	r3, #3
    uint32_t offset;
    uint64_t mask;

    AJ_ASSERT(prev);

    if (curr == 0) 
    a47a:	2900      	cmp	r1, #0
    a47c:	d052      	beq.n	a524 <AJ_CheckIncomingSerial+0xc0>
	{
        // 0 is never a valid serial number 
   //     AJ_WarnPrintf(("AJ_CheckIncomingSerial: 0 is invalid\n"));
        return AJ_ERR_INVALID;
    }
    if (prev->serial == 0) 
    a47e:	6803      	ldr	r3, [r0, #0]
    a480:	2b00      	cmp	r3, #0
    a482:	d104      	bne.n	a48e <AJ_CheckIncomingSerial+0x2a>
	{
        offset = 0;
        prev->offset = 0;
    a484:	2200      	movs	r2, #0
    a486:	2300      	movs	r3, #0
    a488:	6082      	str	r2, [r0, #8]
    a48a:	60c3      	str	r3, [r0, #12]
    a48c:	e044      	b.n	a518 <AJ_CheckIncomingSerial+0xb4>
	{
        offset = a - b;
    }
	else
	{
        offset = (0xFFFFFFFFUL - b) + a + 1;
    a48e:	1aca      	subs	r2, r1, r3
        offset = wrapped_offset(curr, prev->serial);
        if (0 == offset)
		{
            // Current serial number matches highest recent serial 
    //        AJ_WarnPrintf(("AJ_CheckIncomingSerial: Repeated serial %x %x %llx\n", curr, prev->serial, prev->offset));
            return AJ_ERR_INVALID;
    a490:	2303      	movs	r3, #3
        prev->offset = 0;
    } 
	else
	{
        offset = wrapped_offset(curr, prev->serial);
        if (0 == offset)
    a492:	2a00      	cmp	r2, #0
    a494:	d046      	beq.n	a524 <AJ_CheckIncomingSerial+0xc0>
		{
            // Current serial number matches highest recent serial 
    //        AJ_WarnPrintf(("AJ_CheckIncomingSerial: Repeated serial %x %x %llx\n", curr, prev->serial, prev->offset));
            return AJ_ERR_INVALID;
        } 
		else if (0xFFFFFFC0UL < offset)
    a496:	1c13      	adds	r3, r2, #0
    a498:	3340      	adds	r3, #64	; 0x40
    a49a:	d91f      	bls.n	a4dc <AJ_CheckIncomingSerial+0x78>
		{
            // Current serial number is in the recent past. Check mask but don't move the window 
            offset = (0xFFFFFFFFUL - offset) + 1;
    a49c:	4253      	negs	r3, r2
            mask = ((uint64_t) 1) << offset;
    a49e:	2220      	movs	r2, #32
    a4a0:	4252      	negs	r2, r2
    a4a2:	1899      	adds	r1, r3, r2
    a4a4:	d403      	bmi.n	a4ae <AJ_CheckIncomingSerial+0x4a>
    a4a6:	3221      	adds	r2, #33	; 0x21
    a4a8:	408a      	lsls	r2, r1
    a4aa:	1c11      	adds	r1, r2, #0
    a4ac:	e004      	b.n	a4b8 <AJ_CheckIncomingSerial+0x54>
    a4ae:	2120      	movs	r1, #32
    a4b0:	1ac9      	subs	r1, r1, r3
    a4b2:	2201      	movs	r2, #1
    a4b4:	40ca      	lsrs	r2, r1
    a4b6:	1c11      	adds	r1, r2, #0
    a4b8:	2201      	movs	r2, #1
    a4ba:	409a      	lsls	r2, r3
            if (mask & prev->offset) 
    a4bc:	6886      	ldr	r6, [r0, #8]
    a4be:	68c5      	ldr	r5, [r0, #12]
    a4c0:	1c33      	adds	r3, r6, #0
    a4c2:	4013      	ands	r3, r2
    a4c4:	1c2c      	adds	r4, r5, #0
    a4c6:	400c      	ands	r4, r1
    a4c8:	431c      	orrs	r4, r3
			{
     //           AJ_WarnPrintf(("AJ_CheckIncomingSerial: Repeated serial %x %x %llx\n", curr, prev->serial, prev->offset));
                return AJ_ERR_INVALID;
    a4ca:	2303      	movs	r3, #3
		else if (0xFFFFFFC0UL < offset)
		{
            // Current serial number is in the recent past. Check mask but don't move the window 
            offset = (0xFFFFFFFFUL - offset) + 1;
            mask = ((uint64_t) 1) << offset;
            if (mask & prev->offset) 
    a4cc:	2c00      	cmp	r4, #0
    a4ce:	d129      	bne.n	a524 <AJ_CheckIncomingSerial+0xc0>
			{
     //           AJ_WarnPrintf(("AJ_CheckIncomingSerial: Repeated serial %x %x %llx\n", curr, prev->serial, prev->offset));
                return AJ_ERR_INVALID;
            }
            // Switch this mask on to mark this serial number as "seen" 
            prev->offset |= mask;
    a4d0:	4332      	orrs	r2, r6
    a4d2:	6082      	str	r2, [r0, #8]
    a4d4:	4329      	orrs	r1, r5
    a4d6:	60c1      	str	r1, [r0, #12]
            return AJ_OK;
    a4d8:	2300      	movs	r3, #0
    a4da:	e023      	b.n	a524 <AJ_CheckIncomingSerial+0xc0>
        }
		else if (0x80000000UL <= offset) 
    a4dc:	1c14      	adds	r4, r2, #0
		{
            // Too far in the past 
   //         AJ_WarnPrintf(("AJ_CheckIncomingSerial: Invalid serial %x %x %llx\n", curr, prev->serial, prev->offset));
            return AJ_ERR_INVALID;
    a4de:	2303      	movs	r3, #3
            }
            // Switch this mask on to mark this serial number as "seen" 
            prev->offset |= mask;
            return AJ_OK;
        }
		else if (0x80000000UL <= offset) 
    a4e0:	2a00      	cmp	r2, #0
    a4e2:	db1f      	blt.n	a524 <AJ_CheckIncomingSerial+0xc0>
   //         AJ_WarnPrintf(("AJ_CheckIncomingSerial: Invalid serial %x %x %llx\n", curr, prev->serial, prev->offset));
            return AJ_ERR_INVALID;
        }

        // Moving window ahead. 
        if (offset < 64) 
    a4e4:	2a3f      	cmp	r2, #63	; 0x3f
    a4e6:	d813      	bhi.n	a510 <AJ_CheckIncomingSerial+0xac>
		{
            prev->offset <<= offset;
    a4e8:	3b23      	subs	r3, #35	; 0x23
    a4ea:	18d3      	adds	r3, r2, r3
    a4ec:	d403      	bmi.n	a4f6 <AJ_CheckIncomingSerial+0x92>
    a4ee:	6882      	ldr	r2, [r0, #8]
    a4f0:	409a      	lsls	r2, r3
    a4f2:	60c2      	str	r2, [r0, #12]
    a4f4:	e008      	b.n	a508 <AJ_CheckIncomingSerial+0xa4>
    a4f6:	2320      	movs	r3, #32
    a4f8:	1a9b      	subs	r3, r3, r2
    a4fa:	6882      	ldr	r2, [r0, #8]
    a4fc:	40da      	lsrs	r2, r3
    a4fe:	1c13      	adds	r3, r2, #0
    a500:	68c2      	ldr	r2, [r0, #12]
    a502:	40a2      	lsls	r2, r4
    a504:	4313      	orrs	r3, r2
    a506:	60c3      	str	r3, [r0, #12]
    a508:	6883      	ldr	r3, [r0, #8]
    a50a:	40a3      	lsls	r3, r4
    a50c:	6083      	str	r3, [r0, #8]
    a50e:	e003      	b.n	a518 <AJ_CheckIncomingSerial+0xb4>
        }
		else
		{
            prev->offset = 0;
    a510:	2200      	movs	r2, #0
    a512:	2300      	movs	r3, #0
    a514:	6082      	str	r2, [r0, #8]
    a516:	60c3      	str	r3, [r0, #12]
        }
    }

    prev->serial = curr;
    a518:	6001      	str	r1, [r0, #0]
    prev->offset |= 1;
    a51a:	2301      	movs	r3, #1
    a51c:	6882      	ldr	r2, [r0, #8]
    a51e:	4313      	orrs	r3, r2
    a520:	6083      	str	r3, [r0, #8]
    return AJ_OK;
    a522:	2300      	movs	r3, #0
}
    a524:	1c18      	adds	r0, r3, #0
    a526:	bd70      	pop	{r4, r5, r6, pc}
    a528:	0001d2d8 	.word	0x0001d2d8
    a52c:	0001d250 	.word	0x0001d250
    a530:	0001d3ec 	.word	0x0001d3ec
    a534:	00016629 	.word	0x00016629

0000a538 <AJ_DeliverMsg>:
    AJ_MemZeroSecure(key, 16);
    return status;
}

AJ_Status AJ_DeliverMsg(AJ_Message* msg)
{
    a538:	b5f0      	push	{r4, r5, r6, r7, lr}
    a53a:	465f      	mov	r7, fp
    a53c:	4656      	mov	r6, sl
    a53e:	464d      	mov	r5, r9
    a540:	4644      	mov	r4, r8
    a542:	b4f0      	push	{r4, r5, r6, r7}
    a544:	b091      	sub	sp, #68	; 0x44
    a546:	1e04      	subs	r4, r0, #0
    AJ_Status status = AJ_OK;
    AJ_IOBuffer* ioBuf;
  //  printf("AJ_DeliverMsg start \n");
    if (!msg || !msg->bus) 
    a548:	d002      	beq.n	a550 <AJ_DeliverMsg+0x18>
    a54a:	6b05      	ldr	r5, [r0, #48]	; 0x30
    a54c:	2d00      	cmp	r5, #0
    a54e:	d104      	bne.n	a55a <AJ_DeliverMsg+0x22>
	{
		 printf("AJ_DeliverMsg: AJ_ERR_MARSHAL \n");
    a550:	4877      	ldr	r0, [pc, #476]	; (a730 <AJ_DeliverMsg+0x1f8>)
    a552:	4b78      	ldr	r3, [pc, #480]	; (a734 <AJ_DeliverMsg+0x1fc>)
    a554:	4798      	blx	r3
		// while(1);
        return AJ_ERR_MARSHAL;
    a556:	2008      	movs	r0, #8
    a558:	e0e2      	b.n	a720 <AJ_DeliverMsg+0x1e8>
    }

    ioBuf = &msg->bus->sock.tx;

    // If the header has already been marshaled (due to partial delivery) it will be NULL
    if (msg->hdr) 
    a55a:	6843      	ldr	r3, [r0, #4]
    a55c:	2b00      	cmp	r3, #0
    a55e:	d100      	bne.n	a562 <AJ_DeliverMsg+0x2a>
    a560:	e0c0      	b.n	a6e4 <AJ_DeliverMsg+0x1ac>
	{
	//	 printf("AJ_DeliverMsg: if (msg->hdr) \n");
        // Write the final body length to the header
        msg->hdr->bodyLen = msg->bodyBytes;
    a562:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    a564:	605a      	str	r2, [r3, #4]
        AJ_DumpMsg("SENDING", msg, TRUE);
        if (msg->hdr->flags & AJ_FLAG_ENCRYPTED)
    a566:	6843      	ldr	r3, [r0, #4]
    a568:	789a      	ldrb	r2, [r3, #2]
    a56a:	2a7f      	cmp	r2, #127	; 0x7f
    a56c:	d800      	bhi.n	a570 <AJ_DeliverMsg+0x38>
    a56e:	e0c7      	b.n	a700 <AJ_DeliverMsg+0x1c8>
    return status;
}

static AJ_Status EncryptMessage(AJ_Message* msg)
{
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    a570:	6b06      	ldr	r6, [r0, #48]	; 0x30
    AJ_Status status;
    uint8_t key[16];
    uint8_t nonce[MAX_NONCE_LENGTH];
    uint8_t role = AJ_ROLE_KEY_UNDEFINED;
    a572:	2100      	movs	r1, #0
    a574:	2217      	movs	r2, #23
    a576:	a802      	add	r0, sp, #8
    a578:	4684      	mov	ip, r0
    a57a:	4462      	add	r2, ip
    a57c:	7011      	strb	r1, [r2, #0]
}

// Computes total size of a message - note header is padded to an 8 byte boundary
static uint32_t MessageLen(AJ_Message* msg)
{
    return sizeof(AJ_MsgHeader) + ((msg->hdr->headerLen + 7) & 0xFFFFFFF8) + msg->hdr->bodyLen;
    a57e:	68da      	ldr	r2, [r3, #12]
    a580:	9205      	str	r2, [sp, #20]
    a582:	685a      	ldr	r2, [r3, #4]
    a584:	4690      	mov	r8, r2
    uint32_t nonceLen;
    uint32_t extraNonceLen;
    uint32_t cryptoValsLen;

    // Use the group key for multicast and broadcast signals the session key otherwise.
    if ((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination) 
    a586:	785b      	ldrb	r3, [r3, #1]
    a588:	2b04      	cmp	r3, #4
    a58a:	d10a      	bne.n	a5a2 <AJ_DeliverMsg+0x6a>
    a58c:	69a3      	ldr	r3, [r4, #24]
    a58e:	2b00      	cmp	r3, #0
    a590:	d107      	bne.n	a5a2 <AJ_DeliverMsg+0x6a>
	{
		//-   
        status = AJ_GetGroupKey(NULL, key);
    a592:	2000      	movs	r0, #0
    a594:	a90c      	add	r1, sp, #48	; 0x30
    a596:	4b68      	ldr	r3, [pc, #416]	; (a738 <AJ_DeliverMsg+0x200>)
    a598:	4798      	blx	r3
    a59a:	1c07      	adds	r7, r0, #0
        msg->authVersion = MIN_AUTH_FALLBACK_VERSION;
    a59c:	2302      	movs	r3, #2
    a59e:	63e3      	str	r3, [r4, #60]	; 0x3c
    a5a0:	e00a      	b.n	a5b8 <AJ_DeliverMsg+0x80>
    }
	else 
	{
		//-   
        status = AJ_GetSessionKey(msg->destination, key, &role, &msg->authVersion);
    a5a2:	1c23      	adds	r3, r4, #0
    a5a4:	333c      	adds	r3, #60	; 0x3c
    a5a6:	69a0      	ldr	r0, [r4, #24]
    a5a8:	a90c      	add	r1, sp, #48	; 0x30
    a5aa:	2217      	movs	r2, #23
    a5ac:	af02      	add	r7, sp, #8
    a5ae:	46bc      	mov	ip, r7
    a5b0:	4462      	add	r2, ip
    a5b2:	4f62      	ldr	r7, [pc, #392]	; (a73c <AJ_DeliverMsg+0x204>)
    a5b4:	47b8      	blx	r7
    a5b6:	1c07      	adds	r7, r0, #0

static uint32_t GetMACLength(AJ_Message* msg)
{
    uint32_t macLen = MAC_LENGTH;

    if (!MessageRequiresLongerCryptoValues(msg, MIN_AUTH_FULL_MAC_LENGTH)) 
    a5b8:	1c20      	adds	r0, r4, #0
    a5ba:	2103      	movs	r1, #3
    a5bc:	4b60      	ldr	r3, [pc, #384]	; (a740 <AJ_DeliverMsg+0x208>)
    a5be:	4798      	blx	r3
    a5c0:	2800      	cmp	r0, #0
    a5c2:	d104      	bne.n	a5ce <AJ_DeliverMsg+0x96>
	{
        macLen = PREVIOUS_MAC_LENGTH;
    a5c4:	2308      	movs	r3, #8
    a5c6:	469a      	mov	sl, r3
{
    uint32_t nonceLen = NONCE_LENGTH;

    if (!MessageRequiresLongerCryptoValues(msg, MIN_AUTH_FULL_NONCE_LENGTH)) 
	{
        nonceLen = PREVIOUS_NONCE_LENGTH;
    a5c8:	3b03      	subs	r3, #3
    a5ca:	4699      	mov	r9, r3
    a5cc:	e003      	b.n	a5d6 <AJ_DeliverMsg+0x9e>
            !((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination));  // rollback for multicast/broadcast
}

static uint32_t GetMACLength(AJ_Message* msg)
{
    uint32_t macLen = MAC_LENGTH;
    a5ce:	2310      	movs	r3, #16
    a5d0:	469a      	mov	sl, r3
    return macLen;
}

static uint32_t GetNonceLength(AJ_Message* msg)
{
    uint32_t nonceLen = NONCE_LENGTH;
    a5d2:	3b03      	subs	r3, #3
    a5d4:	4699      	mov	r9, r3
		//-   
        status = AJ_GetSessionKey(msg->destination, key, &role, &msg->authVersion);
    }
    macLen = GetMACLength(msg);
    nonceLen = GetNonceLength(msg);
    extraNonceLen = nonceLen - PREVIOUS_NONCE_LENGTH;
    a5d6:	2305      	movs	r3, #5
    a5d8:	425b      	negs	r3, r3
    a5da:	444b      	add	r3, r9
    a5dc:	469b      	mov	fp, r3
    cryptoValsLen = macLen + extraNonceLen;
    a5de:	1c1a      	adds	r2, r3, #0
    a5e0:	4452      	add	r2, sl

    // Check there is room to append the MAC and Nonce
    if (AJ_IO_BUF_SPACE(ioBuf) < cryptoValsLen) 
    a5e2:	8b71      	ldrh	r1, [r6, #26]
    a5e4:	69f3      	ldr	r3, [r6, #28]
    a5e6:	6a70      	ldr	r0, [r6, #36]	; 0x24
    a5e8:	1a1b      	subs	r3, r3, r0
    a5ea:	18cb      	adds	r3, r1, r3
    a5ec:	429a      	cmp	r2, r3
    a5ee:	d90c      	bls.n	a60a <AJ_DeliverMsg+0xd2>
	{
        AJ_ErrPrintf(("EncryptMessage(): AJ_ERR_RESOURCES\n"));
    a5f0:	2001      	movs	r0, #1
    a5f2:	4954      	ldr	r1, [pc, #336]	; (a744 <AJ_DeliverMsg+0x20c>)
    a5f4:	2286      	movs	r2, #134	; 0x86
    a5f6:	0092      	lsls	r2, r2, #2
    a5f8:	4b53      	ldr	r3, [pc, #332]	; (a748 <AJ_DeliverMsg+0x210>)
    a5fa:	4798      	blx	r3
    a5fc:	2800      	cmp	r0, #0
    a5fe:	d100      	bne.n	a602 <AJ_DeliverMsg+0xca>
    a600:	e08c      	b.n	a71c <AJ_DeliverMsg+0x1e4>
    a602:	4852      	ldr	r0, [pc, #328]	; (a74c <AJ_DeliverMsg+0x214>)
    a604:	4b4b      	ldr	r3, [pc, #300]	; (a734 <AJ_DeliverMsg+0x1fc>)
    a606:	4798      	blx	r3
    a608:	e088      	b.n	a71c <AJ_DeliverMsg+0x1e4>
        return AJ_ERR_RESOURCES;
    }
    msg->hdr->bodyLen += cryptoValsLen;
    a60a:	6861      	ldr	r1, [r4, #4]
    a60c:	684b      	ldr	r3, [r1, #4]
    a60e:	189b      	adds	r3, r3, r2
    a610:	604b      	str	r3, [r1, #4]
    ioBuf->writePtr += cryptoValsLen;
    a612:	6a73      	ldr	r3, [r6, #36]	; 0x24
    a614:	469c      	mov	ip, r3
    a616:	4462      	add	r2, ip
    a618:	6272      	str	r2, [r6, #36]	; 0x24

    if (status != AJ_OK) 
    a61a:	2f00      	cmp	r7, #0
    a61c:	d017      	beq.n	a64e <AJ_DeliverMsg+0x116>
	{
        AJ_ErrPrintf(("EncryptMesssage(): peer %s not authenticated", msg->destination));
    a61e:	2001      	movs	r0, #1
    a620:	4948      	ldr	r1, [pc, #288]	; (a744 <AJ_DeliverMsg+0x20c>)
    a622:	2288      	movs	r2, #136	; 0x88
    a624:	0092      	lsls	r2, r2, #2
    a626:	4b48      	ldr	r3, [pc, #288]	; (a748 <AJ_DeliverMsg+0x210>)
    a628:	4798      	blx	r3
    a62a:	2800      	cmp	r0, #0
    a62c:	d003      	beq.n	a636 <AJ_DeliverMsg+0xfe>
    a62e:	4848      	ldr	r0, [pc, #288]	; (a750 <AJ_DeliverMsg+0x218>)
    a630:	69a1      	ldr	r1, [r4, #24]
    a632:	4b48      	ldr	r3, [pc, #288]	; (a754 <AJ_DeliverMsg+0x21c>)
    a634:	4798      	blx	r3
        AJ_ErrPrintf(("EncryptMessage(): AJ_ERR_SECURITY\n"));
    a636:	2001      	movs	r0, #1
    a638:	4942      	ldr	r1, [pc, #264]	; (a744 <AJ_DeliverMsg+0x20c>)
    a63a:	4a47      	ldr	r2, [pc, #284]	; (a758 <AJ_DeliverMsg+0x220>)
    a63c:	4b42      	ldr	r3, [pc, #264]	; (a748 <AJ_DeliverMsg+0x210>)
    a63e:	4798      	blx	r3
        status = AJ_ERR_SECURITY;
    a640:	260d      	movs	r6, #13
    ioBuf->writePtr += cryptoValsLen;

    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("EncryptMesssage(): peer %s not authenticated", msg->destination));
        AJ_ErrPrintf(("EncryptMessage(): AJ_ERR_SECURITY\n"));
    a642:	2800      	cmp	r0, #0
    a644:	d047      	beq.n	a6d6 <AJ_DeliverMsg+0x19e>
    a646:	4845      	ldr	r0, [pc, #276]	; (a75c <AJ_DeliverMsg+0x224>)
    a648:	4b3a      	ldr	r3, [pc, #232]	; (a734 <AJ_DeliverMsg+0x1fc>)
    a64a:	4798      	blx	r3
    a64c:	e043      	b.n	a6d6 <AJ_DeliverMsg+0x19e>
    a64e:	4642      	mov	r2, r8
    a650:	3210      	adds	r2, #16
}

// Computes total size of a message - note header is padded to an 8 byte boundary
static uint32_t MessageLen(AJ_Message* msg)
{
    return sizeof(AJ_MsgHeader) + ((msg->hdr->headerLen + 7) & 0xFFFFFFF8) + msg->hdr->bodyLen;
    a652:	9f05      	ldr	r7, [sp, #20]
    a654:	3707      	adds	r7, #7
    a656:	2307      	movs	r3, #7
    a658:	439f      	bics	r7, r3
    a65a:	19d7      	adds	r7, r2, r7
        AJ_ErrPrintf(("EncryptMessage(): AJ_ERR_SECURITY\n"));
        status = AJ_ERR_SECURITY;
    } 
	else
	{   //-   
        if (MessageRequiresLongerCryptoValues(msg, MIN_AUTH_FULL_NONCE_LENGTH)) 
    a65c:	1c20      	adds	r0, r4, #0
    a65e:	2103      	movs	r1, #3
    a660:	4b37      	ldr	r3, [pc, #220]	; (a740 <AJ_DeliverMsg+0x208>)
    a662:	4798      	blx	r3
    a664:	2800      	cmp	r0, #0
    a666:	d007      	beq.n	a678 <AJ_DeliverMsg+0x140>
		{
            AJ_RandBytes(ioBuf->bufStart + mlen + macLen, extraNonceLen);
    a668:	4653      	mov	r3, sl
    a66a:	19d8      	adds	r0, r3, r7
    a66c:	69f3      	ldr	r3, [r6, #28]
    a66e:	469c      	mov	ip, r3
    a670:	4460      	add	r0, ip
    a672:	4659      	mov	r1, fp
    a674:	4b3a      	ldr	r3, [pc, #232]	; (a760 <AJ_DeliverMsg+0x228>)
    a676:	4798      	blx	r3
        }
        //AJ_InfoPrintf(("EncryptMessage(): "));
		//  
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen + macLen, extraNonceLen);
    a678:	69f3      	ldr	r3, [r6, #28]
    a67a:	9304      	str	r3, [sp, #16]
    return nonceLen;
}

static AJ_Status InitNonce(AJ_Message* msg, uint8_t role, uint8_t* nonce, uint32_t nonceLen, uint8_t* extraNonce, uint32_t extraNonceLen)
{
    uint32_t serial = msg->hdr->serialNum;
    a67c:	6863      	ldr	r3, [r4, #4]
    a67e:	689a      	ldr	r2, [r3, #8]
    nonce[0] = role;
    a680:	ab08      	add	r3, sp, #32
		{
            AJ_RandBytes(ioBuf->bufStart + mlen + macLen, extraNonceLen);
        }
        //AJ_InfoPrintf(("EncryptMessage(): "));
		//  
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen + macLen, extraNonceLen);
    a682:	2017      	movs	r0, #23
    a684:	a902      	add	r1, sp, #8
    a686:	468c      	mov	ip, r1
    a688:	4460      	add	r0, ip
}

static AJ_Status InitNonce(AJ_Message* msg, uint8_t role, uint8_t* nonce, uint32_t nonceLen, uint8_t* extraNonce, uint32_t extraNonceLen)
{
    uint32_t serial = msg->hdr->serialNum;
    nonce[0] = role;
    a68a:	7800      	ldrb	r0, [r0, #0]
    a68c:	7018      	strb	r0, [r3, #0]
    nonce[1] = (uint8_t)(serial >> 24);
    a68e:	0e10      	lsrs	r0, r2, #24
    a690:	7058      	strb	r0, [r3, #1]
    nonce[2] = (uint8_t)(serial >> 16);
    a692:	0c10      	lsrs	r0, r2, #16
    a694:	7098      	strb	r0, [r3, #2]
    nonce[3] = (uint8_t)(serial >> 8);
    a696:	0a10      	lsrs	r0, r2, #8
    a698:	70d8      	strb	r0, [r3, #3]
    nonce[4] = (uint8_t)(serial);
    a69a:	711a      	strb	r2, [r3, #4]
    if (nonceLen < (PREVIOUS_NONCE_LENGTH + extraNonceLen)) 
    a69c:	464b      	mov	r3, r9
    a69e:	2b0d      	cmp	r3, #13
    a6a0:	d80b      	bhi.n	a6ba <AJ_DeliverMsg+0x182>
	{
        return AJ_ERR_SECURITY;
    }
    if (0 < extraNonceLen) 
    a6a2:	465b      	mov	r3, fp
    a6a4:	2b00      	cmp	r3, #0
    a6a6:	d008      	beq.n	a6ba <AJ_DeliverMsg+0x182>
		{
            AJ_RandBytes(ioBuf->bufStart + mlen + macLen, extraNonceLen);
        }
        //AJ_InfoPrintf(("EncryptMessage(): "));
		//  
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen + macLen, extraNonceLen);
    a6a8:	4653      	mov	r3, sl
    a6aa:	19db      	adds	r3, r3, r7
    a6ac:	9a04      	ldr	r2, [sp, #16]
    a6ae:	18d1      	adds	r1, r2, r3
	{
        return AJ_ERR_SECURITY;
    }
    if (0 < extraNonceLen) 
	{
        memcpy(&nonce[PREVIOUS_NONCE_LENGTH], extraNonce, extraNonceLen);
    a6b0:	201d      	movs	r0, #29
    a6b2:	4460      	add	r0, ip
    a6b4:	465a      	mov	r2, fp
    a6b6:	4b2b      	ldr	r3, [pc, #172]	; (a764 <AJ_DeliverMsg+0x22c>)
    a6b8:	4798      	blx	r3
            AJ_RandBytes(ioBuf->bufStart + mlen + macLen, extraNonceLen);
        }
        //AJ_InfoPrintf(("EncryptMessage(): "));
		//  
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen + macLen, extraNonceLen);
        status = AJ_Encrypt_CCM(key, ioBuf->bufStart, mlen, hlen, macLen, nonce, nonceLen);
    a6ba:	69f1      	ldr	r1, [r6, #28]
    AJ_Status status;
    uint8_t key[16];
    uint8_t nonce[MAX_NONCE_LENGTH];
    uint8_t role = AJ_ROLE_KEY_UNDEFINED;
    uint32_t mlen = MessageLen(msg);
    uint32_t hlen = mlen - msg->hdr->bodyLen;
    a6bc:	4643      	mov	r3, r8
    a6be:	1afb      	subs	r3, r7, r3
            AJ_RandBytes(ioBuf->bufStart + mlen + macLen, extraNonceLen);
        }
        //AJ_InfoPrintf(("EncryptMessage(): "));
		//  
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen + macLen, extraNonceLen);
        status = AJ_Encrypt_CCM(key, ioBuf->bufStart, mlen, hlen, macLen, nonce, nonceLen);
    a6c0:	4652      	mov	r2, sl
    a6c2:	9200      	str	r2, [sp, #0]
    a6c4:	aa08      	add	r2, sp, #32
    a6c6:	9201      	str	r2, [sp, #4]
    a6c8:	464a      	mov	r2, r9
    a6ca:	9202      	str	r2, [sp, #8]
    a6cc:	a80c      	add	r0, sp, #48	; 0x30
    a6ce:	1c3a      	adds	r2, r7, #0
    a6d0:	4e25      	ldr	r6, [pc, #148]	; (a768 <AJ_DeliverMsg+0x230>)
    a6d2:	47b0      	blx	r6
    a6d4:	1c06      	adds	r6, r0, #0
    }
    AJ_MemZeroSecure(key, 16);
    a6d6:	a80c      	add	r0, sp, #48	; 0x30
    a6d8:	2110      	movs	r1, #16
    a6da:	4b24      	ldr	r3, [pc, #144]	; (a76c <AJ_DeliverMsg+0x234>)
    a6dc:	4798      	blx	r3
            status = AJ_ERR_MARSHAL;
        }
    }
//	printf("AJ_DeliverMsg: status=%s \n", AJ_StatusText(status));

    if (status == AJ_OK) 
    a6de:	2e00      	cmp	r6, #0
    a6e0:	d113      	bne.n	a70a <AJ_DeliverMsg+0x1d2>
    a6e2:	e00d      	b.n	a700 <AJ_DeliverMsg+0x1c8>
    } 
	else 
	{
	//	printf("AJ_DeliverMsg: else if (msg->hdr) \n");
        // Check that the entire body was written
        if (msg->bodyBytes) 
    a6e4:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
    a6e6:	2b00      	cmp	r3, #0
    a6e8:	d00a      	beq.n	a700 <AJ_DeliverMsg+0x1c8>
		{
            AJ_ErrPrintf(("AJ_DeliverMsg(): AJ_ERR_MARSHAL\n"));
    a6ea:	2001      	movs	r0, #1
    a6ec:	4915      	ldr	r1, [pc, #84]	; (a744 <AJ_DeliverMsg+0x20c>)
    a6ee:	4a20      	ldr	r2, [pc, #128]	; (a770 <AJ_DeliverMsg+0x238>)
    a6f0:	4b15      	ldr	r3, [pc, #84]	; (a748 <AJ_DeliverMsg+0x210>)
    a6f2:	4798      	blx	r3
    a6f4:	2800      	cmp	r0, #0
    a6f6:	d00f      	beq.n	a718 <AJ_DeliverMsg+0x1e0>
    a6f8:	481e      	ldr	r0, [pc, #120]	; (a774 <AJ_DeliverMsg+0x23c>)
    a6fa:	4b0e      	ldr	r3, [pc, #56]	; (a734 <AJ_DeliverMsg+0x1fc>)
    a6fc:	4798      	blx	r3
    a6fe:	e00b      	b.n	a718 <AJ_DeliverMsg+0x1e0>
		 printf("AJ_DeliverMsg: AJ_ERR_MARSHAL \n");
		// while(1);
        return AJ_ERR_MARSHAL;
    }

    ioBuf = &msg->bus->sock.tx;
    a700:	1c28      	adds	r0, r5, #0
    a702:	3018      	adds	r0, #24

    if (status == AJ_OK) 
	{
        //#pragma calls = AJ_Net_Send
//		printf("AJ_DeliverMsg: ioBuf->send(ioBuf) \n");
        status = ioBuf->send(ioBuf);
    a704:	6aab      	ldr	r3, [r5, #40]	; 0x28
    a706:	4798      	blx	r3
    a708:	1c06      	adds	r6, r0, #0
    }
    memset(msg, 0, sizeof(AJ_Message));
    a70a:	1c20      	adds	r0, r4, #0
    a70c:	2100      	movs	r1, #0
    a70e:	2240      	movs	r2, #64	; 0x40
    a710:	4b19      	ldr	r3, [pc, #100]	; (a778 <AJ_DeliverMsg+0x240>)
    a712:	4798      	blx	r3
    return status;
    a714:	1c30      	adds	r0, r6, #0
    a716:	e003      	b.n	a720 <AJ_DeliverMsg+0x1e8>

    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("EncryptMesssage(): peer %s not authenticated", msg->destination));
        AJ_ErrPrintf(("EncryptMessage(): AJ_ERR_SECURITY\n"));
        status = AJ_ERR_SECURITY;
    a718:	2608      	movs	r6, #8
    a71a:	e7f6      	b.n	a70a <AJ_DeliverMsg+0x1d2>
    a71c:	260b      	movs	r6, #11
    a71e:	e7f4      	b.n	a70a <AJ_DeliverMsg+0x1d2>
//		printf("AJ_DeliverMsg: ioBuf->send(ioBuf) \n");
        status = ioBuf->send(ioBuf);
    }
    memset(msg, 0, sizeof(AJ_Message));
    return status;
}
    a720:	b011      	add	sp, #68	; 0x44
    a722:	bc3c      	pop	{r2, r3, r4, r5}
    a724:	4690      	mov	r8, r2
    a726:	4699      	mov	r9, r3
    a728:	46a2      	mov	sl, r4
    a72a:	46ab      	mov	fp, r5
    a72c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a72e:	46c0      	nop			; (mov r8, r8)
    a730:	0001d3f4 	.word	0x0001d3f4
    a734:	00016f5d 	.word	0x00016f5d
    a738:	00007cd9 	.word	0x00007cd9
    a73c:	00007c65 	.word	0x00007c65
    a740:	00009ae5 	.word	0x00009ae5
    a744:	0001d2d8 	.word	0x0001d2d8
    a748:	0000636d 	.word	0x0000636d
    a74c:	0001d414 	.word	0x0001d414
    a750:	0001d438 	.word	0x0001d438
    a754:	00016e3d 	.word	0x00016e3d
    a758:	00000221 	.word	0x00000221
    a75c:	0001d468 	.word	0x0001d468
    a760:	0000d6a9 	.word	0x0000d6a9
    a764:	00016739 	.word	0x00016739
    a768:	0000482d 	.word	0x0000482d
    a76c:	0000d71d 	.word	0x0000d71d
    a770:	00000253 	.word	0x00000253
    a774:	0001d48c 	.word	0x0001d48c
    a778:	00016773 	.word	0x00016773

0000a77c <AJ_CloseMsg>:

// Write pad bytes to an I/O buffer
#define WritePad(msg, pad) WriteBytes(msg, NULL, 0, pad)

AJ_Status AJ_CloseMsg(AJ_Message* msg)
{
    a77c:	b5f0      	push	{r4, r5, r6, r7, lr}
    a77e:	465f      	mov	r7, fp
    a780:	b480      	push	{r7}
    a782:	b082      	sub	sp, #8
    AJ_Status status = AJ_OK;
    // This function is idempotent
    if (msg->bus)
    a784:	6b05      	ldr	r5, [r0, #48]	; 0x30
    a786:	2d00      	cmp	r5, #0
    a788:	d045      	beq.n	a816 <AJ_CloseMsg+0x9a>
    a78a:	1c06      	adds	r6, r0, #0
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    a78c:	2330      	movs	r3, #48	; 0x30
    a78e:	469c      	mov	ip, r3
    a790:	44ac      	add	ip, r5
    a792:	4663      	mov	r3, ip
    a794:	9300      	str	r3, [sp, #0]
        // Skip any unconsumed bytes
        while (msg->bodyBytes) 
    a796:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    a798:	2a00      	cmp	r2, #0
    a79a:	d032      	beq.n	a802 <AJ_CloseMsg+0x86>
            if (!sz) 
			{
                AJ_IO_BUF_RESET(ioBuf);
                sz = min(msg->bodyBytes, ioBuf->bufSize);
            }
            status = LoadBytes(ioBuf, sz, 0, &msg->timeout);
    a79c:	2338      	movs	r3, #56	; 0x38
    a79e:	469c      	mov	ip, r3
    a7a0:	4484      	add	ip, r0
    a7a2:	4663      	mov	r3, ip
    a7a4:	9301      	str	r3, [sp, #4]
    a7a6:	4b1f      	ldr	r3, [pc, #124]	; (a824 <AJ_CloseMsg+0xa8>)
    a7a8:	469b      	mov	fp, r3
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Skip any unconsumed bytes
        while (msg->bodyBytes) 
		{
            uint16_t sz = AJ_IO_BUF_AVAIL(ioBuf);
    a7aa:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    a7ac:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    a7ae:	1a5b      	subs	r3, r3, r1
    a7b0:	b29b      	uxth	r3, r3
            sz = min(sz, msg->bodyBytes);
    a7b2:	1c14      	adds	r4, r2, #0
    a7b4:	429a      	cmp	r2, r3
    a7b6:	d900      	bls.n	a7ba <AJ_CloseMsg+0x3e>
    a7b8:	1c1c      	adds	r4, r3, #0
    a7ba:	b2a4      	uxth	r4, r4
            if (!sz) 
    a7bc:	2c00      	cmp	r4, #0
    a7be:	d10e      	bne.n	a7de <AJ_CloseMsg+0x62>
			{
                AJ_IO_BUF_RESET(ioBuf);
    a7c0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    a7c2:	63ab      	str	r3, [r5, #56]	; 0x38
    a7c4:	63eb      	str	r3, [r5, #60]	; 0x3c
    a7c6:	1c2b      	adds	r3, r5, #0
    a7c8:	3330      	adds	r3, #48	; 0x30
    a7ca:	2200      	movs	r2, #0
    a7cc:	705a      	strb	r2, [r3, #1]
                sz = min(msg->bodyBytes, ioBuf->bufSize);
    a7ce:	8e6a      	ldrh	r2, [r5, #50]	; 0x32
    a7d0:	8df3      	ldrh	r3, [r6, #46]	; 0x2e
    a7d2:	1c1c      	adds	r4, r3, #0
    a7d4:	b29b      	uxth	r3, r3
    a7d6:	4293      	cmp	r3, r2
    a7d8:	d900      	bls.n	a7dc <AJ_CloseMsg+0x60>
    a7da:	1c14      	adds	r4, r2, #0
    a7dc:	b2a4      	uxth	r4, r4
            }
            status = LoadBytes(ioBuf, sz, 0, &msg->timeout);
    a7de:	9800      	ldr	r0, [sp, #0]
    a7e0:	1c21      	adds	r1, r4, #0
    a7e2:	2200      	movs	r2, #0
    a7e4:	9b01      	ldr	r3, [sp, #4]
    a7e6:	47d8      	blx	fp
    a7e8:	1e07      	subs	r7, r0, #0
            if (status != AJ_OK) 
    a7ea:	d10b      	bne.n	a804 <AJ_CloseMsg+0x88>
			{
                break;
            }
            msg->bodyBytes -= sz;
    a7ec:	8df3      	ldrh	r3, [r6, #46]	; 0x2e
    a7ee:	1b1b      	subs	r3, r3, r4
    a7f0:	85f3      	strh	r3, [r6, #46]	; 0x2e
            ioBuf->readPtr += sz;
    a7f2:	6bab      	ldr	r3, [r5, #56]	; 0x38
    a7f4:	469c      	mov	ip, r3
    a7f6:	4464      	add	r4, ip
    a7f8:	63ac      	str	r4, [r5, #56]	; 0x38
    // This function is idempotent
    if (msg->bus)
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Skip any unconsumed bytes
        while (msg->bodyBytes) 
    a7fa:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
    a7fc:	2a00      	cmp	r2, #0
    a7fe:	d1d4      	bne.n	a7aa <AJ_CloseMsg+0x2e>
    a800:	e000      	b.n	a804 <AJ_CloseMsg+0x88>
// Write pad bytes to an I/O buffer
#define WritePad(msg, pad) WriteBytes(msg, NULL, 0, pad)

AJ_Status AJ_CloseMsg(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    a802:	2700      	movs	r7, #0
                break;
            }
            msg->bodyBytes -= sz;
            ioBuf->readPtr += sz;
        }
        memset(msg, 0, sizeof(AJ_Message));
    a804:	1c30      	adds	r0, r6, #0
    a806:	2100      	movs	r1, #0
    a808:	2240      	movs	r2, #64	; 0x40
    a80a:	4b07      	ldr	r3, [pc, #28]	; (a828 <AJ_CloseMsg+0xac>)
    a80c:	4798      	blx	r3
#ifndef NDEBUG
        currentMsg = NULL;
    a80e:	2200      	movs	r2, #0
    a810:	4b06      	ldr	r3, [pc, #24]	; (a82c <AJ_CloseMsg+0xb0>)
    a812:	601a      	str	r2, [r3, #0]
    a814:	e000      	b.n	a818 <AJ_CloseMsg+0x9c>
// Write pad bytes to an I/O buffer
#define WritePad(msg, pad) WriteBytes(msg, NULL, 0, pad)

AJ_Status AJ_CloseMsg(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    a816:	2700      	movs	r7, #0
#ifndef NDEBUG
        currentMsg = NULL;
#endif
    }
    return status;
}
    a818:	1c38      	adds	r0, r7, #0
    a81a:	b002      	add	sp, #8
    a81c:	bc04      	pop	{r2}
    a81e:	4693      	mov	fp, r2
    a820:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a822:	46c0      	nop			; (mov r8, r8)
    a824:	00009c05 	.word	0x00009c05
    a828:	00016773 	.word	0x00016773
    a82c:	2000097c 	.word	0x2000097c

0000a830 <AJ_NextArgSig>:
    return status;
}

const char* AJ_NextArgSig(AJ_Message* msg)
{
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    a830:	6b01      	ldr	r1, [r0, #48]	; 0x30
    AJ_Arg* container = msg->outer;
    a832:	6b43      	ldr	r3, [r0, #52]	; 0x34
    const char* sig;

    if (msg->varOffset) 
    a834:	222d      	movs	r2, #45	; 0x2d
    a836:	5c82      	ldrb	r2, [r0, r2]
    a838:	2a00      	cmp	r2, #0
    a83a:	d002      	beq.n	a842 <AJ_NextArgSig+0x12>
	{
        // Variant - get the signature from the I/O buffer
        sig = (const char*)(ioBuf->readPtr - msg->varOffset);
    a83c:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    a83e:	1a98      	subs	r0, r3, r2
    a840:	e007      	b.n	a852 <AJ_NextArgSig+0x22>
    } 
	else 
	   if (container)
    a842:	2b00      	cmp	r3, #0
    a844:	d001      	beq.n	a84a <AJ_NextArgSig+0x1a>
	   {
        // Component of a container - use the container's signature
        sig = container->sigPtr;
    a846:	6898      	ldr	r0, [r3, #8]
    a848:	e003      	b.n	a852 <AJ_NextArgSig+0x22>
       } 
	   else 
	   {
        // Everything else - use the message signature
        sig = msg->signature + msg->sigOffset;
    a84a:	232c      	movs	r3, #44	; 0x2c
    a84c:	5cc3      	ldrb	r3, [r0, r3]
    a84e:	69c0      	ldr	r0, [r0, #28]
    a850:	18c0      	adds	r0, r0, r3
    }
    return sig;
}
    a852:	4770      	bx	lr

0000a854 <AJ_UnmarshalArg>:

AJ_Status AJ_UnmarshalArg(AJ_Message* msg, AJ_Arg* arg)
{
    a854:	b5f0      	push	{r4, r5, r6, r7, lr}
    a856:	b085      	sub	sp, #20
    a858:	1c04      	adds	r4, r0, #0
    a85a:	9101      	str	r1, [sp, #4]
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    a85c:	6b06      	ldr	r6, [r0, #48]	; 0x30
    AJ_Arg* container = msg->outer;
    a85e:	6b45      	ldr	r5, [r0, #52]	; 0x34
    uint8_t* argStart = ioBuf->readPtr;
    a860:	6bb7      	ldr	r7, [r6, #56]	; 0x38
    size_t consumed;
	//  
    const char* sig = AJ_NextArgSig(msg);
    a862:	4b31      	ldr	r3, [pc, #196]	; (a928 <AJ_UnmarshalArg+0xd4>)
    a864:	4798      	blx	r3
    a866:	9003      	str	r0, [sp, #12]

    if (msg->varOffset)
    a868:	232d      	movs	r3, #45	; 0x2d
    a86a:	5ce3      	ldrb	r3, [r4, r3]
    a86c:	2b00      	cmp	r3, #0
    a86e:	d008      	beq.n	a882 <AJ_UnmarshalArg+0x2e>
	{
        msg->varOffset = 0;
    a870:	2200      	movs	r2, #0
    a872:	232d      	movs	r3, #45	; 0x2d
    a874:	54e2      	strb	r2, [r4, r3]
        status = Unmarshal(msg, &sig, arg);
    a876:	1c20      	adds	r0, r4, #0
    a878:	a903      	add	r1, sp, #12
    a87a:	9a01      	ldr	r2, [sp, #4]
    a87c:	4b2b      	ldr	r3, [pc, #172]	; (a92c <AJ_UnmarshalArg+0xd8>)
    a87e:	4798      	blx	r3
    a880:	e046      	b.n	a910 <AJ_UnmarshalArg+0xbc>
    } 
	else 
	if (container) 
    a882:	2d00      	cmp	r5, #0
    a884:	d029      	beq.n	a8da <AJ_UnmarshalArg+0x86>
	{
        if (container->typeId == AJ_ARG_ARRAY) 
    a886:	782b      	ldrb	r3, [r5, #0]
    a888:	2b61      	cmp	r3, #97	; 0x61
    a88a:	d11e      	bne.n	a8ca <AJ_UnmarshalArg+0x76>
		{
            size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)container->val.v_data);
            // Return an error status if there are no more array elements.
            if (len == container->len) 
    a88c:	886a      	ldrh	r2, [r5, #2]
	else 
	if (container) 
	{
        if (container->typeId == AJ_ARG_ARRAY) 
		{
            size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)container->val.v_data);
    a88e:	686b      	ldr	r3, [r5, #4]
    a890:	1afb      	subs	r3, r7, r3
    a892:	b29b      	uxth	r3, r3
            // Return an error status if there are no more array elements.
            if (len == container->len) 
    a894:	4293      	cmp	r3, r2
    a896:	d112      	bne.n	a8be <AJ_UnmarshalArg+0x6a>
			{
                memset(arg, 0, sizeof(AJ_Arg));
    a898:	9801      	ldr	r0, [sp, #4]
    a89a:	2100      	movs	r1, #0
    a89c:	2210      	movs	r2, #16
    a89e:	4b24      	ldr	r3, [pc, #144]	; (a930 <AJ_UnmarshalArg+0xdc>)
    a8a0:	4798      	blx	r3
                AJ_ErrPrintf(("AJ_UnmarshalMsg(): AJ_ERR_NO_MORE\n"));
    a8a2:	2001      	movs	r0, #1
    a8a4:	4923      	ldr	r1, [pc, #140]	; (a934 <AJ_UnmarshalArg+0xe0>)
    a8a6:	4a24      	ldr	r2, [pc, #144]	; (a938 <AJ_UnmarshalArg+0xe4>)
    a8a8:	4b24      	ldr	r3, [pc, #144]	; (a93c <AJ_UnmarshalArg+0xe8>)
    a8aa:	4798      	blx	r3
    a8ac:	1c03      	adds	r3, r0, #0
                status = AJ_ERR_NO_MORE;
    a8ae:	200c      	movs	r0, #12
            size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)container->val.v_data);
            // Return an error status if there are no more array elements.
            if (len == container->len) 
			{
                memset(arg, 0, sizeof(AJ_Arg));
                AJ_ErrPrintf(("AJ_UnmarshalMsg(): AJ_ERR_NO_MORE\n"));
    a8b0:	2b00      	cmp	r3, #0
    a8b2:	d02d      	beq.n	a910 <AJ_UnmarshalArg+0xbc>
    a8b4:	4822      	ldr	r0, [pc, #136]	; (a940 <AJ_UnmarshalArg+0xec>)
    a8b6:	4b23      	ldr	r3, [pc, #140]	; (a944 <AJ_UnmarshalArg+0xf0>)
    a8b8:	4798      	blx	r3
                status = AJ_ERR_NO_MORE;
    a8ba:	200c      	movs	r0, #12
    a8bc:	e028      	b.n	a910 <AJ_UnmarshalArg+0xbc>
            }
			else 
			{
                status = Unmarshal(msg, &sig, arg);
    a8be:	1c20      	adds	r0, r4, #0
    a8c0:	a903      	add	r1, sp, #12
    a8c2:	9a01      	ldr	r2, [sp, #4]
    a8c4:	4b19      	ldr	r3, [pc, #100]	; (a92c <AJ_UnmarshalArg+0xd8>)
    a8c6:	4798      	blx	r3
    a8c8:	e022      	b.n	a910 <AJ_UnmarshalArg+0xbc>
            }
        } 
		else 
		{
            status = Unmarshal(msg, &sig, arg);
    a8ca:	1c20      	adds	r0, r4, #0
    a8cc:	a903      	add	r1, sp, #12
    a8ce:	9a01      	ldr	r2, [sp, #4]
    a8d0:	4b16      	ldr	r3, [pc, #88]	; (a92c <AJ_UnmarshalArg+0xd8>)
    a8d2:	4798      	blx	r3
            container->sigPtr = sig;
    a8d4:	9b03      	ldr	r3, [sp, #12]
    a8d6:	60ab      	str	r3, [r5, #8]
    a8d8:	e01a      	b.n	a910 <AJ_UnmarshalArg+0xbc>
        }
    }
	else 
	{
        // The signature representing the message body does not match the number of body bytes
        if (!msg->bodyBytes) 
    a8da:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    a8dc:	2b00      	cmp	r3, #0
    a8de:	d10d      	bne.n	a8fc <AJ_UnmarshalArg+0xa8>
		{
            AJ_ErrPrintf(("AJ_UnmarshalArg(): Message body length is incorrect, status = AJ_ERR_UNMARSHAL\n"));
    a8e0:	2001      	movs	r0, #1
    a8e2:	4914      	ldr	r1, [pc, #80]	; (a934 <AJ_UnmarshalArg+0xe0>)
    a8e4:	4a18      	ldr	r2, [pc, #96]	; (a948 <AJ_UnmarshalArg+0xf4>)
    a8e6:	4b15      	ldr	r3, [pc, #84]	; (a93c <AJ_UnmarshalArg+0xe8>)
    a8e8:	4798      	blx	r3
    a8ea:	1c03      	adds	r3, r0, #0
            status = AJ_ERR_UNMARSHAL;
    a8ec:	2009      	movs	r0, #9
	else 
	{
        // The signature representing the message body does not match the number of body bytes
        if (!msg->bodyBytes) 
		{
            AJ_ErrPrintf(("AJ_UnmarshalArg(): Message body length is incorrect, status = AJ_ERR_UNMARSHAL\n"));
    a8ee:	2b00      	cmp	r3, #0
    a8f0:	d00e      	beq.n	a910 <AJ_UnmarshalArg+0xbc>
    a8f2:	4816      	ldr	r0, [pc, #88]	; (a94c <AJ_UnmarshalArg+0xf8>)
    a8f4:	4b13      	ldr	r3, [pc, #76]	; (a944 <AJ_UnmarshalArg+0xf0>)
    a8f6:	4798      	blx	r3
            status = AJ_ERR_UNMARSHAL;
    a8f8:	2009      	movs	r0, #9
    a8fa:	e009      	b.n	a910 <AJ_UnmarshalArg+0xbc>
        } 
		else 
		{
			//!!!!!!!!!!!!!!!!!!!!!!!!
            status = Unmarshal(msg, &sig, arg);
    a8fc:	1c20      	adds	r0, r4, #0
    a8fe:	a903      	add	r1, sp, #12
    a900:	9a01      	ldr	r2, [sp, #4]
    a902:	4b0a      	ldr	r3, [pc, #40]	; (a92c <AJ_UnmarshalArg+0xd8>)
    a904:	4798      	blx	r3
            msg->sigOffset = (uint8_t)(sig - msg->signature);
    a906:	9b03      	ldr	r3, [sp, #12]
    a908:	69e2      	ldr	r2, [r4, #28]
    a90a:	1a9b      	subs	r3, r3, r2
    a90c:	222c      	movs	r2, #44	; 0x2c
    a90e:	54a3      	strb	r3, [r4, r2]
        }
    }
    consumed = (ioBuf->readPtr - argStart);
    a910:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    a912:	1bdb      	subs	r3, r3, r7

    if (consumed > msg->bodyBytes) 
    a914:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
    a916:	4293      	cmp	r3, r2
    a918:	d802      	bhi.n	a920 <AJ_UnmarshalArg+0xcc>
     //   printf("AJ_UnmarshalArg(): AJ_ERR_READ\n");
        status = AJ_ERR_READ;
    } 
	else 
	{
        msg->bodyBytes -= (uint16_t)consumed;
    a91a:	1ad3      	subs	r3, r2, r3
    a91c:	85e3      	strh	r3, [r4, #46]	; 0x2e
    a91e:	e000      	b.n	a922 <AJ_UnmarshalArg+0xce>

    if (consumed > msg->bodyBytes) 
	{
        // Unrecoverable
     //   printf("AJ_UnmarshalArg(): AJ_ERR_READ\n");
        status = AJ_ERR_READ;
    a920:	2005      	movs	r0, #5
	else 
	{
        msg->bodyBytes -= (uint16_t)consumed;
    }
    return status;
}
    a922:	b005      	add	sp, #20
    a924:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a926:	46c0      	nop			; (mov r8, r8)
    a928:	0000a831 	.word	0x0000a831
    a92c:	00009cf1 	.word	0x00009cf1
    a930:	00016773 	.word	0x00016773
    a934:	0001d2d8 	.word	0x0001d2d8
    a938:	00000621 	.word	0x00000621
    a93c:	0000636d 	.word	0x0000636d
    a940:	0001d4ac 	.word	0x0001d4ac
    a944:	00016f5d 	.word	0x00016f5d
    a948:	00000634 	.word	0x00000634
    a94c:	0001d4d0 	.word	0x0001d4d0

0000a950 <AJ_UnmarshalContainer>:
    }
    return status;
}

AJ_Status AJ_UnmarshalContainer(AJ_Message* msg, AJ_Arg* arg, uint8_t typeId)
{
    a950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    AJ_Status status = AJ_ERR_UNMARSHAL;

    if ((TYPE_FLAG(typeId) & AJ_CONTAINER)) 
    a952:	1c13      	adds	r3, r2, #0
    a954:	3b28      	subs	r3, #40	; 0x28
    a956:	2b01      	cmp	r3, #1
    a958:	d801      	bhi.n	a95e <AJ_UnmarshalContainer+0xe>
    a95a:	1c1c      	adds	r4, r3, #0
    a95c:	e006      	b.n	a96c <AJ_UnmarshalContainer+0x1c>
    a95e:	241e      	movs	r4, #30
    a960:	1c13      	adds	r3, r2, #0
    a962:	3b61      	subs	r3, #97	; 0x61
    a964:	2b1c      	cmp	r3, #28
    a966:	d801      	bhi.n	a96c <AJ_UnmarshalContainer+0x1c>
    a968:	1c14      	adds	r4, r2, #0
    a96a:	3c5f      	subs	r4, #95	; 0x5f
    a96c:	4b13      	ldr	r3, [pc, #76]	; (a9bc <AJ_UnmarshalContainer+0x6c>)
    a96e:	5d1c      	ldrb	r4, [r3, r4]
    return status;
}

AJ_Status AJ_UnmarshalContainer(AJ_Message* msg, AJ_Arg* arg, uint8_t typeId)
{
    AJ_Status status = AJ_ERR_UNMARSHAL;
    a970:	2309      	movs	r3, #9

    if ((TYPE_FLAG(typeId) & AJ_CONTAINER)) 
    a972:	06a4      	lsls	r4, r4, #26
    a974:	d520      	bpl.n	a9b8 <AJ_UnmarshalContainer+0x68>
    a976:	1c14      	adds	r4, r2, #0
    a978:	1c0d      	adds	r5, r1, #0
    a97a:	1c07      	adds	r7, r0, #0
	{
        unmarshalScalarAsElement = TRUE;
    a97c:	4e10      	ldr	r6, [pc, #64]	; (a9c0 <AJ_UnmarshalContainer+0x70>)
    a97e:	3b08      	subs	r3, #8
    a980:	7033      	strb	r3, [r6, #0]
        status = AJ_UnmarshalArg(msg, arg);
    a982:	4b10      	ldr	r3, [pc, #64]	; (a9c4 <AJ_UnmarshalContainer+0x74>)
    a984:	4798      	blx	r3
    a986:	1c03      	adds	r3, r0, #0
        unmarshalScalarAsElement = FALSE;
    a988:	2200      	movs	r2, #0
    a98a:	7032      	strb	r2, [r6, #0]
        if (status == AJ_OK) 
    a98c:	2800      	cmp	r0, #0
    a98e:	d113      	bne.n	a9b8 <AJ_UnmarshalContainer+0x68>
		{
            if (arg->typeId == typeId)
    a990:	782a      	ldrb	r2, [r5, #0]
    a992:	42a2      	cmp	r2, r4
    a994:	d103      	bne.n	a99e <AJ_UnmarshalContainer+0x4e>
			 {
                arg->container = msg->outer;
    a996:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    a998:	60ea      	str	r2, [r5, #12]
                msg->outer = arg;
    a99a:	637d      	str	r5, [r7, #52]	; 0x34
    a99c:	e00c      	b.n	a9b8 <AJ_UnmarshalContainer+0x68>
            } 
			else
			{
                AJ_ErrPrintf(("AJ_UnmarshalContainer(): AJ_ERR_UNMARSHAL\n"));
    a99e:	2001      	movs	r0, #1
    a9a0:	4909      	ldr	r1, [pc, #36]	; (a9c8 <AJ_UnmarshalContainer+0x78>)
    a9a2:	22e8      	movs	r2, #232	; 0xe8
    a9a4:	00d2      	lsls	r2, r2, #3
    a9a6:	4b09      	ldr	r3, [pc, #36]	; (a9cc <AJ_UnmarshalContainer+0x7c>)
    a9a8:	4798      	blx	r3
                status =  AJ_ERR_UNMARSHAL;
    a9aa:	2309      	movs	r3, #9
                arg->container = msg->outer;
                msg->outer = arg;
            } 
			else
			{
                AJ_ErrPrintf(("AJ_UnmarshalContainer(): AJ_ERR_UNMARSHAL\n"));
    a9ac:	2800      	cmp	r0, #0
    a9ae:	d003      	beq.n	a9b8 <AJ_UnmarshalContainer+0x68>
    a9b0:	4807      	ldr	r0, [pc, #28]	; (a9d0 <AJ_UnmarshalContainer+0x80>)
    a9b2:	4b08      	ldr	r3, [pc, #32]	; (a9d4 <AJ_UnmarshalContainer+0x84>)
    a9b4:	4798      	blx	r3
                status =  AJ_ERR_UNMARSHAL;
    a9b6:	2309      	movs	r3, #9
            }
        }
    }
    return status;
}
    a9b8:	1c18      	adds	r0, r3, #0
    a9ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a9bc:	0001dac0 	.word	0x0001dac0
    a9c0:	20000980 	.word	0x20000980
    a9c4:	0000a855 	.word	0x0000a855
    a9c8:	0001d2d8 	.word	0x0001d2d8
    a9cc:	0000636d 	.word	0x0000636d
    a9d0:	0001d568 	.word	0x0001d568
    a9d4:	00016f5d 	.word	0x00016f5d

0000a9d8 <AJ_UnmarshalCloseContainer>:

AJ_Status AJ_UnmarshalCloseContainer(AJ_Message* msg, AJ_Arg* arg)
{
    a9d8:	b510      	push	{r4, lr}
    AJ_ASSERT(TYPE_FLAG(arg->typeId) & AJ_CONTAINER);
    a9da:	780b      	ldrb	r3, [r1, #0]
    a9dc:	1c1a      	adds	r2, r3, #0
    a9de:	3a28      	subs	r2, #40	; 0x28
    a9e0:	2a01      	cmp	r2, #1
    a9e2:	d801      	bhi.n	a9e8 <AJ_UnmarshalCloseContainer+0x10>
    a9e4:	1c14      	adds	r4, r2, #0
    a9e6:	e006      	b.n	a9f6 <AJ_UnmarshalCloseContainer+0x1e>
    a9e8:	241e      	movs	r4, #30
    a9ea:	1c1a      	adds	r2, r3, #0
    a9ec:	3a61      	subs	r2, #97	; 0x61
    a9ee:	2a1c      	cmp	r2, #28
    a9f0:	d801      	bhi.n	a9f6 <AJ_UnmarshalCloseContainer+0x1e>
    a9f2:	3b5f      	subs	r3, #95	; 0x5f
    a9f4:	1c1c      	adds	r4, r3, #0
    a9f6:	4b2c      	ldr	r3, [pc, #176]	; (aaa8 <AJ_UnmarshalCloseContainer+0xd0>)
    a9f8:	5d1b      	ldrb	r3, [r3, r4]
    a9fa:	069b      	lsls	r3, r3, #26
    a9fc:	d405      	bmi.n	aa0a <AJ_UnmarshalCloseContainer+0x32>
    a9fe:	482b      	ldr	r0, [pc, #172]	; (aaac <AJ_UnmarshalCloseContainer+0xd4>)
    aa00:	492b      	ldr	r1, [pc, #172]	; (aab0 <AJ_UnmarshalCloseContainer+0xd8>)
    aa02:	4a2c      	ldr	r2, [pc, #176]	; (aab4 <AJ_UnmarshalCloseContainer+0xdc>)
    aa04:	4b2c      	ldr	r3, [pc, #176]	; (aab8 <AJ_UnmarshalCloseContainer+0xe0>)
    aa06:	4c2d      	ldr	r4, [pc, #180]	; (aabc <AJ_UnmarshalCloseContainer+0xe4>)
    aa08:	47a0      	blx	r4
    AJ_ASSERT(msg->outer == arg);
    aa0a:	6b43      	ldr	r3, [r0, #52]	; 0x34
    aa0c:	428b      	cmp	r3, r1
    aa0e:	d005      	beq.n	aa1c <AJ_UnmarshalCloseContainer+0x44>
    aa10:	4826      	ldr	r0, [pc, #152]	; (aaac <AJ_UnmarshalCloseContainer+0xd4>)
    aa12:	492b      	ldr	r1, [pc, #172]	; (aac0 <AJ_UnmarshalCloseContainer+0xe8>)
    aa14:	4a27      	ldr	r2, [pc, #156]	; (aab4 <AJ_UnmarshalCloseContainer+0xdc>)
    aa16:	4b2b      	ldr	r3, [pc, #172]	; (aac4 <AJ_UnmarshalCloseContainer+0xec>)
    aa18:	4c28      	ldr	r4, [pc, #160]	; (aabc <AJ_UnmarshalCloseContainer+0xe4>)
    aa1a:	47a0      	blx	r4

    msg->outer = arg->container;
    aa1c:	68da      	ldr	r2, [r3, #12]
    aa1e:	6342      	str	r2, [r0, #52]	; 0x34

    if (arg->typeId == AJ_ARG_ARRAY) 
    aa20:	781a      	ldrb	r2, [r3, #0]
    aa22:	2a61      	cmp	r2, #97	; 0x61
    aa24:	d116      	bne.n	aa54 <AJ_UnmarshalCloseContainer+0x7c>
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Check that all the array elements have been unmarshaled
        size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)arg->val.v_data);
        if (len != arg->len) 
    aa26:	8859      	ldrh	r1, [r3, #2]

    if (arg->typeId == AJ_ARG_ARRAY) 
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Check that all the array elements have been unmarshaled
        size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)arg->val.v_data);
    aa28:	6b02      	ldr	r2, [r0, #48]	; 0x30
    aa2a:	6b92      	ldr	r2, [r2, #56]	; 0x38
    aa2c:	685b      	ldr	r3, [r3, #4]
    aa2e:	1ad3      	subs	r3, r2, r3
    aa30:	b29b      	uxth	r3, r3
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return AJ_OK;
    aa32:	2000      	movs	r0, #0
    if (arg->typeId == AJ_ARG_ARRAY) 
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Check that all the array elements have been unmarshaled
        size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)arg->val.v_data);
        if (len != arg->len) 
    aa34:	428b      	cmp	r3, r1
    aa36:	d036      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_UNMARSHAL\n"));
    aa38:	3001      	adds	r0, #1
    aa3a:	491c      	ldr	r1, [pc, #112]	; (aaac <AJ_UnmarshalCloseContainer+0xd4>)
    aa3c:	4a22      	ldr	r2, [pc, #136]	; (aac8 <AJ_UnmarshalCloseContainer+0xf0>)
    aa3e:	4b23      	ldr	r3, [pc, #140]	; (aacc <AJ_UnmarshalCloseContainer+0xf4>)
    aa40:	4798      	blx	r3
    aa42:	1c03      	adds	r3, r0, #0
            return AJ_ERR_UNMARSHAL;
    aa44:	2009      	movs	r0, #9
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        // Check that all the array elements have been unmarshaled
        size_t len = (uint16_t)(ioBuf->readPtr - (uint8_t*)arg->val.v_data);
        if (len != arg->len) 
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_UNMARSHAL\n"));
    aa46:	2b00      	cmp	r3, #0
    aa48:	d02d      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
    aa4a:	4821      	ldr	r0, [pc, #132]	; (aad0 <AJ_UnmarshalCloseContainer+0xf8>)
    aa4c:	4b21      	ldr	r3, [pc, #132]	; (aad4 <AJ_UnmarshalCloseContainer+0xfc>)
    aa4e:	4798      	blx	r3
            return AJ_ERR_UNMARSHAL;
    aa50:	2009      	movs	r0, #9
    aa52:	e028      	b.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
        }
    } 
	else 
	{
        // Check that all of the struct elements have been unmarshaled
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
    aa54:	2a28      	cmp	r2, #40	; 0x28
    aa56:	d112      	bne.n	aa7e <AJ_UnmarshalCloseContainer+0xa6>
    aa58:	689b      	ldr	r3, [r3, #8]
    aa5a:	781b      	ldrb	r3, [r3, #0]
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return AJ_OK;
    aa5c:	2000      	movs	r0, #0
        }
    } 
	else 
	{
        // Check that all of the struct elements have been unmarshaled
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
    aa5e:	2b29      	cmp	r3, #41	; 0x29
    aa60:	d021      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    aa62:	3001      	adds	r0, #1
    aa64:	4911      	ldr	r1, [pc, #68]	; (aaac <AJ_UnmarshalCloseContainer+0xd4>)
    aa66:	4a1c      	ldr	r2, [pc, #112]	; (aad8 <AJ_UnmarshalCloseContainer+0x100>)
    aa68:	4b18      	ldr	r3, [pc, #96]	; (aacc <AJ_UnmarshalCloseContainer+0xf4>)
    aa6a:	4798      	blx	r3
    aa6c:	1c03      	adds	r3, r0, #0
            return AJ_ERR_SIGNATURE;
    aa6e:	2011      	movs	r0, #17
	else 
	{
        // Check that all of the struct elements have been unmarshaled
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    aa70:	2b00      	cmp	r3, #0
    aa72:	d018      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
    aa74:	4819      	ldr	r0, [pc, #100]	; (aadc <AJ_UnmarshalCloseContainer+0x104>)
    aa76:	4b17      	ldr	r3, [pc, #92]	; (aad4 <AJ_UnmarshalCloseContainer+0xfc>)
    aa78:	4798      	blx	r3
            return AJ_ERR_SIGNATURE;
    aa7a:	2011      	movs	r0, #17
    aa7c:	e013      	b.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return AJ_OK;
    aa7e:	2000      	movs	r0, #0
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
        if ((arg->typeId == AJ_ARG_DICT_ENTRY) && (*arg->sigPtr != AJ_DICT_ENTRY_CLOSE))
    aa80:	2a7b      	cmp	r2, #123	; 0x7b
    aa82:	d110      	bne.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
    aa84:	689b      	ldr	r3, [r3, #8]
    aa86:	781b      	ldrb	r3, [r3, #0]
    aa88:	2b7d      	cmp	r3, #125	; 0x7d
    aa8a:	d00c      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    aa8c:	3001      	adds	r0, #1
    aa8e:	4907      	ldr	r1, [pc, #28]	; (aaac <AJ_UnmarshalCloseContainer+0xd4>)
    aa90:	4a13      	ldr	r2, [pc, #76]	; (aae0 <AJ_UnmarshalCloseContainer+0x108>)
    aa92:	4b0e      	ldr	r3, [pc, #56]	; (aacc <AJ_UnmarshalCloseContainer+0xf4>)
    aa94:	4798      	blx	r3
    aa96:	1c03      	adds	r3, r0, #0
            return AJ_ERR_SIGNATURE;
    aa98:	2011      	movs	r0, #17
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
        if ((arg->typeId == AJ_ARG_DICT_ENTRY) && (*arg->sigPtr != AJ_DICT_ENTRY_CLOSE))
		{
            AJ_ErrPrintf(("AJ_UnmarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    aa9a:	2b00      	cmp	r3, #0
    aa9c:	d003      	beq.n	aaa6 <AJ_UnmarshalCloseContainer+0xce>
    aa9e:	480f      	ldr	r0, [pc, #60]	; (aadc <AJ_UnmarshalCloseContainer+0x104>)
    aaa0:	4b0c      	ldr	r3, [pc, #48]	; (aad4 <AJ_UnmarshalCloseContainer+0xfc>)
    aaa2:	4798      	blx	r3
            return AJ_ERR_SIGNATURE;
    aaa4:	2011      	movs	r0, #17
        }
    }
    return AJ_OK;
}
    aaa6:	bd10      	pop	{r4, pc}
    aaa8:	0001dac0 	.word	0x0001dac0
    aaac:	0001d2d8 	.word	0x0001d2d8
    aab0:	0000074a 	.word	0x0000074a
    aab4:	0001d268 	.word	0x0001d268
    aab8:	0001d594 	.word	0x0001d594
    aabc:	00016629 	.word	0x00016629
    aac0:	0000074b 	.word	0x0000074b
    aac4:	0001d648 	.word	0x0001d648
    aac8:	00000756 	.word	0x00000756
    aacc:	0000636d 	.word	0x0000636d
    aad0:	0001d65c 	.word	0x0001d65c
    aad4:	00016f5d 	.word	0x00016f5d
    aad8:	0000075f 	.word	0x0000075f
    aadc:	0001d68c 	.word	0x0001d68c
    aae0:	00000764 	.word	0x00000764

0000aae4 <AJ_SkipArg>:
//	printf("----AJ_UnmarshalMsg() end status=%s----\n",AJ_StatusText(status));
    return status;
}

AJ_Status AJ_SkipArg(AJ_Message* msg)
{
    aae4:	b570      	push	{r4, r5, r6, lr}
    aae6:	b084      	sub	sp, #16
    AJ_Status status;
    AJ_Arg skippy;

    // Variants must be skipped atomically
    if (msg->varOffset) 
    aae8:	232d      	movs	r3, #45	; 0x2d
    aaea:	5cc2      	ldrb	r2, [r0, r3]
	{
        return AJ_ERR_UNEXPECTED;
    aaec:	3b2b      	subs	r3, #43	; 0x2b
{
    AJ_Status status;
    AJ_Arg skippy;

    // Variants must be skipped atomically
    if (msg->varOffset) 
    aaee:	2a00      	cmp	r2, #0
    aaf0:	d165      	bne.n	abbe <AJ_SkipArg+0xda>
    aaf2:	1c04      	adds	r4, r0, #0
	{
        return AJ_ERR_UNEXPECTED;
    }
    status = AJ_UnmarshalArg(msg, &skippy);
    aaf4:	4669      	mov	r1, sp
    aaf6:	4b33      	ldr	r3, [pc, #204]	; (abc4 <AJ_SkipArg+0xe0>)
    aaf8:	4798      	blx	r3
    aafa:	1c02      	adds	r2, r0, #0
    if (status != AJ_OK) 
	{
        return status;
    aafc:	1e03      	subs	r3, r0, #0
    if (msg->varOffset) 
	{
        return AJ_ERR_UNEXPECTED;
    }
    status = AJ_UnmarshalArg(msg, &skippy);
    if (status != AJ_OK) 
    aafe:	d15e      	bne.n	abbe <AJ_SkipArg+0xda>
	{
        return status;
    }
    if (msg->varOffset) 
    ab00:	232d      	movs	r3, #45	; 0x2d
    ab02:	5ce3      	ldrb	r3, [r4, r3]
    ab04:	2b00      	cmp	r3, #0
    ab06:	d004      	beq.n	ab12 <AJ_SkipArg+0x2e>
	{
        status = AJ_UnmarshalArg(msg, &skippy);
    ab08:	1c20      	adds	r0, r4, #0
    ab0a:	4669      	mov	r1, sp
    ab0c:	4b2d      	ldr	r3, [pc, #180]	; (abc4 <AJ_SkipArg+0xe0>)
    ab0e:	4798      	blx	r3
    ab10:	1c02      	adds	r2, r0, #0
    }
    if (TYPE_FLAG(skippy.typeId) == 0) 
    ab12:	466b      	mov	r3, sp
    ab14:	7819      	ldrb	r1, [r3, #0]
    ab16:	1c0b      	adds	r3, r1, #0
    ab18:	3b28      	subs	r3, #40	; 0x28
    ab1a:	2b01      	cmp	r3, #1
    ab1c:	d806      	bhi.n	ab2c <AJ_SkipArg+0x48>
    ab1e:	1c18      	adds	r0, r3, #0
    ab20:	4b29      	ldr	r3, [pc, #164]	; (abc8 <AJ_SkipArg+0xe4>)
    ab22:	5c1d      	ldrb	r5, [r3, r0]
	{
        return AJ_ERR_SIGNATURE;
    ab24:	2311      	movs	r3, #17
    }
    if (msg->varOffset) 
	{
        status = AJ_UnmarshalArg(msg, &skippy);
    }
    if (TYPE_FLAG(skippy.typeId) == 0) 
    ab26:	2d00      	cmp	r5, #0
    ab28:	d049      	beq.n	abbe <AJ_SkipArg+0xda>
    ab2a:	e00c      	b.n	ab46 <AJ_SkipArg+0x62>
	{
        return AJ_ERR_SIGNATURE;
    ab2c:	2311      	movs	r3, #17
    }
    if (msg->varOffset) 
	{
        status = AJ_UnmarshalArg(msg, &skippy);
    }
    if (TYPE_FLAG(skippy.typeId) == 0) 
    ab2e:	1c08      	adds	r0, r1, #0
    ab30:	3861      	subs	r0, #97	; 0x61
    ab32:	281c      	cmp	r0, #28
    ab34:	d843      	bhi.n	abbe <AJ_SkipArg+0xda>
    ab36:	4b24      	ldr	r3, [pc, #144]	; (abc8 <AJ_SkipArg+0xe4>)
    ab38:	185b      	adds	r3, r3, r1
    ab3a:	3b5f      	subs	r3, #95	; 0x5f
    ab3c:	7818      	ldrb	r0, [r3, #0]
	{
        return AJ_ERR_SIGNATURE;
    ab3e:	2311      	movs	r3, #17
    }
    if (msg->varOffset) 
	{
        status = AJ_UnmarshalArg(msg, &skippy);
    }
    if (TYPE_FLAG(skippy.typeId) == 0) 
    ab40:	2800      	cmp	r0, #0
    ab42:	d03c      	beq.n	abbe <AJ_SkipArg+0xda>
    ab44:	e038      	b.n	abb8 <AJ_SkipArg+0xd4>
	{
        return AJ_ERR_SIGNATURE;
    }
    // If skipping a container skip the contents
    if (TYPE_FLAG(skippy.typeId) & AJ_CONTAINER) 
    ab46:	4b20      	ldr	r3, [pc, #128]	; (abc8 <AJ_SkipArg+0xe4>)
    ab48:	5c18      	ldrb	r0, [r3, r0]
    ab4a:	1c13      	adds	r3, r2, #0
    ab4c:	0680      	lsls	r0, r0, #26
    ab4e:	d536      	bpl.n	abbe <AJ_SkipArg+0xda>
	{
        skippy.container = msg->outer;
    ab50:	6b63      	ldr	r3, [r4, #52]	; 0x34
    ab52:	9303      	str	r3, [sp, #12]
        msg->outer = &skippy;
    ab54:	466b      	mov	r3, sp
    ab56:	6363      	str	r3, [r4, #52]	; 0x34
        if (skippy.typeId == AJ_ARG_ARRAY)
    ab58:	2961      	cmp	r1, #97	; 0x61
    ab5a:	d113      	bne.n	ab84 <AJ_SkipArg+0xa0>
		{
            AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    ab5c:	6b25      	ldr	r5, [r4, #48]	; 0x30
    ab5e:	1c28      	adds	r0, r5, #0
    ab60:	3030      	adds	r0, #48	; 0x30
            // Just consume the array bytes
            status = LoadBytes(ioBuf, skippy.len, 0, &msg->timeout);
    ab62:	8859      	ldrh	r1, [r3, #2]
    ab64:	1c23      	adds	r3, r4, #0
    ab66:	3338      	adds	r3, #56	; 0x38
    ab68:	2200      	movs	r2, #0
    ab6a:	4e18      	ldr	r6, [pc, #96]	; (abcc <AJ_SkipArg+0xe8>)
    ab6c:	47b0      	blx	r6
    ab6e:	1e02      	subs	r2, r0, #0
            if (status == AJ_OK) 
    ab70:	d11e      	bne.n	abb0 <AJ_SkipArg+0xcc>
			{
                ioBuf->readPtr += skippy.len;
    ab72:	466b      	mov	r3, sp
    ab74:	8859      	ldrh	r1, [r3, #2]
    ab76:	6bab      	ldr	r3, [r5, #56]	; 0x38
    ab78:	185a      	adds	r2, r3, r1
    ab7a:	63aa      	str	r2, [r5, #56]	; 0x38
                msg->bodyBytes -= skippy.len;
    ab7c:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    ab7e:	1a5b      	subs	r3, r3, r1
    ab80:	85e3      	strh	r3, [r4, #46]	; 0x2e
    ab82:	e010      	b.n	aba6 <AJ_SkipArg+0xc2>
            }
        } 
		else
		{
            // Skip the individual elements
            char close = (skippy.typeId == AJ_ARG_STRUCT) ?  AJ_STRUCT_CLOSE : AJ_DICT_ENTRY_CLOSE;
    ab84:	2928      	cmp	r1, #40	; 0x28
    ab86:	d001      	beq.n	ab8c <AJ_SkipArg+0xa8>
    ab88:	257d      	movs	r5, #125	; 0x7d
    ab8a:	e006      	b.n	ab9a <AJ_SkipArg+0xb6>
    ab8c:	2529      	movs	r5, #41	; 0x29
            while (*skippy.sigPtr != close) 
    ab8e:	e004      	b.n	ab9a <AJ_SkipArg+0xb6>
			{
                status = AJ_SkipArg(msg);
    ab90:	1c20      	adds	r0, r4, #0
    ab92:	f7ff ffa7 	bl	aae4 <AJ_SkipArg>
    ab96:	1e02      	subs	r2, r0, #0
                if (status != AJ_OK) 
    ab98:	d10a      	bne.n	abb0 <AJ_SkipArg+0xcc>
        } 
		else
		{
            // Skip the individual elements
            char close = (skippy.typeId == AJ_ARG_STRUCT) ?  AJ_STRUCT_CLOSE : AJ_DICT_ENTRY_CLOSE;
            while (*skippy.sigPtr != close) 
    ab9a:	9b02      	ldr	r3, [sp, #8]
    ab9c:	781b      	ldrb	r3, [r3, #0]
    ab9e:	42ab      	cmp	r3, r5
    aba0:	d1f6      	bne.n	ab90 <AJ_SkipArg+0xac>
				{
                    break;
                }
            }
        }
        if (status == AJ_OK) 
    aba2:	2a00      	cmp	r2, #0
    aba4:	d104      	bne.n	abb0 <AJ_SkipArg+0xcc>
		{
            status = AJ_UnmarshalCloseContainer(msg, &skippy);
    aba6:	1c20      	adds	r0, r4, #0
    aba8:	4669      	mov	r1, sp
    abaa:	4b09      	ldr	r3, [pc, #36]	; (abd0 <AJ_SkipArg+0xec>)
    abac:	4798      	blx	r3
    abae:	1c02      	adds	r2, r0, #0
        }
        msg->outer = skippy.container;
    abb0:	9b03      	ldr	r3, [sp, #12]
    abb2:	6363      	str	r3, [r4, #52]	; 0x34
    abb4:	1c13      	adds	r3, r2, #0
    abb6:	e002      	b.n	abbe <AJ_SkipArg+0xda>
    if (TYPE_FLAG(skippy.typeId) == 0) 
	{
        return AJ_ERR_SIGNATURE;
    }
    // If skipping a container skip the contents
    if (TYPE_FLAG(skippy.typeId) & AJ_CONTAINER) 
    abb8:	1c08      	adds	r0, r1, #0
    abba:	385f      	subs	r0, #95	; 0x5f
    abbc:	e7c3      	b.n	ab46 <AJ_SkipArg+0x62>
            status = AJ_UnmarshalCloseContainer(msg, &skippy);
        }
        msg->outer = skippy.container;
    }
    return status;
}
    abbe:	1c18      	adds	r0, r3, #0
    abc0:	b004      	add	sp, #16
    abc2:	bd70      	pop	{r4, r5, r6, pc}
    abc4:	0000a855 	.word	0x0000a855
    abc8:	0001dac0 	.word	0x0001dac0
    abcc:	00009c05 	.word	0x00009c05
    abd0:	0000a9d9 	.word	0x0000a9d9

0000abd4 <AJ_ResetArgs>:
    }
    return status;
}

AJ_Status AJ_ResetArgs(AJ_Message* msg)
{
    abd4:	b570      	push	{r4, r5, r6, lr}
    AJ_Status status = AJ_OK;;

    if (!msg->hdr)
    abd6:	6843      	ldr	r3, [r0, #4]
    abd8:	2b00      	cmp	r3, #0
    abda:	d044      	beq.n	ac66 <AJ_ResetArgs+0x92>
	{
        return AJ_ERR_NULL;
    }
    // Nothing to do if the message has no arguments
    if (!msg->signature || (msg->signature[0] == '\0'))
    abdc:	69c3      	ldr	r3, [r0, #28]
    abde:	2b00      	cmp	r3, #0
    abe0:	d043      	beq.n	ac6a <AJ_ResetArgs+0x96>
    abe2:	781a      	ldrb	r2, [r3, #0]
    abe4:	2a00      	cmp	r2, #0
    abe6:	d042      	beq.n	ac6e <AJ_ResetArgs+0x9a>
    abe8:	1c05      	adds	r5, r0, #0
	{
        return status;
    }
    // The arguments must fully unmarshaled before we can do a reset
    while (msg->bodyBytes && (status == AJ_OK)) 
    abea:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    abec:	2a00      	cmp	r2, #0
    abee:	d048      	beq.n	ac82 <AJ_ResetArgs+0xae>
	{
        status = AJ_SkipArg(msg);
    abf0:	4e28      	ldr	r6, [pc, #160]	; (ac94 <AJ_ResetArgs+0xc0>)
    abf2:	1c28      	adds	r0, r5, #0
    abf4:	47b0      	blx	r6
    abf6:	1c04      	adds	r4, r0, #0
    if (!msg->signature || (msg->signature[0] == '\0'))
	{
        return status;
    }
    // The arguments must fully unmarshaled before we can do a reset
    while (msg->bodyBytes && (status == AJ_OK)) 
    abf8:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    abfa:	2b00      	cmp	r3, #0
    abfc:	d002      	beq.n	ac04 <AJ_ResetArgs+0x30>
    abfe:	2800      	cmp	r0, #0
    ac00:	d0f7      	beq.n	abf2 <AJ_ResetArgs+0x1e>
    ac02:	e036      	b.n	ac72 <AJ_ResetArgs+0x9e>
	{
        status = AJ_SkipArg(msg);
    }
    AJ_ASSERT(msg->sigOffset == strlen(msg->signature));
    ac04:	69e8      	ldr	r0, [r5, #28]
    ac06:	4b24      	ldr	r3, [pc, #144]	; (ac98 <AJ_ResetArgs+0xc4>)
    ac08:	4798      	blx	r3
    ac0a:	232c      	movs	r3, #44	; 0x2c
    ac0c:	5ceb      	ldrb	r3, [r5, r3]
    ac0e:	4283      	cmp	r3, r0
    ac10:	d005      	beq.n	ac1e <AJ_ResetArgs+0x4a>
    ac12:	4822      	ldr	r0, [pc, #136]	; (ac9c <AJ_ResetArgs+0xc8>)
    ac14:	4922      	ldr	r1, [pc, #136]	; (aca0 <AJ_ResetArgs+0xcc>)
    ac16:	4a23      	ldr	r2, [pc, #140]	; (aca4 <AJ_ResetArgs+0xd0>)
    ac18:	4b23      	ldr	r3, [pc, #140]	; (aca8 <AJ_ResetArgs+0xd4>)
    ac1a:	4c24      	ldr	r4, [pc, #144]	; (acac <AJ_ResetArgs+0xd8>)
    ac1c:	47a0      	blx	r4
    if (status == AJ_OK) 
    ac1e:	2c00      	cmp	r4, #0
    ac20:	d11f      	bne.n	ac62 <AJ_ResetArgs+0x8e>
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    ac22:	6b29      	ldr	r1, [r5, #48]	; 0x30
        size_t hdrSize = sizeof(AJ_MsgHeader) + msg->hdr->headerLen + ((8 - msg->hdr->headerLen) & 7);
    ac24:	686b      	ldr	r3, [r5, #4]
    ac26:	68da      	ldr	r2, [r3, #12]
        /*
               * Args have already been converted to native endianess in place in the input buffer, this
               * prevents the unmarshaler from incorrectly undoing the conversion.
              */
        msg->hdr->endianess = AJ_NATIVE_ENDIAN;
    ac28:	206c      	movs	r0, #108	; 0x6c
    ac2a:	7018      	strb	r0, [r3, #0]
    ac2c:	1c10      	adds	r0, r2, #0
    ac2e:	3010      	adds	r0, #16
    }
    AJ_ASSERT(msg->sigOffset == strlen(msg->signature));
    if (status == AJ_OK) 
	{
        AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
        size_t hdrSize = sizeof(AJ_MsgHeader) + msg->hdr->headerLen + ((8 - msg->hdr->headerLen) & 7);
    ac30:	4252      	negs	r2, r2
    ac32:	2307      	movs	r3, #7
    ac34:	401a      	ands	r2, r3
    ac36:	1883      	adds	r3, r0, r2
               * Args have already been converted to native endianess in place in the input buffer, this
               * prevents the unmarshaler from incorrectly undoing the conversion.
              */
        msg->hdr->endianess = AJ_NATIVE_ENDIAN;
        // Reset the read pointer to the start of the argument list
        ioBuf->readPtr = ioBuf->bufStart + hdrSize;
    ac38:	6b4a      	ldr	r2, [r1, #52]	; 0x34
    ac3a:	4694      	mov	ip, r2
    ac3c:	4463      	add	r3, ip
    ac3e:	638b      	str	r3, [r1, #56]	; 0x38
        AJ_ASSERT(ioBuf->readPtr < ioBuf->writePtr);
    ac40:	6bca      	ldr	r2, [r1, #60]	; 0x3c
    ac42:	4293      	cmp	r3, r2
    ac44:	d306      	bcc.n	ac54 <AJ_ResetArgs+0x80>
    ac46:	4815      	ldr	r0, [pc, #84]	; (ac9c <AJ_ResetArgs+0xc8>)
    ac48:	2186      	movs	r1, #134	; 0x86
    ac4a:	00c9      	lsls	r1, r1, #3
    ac4c:	4a15      	ldr	r2, [pc, #84]	; (aca4 <AJ_ResetArgs+0xd0>)
    ac4e:	4b18      	ldr	r3, [pc, #96]	; (acb0 <AJ_ResetArgs+0xdc>)
    ac50:	4c16      	ldr	r4, [pc, #88]	; (acac <AJ_ResetArgs+0xd8>)
    ac52:	47a0      	blx	r4
        // Reset signature and body offsets
        msg->sigOffset = 0;
    ac54:	2200      	movs	r2, #0
    ac56:	232c      	movs	r3, #44	; 0x2c
    ac58:	54ea      	strb	r2, [r5, r3]
        msg->bodyBytes = msg->hdr->bodyLen;
    ac5a:	686b      	ldr	r3, [r5, #4]
    ac5c:	685b      	ldr	r3, [r3, #4]
    ac5e:	85eb      	strh	r3, [r5, #46]	; 0x2e
    ac60:	2400      	movs	r4, #0
    }
    return status;
    ac62:	1c20      	adds	r0, r4, #0
    ac64:	e015      	b.n	ac92 <AJ_ResetArgs+0xbe>
{
    AJ_Status status = AJ_OK;;

    if (!msg->hdr)
	{
        return AJ_ERR_NULL;
    ac66:	2001      	movs	r0, #1
    ac68:	e013      	b.n	ac92 <AJ_ResetArgs+0xbe>
    }
    // Nothing to do if the message has no arguments
    if (!msg->signature || (msg->signature[0] == '\0'))
	{
        return status;
    ac6a:	2000      	movs	r0, #0
    ac6c:	e011      	b.n	ac92 <AJ_ResetArgs+0xbe>
    ac6e:	2000      	movs	r0, #0
    ac70:	e00f      	b.n	ac92 <AJ_ResetArgs+0xbe>
    // The arguments must fully unmarshaled before we can do a reset
    while (msg->bodyBytes && (status == AJ_OK)) 
	{
        status = AJ_SkipArg(msg);
    }
    AJ_ASSERT(msg->sigOffset == strlen(msg->signature));
    ac72:	69e8      	ldr	r0, [r5, #28]
    ac74:	4b08      	ldr	r3, [pc, #32]	; (ac98 <AJ_ResetArgs+0xc4>)
    ac76:	4798      	blx	r3
    ac78:	232c      	movs	r3, #44	; 0x2c
    ac7a:	5ceb      	ldrb	r3, [r5, r3]
    ac7c:	4283      	cmp	r3, r0
    ac7e:	d0f0      	beq.n	ac62 <AJ_ResetArgs+0x8e>
    ac80:	e7c7      	b.n	ac12 <AJ_ResetArgs+0x3e>
    ac82:	1c18      	adds	r0, r3, #0
    ac84:	4b04      	ldr	r3, [pc, #16]	; (ac98 <AJ_ResetArgs+0xc4>)
    ac86:	4798      	blx	r3
    ac88:	232c      	movs	r3, #44	; 0x2c
    ac8a:	5ceb      	ldrb	r3, [r5, r3]
    ac8c:	4283      	cmp	r3, r0
    ac8e:	d0c8      	beq.n	ac22 <AJ_ResetArgs+0x4e>
    ac90:	e7bf      	b.n	ac12 <AJ_ResetArgs+0x3e>
        // Reset signature and body offsets
        msg->sigOffset = 0;
        msg->bodyBytes = msg->hdr->bodyLen;
    }
    return status;
}
    ac92:	bd70      	pop	{r4, r5, r6, pc}
    ac94:	0000aae5 	.word	0x0000aae5
    ac98:	0001715b 	.word	0x0001715b
    ac9c:	0001d2d8 	.word	0x0001d2d8
    aca0:	00000424 	.word	0x00000424
    aca4:	0001db0c 	.word	0x0001db0c
    aca8:	0001d6bc 	.word	0x0001d6bc
    acac:	00016629 	.word	0x00016629
    acb0:	0001d6e8 	.word	0x0001d6e8

0000acb4 <AJ_UnmarshalMsg>:

extern volatile uint8_t tcp_data_rx[1460];
extern volatile uint16_t tcp_rx_ready;

AJ_Status AJ_UnmarshalMsg(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t timeout)
{
    acb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    acb6:	465f      	mov	r7, fp
    acb8:	4656      	mov	r6, sl
    acba:	464d      	mov	r5, r9
    acbc:	4644      	mov	r4, r8
    acbe:	b4f0      	push	{r4, r5, r6, r7}
    acc0:	b093      	sub	sp, #76	; 0x4c
    acc2:	1c05      	adds	r5, r0, #0
    acc4:	1c0c      	adds	r4, r1, #0
    acc6:	1c16      	adds	r6, r2, #0
    uint32_t hdrPad;
    AJ_Time msgTimer;

  //  printf("----AJ_UnmarshalMsg() begin----\n");

    AJ_InitTimer(&msgTimer);
    acc8:	a810      	add	r0, sp, #64	; 0x40
    acca:	4bb9      	ldr	r3, [pc, #740]	; (afb0 <AJ_UnmarshalMsg+0x2fc>)
    accc:	4798      	blx	r3
    // Clear message then set the bus and overall timeout
    memset(msg, 0, sizeof(AJ_Message));
    acce:	1c20      	adds	r0, r4, #0
    acd0:	2100      	movs	r1, #0
    acd2:	2240      	movs	r2, #64	; 0x40
    acd4:	4bb7      	ldr	r3, [pc, #732]	; (afb4 <AJ_UnmarshalMsg+0x300>)
    acd6:	4798      	blx	r3
    msg->msgId = AJ_INVALID_MSG_ID;
    acd8:	2301      	movs	r3, #1
    acda:	425b      	negs	r3, r3
    acdc:	6023      	str	r3, [r4, #0]
    msg->bus = bus;
    acde:	6325      	str	r5, [r4, #48]	; 0x30
    msg->timeout = timeout;
    ace0:	63a6      	str	r6, [r4, #56]	; 0x38
/*	printf("---------------------\n");
	printf("ReadPtr= %d\n", ioBuf->readPtr);
	printf("WritePtr= %d\n", ioBuf->writePtr);
	printf("---------------------\n");*/
    // Check that the read and write pointers are within the bounds of the recv buffer
    if ((ioBuf->readPtr < ioBuf->bufStart) || (ioBuf->readPtr > (ioBuf->bufStart + ioBuf->bufSize)) ||
    ace2:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    ace4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
        (ioBuf->writePtr < ioBuf->readPtr) || (ioBuf->writePtr > (ioBuf->bufStart + ioBuf->bufSize))) 
	{
  //      printf("AJ_UnmarshalMsg(): recv buffer pointer out of bounds: AJ_ERR_IO_BUFFER\n");
        return AJ_ERR_READ; //Buffer pointer is out of bounds, this is unrecoverable
    ace6:	2005      	movs	r0, #5
/*	printf("---------------------\n");
	printf("ReadPtr= %d\n", ioBuf->readPtr);
	printf("WritePtr= %d\n", ioBuf->writePtr);
	printf("---------------------\n");*/
    // Check that the read and write pointers are within the bounds of the recv buffer
    if ((ioBuf->readPtr < ioBuf->bufStart) || (ioBuf->readPtr > (ioBuf->bufStart + ioBuf->bufSize)) ||
    ace8:	4299      	cmp	r1, r3
    acea:	d200      	bcs.n	acee <AJ_UnmarshalMsg+0x3a>
    acec:	e2d6      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
    acee:	8e6e      	ldrh	r6, [r5, #50]	; 0x32
    acf0:	199e      	adds	r6, r3, r6
    acf2:	42b1      	cmp	r1, r6
    acf4:	d900      	bls.n	acf8 <AJ_UnmarshalMsg+0x44>
    acf6:	e2d1      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
        (ioBuf->writePtr < ioBuf->readPtr) || (ioBuf->writePtr > (ioBuf->bufStart + ioBuf->bufSize))) 
    acf8:	6bea      	ldr	r2, [r5, #60]	; 0x3c
/*	printf("---------------------\n");
	printf("ReadPtr= %d\n", ioBuf->readPtr);
	printf("WritePtr= %d\n", ioBuf->writePtr);
	printf("---------------------\n");*/
    // Check that the read and write pointers are within the bounds of the recv buffer
    if ((ioBuf->readPtr < ioBuf->bufStart) || (ioBuf->readPtr > (ioBuf->bufStart + ioBuf->bufSize)) ||
    acfa:	4291      	cmp	r1, r2
    acfc:	d900      	bls.n	ad00 <AJ_UnmarshalMsg+0x4c>
    acfe:	e2cd      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
        (ioBuf->writePtr < ioBuf->readPtr) || (ioBuf->writePtr > (ioBuf->bufStart + ioBuf->bufSize))) 
    ad00:	4296      	cmp	r6, r2
    ad02:	d200      	bcs.n	ad06 <AJ_UnmarshalMsg+0x52>
    ad04:	e2ca      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
extern volatile uint16_t tcp_rx_ready;

AJ_Status AJ_UnmarshalMsg(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t timeout)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &bus->sock.rx;
    ad06:	1c2e      	adds	r6, r5, #0
    ad08:	3630      	adds	r6, #48	; 0x30
  //      printf("AJ_UnmarshalMsg(): recv buffer pointer out of bounds: AJ_ERR_IO_BUFFER\n");
        return AJ_ERR_READ; //Buffer pointer is out of bounds, this is unrecoverable
    }
	//printf("tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
    //Move any unconsumed data to the start of the I/O buffer
    if (tcp_rx_ready==0)
    ad0a:	48ab      	ldr	r0, [pc, #684]	; (afb8 <AJ_UnmarshalMsg+0x304>)
    ad0c:	8800      	ldrh	r0, [r0, #0]
    ad0e:	b280      	uxth	r0, r0
    ad10:	2800      	cmp	r0, #0
    ad12:	d108      	bne.n	ad26 <AJ_UnmarshalMsg+0x72>
    {
	   printf("ioBuf->readPtr=0x%x ioBuf->writePtr = 0x%x AJ_IO_BUF_AVAIL(ioBuf) =%d\n",ioBuf->readPtr,ioBuf->writePtr,AJ_IO_BUF_AVAIL(ioBuf));
    ad14:	1a53      	subs	r3, r2, r1
    ad16:	48a9      	ldr	r0, [pc, #676]	; (afbc <AJ_UnmarshalMsg+0x308>)
    ad18:	4fa9      	ldr	r7, [pc, #676]	; (afc0 <AJ_UnmarshalMsg+0x30c>)
    ad1a:	47b8      	blx	r7
       AJ_IOBufRebase(ioBuf, 0);
    ad1c:	1c30      	adds	r0, r6, #0
    ad1e:	2100      	movs	r1, #0
    ad20:	4ba8      	ldr	r3, [pc, #672]	; (afc4 <AJ_UnmarshalMsg+0x310>)
    ad22:	4798      	blx	r3
    ad24:	e023      	b.n	ad6e <AJ_UnmarshalMsg+0xba>
    }
	else
	{
	    ioBuf->readPtr = ioBuf->bufStart;
    ad26:	63ab      	str	r3, [r5, #56]	; 0x38
	    ioBuf->writePtr = ioBuf->bufStart;
    ad28:	63eb      	str	r3, [r5, #60]	; 0x3c
    ad2a:	e020      	b.n	ad6e <AJ_UnmarshalMsg+0xba>
        //#pragma calls = AJ_Net_Recv
		// AJ_IO_BUF_AVAIL(ioBuf)=WritePtr-ReadPtr
   //     printf("AJ_UnmarshalMsg(): ioBufBytes=%u\n", AJ_IO_BUF_AVAIL(ioBuf));
       while ( AJ_IO_BUF_AVAIL(ioBuf) < sizeof(AJ_MsgHeader))
       {
		         status = ioBuf->recv(ioBuf, sizeof(AJ_MsgHeader) - AJ_IO_BUF_AVAIL(ioBuf), msg->timeout);
    ad2c:	1a59      	subs	r1, r3, r1
    ad2e:	3110      	adds	r1, #16
    ad30:	1c30      	adds	r0, r6, #0
    ad32:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    ad34:	6c2b      	ldr	r3, [r5, #64]	; 0x40
    ad36:	4798      	blx	r3
	//	printf("AJ_UnmarshalMsg() after recv: ioBufBytes=%u\n", AJ_IO_BUF_AVAIL(ioBuf));
    //    printf("AJ_UnmarshalMsg() ioBuf->recv status= %d \n", status);
        if (status != AJ_OK)
    ad38:	2800      	cmp	r0, #0
    ad3a:	d018      	beq.n	ad6e <AJ_UnmarshalMsg+0xba>
		{
            if (status == AJ_ERR_TIMEOUT) 
    ad3c:	2807      	cmp	r0, #7
    ad3e:	d000      	beq.n	ad42 <AJ_UnmarshalMsg+0x8e>
    ad40:	e2ac      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
			{
                // Work around recv implementations that return too soon.
                uint32_t elapsed = AJ_GetElapsedTime(&msgTimer, FALSE);
    ad42:	a810      	add	r0, sp, #64	; 0x40
    ad44:	2100      	movs	r1, #0
    ad46:	4ba0      	ldr	r3, [pc, #640]	; (afc8 <AJ_UnmarshalMsg+0x314>)
    ad48:	4798      	blx	r3
                if (msg->timeout > elapsed) 
    ad4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    ad4c:	4298      	cmp	r0, r3
    ad4e:	d300      	bcc.n	ad52 <AJ_UnmarshalMsg+0x9e>
    ad50:	e26f      	b.n	b232 <AJ_UnmarshalMsg+0x57e>
				{
                    msg->timeout -= elapsed;
    ad52:	1a1b      	subs	r3, r3, r0
    ad54:	63a3      	str	r3, [r4, #56]	; 0x38
                    continue;
    ad56:	e00a      	b.n	ad6e <AJ_UnmarshalMsg+0xba>
            *  timed-out and if so generate an internal error message to allow the application to
            * proceed.
            */
            if ((status == AJ_ERR_TIMEOUT) && AJ_TimedOutMethodCall(msg)) 
			{
                msg->hdr = (AJ_MsgHeader*)&internalErrorHdr;
    ad58:	4b9c      	ldr	r3, [pc, #624]	; (afcc <AJ_UnmarshalMsg+0x318>)
    ad5a:	6063      	str	r3, [r4, #4]
                msg->error = AJ_ErrTimeout;
    ad5c:	4b9c      	ldr	r3, [pc, #624]	; (afd0 <AJ_UnmarshalMsg+0x31c>)
    ad5e:	60e3      	str	r3, [r4, #12]
                msg->sender = AJ_GetUniqueName(msg->bus);
    ad60:	6b20      	ldr	r0, [r4, #48]	; 0x30
    ad62:	4b9c      	ldr	r3, [pc, #624]	; (afd4 <AJ_UnmarshalMsg+0x320>)
    ad64:	4798      	blx	r3
    ad66:	6160      	str	r0, [r4, #20]
                msg->destination = msg->sender;
    ad68:	61a0      	str	r0, [r4, #24]
                status = AJ_OK;
    ad6a:	2000      	movs	r0, #0
    ad6c:	e296      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
 //   while (AJ_IO_BUF_AVAIL(ioBuf) < sizeof(AJ_MsgHeader)) 
//	{
        //#pragma calls = AJ_Net_Recv
		// AJ_IO_BUF_AVAIL(ioBuf)=WritePtr-ReadPtr
   //     printf("AJ_UnmarshalMsg(): ioBufBytes=%u\n", AJ_IO_BUF_AVAIL(ioBuf));
       while ( AJ_IO_BUF_AVAIL(ioBuf) < sizeof(AJ_MsgHeader))
    ad6e:	6be9      	ldr	r1, [r5, #60]	; 0x3c
    ad70:	6bab      	ldr	r3, [r5, #56]	; 0x38
    ad72:	1aca      	subs	r2, r1, r3
    ad74:	2a0f      	cmp	r2, #15
    ad76:	d9d9      	bls.n	ad2c <AJ_UnmarshalMsg+0x78>
       }
  
 //   }
 
    // Header was unmarsalled directly into the rx buffer
    msg->hdr = (AJ_MsgHeader*)ioBuf->bufStart;
    ad78:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    ad7a:	6063      	str	r3, [r4, #4]
	//printf("ioBuf->readPtr= %d \n",ioBuf->readPtr);
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ioBuf->readPtr += sizeof(AJ_MsgHeader);
    ad7c:	6bab      	ldr	r3, [r5, #56]	; 0x38
    ad7e:	3310      	adds	r3, #16
    ad80:	63ab      	str	r3, [r5, #56]	; 0x38
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//printf("ioBuf->readPtr= %d \n",ioBuf->readPtr);
    // Quick sanity check on the header - unrecoverable error if this check fails
    if ((msg->hdr->endianess != AJ_LITTLE_ENDIAN) && (msg->hdr->endianess != AJ_BIG_ENDIAN)) 
    ad82:	6862      	ldr	r2, [r4, #4]
    ad84:	7813      	ldrb	r3, [r2, #0]
    ad86:	2b6c      	cmp	r3, #108	; 0x6c
    ad88:	d003      	beq.n	ad92 <AJ_UnmarshalMsg+0xde>
	{
  //      printf("AJ_UnmarshalMsg(): AJ_ERR_READ\n");
	//	printf("AJ_UnmarshalMsg(): msg->hdr->endianess= %d\n",msg->hdr->endianess);
        return AJ_ERR_READ;
    ad8a:	2005      	movs	r0, #5
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ioBuf->readPtr += sizeof(AJ_MsgHeader);
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//printf("ioBuf->readPtr= %d \n",ioBuf->readPtr);
    // Quick sanity check on the header - unrecoverable error if this check fails
    if ((msg->hdr->endianess != AJ_LITTLE_ENDIAN) && (msg->hdr->endianess != AJ_BIG_ENDIAN)) 
    ad8c:	2b42      	cmp	r3, #66	; 0x42
    ad8e:	d000      	beq.n	ad92 <AJ_UnmarshalMsg+0xde>
    ad90:	e284      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
  //      printf("AJ_UnmarshalMsg(): AJ_ERR_READ\n");
	//	printf("AJ_UnmarshalMsg(): msg->hdr->endianess= %d\n",msg->hdr->endianess);
        return AJ_ERR_READ;
    }
    // Endian swap header info - conveniently they are contiguous in the header
    EndianSwap(msg, AJ_ARG_INT32, &msg->hdr->bodyLen, 3);
    ad92:	3204      	adds	r2, #4
    ad94:	1c20      	adds	r0, r4, #0
    ad96:	2169      	movs	r1, #105	; 0x69
    ad98:	2303      	movs	r3, #3
    ad9a:	4f8f      	ldr	r7, [pc, #572]	; (afd8 <AJ_UnmarshalMsg+0x324>)
    ad9c:	47b8      	blx	r7
    msg->bodyBytes = msg->hdr->bodyLen;
    ad9e:	6863      	ldr	r3, [r4, #4]
    ada0:	889a      	ldrh	r2, [r3, #4]
    ada2:	85e2      	strh	r2, [r4, #46]	; 0x2e
    // The header is null-padded to an 8-byte boundary
    hdrPad = (8 - msg->hdr->headerLen) & 7;
    ada4:	68db      	ldr	r3, [r3, #12]
    ada6:	425a      	negs	r2, r3
    ada8:	2107      	movs	r1, #7
    adaa:	4011      	ands	r1, r2
    adac:	4689      	mov	r9, r1
    /*
    * Make sure the header (plus pad) isn't going to overrun the buffer
    * and that the total header length doesn't overflow.
    */
    if ((msg->hdr->headerLen + hdrPad) > (ioBuf->bufSize - sizeof(AJ_MsgHeader))) 
    adae:	18c9      	adds	r1, r1, r3
    adb0:	8e6a      	ldrh	r2, [r5, #50]	; 0x32
    adb2:	3a10      	subs	r2, #16
	{
  //      printf("AJ_UnmarshalMsg(): Header was too large: AJ_ERR_HDR_CORRUPT\n");
		return AJ_ERR_READ; //Unrecoverable state, return read error
    adb4:	2005      	movs	r0, #5
    hdrPad = (8 - msg->hdr->headerLen) & 7;
    /*
    * Make sure the header (plus pad) isn't going to overrun the buffer
    * and that the total header length doesn't overflow.
    */
    if ((msg->hdr->headerLen + hdrPad) > (ioBuf->bufSize - sizeof(AJ_MsgHeader))) 
    adb6:	4291      	cmp	r1, r2
    adb8:	d900      	bls.n	adbc <AJ_UnmarshalMsg+0x108>
    adba:	e26f      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
	{
  //      printf("AJ_UnmarshalMsg(): Header was too large: AJ_ERR_HDR_CORRUPT\n");
		return AJ_ERR_READ; //Unrecoverable state, return read error
    }
    // Load the header
    status = LoadBytes(ioBuf, msg->hdr->headerLen + hdrPad, 0, &msg->timeout);
    adbc:	2238      	movs	r2, #56	; 0x38
    adbe:	4694      	mov	ip, r2
    adc0:	44a4      	add	ip, r4
    adc2:	4662      	mov	r2, ip
    adc4:	9205      	str	r2, [sp, #20]
    adc6:	b289      	uxth	r1, r1
    adc8:	1c30      	adds	r0, r6, #0
    adca:	2200      	movs	r2, #0
    adcc:	4663      	mov	r3, ip
    adce:	4f83      	ldr	r7, [pc, #524]	; (afdc <AJ_UnmarshalMsg+0x328>)
    add0:	47b8      	blx	r7
    add2:	1e07      	subs	r7, r0, #0
    if (status != AJ_OK) 
    add4:	d000      	beq.n	add8 <AJ_UnmarshalMsg+0x124>
    add6:	e261      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
	{
        return status;
    }
#ifndef NDEBUG
    // Check that messages are getting closed
    AJ_ASSERT(!currentMsg);
    add8:	4b81      	ldr	r3, [pc, #516]	; (afe0 <AJ_UnmarshalMsg+0x32c>)
    adda:	681b      	ldr	r3, [r3, #0]
    addc:	2b00      	cmp	r3, #0
    adde:	d005      	beq.n	adec <AJ_UnmarshalMsg+0x138>
    ade0:	4880      	ldr	r0, [pc, #512]	; (afe4 <AJ_UnmarshalMsg+0x330>)
    ade2:	4981      	ldr	r1, [pc, #516]	; (afe8 <AJ_UnmarshalMsg+0x334>)
    ade4:	4a81      	ldr	r2, [pc, #516]	; (afec <AJ_UnmarshalMsg+0x338>)
    ade6:	4b82      	ldr	r3, [pc, #520]	; (aff0 <AJ_UnmarshalMsg+0x33c>)
    ade8:	4c82      	ldr	r4, [pc, #520]	; (aff4 <AJ_UnmarshalMsg+0x340>)
    adea:	47a0      	blx	r4
    currentMsg = msg;
    adec:	4b7c      	ldr	r3, [pc, #496]	; (afe0 <AJ_UnmarshalMsg+0x32c>)
    adee:	601c      	str	r4, [r3, #0]
    /*
    * If the message is encrypted and the endianess of the message is different than the local host
    * endianness we need to copy the header bytes before we unmarshal the header and swizzle all
    * the integers.
    */
    if ((msg->hdr->endianess != HOST_ENDIANESS) && (msg->hdr->flags & AJ_FLAG_ENCRYPTED))
    adf0:	6863      	ldr	r3, [r4, #4]
    adf2:	781a      	ldrb	r2, [r3, #0]
    adf4:	2a6c      	cmp	r2, #108	; 0x6c
    adf6:	d010      	beq.n	ae1a <AJ_UnmarshalMsg+0x166>
    adf8:	789a      	ldrb	r2, [r3, #2]

AJ_Status AJ_UnmarshalMsg(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t timeout)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &bus->sock.rx;
    void* hdrRaw = NULL;
    adfa:	2100      	movs	r1, #0
    adfc:	9104      	str	r1, [sp, #16]
    /*
    * If the message is encrypted and the endianess of the message is different than the local host
    * endianness we need to copy the header bytes before we unmarshal the header and swizzle all
    * the integers.
    */
    if ((msg->hdr->endianess != HOST_ENDIANESS) && (msg->hdr->flags & AJ_FLAG_ENCRYPTED))
    adfe:	2a7f      	cmp	r2, #127	; 0x7f
    ae00:	d90d      	bls.n	ae1e <AJ_UnmarshalMsg+0x16a>
	{
        hdrRaw = AJ_Malloc(msg->hdr->headerLen);
    ae02:	68d8      	ldr	r0, [r3, #12]
    ae04:	4b7c      	ldr	r3, [pc, #496]	; (aff8 <AJ_UnmarshalMsg+0x344>)
    ae06:	4798      	blx	r3
    ae08:	9004      	str	r0, [sp, #16]
        if (hdrRaw) 
    ae0a:	2800      	cmp	r0, #0
    ae0c:	d007      	beq.n	ae1e <AJ_UnmarshalMsg+0x16a>
		{
            memcpy(hdrRaw, ioBuf->readPtr, msg->hdr->headerLen);
    ae0e:	6863      	ldr	r3, [r4, #4]
    ae10:	68da      	ldr	r2, [r3, #12]
    ae12:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    ae14:	4b79      	ldr	r3, [pc, #484]	; (affc <AJ_UnmarshalMsg+0x348>)
    ae16:	4798      	blx	r3
    ae18:	e001      	b.n	ae1e <AJ_UnmarshalMsg+0x16a>

AJ_Status AJ_UnmarshalMsg(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t timeout)
{
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &bus->sock.rx;
    void* hdrRaw = NULL;
    ae1a:	2300      	movs	r3, #0
    ae1c:	9304      	str	r3, [sp, #16]
		{
            memcpy(hdrRaw, ioBuf->readPtr, msg->hdr->headerLen);
        }
    }
    // Assume an empty signature
    msg->signature = "";
    ae1e:	4b78      	ldr	r3, [pc, #480]	; (b000 <AJ_UnmarshalMsg+0x34c>)
    ae20:	61e3      	str	r3, [r4, #28]
    //We have the header in the buffer now we can unmarshal the header fields
    endOfHeader = ioBuf->bufStart + sizeof(AJ_MsgHeader) + msg->hdr->headerLen;
    ae22:	6863      	ldr	r3, [r4, #4]
    ae24:	68db      	ldr	r3, [r3, #12]
    ae26:	3310      	adds	r3, #16
    ae28:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    ae2a:	4693      	mov	fp, r2
    ae2c:	449b      	add	fp, r3
   /* printf("msg->hdr->headerLen= %d\n",msg->hdr->headerLen);
	printf("sizeof(AJ_MsgHeader)= %d\n",sizeof(AJ_MsgHeader));
	printf("Before header parse endOfHeader= %d\n",endOfHeader);*/
    while (ioBuf->readPtr < endOfHeader) 
    ae2e:	6bab      	ldr	r3, [r5, #56]	; 0x38
    ae30:	455b      	cmp	r3, fp
    ae32:	d260      	bcs.n	aef6 <AJ_UnmarshalMsg+0x242>
	{
        const char* fieldSig;
        uint8_t fieldId;
        AJ_Arg hdrVal;
        // Custom unmarshal the header field - signature is "(yv)" so starts off with STRUCT aligment.
        status = LoadBytes(ioBuf, 4, PadForType(AJ_ARG_STRUCT, ioBuf), &msg->timeout);
    ae34:	4b69      	ldr	r3, [pc, #420]	; (afdc <AJ_UnmarshalMsg+0x328>)
    ae36:	4698      	mov	r8, r3
        fieldId = ioBuf->readPtr[0];
        fieldSig = (const char*)&ioBuf->readPtr[2];
        ioBuf->readPtr += 4;
	//	printf("ioBuf->readPtr= %d \n",ioBuf->readPtr);
        // Now unmarshal the field value
        status = Unmarshal(msg, &fieldSig, &hdrVal);
    ae38:	46ba      	mov	sl, r7
    ae3a:	1c37      	adds	r7, r6, #0
	{
        const char* fieldSig;
        uint8_t fieldId;
        AJ_Arg hdrVal;
        // Custom unmarshal the header field - signature is "(yv)" so starts off with STRUCT aligment.
        status = LoadBytes(ioBuf, 4, PadForType(AJ_ARG_STRUCT, ioBuf), &msg->timeout);
    ae3c:	2028      	movs	r0, #40	; 0x28
    ae3e:	1c39      	adds	r1, r7, #0
    ae40:	4b70      	ldr	r3, [pc, #448]	; (b004 <AJ_UnmarshalMsg+0x350>)
    ae42:	4798      	blx	r3
    ae44:	b2c2      	uxtb	r2, r0
    ae46:	1c38      	adds	r0, r7, #0
    ae48:	2104      	movs	r1, #4
    ae4a:	9b05      	ldr	r3, [sp, #20]
    ae4c:	47c0      	blx	r8
        if (status != AJ_OK) 
    ae4e:	2800      	cmp	r0, #0
    ae50:	d14a      	bne.n	aee8 <AJ_UnmarshalMsg+0x234>
		{
            break;
        }
        fieldId = ioBuf->readPtr[0];
    ae52:	6bab      	ldr	r3, [r5, #56]	; 0x38
    ae54:	781e      	ldrb	r6, [r3, #0]
        fieldSig = (const char*)&ioBuf->readPtr[2];
    ae56:	1c9a      	adds	r2, r3, #2
    ae58:	9208      	str	r2, [sp, #32]
        ioBuf->readPtr += 4;
    ae5a:	3304      	adds	r3, #4
    ae5c:	63ab      	str	r3, [r5, #56]	; 0x38
	//	printf("ioBuf->readPtr= %d \n",ioBuf->readPtr);
        // Now unmarshal the field value
        status = Unmarshal(msg, &fieldSig, &hdrVal);
    ae5e:	1c20      	adds	r0, r4, #0
    ae60:	a908      	add	r1, sp, #32
    ae62:	aa0c      	add	r2, sp, #48	; 0x30
    ae64:	4b68      	ldr	r3, [pc, #416]	; (b008 <AJ_UnmarshalMsg+0x354>)
    ae66:	4798      	blx	r3
        if (status != AJ_OK) 
    ae68:	2800      	cmp	r0, #0
    ae6a:	d140      	bne.n	aeee <AJ_UnmarshalMsg+0x23a>
		{			
            break;
        }
        // Check the field has the type we expect - we ignore fields we don't know
        if ((fieldId <= AJ_HDR_SESSION_ID) && (TypeForHdr[fieldId] != hdrVal.typeId)) 
    ae6c:	2e13      	cmp	r6, #19
    ae6e:	d805      	bhi.n	ae7c <AJ_UnmarshalMsg+0x1c8>
    ae70:	4b66      	ldr	r3, [pc, #408]	; (b00c <AJ_UnmarshalMsg+0x358>)
    ae72:	5d9a      	ldrb	r2, [r3, r6]
    ae74:	ab0c      	add	r3, sp, #48	; 0x30
    ae76:	781b      	ldrb	r3, [r3, #0]
    ae78:	429a      	cmp	r2, r3
    ae7a:	d131      	bne.n	aee0 <AJ_UnmarshalMsg+0x22c>
            status = AJ_ERR_UNMARSHAL;
            break;
        }
		//printf("Reply serial %d\n", msg->replySerial);
        // Set the field value in the message
        switch (fieldId) 
    ae7c:	2e13      	cmp	r6, #19
    ae7e:	d829      	bhi.n	aed4 <AJ_UnmarshalMsg+0x220>
    ae80:	00b6      	lsls	r6, r6, #2
    ae82:	4b63      	ldr	r3, [pc, #396]	; (b010 <AJ_UnmarshalMsg+0x35c>)
    ae84:	599b      	ldr	r3, [r3, r6]
    ae86:	469f      	mov	pc, r3
            msg->sessionId = *(hdrVal.val.v_uint32);
            break;

        case AJ_HDR_COMPRESSION_TOKEN:
     //       printf("Compressed headers not currently handled\n");
            status = AJ_ERR_UNMARSHAL;
    ae88:	2009      	movs	r0, #9
    ae8a:	e023      	b.n	aed4 <AJ_UnmarshalMsg+0x220>
		//printf("Reply serial %d\n", msg->replySerial);
        // Set the field value in the message
        switch (fieldId) 
		{
        case AJ_HDR_OBJ_PATH:
            msg->objPath = hdrVal.val.v_objPath;
    ae8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ae8e:	60a3      	str	r3, [r4, #8]
            break;
    ae90:	e020      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_INTERFACE:
            msg->iface = hdrVal.val.v_string;
    ae92:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ae94:	6123      	str	r3, [r4, #16]
            break;
    ae96:	e01d      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_MEMBER:
            msg->member = hdrVal.val.v_string;
    ae98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ae9a:	60e3      	str	r3, [r4, #12]
            break;
    ae9c:	e01a      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_ERROR_NAME:
            msg->error = hdrVal.val.v_string;
    ae9e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aea0:	60e3      	str	r3, [r4, #12]
            break;
    aea2:	e017      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_REPLY_SERIAL:
            msg->replySerial = *(hdrVal.val.v_uint32);
    aea4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aea6:	681b      	ldr	r3, [r3, #0]
    aea8:	60a3      	str	r3, [r4, #8]
			
            break;
    aeaa:	e013      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_DESTINATION:
            msg->destination = hdrVal.val.v_string;
    aeac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aeae:	61a3      	str	r3, [r4, #24]
            break;
    aeb0:	e010      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_SENDER:
            msg->sender = hdrVal.val.v_string;
    aeb2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aeb4:	6163      	str	r3, [r4, #20]
            break;
    aeb6:	e00d      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_SIGNATURE:
            msg->signature = hdrVal.val.v_signature;
    aeb8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aeba:	61e3      	str	r3, [r4, #28]
            break;
    aebc:	e00a      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_TIMESTAMP:
            msg->timestamp = *(hdrVal.val.v_uint32);
    aebe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aec0:	681b      	ldr	r3, [r3, #0]
    aec2:	6263      	str	r3, [r4, #36]	; 0x24
            break;
    aec4:	e006      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_TIME_TO_LIVE:
            msg->ttl = *(hdrVal.val.v_uint32);
    aec6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aec8:	681b      	ldr	r3, [r3, #0]
    aeca:	62a3      	str	r3, [r4, #40]	; 0x28
            break;
    aecc:	e002      	b.n	aed4 <AJ_UnmarshalMsg+0x220>

        case AJ_HDR_SESSION_ID:
            msg->sessionId = *(hdrVal.val.v_uint32);
    aece:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aed0:	681b      	ldr	r3, [r3, #0]
    aed2:	6223      	str	r3, [r4, #32]
    //We have the header in the buffer now we can unmarshal the header fields
    endOfHeader = ioBuf->bufStart + sizeof(AJ_MsgHeader) + msg->hdr->headerLen;
   /* printf("msg->hdr->headerLen= %d\n",msg->hdr->headerLen);
	printf("sizeof(AJ_MsgHeader)= %d\n",sizeof(AJ_MsgHeader));
	printf("Before header parse endOfHeader= %d\n",endOfHeader);*/
    while (ioBuf->readPtr < endOfHeader) 
    aed4:	6bab      	ldr	r3, [r5, #56]	; 0x38
    aed6:	459b      	cmp	fp, r3
    aed8:	d8b0      	bhi.n	ae3c <AJ_UnmarshalMsg+0x188>
    aeda:	1c3e      	adds	r6, r7, #0
    aedc:	4657      	mov	r7, sl
    aede:	e008      	b.n	aef2 <AJ_UnmarshalMsg+0x23e>
    aee0:	1c3e      	adds	r6, r7, #0
    aee2:	4657      	mov	r7, sl
        }
        // Check the field has the type we expect - we ignore fields we don't know
        if ((fieldId <= AJ_HDR_SESSION_ID) && (TypeForHdr[fieldId] != hdrVal.typeId)) 
		{
   //         printf("AJ_UnmarshalMsg(): AJ_ERR_UNMARSHAL\n");
            status = AJ_ERR_UNMARSHAL;
    aee4:	2009      	movs	r0, #9
    aee6:	e004      	b.n	aef2 <AJ_UnmarshalMsg+0x23e>
    aee8:	1c3e      	adds	r6, r7, #0
    aeea:	4657      	mov	r7, sl
    aeec:	e001      	b.n	aef2 <AJ_UnmarshalMsg+0x23e>
    aeee:	1c3e      	adds	r6, r7, #0
    aef0:	4657      	mov	r7, sl
            // Ignored 
            break;
        }
    }
    // Check that the required header fields are present
    if (status == AJ_OK) 
    aef2:	2800      	cmp	r0, #0
    aef4:	d149      	bne.n	af8a <AJ_UnmarshalMsg+0x2d6>
static AJ_Status ValidateHeader(const AJ_Message* msg)
{
    AJ_Status status = AJ_ERR_UNMARSHAL;
    // Sender field is mandatory for all messages

    if ((msg->sender) && (msg->objPath)) 
    aef6:	6963      	ldr	r3, [r4, #20]
    aef8:	2b00      	cmp	r3, #0
    aefa:	d03a      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
    aefc:	68a2      	ldr	r2, [r4, #8]
    aefe:	2a00      	cmp	r2, #0
    af00:	d037      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
	{
        // Check required fields are present for each message type
        switch (msg->hdr->msgType) 
    af02:	6863      	ldr	r3, [r4, #4]
    af04:	785b      	ldrb	r3, [r3, #1]
    af06:	2b02      	cmp	r3, #2
    af08:	d02e      	beq.n	af68 <AJ_UnmarshalMsg+0x2b4>
    af0a:	b2d9      	uxtb	r1, r3
    af0c:	2902      	cmp	r1, #2
    af0e:	d802      	bhi.n	af16 <AJ_UnmarshalMsg+0x262>
    af10:	2b01      	cmp	r3, #1
    af12:	d00b      	beq.n	af2c <AJ_UnmarshalMsg+0x278>
    af14:	e02d      	b.n	af72 <AJ_UnmarshalMsg+0x2be>
    af16:	2b03      	cmp	r3, #3
    af18:	d012      	beq.n	af40 <AJ_UnmarshalMsg+0x28c>
    af1a:	2b04      	cmp	r3, #4
    af1c:	d129      	bne.n	af72 <AJ_UnmarshalMsg+0x2be>
		{
        case AJ_MSG_SIGNAL:
            if (msg->iface && msg->member) 
    af1e:	6923      	ldr	r3, [r4, #16]
    af20:	2b00      	cmp	r3, #0
    af22:	d026      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
    af24:	68e3      	ldr	r3, [r4, #12]
    af26:	2b00      	cmp	r3, #0
    af28:	d130      	bne.n	af8c <AJ_UnmarshalMsg+0x2d8>
    af2a:	e022      	b.n	af72 <AJ_UnmarshalMsg+0x2be>
                status = AJ_OK;
            }
            break;

        case AJ_MSG_METHOD_CALL:
            if (msg->destination && msg->iface && msg->member) 
    af2c:	69a3      	ldr	r3, [r4, #24]
    af2e:	2b00      	cmp	r3, #0
    af30:	d01f      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
    af32:	6923      	ldr	r3, [r4, #16]
    af34:	2b00      	cmp	r3, #0
    af36:	d01c      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
    af38:	68e3      	ldr	r3, [r4, #12]
    af3a:	2b00      	cmp	r3, #0
    af3c:	d126      	bne.n	af8c <AJ_UnmarshalMsg+0x2d8>
    af3e:	e018      	b.n	af72 <AJ_UnmarshalMsg+0x2be>
                status = AJ_OK;
            }
            break;

        case AJ_MSG_ERROR:
            if (msg->destination && msg->error && msg->replySerial)
    af40:	69a3      	ldr	r3, [r4, #24]
    af42:	2b00      	cmp	r3, #0
    af44:	d004      	beq.n	af50 <AJ_UnmarshalMsg+0x29c>
    af46:	68e3      	ldr	r3, [r4, #12]
    af48:	2b00      	cmp	r3, #0
    af4a:	d001      	beq.n	af50 <AJ_UnmarshalMsg+0x29c>
    af4c:	2a00      	cmp	r2, #0
    af4e:	d11d      	bne.n	af8c <AJ_UnmarshalMsg+0x2d8>
			{
                status = AJ_OK;
            } 
			else
			{
                AJ_ErrPrintf(("The connection was rejected by the routing node\n"));
    af50:	2001      	movs	r0, #1
    af52:	4924      	ldr	r1, [pc, #144]	; (afe4 <AJ_UnmarshalMsg+0x330>)
    af54:	4a2f      	ldr	r2, [pc, #188]	; (b014 <AJ_UnmarshalMsg+0x360>)
    af56:	4b30      	ldr	r3, [pc, #192]	; (b018 <AJ_UnmarshalMsg+0x364>)
    af58:	4798      	blx	r3
                status = AJ_ERR_REJECTED;
                return status;
    af5a:	2720      	movs	r7, #32
			{
                status = AJ_OK;
            } 
			else
			{
                AJ_ErrPrintf(("The connection was rejected by the routing node\n"));
    af5c:	2800      	cmp	r0, #0
    af5e:	d015      	beq.n	af8c <AJ_UnmarshalMsg+0x2d8>
    af60:	482e      	ldr	r0, [pc, #184]	; (b01c <AJ_UnmarshalMsg+0x368>)
    af62:	4b2f      	ldr	r3, [pc, #188]	; (b020 <AJ_UnmarshalMsg+0x36c>)
    af64:	4798      	blx	r3
    af66:	e011      	b.n	af8c <AJ_UnmarshalMsg+0x2d8>
                return status;
            }
            break;

        case AJ_MSG_METHOD_RET:
            if (msg->destination && msg->replySerial) 
    af68:	69a3      	ldr	r3, [r4, #24]
    af6a:	2b00      	cmp	r3, #0
    af6c:	d001      	beq.n	af72 <AJ_UnmarshalMsg+0x2be>
    af6e:	2a00      	cmp	r2, #0
    af70:	d10c      	bne.n	af8c <AJ_UnmarshalMsg+0x2d8>
            break;
        }
    }
    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Header does not contain the required fields for the message type\n"));
    af72:	2001      	movs	r0, #1
    af74:	491b      	ldr	r1, [pc, #108]	; (afe4 <AJ_UnmarshalMsg+0x330>)
    af76:	4a2b      	ldr	r2, [pc, #172]	; (b024 <AJ_UnmarshalMsg+0x370>)
    af78:	4b27      	ldr	r3, [pc, #156]	; (b018 <AJ_UnmarshalMsg+0x364>)
    af7a:	4798      	blx	r3
    af7c:	2709      	movs	r7, #9
    af7e:	2800      	cmp	r0, #0
    af80:	d004      	beq.n	af8c <AJ_UnmarshalMsg+0x2d8>
    af82:	4829      	ldr	r0, [pc, #164]	; (b028 <AJ_UnmarshalMsg+0x374>)
    af84:	4b26      	ldr	r3, [pc, #152]	; (b020 <AJ_UnmarshalMsg+0x36c>)
    af86:	4798      	blx	r3
    af88:	e000      	b.n	af8c <AJ_UnmarshalMsg+0x2d8>
    af8a:	1c07      	adds	r7, r0, #0
    }
    /*
     * If we copied the raw header earlier we copy it back now. This only happens if the message is
     * encrypted and the endianness of the message is different from the local host's endianness.
    */
    if (hdrRaw)
    af8c:	9904      	ldr	r1, [sp, #16]
    af8e:	2900      	cmp	r1, #0
    af90:	d008      	beq.n	afa4 <AJ_UnmarshalMsg+0x2f0>
	{
        memcpy(ioBuf->bufStart + sizeof(AJ_MsgHeader), hdrRaw, msg->hdr->headerLen);
    af92:	6b68      	ldr	r0, [r5, #52]	; 0x34
    af94:	3010      	adds	r0, #16
    af96:	6863      	ldr	r3, [r4, #4]
    af98:	68da      	ldr	r2, [r3, #12]
    af9a:	4b18      	ldr	r3, [pc, #96]	; (affc <AJ_UnmarshalMsg+0x348>)
    af9c:	4798      	blx	r3
        AJ_Free(hdrRaw);
    af9e:	9804      	ldr	r0, [sp, #16]
    afa0:	4b22      	ldr	r3, [pc, #136]	; (b02c <AJ_UnmarshalMsg+0x378>)
    afa2:	4798      	blx	r3
        hdrRaw = NULL;
    }
    if (ioBuf->readPtr != endOfHeader) 
    afa4:	6bab      	ldr	r3, [r5, #56]	; 0x38
    afa6:	455b      	cmp	r3, fp
    afa8:	d000      	beq.n	afac <AJ_UnmarshalMsg+0x2f8>
    afaa:	e113      	b.n	b1d4 <AJ_UnmarshalMsg+0x520>
    afac:	e149      	b.n	b242 <AJ_UnmarshalMsg+0x58e>
    afae:	46c0      	nop			; (mov r8, r8)
    afb0:	0000d7ad 	.word	0x0000d7ad
    afb4:	00016773 	.word	0x00016773
    afb8:	20001ecc 	.word	0x20001ecc
    afbc:	0001d70c 	.word	0x0001d70c
    afc0:	00016e3d 	.word	0x00016e3d
    afc4:	0000274d 	.word	0x0000274d
    afc8:	0000d769 	.word	0x0000d769
    afcc:	0001d284 	.word	0x0001d284
    afd0:	0001e90c 	.word	0x0001e90c
    afd4:	000028e9 	.word	0x000028e9
    afd8:	00009a19 	.word	0x00009a19
    afdc:	00009c05 	.word	0x00009c05
    afe0:	2000097c 	.word	0x2000097c
    afe4:	0001d2d8 	.word	0x0001d2d8
    afe8:	000004fb 	.word	0x000004fb
    afec:	0001dafc 	.word	0x0001dafc
    aff0:	0001d754 	.word	0x0001d754
    aff4:	00016629 	.word	0x00016629
    aff8:	0000d7dd 	.word	0x0000d7dd
    affc:	00016739 	.word	0x00016739
    b000:	0001d368 	.word	0x0001d368
    b004:	000099d9 	.word	0x000099d9
    b008:	00009cf1 	.word	0x00009cf1
    b00c:	0001d23c 	.word	0x0001d23c
    b010:	0001d1ec 	.word	0x0001d1ec
    b014:	000003fd 	.word	0x000003fd
    b018:	0000636d 	.word	0x0000636d
    b01c:	0001d760 	.word	0x0001d760
    b020:	00016f5d 	.word	0x00016f5d
    b024:	0000040d 	.word	0x0000040d
    b028:	0001d790 	.word	0x0001d790
    b02c:	0000d7e9 	.word	0x0000d7e9
    }
    if (status == AJ_OK) 
	{
        AJ_ASSERT(ioBuf->readPtr == endOfHeader);
        // Consume the header pad bytes.
        ioBuf->readPtr += hdrPad;
    b030:	444b      	add	r3, r9
    b032:	63ab      	str	r3, [r5, #56]	; 0x38
        // If the message is encrypted load the entire message body and decrypt it.
		
        if (msg->hdr->flags & AJ_FLAG_ENCRYPTED) 
    b034:	6863      	ldr	r3, [r4, #4]
    b036:	789a      	ldrb	r2, [r3, #2]
    b038:	2a7f      	cmp	r2, #127	; 0x7f
    b03a:	d800      	bhi.n	b03e <AJ_UnmarshalMsg+0x38a>
    b03c:	e0bb      	b.n	b1b6 <AJ_UnmarshalMsg+0x502>
		{
            status = LoadBytes(ioBuf, msg->hdr->bodyLen, 0, &msg->timeout);
    b03e:	6859      	ldr	r1, [r3, #4]
    b040:	b289      	uxth	r1, r1
    b042:	1c30      	adds	r0, r6, #0
    b044:	2200      	movs	r2, #0
    b046:	9b05      	ldr	r3, [sp, #20]
    b048:	4d98      	ldr	r5, [pc, #608]	; (b2ac <AJ_UnmarshalMsg+0x5f8>)
    b04a:	47a8      	blx	r5
    b04c:	1e07      	subs	r7, r0, #0
            if (status == AJ_OK) 
    b04e:	d000      	beq.n	b052 <AJ_UnmarshalMsg+0x39e>
    b050:	e0fb      	b.n	b24a <AJ_UnmarshalMsg+0x596>
    return AJ_OK;
}

static AJ_Status DecryptMessage(AJ_Message* msg)
{
    AJ_IOBuffer* ioBuf = &msg->bus->sock.rx;
    b052:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b054:	9304      	str	r3, [sp, #16]
    AJ_Status status;
    uint8_t key[16];
    uint8_t nonce[MAX_NONCE_LENGTH];
    uint8_t role = AJ_ROLE_KEY_UNDEFINED;
    b056:	2200      	movs	r2, #0
    b058:	2313      	movs	r3, #19
    b05a:	a902      	add	r1, sp, #8
    b05c:	468c      	mov	ip, r1
    b05e:	4463      	add	r3, ip
    b060:	701a      	strb	r2, [r3, #0]
}

// Computes total size of a message - note header is padded to an 8 byte boundary
static uint32_t MessageLen(AJ_Message* msg)
{
    return sizeof(AJ_MsgHeader) + ((msg->hdr->headerLen + 7) & 0xFFFFFFF8) + msg->hdr->bodyLen;
    b062:	6862      	ldr	r2, [r4, #4]
    b064:	6850      	ldr	r0, [r2, #4]
    b066:	1c05      	adds	r5, r0, #0
    b068:	3510      	adds	r5, #16
    b06a:	68d3      	ldr	r3, [r2, #12]
    b06c:	3307      	adds	r3, #7
    b06e:	2107      	movs	r1, #7
    b070:	438b      	bics	r3, r1
    b072:	18ed      	adds	r5, r5, r3
    AJ_Status status;
    uint8_t key[16];
    uint8_t nonce[MAX_NONCE_LENGTH];
    uint8_t role = AJ_ROLE_KEY_UNDEFINED;
    uint32_t mlen = MessageLen(msg);
    uint32_t hLen = mlen - msg->hdr->bodyLen;
    b074:	1a2b      	subs	r3, r5, r0
    b076:	469a      	mov	sl, r3
    uint32_t extraNonceLen;
    uint32_t cryptoValsLen;
    AJ_SerialNum* incoming;

    // Use the group key for multicast and broadcast signals the session key otherwise.
    if ((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination) 
    b078:	7853      	ldrb	r3, [r2, #1]
    b07a:	2b04      	cmp	r3, #4
    b07c:	d10a      	bne.n	b094 <AJ_UnmarshalMsg+0x3e0>
    b07e:	69a3      	ldr	r3, [r4, #24]
    b080:	2b00      	cmp	r3, #0
    b082:	d107      	bne.n	b094 <AJ_UnmarshalMsg+0x3e0>
	{
        status = AJ_GetGroupKey(msg->sender, key);
    b084:	6960      	ldr	r0, [r4, #20]
    b086:	a90c      	add	r1, sp, #48	; 0x30
    b088:	4b89      	ldr	r3, [pc, #548]	; (b2b0 <AJ_UnmarshalMsg+0x5fc>)
    b08a:	4798      	blx	r3
    b08c:	1c03      	adds	r3, r0, #0
        msg->authVersion = MIN_AUTH_FALLBACK_VERSION;
    b08e:	2202      	movs	r2, #2
    b090:	63e2      	str	r2, [r4, #60]	; 0x3c
    b092:	e015      	b.n	b0c0 <AJ_UnmarshalMsg+0x40c>
    } 
	else
	{
        status = AJ_GetSessionKey(msg->sender, key, &role, &msg->authVersion);
    b094:	2713      	movs	r7, #19
    b096:	ab02      	add	r3, sp, #8
    b098:	469c      	mov	ip, r3
    b09a:	4467      	add	r7, ip
    b09c:	1c23      	adds	r3, r4, #0
    b09e:	333c      	adds	r3, #60	; 0x3c
    b0a0:	6960      	ldr	r0, [r4, #20]
    b0a2:	a90c      	add	r1, sp, #48	; 0x30
    b0a4:	1c3a      	adds	r2, r7, #0
    b0a6:	4e83      	ldr	r6, [pc, #524]	; (b2b4 <AJ_UnmarshalMsg+0x600>)
    b0a8:	47b0      	blx	r6
        //We use the oppsite role when decrypting.
        role ^= 3;
    b0aa:	783b      	ldrb	r3, [r7, #0]
    b0ac:	2203      	movs	r2, #3
    b0ae:	4053      	eors	r3, r2
    b0b0:	703b      	strb	r3, [r7, #0]
        if (AJ_OK == status) 
    b0b2:	2800      	cmp	r0, #0
    b0b4:	d106      	bne.n	b0c4 <AJ_UnmarshalMsg+0x410>
		{
            status = AJ_GetSerialNumbers(msg->sender, &incoming);
    b0b6:	6960      	ldr	r0, [r4, #20]
    b0b8:	a907      	add	r1, sp, #28
    b0ba:	4b7f      	ldr	r3, [pc, #508]	; (b2b8 <AJ_UnmarshalMsg+0x604>)
    b0bc:	4798      	blx	r3
    b0be:	1c03      	adds	r3, r0, #0
        }
    }
    if (status != AJ_OK) 
    b0c0:	2b00      	cmp	r3, #0
    b0c2:	d00d      	beq.n	b0e0 <AJ_UnmarshalMsg+0x42c>
	{
        AJ_ErrPrintf(("DecryptMessage(): AJ_ERR_SECURITY\n"));
    b0c4:	2001      	movs	r0, #1
    b0c6:	497d      	ldr	r1, [pc, #500]	; (b2bc <AJ_UnmarshalMsg+0x608>)
    b0c8:	22ed      	movs	r2, #237	; 0xed
    b0ca:	0052      	lsls	r2, r2, #1
    b0cc:	4b7c      	ldr	r3, [pc, #496]	; (b2c0 <AJ_UnmarshalMsg+0x60c>)
    b0ce:	4798      	blx	r3
        status = AJ_ERR_SECURITY;
    b0d0:	270d      	movs	r7, #13
            status = AJ_GetSerialNumbers(msg->sender, &incoming);
        }
    }
    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("DecryptMessage(): AJ_ERR_SECURITY\n"));
    b0d2:	2800      	cmp	r0, #0
    b0d4:	d100      	bne.n	b0d8 <AJ_UnmarshalMsg+0x424>
    b0d6:	e0d7      	b.n	b288 <AJ_UnmarshalMsg+0x5d4>
    b0d8:	487a      	ldr	r0, [pc, #488]	; (b2c4 <AJ_UnmarshalMsg+0x610>)
    b0da:	4b7b      	ldr	r3, [pc, #492]	; (b2c8 <AJ_UnmarshalMsg+0x614>)
    b0dc:	4798      	blx	r3
    b0de:	e0d3      	b.n	b288 <AJ_UnmarshalMsg+0x5d4>

static uint32_t GetMACLength(AJ_Message* msg)
{
    uint32_t macLen = MAC_LENGTH;

    if (!MessageRequiresLongerCryptoValues(msg, MIN_AUTH_FULL_MAC_LENGTH)) 
    b0e0:	1c20      	adds	r0, r4, #0
    b0e2:	2103      	movs	r1, #3
    b0e4:	4b79      	ldr	r3, [pc, #484]	; (b2cc <AJ_UnmarshalMsg+0x618>)
    b0e6:	4798      	blx	r3
    b0e8:	2800      	cmp	r0, #0
    b0ea:	d103      	bne.n	b0f4 <AJ_UnmarshalMsg+0x440>
	{
        macLen = PREVIOUS_MAC_LENGTH;
    b0ec:	2308      	movs	r3, #8
    b0ee:	469b      	mov	fp, r3
{
    uint32_t nonceLen = NONCE_LENGTH;

    if (!MessageRequiresLongerCryptoValues(msg, MIN_AUTH_FULL_NONCE_LENGTH)) 
	{
        nonceLen = PREVIOUS_NONCE_LENGTH;
    b0f0:	2705      	movs	r7, #5
    b0f2:	e002      	b.n	b0fa <AJ_UnmarshalMsg+0x446>
            !((msg->hdr->msgType == AJ_MSG_SIGNAL) && !msg->destination));  // rollback for multicast/broadcast
}

static uint32_t GetMACLength(AJ_Message* msg)
{
    uint32_t macLen = MAC_LENGTH;
    b0f4:	2310      	movs	r3, #16
    b0f6:	469b      	mov	fp, r3
    return macLen;
}

static uint32_t GetNonceLength(AJ_Message* msg)
{
    uint32_t nonceLen = NONCE_LENGTH;
    b0f8:	270d      	movs	r7, #13
    } 
	else 
	{
        macLen = GetMACLength(msg);
        nonceLen = GetNonceLength(msg);
        extraNonceLen = nonceLen - PREVIOUS_NONCE_LENGTH;
    b0fa:	1f7b      	subs	r3, r7, #5
    b0fc:	4698      	mov	r8, r3
    b0fe:	465b      	mov	r3, fp
    b100:	1aeb      	subs	r3, r5, r3
    b102:	4699      	mov	r9, r3
        cryptoValsLen = macLen + extraNonceLen;
        //AJ_InfoPrintf(("DecryptMessage(): \n"));
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen - extraNonceLen, extraNonceLen);
    b104:	4643      	mov	r3, r8
    b106:	1aed      	subs	r5, r5, r3
    b108:	9b04      	ldr	r3, [sp, #16]
    b10a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    b10c:	1959      	adds	r1, r3, r5
    return nonceLen;
}

static AJ_Status InitNonce(AJ_Message* msg, uint8_t role, uint8_t* nonce, uint32_t nonceLen, uint8_t* extraNonce, uint32_t extraNonceLen)
{
    uint32_t serial = msg->hdr->serialNum;
    b10e:	6865      	ldr	r5, [r4, #4]
    b110:	68aa      	ldr	r2, [r5, #8]
    nonce[0] = role;
    b112:	ab08      	add	r3, sp, #32
        macLen = GetMACLength(msg);
        nonceLen = GetNonceLength(msg);
        extraNonceLen = nonceLen - PREVIOUS_NONCE_LENGTH;
        cryptoValsLen = macLen + extraNonceLen;
        //AJ_InfoPrintf(("DecryptMessage(): \n"));
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen - extraNonceLen, extraNonceLen);
    b114:	2013      	movs	r0, #19
    b116:	ae02      	add	r6, sp, #8
    b118:	46b4      	mov	ip, r6
    b11a:	4460      	add	r0, ip
}

static AJ_Status InitNonce(AJ_Message* msg, uint8_t role, uint8_t* nonce, uint32_t nonceLen, uint8_t* extraNonce, uint32_t extraNonceLen)
{
    uint32_t serial = msg->hdr->serialNum;
    nonce[0] = role;
    b11c:	7800      	ldrb	r0, [r0, #0]
    b11e:	7018      	strb	r0, [r3, #0]
    nonce[1] = (uint8_t)(serial >> 24);
    b120:	0e10      	lsrs	r0, r2, #24
    b122:	7058      	strb	r0, [r3, #1]
    nonce[2] = (uint8_t)(serial >> 16);
    b124:	0c10      	lsrs	r0, r2, #16
    b126:	7098      	strb	r0, [r3, #2]
    nonce[3] = (uint8_t)(serial >> 8);
    b128:	0a10      	lsrs	r0, r2, #8
    b12a:	70d8      	strb	r0, [r3, #3]
    nonce[4] = (uint8_t)(serial);
    b12c:	711a      	strb	r2, [r3, #4]
    if (nonceLen < (PREVIOUS_NONCE_LENGTH + extraNonceLen)) 
    b12e:	2f0d      	cmp	r7, #13
    b130:	d807      	bhi.n	b142 <AJ_UnmarshalMsg+0x48e>
	{
        return AJ_ERR_SECURITY;
    }
    if (0 < extraNonceLen) 
    b132:	4643      	mov	r3, r8
    b134:	2b00      	cmp	r3, #0
    b136:	d004      	beq.n	b142 <AJ_UnmarshalMsg+0x48e>
	{
        memcpy(&nonce[PREVIOUS_NONCE_LENGTH], extraNonce, extraNonceLen);
    b138:	201d      	movs	r0, #29
    b13a:	4460      	add	r0, ip
    b13c:	4642      	mov	r2, r8
    b13e:	4b64      	ldr	r3, [pc, #400]	; (b2d0 <AJ_UnmarshalMsg+0x61c>)
    b140:	4798      	blx	r3
        nonceLen = GetNonceLength(msg);
        extraNonceLen = nonceLen - PREVIOUS_NONCE_LENGTH;
        cryptoValsLen = macLen + extraNonceLen;
        //AJ_InfoPrintf(("DecryptMessage(): \n"));
        InitNonce(msg, role, nonce, sizeof(nonce), ioBuf->bufStart + mlen - extraNonceLen, extraNonceLen);
        EndianSwap(msg, AJ_ARG_INT32, &msg->hdr->bodyLen, 3);
    b142:	1d2a      	adds	r2, r5, #4
    b144:	1c20      	adds	r0, r4, #0
    b146:	2169      	movs	r1, #105	; 0x69
    b148:	2303      	movs	r3, #3
    b14a:	4d62      	ldr	r5, [pc, #392]	; (b2d4 <AJ_UnmarshalMsg+0x620>)
    b14c:	47a8      	blx	r5
        status = AJ_Decrypt_CCM(key, ioBuf->bufStart, mlen - cryptoValsLen, hLen, macLen, nonce, nonceLen);
    b14e:	464b      	mov	r3, r9
    b150:	4642      	mov	r2, r8
    b152:	1a9a      	subs	r2, r3, r2
    b154:	465b      	mov	r3, fp
    b156:	9300      	str	r3, [sp, #0]
    b158:	ab08      	add	r3, sp, #32
    b15a:	9301      	str	r3, [sp, #4]
    b15c:	9702      	str	r7, [sp, #8]
    b15e:	a80c      	add	r0, sp, #48	; 0x30
    b160:	9b04      	ldr	r3, [sp, #16]
    b162:	6b59      	ldr	r1, [r3, #52]	; 0x34
    b164:	4653      	mov	r3, sl
    b166:	4e5c      	ldr	r6, [pc, #368]	; (b2d8 <AJ_UnmarshalMsg+0x624>)
    b168:	47b0      	blx	r6
    b16a:	1c07      	adds	r7, r0, #0
        EndianSwap(msg, AJ_ARG_INT32, &msg->hdr->bodyLen, 3);
    b16c:	6863      	ldr	r3, [r4, #4]
    b16e:	1d1a      	adds	r2, r3, #4
    b170:	1c20      	adds	r0, r4, #0
    b172:	2169      	movs	r1, #105	; 0x69
    b174:	2303      	movs	r3, #3
    b176:	47a8      	blx	r5
        if (AJ_OK == status) 
    b178:	2f00      	cmp	r7, #0
    b17a:	d000      	beq.n	b17e <AJ_UnmarshalMsg+0x4ca>
    b17c:	e084      	b.n	b288 <AJ_UnmarshalMsg+0x5d4>
		{
            if ((AJ_MSG_METHOD_CALL == msg->hdr->msgType) || (AJ_MSG_SIGNAL == msg->hdr->msgType)) 
    b17e:	6863      	ldr	r3, [r4, #4]
    b180:	785a      	ldrb	r2, [r3, #1]
    b182:	2a01      	cmp	r2, #1
    b184:	d001      	beq.n	b18a <AJ_UnmarshalMsg+0x4d6>
    b186:	2a04      	cmp	r2, #4
    b188:	d174      	bne.n	b274 <AJ_UnmarshalMsg+0x5c0>
			{
                // Methods and signals 
				printf("msg->hdr->serialNum = %d\n", (msg->hdr->serialNum));
    b18a:	4854      	ldr	r0, [pc, #336]	; (b2dc <AJ_UnmarshalMsg+0x628>)
    b18c:	6899      	ldr	r1, [r3, #8]
    b18e:	4b54      	ldr	r3, [pc, #336]	; (b2e0 <AJ_UnmarshalMsg+0x62c>)
    b190:	4798      	blx	r3
                status = AJ_CheckIncomingSerial(incoming, msg->hdr->serialNum);
    b192:	6863      	ldr	r3, [r4, #4]
    b194:	9807      	ldr	r0, [sp, #28]
    b196:	6899      	ldr	r1, [r3, #8]
    b198:	4b52      	ldr	r3, [pc, #328]	; (b2e4 <AJ_UnmarshalMsg+0x630>)
    b19a:	4798      	blx	r3
    b19c:	1c07      	adds	r7, r0, #0
            }
        }
    }
    AJ_MemZeroSecure(key, 16);
    b19e:	a80c      	add	r0, sp, #48	; 0x30
    b1a0:	2110      	movs	r1, #16
    b1a2:	4b51      	ldr	r3, [pc, #324]	; (b2e8 <AJ_UnmarshalMsg+0x634>)
    b1a4:	4798      	blx	r3
        /*
        * Toggle the AUTO_START flag so in the API no flags == 0
        *
        * Note we must do this after decrypting the message or message authentication will fail.
        */
        msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    b1a6:	6862      	ldr	r2, [r4, #4]
    b1a8:	7893      	ldrb	r3, [r2, #2]
    b1aa:	2102      	movs	r1, #2
    b1ac:	404b      	eors	r3, r1
    b1ae:	7093      	strb	r3, [r2, #2]
        // If the message looks good try to identify it.
        if (status == AJ_OK) 
    b1b0:	2f00      	cmp	r7, #0
    b1b2:	d113      	bne.n	b1dc <AJ_UnmarshalMsg+0x528>
    b1b4:	e008      	b.n	b1c8 <AJ_UnmarshalMsg+0x514>
            if (status == AJ_OK) 
			{
                status = DecryptMessage(msg);
            }
        }
		else		printf("msg->hdr->serialNum = %d\n", (msg->hdr->serialNum));
    b1b6:	4849      	ldr	r0, [pc, #292]	; (b2dc <AJ_UnmarshalMsg+0x628>)
    b1b8:	6899      	ldr	r1, [r3, #8]
    b1ba:	4b49      	ldr	r3, [pc, #292]	; (b2e0 <AJ_UnmarshalMsg+0x62c>)
    b1bc:	4798      	blx	r3
        /*
        * Toggle the AUTO_START flag so in the API no flags == 0
        *
        * Note we must do this after decrypting the message or message authentication will fail.
        */
        msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    b1be:	6862      	ldr	r2, [r4, #4]
    b1c0:	7893      	ldrb	r3, [r2, #2]
    b1c2:	2102      	movs	r1, #2
    b1c4:	404b      	eors	r3, r1
    b1c6:	7093      	strb	r3, [r2, #2]
        // If the message looks good try to identify it.
        if (status == AJ_OK) 
		{
            status = AJ_IdentifyMessage(msg);
    b1c8:	1c20      	adds	r0, r4, #0
    b1ca:	4b48      	ldr	r3, [pc, #288]	; (b2ec <AJ_UnmarshalMsg+0x638>)
    b1cc:	4798      	blx	r3
    b1ce:	1e07      	subs	r7, r0, #0
	else
	{
        // Consume entire header
        ioBuf->readPtr = endOfHeader + hdrPad;
    }
    if (status == AJ_OK) 
    b1d0:	d041      	beq.n	b256 <AJ_UnmarshalMsg+0x5a2>
    b1d2:	e003      	b.n	b1dc <AJ_UnmarshalMsg+0x528>
        hdrRaw = NULL;
    }
    if (ioBuf->readPtr != endOfHeader) 
	{
	//	printf("ioBuf->readPtr= %d, endOfHeader= %d\n",ioBuf->readPtr,endOfHeader);
        status = AJ_ERR_HDR_CORRUPT;
    b1d4:	271d      	movs	r7, #29
        }
    } 
	else
	{
        // Consume entire header
        ioBuf->readPtr = endOfHeader + hdrPad;
    b1d6:	465b      	mov	r3, fp
    b1d8:	444b      	add	r3, r9
    b1da:	63ab      	str	r3, [r5, #56]	; 0x38
	else
	{
        // Silently discard message unless in debug mode
  //      AJ_WarnPrintf(("Discarding unknown message %s\n", AJ_StatusText(status)));
        AJ_DumpMsg("DISCARDING", msg, FALSE);
        AJ_CloseMsg(msg);
    b1dc:	1c20      	adds	r0, r4, #0
    b1de:	4b44      	ldr	r3, [pc, #272]	; (b2f0 <AJ_UnmarshalMsg+0x63c>)
    b1e0:	4798      	blx	r3
    b1e2:	1c38      	adds	r0, r7, #0
    b1e4:	e05a      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
    //Check for the special case messages 
    switch (msg->msgId) 
	{
    case AJ_REPLY_ID(AJ_METHOD_NAME_HAS_OWNER):
   //     printf("ProcessBusMessages(): AJ_REPLY_ID(AJ_METHOD_NAME_HAS_OWNER)\n");
        status = AJ_GUID_HandleNameHasOwnerReply(msg);
    b1e6:	1c20      	adds	r0, r4, #0
    b1e8:	4b42      	ldr	r3, [pc, #264]	; (b2f4 <AJ_UnmarshalMsg+0x640>)
    b1ea:	4798      	blx	r3
    b1ec:	1e03      	subs	r3, r0, #0
        /*
        * Reset so the application can handle this too.  Don't overwrite any
        * error detected during AJ_GUID_HandleNameHasOwnerReply() above.
        */
        if (status == AJ_OK) 
    b1ee:	d155      	bne.n	b29c <AJ_UnmarshalMsg+0x5e8>
		{
            status = AJ_ResetArgs(msg);
    b1f0:	1c20      	adds	r0, r4, #0
    b1f2:	4b41      	ldr	r3, [pc, #260]	; (b2f8 <AJ_UnmarshalMsg+0x644>)
    b1f4:	4798      	blx	r3
    b1f6:	e051      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
        }
        break;

    case AJ_REPLY_ID(AJ_METHOD_ADD_MATCH):
   //     printf("ProcessBusMessages(): AJ_REPLY_ID(AJ_METHOD_ADD_MATCH)\n");
        status = AJ_GUID_HandleAddMatchReply(msg);
    b1f8:	1c20      	adds	r0, r4, #0
    b1fa:	4b40      	ldr	r3, [pc, #256]	; (b2fc <AJ_UnmarshalMsg+0x648>)
    b1fc:	4798      	blx	r3
    b1fe:	1e03      	subs	r3, r0, #0
        /*
          * Reset so the application can handle this too.  Don't overwrite any
          * error detected during AJ_GUID_HandleAddMatchReply() above.
        */
        if (status == AJ_OK)
    b200:	d14c      	bne.n	b29c <AJ_UnmarshalMsg+0x5e8>
		{
            status = AJ_ResetArgs(msg);
    b202:	1c20      	adds	r0, r4, #0
    b204:	4b3c      	ldr	r3, [pc, #240]	; (b2f8 <AJ_UnmarshalMsg+0x644>)
    b206:	4798      	blx	r3
    b208:	e048      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
        }
        break;

    case AJ_REPLY_ID(AJ_METHOD_REMOVE_MATCH):
   //     printf("ProcessBusMessages(): AJ_REPLY_ID(AJ_METHOD_REMOVE_MATCH)\n");
        status = AJ_GUID_HandleRemoveMatchReply(msg);
    b20a:	1c20      	adds	r0, r4, #0
    b20c:	4b3c      	ldr	r3, [pc, #240]	; (b300 <AJ_UnmarshalMsg+0x64c>)
    b20e:	4798      	blx	r3
    b210:	1e03      	subs	r3, r0, #0
        /*
        * Reset so the application can handle this too.  Don't overwrite any
         * error detected during AJ_GUID_HandleRemoveMatchReply() above.
         */
        if (status == AJ_OK) 
    b212:	d143      	bne.n	b29c <AJ_UnmarshalMsg+0x5e8>
		{
            status = AJ_ResetArgs(msg);
    b214:	1c20      	adds	r0, r4, #0
    b216:	4b38      	ldr	r3, [pc, #224]	; (b2f8 <AJ_UnmarshalMsg+0x644>)
    b218:	4798      	blx	r3
    b21a:	e03f      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
        }
        break;

    case AJ_SIGNAL_NAME_OWNER_CHANGED:
    //    printf("ProcessBusMessages(): AJ_SIGNAL_NAME_OWNER_CHANGED)\n");
        status = AJ_GUID_HandleNameOwnerChanged(msg);
    b21c:	1c20      	adds	r0, r4, #0
    b21e:	4b39      	ldr	r3, [pc, #228]	; (b304 <AJ_UnmarshalMsg+0x650>)
    b220:	4798      	blx	r3
    b222:	1e03      	subs	r3, r0, #0
        /*
         * Reset so the application can handle this too.  Don't overwrite any
        * error detected during AJ_GUID_HandleNameOwnerChanged() above.
        */
        if (status == AJ_OK) 
    b224:	d13a      	bne.n	b29c <AJ_UnmarshalMsg+0x5e8>
		{
            status = AJ_ResetArgs(msg);
    b226:	1c20      	adds	r0, r4, #0
    b228:	4b33      	ldr	r3, [pc, #204]	; (b2f8 <AJ_UnmarshalMsg+0x644>)
    b22a:	4798      	blx	r3
    b22c:	e036      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
 *
 * @param msg   The message
 */
static AJ_Status ProcessBusMessages(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    b22e:	2000      	movs	r0, #0
    b230:	e034      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
            /*
            * If there were no messages to receive check if we have any methods call that have
            *  timed-out and if so generate an internal error message to allow the application to
            * proceed.
            */
            if ((status == AJ_ERR_TIMEOUT) && AJ_TimedOutMethodCall(msg)) 
    b232:	1c20      	adds	r0, r4, #0
    b234:	4b34      	ldr	r3, [pc, #208]	; (b308 <AJ_UnmarshalMsg+0x654>)
    b236:	4798      	blx	r3
    b238:	2800      	cmp	r0, #0
    b23a:	d000      	beq.n	b23e <AJ_UnmarshalMsg+0x58a>
    b23c:	e58c      	b.n	ad58 <AJ_UnmarshalMsg+0xa4>
        //#pragma calls = AJ_Net_Recv
		// AJ_IO_BUF_AVAIL(ioBuf)=WritePtr-ReadPtr
   //     printf("AJ_UnmarshalMsg(): ioBufBytes=%u\n", AJ_IO_BUF_AVAIL(ioBuf));
       while ( AJ_IO_BUF_AVAIL(ioBuf) < sizeof(AJ_MsgHeader))
       {
		         status = ioBuf->recv(ioBuf, sizeof(AJ_MsgHeader) - AJ_IO_BUF_AVAIL(ioBuf), msg->timeout);
    b23e:	3007      	adds	r0, #7
    b240:	e02c      	b.n	b29c <AJ_UnmarshalMsg+0x5e8>
    if (ioBuf->readPtr != endOfHeader) 
	{
	//	printf("ioBuf->readPtr= %d, endOfHeader= %d\n",ioBuf->readPtr,endOfHeader);
        status = AJ_ERR_HDR_CORRUPT;
    }
    if (status == AJ_OK) 
    b242:	2f00      	cmp	r7, #0
    b244:	d100      	bne.n	b248 <AJ_UnmarshalMsg+0x594>
    b246:	e6f3      	b.n	b030 <AJ_UnmarshalMsg+0x37c>
    b248:	e7c5      	b.n	b1d6 <AJ_UnmarshalMsg+0x522>
        /*
        * Toggle the AUTO_START flag so in the API no flags == 0
        *
        * Note we must do this after decrypting the message or message authentication will fail.
        */
        msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    b24a:	6862      	ldr	r2, [r4, #4]
    b24c:	7893      	ldrb	r3, [r2, #2]
    b24e:	2102      	movs	r1, #2
    b250:	404b      	eors	r3, r1
    b252:	7093      	strb	r3, [r2, #2]
    b254:	e7c2      	b.n	b1dc <AJ_UnmarshalMsg+0x528>
 */
static AJ_Status ProcessBusMessages(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    //Check for the special case messages 
    switch (msg->msgId) 
    b256:	6823      	ldr	r3, [r4, #0]
    b258:	4a2c      	ldr	r2, [pc, #176]	; (b30c <AJ_UnmarshalMsg+0x658>)
    b25a:	4293      	cmp	r3, r2
    b25c:	d0cc      	beq.n	b1f8 <AJ_UnmarshalMsg+0x544>
    b25e:	d802      	bhi.n	b266 <AJ_UnmarshalMsg+0x5b2>
    b260:	2b01      	cmp	r3, #1
    b262:	d0db      	beq.n	b21c <AJ_UnmarshalMsg+0x568>
    b264:	e7e3      	b.n	b22e <AJ_UnmarshalMsg+0x57a>
    b266:	4a2a      	ldr	r2, [pc, #168]	; (b310 <AJ_UnmarshalMsg+0x65c>)
    b268:	4293      	cmp	r3, r2
    b26a:	d0ce      	beq.n	b20a <AJ_UnmarshalMsg+0x556>
    b26c:	4a29      	ldr	r2, [pc, #164]	; (b314 <AJ_UnmarshalMsg+0x660>)
    b26e:	4293      	cmp	r3, r2
    b270:	d0b9      	beq.n	b1e6 <AJ_UnmarshalMsg+0x532>
    b272:	e7dc      	b.n	b22e <AJ_UnmarshalMsg+0x57a>
				printf("msg->hdr->serialNum = %d\n", (msg->hdr->serialNum));
                status = AJ_CheckIncomingSerial(incoming, msg->hdr->serialNum);
            }
        }
    }
    AJ_MemZeroSecure(key, 16);
    b274:	a80c      	add	r0, sp, #48	; 0x30
    b276:	2110      	movs	r1, #16
    b278:	4b1b      	ldr	r3, [pc, #108]	; (b2e8 <AJ_UnmarshalMsg+0x634>)
    b27a:	4798      	blx	r3
        /*
        * Toggle the AUTO_START flag so in the API no flags == 0
        *
        * Note we must do this after decrypting the message or message authentication will fail.
        */
        msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    b27c:	6862      	ldr	r2, [r4, #4]
    b27e:	7893      	ldrb	r3, [r2, #2]
    b280:	2102      	movs	r1, #2
    b282:	404b      	eors	r3, r1
    b284:	7093      	strb	r3, [r2, #2]
    b286:	e79f      	b.n	b1c8 <AJ_UnmarshalMsg+0x514>
				printf("msg->hdr->serialNum = %d\n", (msg->hdr->serialNum));
                status = AJ_CheckIncomingSerial(incoming, msg->hdr->serialNum);
            }
        }
    }
    AJ_MemZeroSecure(key, 16);
    b288:	a80c      	add	r0, sp, #48	; 0x30
    b28a:	2110      	movs	r1, #16
    b28c:	4b16      	ldr	r3, [pc, #88]	; (b2e8 <AJ_UnmarshalMsg+0x634>)
    b28e:	4798      	blx	r3
        /*
        * Toggle the AUTO_START flag so in the API no flags == 0
        *
        * Note we must do this after decrypting the message or message authentication will fail.
        */
        msg->hdr->flags ^= AJ_FLAG_AUTO_START;
    b290:	6862      	ldr	r2, [r4, #4]
    b292:	7893      	ldrb	r3, [r2, #2]
    b294:	2102      	movs	r1, #2
    b296:	404b      	eors	r3, r1
    b298:	7093      	strb	r3, [r2, #2]
    b29a:	e79f      	b.n	b1dc <AJ_UnmarshalMsg+0x528>
	{
        status = ProcessBusMessages(msg);
    }
//	printf("----AJ_UnmarshalMsg() end status=%s----\n",AJ_StatusText(status));
    return status;
}
    b29c:	b013      	add	sp, #76	; 0x4c
    b29e:	bc3c      	pop	{r2, r3, r4, r5}
    b2a0:	4690      	mov	r8, r2
    b2a2:	4699      	mov	r9, r3
    b2a4:	46a2      	mov	sl, r4
    b2a6:	46ab      	mov	fp, r5
    b2a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b2aa:	46c0      	nop			; (mov r8, r8)
    b2ac:	00009c05 	.word	0x00009c05
    b2b0:	00007cd9 	.word	0x00007cd9
    b2b4:	00007c65 	.word	0x00007c65
    b2b8:	00007c99 	.word	0x00007c99
    b2bc:	0001d2d8 	.word	0x0001d2d8
    b2c0:	0000636d 	.word	0x0000636d
    b2c4:	0001d7d4 	.word	0x0001d7d4
    b2c8:	00016f5d 	.word	0x00016f5d
    b2cc:	00009ae5 	.word	0x00009ae5
    b2d0:	00016739 	.word	0x00016739
    b2d4:	00009a19 	.word	0x00009a19
    b2d8:	000048fd 	.word	0x000048fd
    b2dc:	0001d7f8 	.word	0x0001d7f8
    b2e0:	00016e3d 	.word	0x00016e3d
    b2e4:	0000a465 	.word	0x0000a465
    b2e8:	0000d71d 	.word	0x0000d71d
    b2ec:	00008f2d 	.word	0x00008f2d
    b2f0:	0000a77d 	.word	0x0000a77d
    b2f4:	00007e79 	.word	0x00007e79
    b2f8:	0000abd5 	.word	0x0000abd5
    b2fc:	00007d45 	.word	0x00007d45
    b300:	00007fb9 	.word	0x00007fb9
    b304:	00007f75 	.word	0x00007f75
    b308:	00008a4d 	.word	0x00008a4d
    b30c:	80000006 	.word	0x80000006
    b310:	80000007 	.word	0x80000007
    b314:	80000009 	.word	0x80000009

0000b318 <AJ_UnmarshalVariant>:
    }
    return AJ_OK;
}

AJ_Status AJ_UnmarshalVariant(AJ_Message* msg, const char** sig)
{
    b318:	b510      	push	{r4, lr}
    b31a:	b084      	sub	sp, #16
    b31c:	1c0c      	adds	r4, r1, #0
    AJ_Arg arg;
    AJ_Status status = AJ_UnmarshalArg(msg, &arg);
    b31e:	4669      	mov	r1, sp
    b320:	4b04      	ldr	r3, [pc, #16]	; (b334 <AJ_UnmarshalVariant+0x1c>)
    b322:	4798      	blx	r3
    if (status == AJ_OK) 
    b324:	2800      	cmp	r0, #0
    b326:	d103      	bne.n	b330 <AJ_UnmarshalVariant+0x18>
	{
        if (sig)
    b328:	2c00      	cmp	r4, #0
    b32a:	d001      	beq.n	b330 <AJ_UnmarshalVariant+0x18>
		{
            *sig = arg.val.v_string;
    b32c:	9b01      	ldr	r3, [sp, #4]
    b32e:	6023      	str	r3, [r4, #0]
        }
    }
    return status;
}
    b330:	b004      	add	sp, #16
    b332:	bd10      	pop	{r4, pc}
    b334:	0000a855 	.word	0x0000a855

0000b338 <VUnmarshalArgs>:
    }
    return status;
}

static AJ_Status VUnmarshalArgs(AJ_Message* msg, const char** sig, va_list* argpp)
{
    b338:	b5f0      	push	{r4, r5, r6, r7, lr}
    b33a:	4647      	mov	r7, r8
    b33c:	b480      	push	{r7}
    b33e:	b08c      	sub	sp, #48	; 0x30
    b340:	9001      	str	r0, [sp, #4]
    b342:	1c0f      	adds	r7, r1, #0
    b344:	1c16      	adds	r6, r2, #0
    AJ_Status status = AJ_OK;
    AJ_Arg arg;
    AJ_Arg container;
    va_list argp;

    __va_copy(argp, *argpp);
    b346:	6813      	ldr	r3, [r2, #0]
    b348:	9303      	str	r3, [sp, #12]

    container.typeId = AJ_ARG_INVALID;
    b34a:	2200      	movs	r2, #0
    b34c:	ab04      	add	r3, sp, #16
    b34e:	701a      	strb	r2, [r3, #0]

    while (**sig)
    b350:	e112      	b.n	b578 <VUnmarshalArgs+0x240>
	{
        uint8_t typeId = (uint8_t)*((*sig)++);
    b352:	1c5a      	adds	r2, r3, #1
    b354:	603a      	str	r2, [r7, #0]
    b356:	781c      	ldrb	r4, [r3, #0]
        void* val;

        if (!IsBasicType(typeId)) 
    b358:	1c25      	adds	r5, r4, #0
    b35a:	3d28      	subs	r5, #40	; 0x28
    b35c:	b2ed      	uxtb	r5, r5
    b35e:	2d01      	cmp	r5, #1
    b360:	d802      	bhi.n	b368 <VUnmarshalArgs+0x30>
    b362:	1c21      	adds	r1, r4, #0
    b364:	3928      	subs	r1, #40	; 0x28
    b366:	e006      	b.n	b376 <VUnmarshalArgs+0x3e>
    b368:	211e      	movs	r1, #30
    b36a:	1c22      	adds	r2, r4, #0
    b36c:	3a61      	subs	r2, #97	; 0x61
    b36e:	2a1c      	cmp	r2, #28
    b370:	d801      	bhi.n	b376 <VUnmarshalArgs+0x3e>
    b372:	1c21      	adds	r1, r4, #0
    b374:	395f      	subs	r1, #95	; 0x5f
    b376:	4a8d      	ldr	r2, [pc, #564]	; (b5ac <VUnmarshalArgs+0x274>)
    b378:	5c52      	ldrb	r2, [r2, r1]
    b37a:	2150      	movs	r1, #80	; 0x50
    b37c:	4211      	tst	r1, r2
    b37e:	d000      	beq.n	b382 <VUnmarshalArgs+0x4a>
    b380:	e0a5      	b.n	b4ce <VUnmarshalArgs+0x196>
		{
            if ((typeId == AJ_ARG_STRUCT) || (typeId == AJ_ARG_DICT_ENTRY)) 
    b382:	2c28      	cmp	r4, #40	; 0x28
    b384:	d001      	beq.n	b38a <VUnmarshalArgs+0x52>
    b386:	2c7b      	cmp	r4, #123	; 0x7b
    b388:	d138      	bne.n	b3fc <VUnmarshalArgs+0xc4>
			{
                //This function supports unmarshaling of a single level structs.
                status = AJ_UnmarshalContainer(msg, &container, typeId);
    b38a:	9d01      	ldr	r5, [sp, #4]
    b38c:	1c28      	adds	r0, r5, #0
    b38e:	a904      	add	r1, sp, #16
    b390:	1c22      	adds	r2, r4, #0
    b392:	4b87      	ldr	r3, [pc, #540]	; (b5b0 <VUnmarshalArgs+0x278>)
    b394:	4798      	blx	r3
    b396:	4680      	mov	r8, r0
				printf("VUnmarshalArgs(): AJ_UnmarshalContainer status = %s\n",AJ_StatusText(status) );
    b398:	4b86      	ldr	r3, [pc, #536]	; (b5b4 <VUnmarshalArgs+0x27c>)
    b39a:	4798      	blx	r3
    b39c:	1c01      	adds	r1, r0, #0
    b39e:	4886      	ldr	r0, [pc, #536]	; (b5b8 <VUnmarshalArgs+0x280>)
    b3a0:	4b86      	ldr	r3, [pc, #536]	; (b5bc <VUnmarshalArgs+0x284>)
    b3a2:	4798      	blx	r3
                if (status != AJ_OK) 
    b3a4:	4643      	mov	r3, r8
    b3a6:	2b00      	cmp	r3, #0
    b3a8:	d000      	beq.n	b3ac <VUnmarshalArgs+0x74>
    b3aa:	e0f8      	b.n	b59e <VUnmarshalArgs+0x266>
				{
                    break;
                }

                status = VUnmarshalArgs(msg, sig, &argp);
    b3ac:	1c28      	adds	r0, r5, #0
    b3ae:	1c39      	adds	r1, r7, #0
    b3b0:	aa03      	add	r2, sp, #12
    b3b2:	f7ff ffc1 	bl	b338 <VUnmarshalArgs>
    b3b6:	4680      	mov	r8, r0
                /*
                              * Upon successful return from a nested call, continue from
                              * where the inner call advanced in the signature.
                            */
				printf("VUnmarshalArgs(): VUnmarshalArgs status = %s\n",AJ_StatusText(status) );
    b3b8:	4b7e      	ldr	r3, [pc, #504]	; (b5b4 <VUnmarshalArgs+0x27c>)
    b3ba:	4798      	blx	r3
    b3bc:	1c01      	adds	r1, r0, #0
    b3be:	4880      	ldr	r0, [pc, #512]	; (b5c0 <VUnmarshalArgs+0x288>)
    b3c0:	4b7e      	ldr	r3, [pc, #504]	; (b5bc <VUnmarshalArgs+0x284>)
    b3c2:	4798      	blx	r3
                if (status == AJ_OK) 
    b3c4:	4643      	mov	r3, r8
    b3c6:	2b00      	cmp	r3, #0
    b3c8:	d000      	beq.n	b3cc <VUnmarshalArgs+0x94>
    b3ca:	e0e8      	b.n	b59e <VUnmarshalArgs+0x266>
				{
                    char tId = *(*sig - 1);
    b3cc:	683b      	ldr	r3, [r7, #0]
    b3ce:	3b01      	subs	r3, #1
    b3d0:	781b      	ldrb	r3, [r3, #0]
                    if ((tId == AJ_STRUCT_CLOSE) || (tId == AJ_DICT_ENTRY_CLOSE)) 
    b3d2:	2b29      	cmp	r3, #41	; 0x29
    b3d4:	d002      	beq.n	b3dc <VUnmarshalArgs+0xa4>
    b3d6:	2b7d      	cmp	r3, #125	; 0x7d
    b3d8:	d000      	beq.n	b3dc <VUnmarshalArgs+0xa4>
    b3da:	e0d5      	b.n	b588 <VUnmarshalArgs+0x250>
					{
                        status = AJ_UnmarshalCloseContainer(msg, &container);
    b3dc:	9801      	ldr	r0, [sp, #4]
    b3de:	a904      	add	r1, sp, #16
    b3e0:	4b78      	ldr	r3, [pc, #480]	; (b5c4 <VUnmarshalArgs+0x28c>)
    b3e2:	4798      	blx	r3
    b3e4:	4680      	mov	r8, r0
						printf("VUnmarshalArgs(): AJ_UnmarshalCloseContainer status = %s\n",AJ_StatusText(status) );
    b3e6:	4b73      	ldr	r3, [pc, #460]	; (b5b4 <VUnmarshalArgs+0x27c>)
    b3e8:	4798      	blx	r3
    b3ea:	1c01      	adds	r1, r0, #0
    b3ec:	4876      	ldr	r0, [pc, #472]	; (b5c8 <VUnmarshalArgs+0x290>)
    b3ee:	4b73      	ldr	r3, [pc, #460]	; (b5bc <VUnmarshalArgs+0x284>)
    b3f0:	4798      	blx	r3

                        if (status != AJ_OK) 
    b3f2:	4643      	mov	r3, r8
    b3f4:	2b00      	cmp	r3, #0
    b3f6:	d100      	bne.n	b3fa <VUnmarshalArgs+0xc2>
    b3f8:	e0be      	b.n	b578 <VUnmarshalArgs+0x240>
    b3fa:	e0d0      	b.n	b59e <VUnmarshalArgs+0x266>
				{
                    break;
                }
                continue;
            }
            if ((typeId == AJ_ARG_ARRAY) && IsBasicType(**sig)) 
    b3fc:	2c61      	cmp	r4, #97	; 0x61
    b3fe:	d129      	bne.n	b454 <VUnmarshalArgs+0x11c>
    b400:	785a      	ldrb	r2, [r3, #1]
    b402:	1c11      	adds	r1, r2, #0
    b404:	3928      	subs	r1, #40	; 0x28
    b406:	2901      	cmp	r1, #1
    b408:	d801      	bhi.n	b40e <VUnmarshalArgs+0xd6>
    b40a:	1c08      	adds	r0, r1, #0
    b40c:	e006      	b.n	b41c <VUnmarshalArgs+0xe4>
    b40e:	201e      	movs	r0, #30
    b410:	1c11      	adds	r1, r2, #0
    b412:	3961      	subs	r1, #97	; 0x61
    b414:	291c      	cmp	r1, #28
    b416:	d801      	bhi.n	b41c <VUnmarshalArgs+0xe4>
    b418:	3a5f      	subs	r2, #95	; 0x5f
    b41a:	1c10      	adds	r0, r2, #0
    b41c:	4a63      	ldr	r2, [pc, #396]	; (b5ac <VUnmarshalArgs+0x274>)
    b41e:	5c12      	ldrb	r2, [r2, r0]
    b420:	2150      	movs	r1, #80	; 0x50
    b422:	4211      	tst	r1, r2
    b424:	d046      	beq.n	b4b4 <VUnmarshalArgs+0x17c>
			{
                const void** ptr = va_arg(argp, const void**);
    b426:	9a03      	ldr	r2, [sp, #12]
    b428:	1d11      	adds	r1, r2, #4
    b42a:	9103      	str	r1, [sp, #12]
    b42c:	6814      	ldr	r4, [r2, #0]
                size_t* len = va_arg(argp, size_t*);
    b42e:	3104      	adds	r1, #4
    b430:	9103      	str	r1, [sp, #12]
    b432:	6855      	ldr	r5, [r2, #4]
                (*sig)++;
    b434:	3302      	adds	r3, #2
    b436:	603b      	str	r3, [r7, #0]
                status = AJ_UnmarshalArg(msg, &arg);
    b438:	9801      	ldr	r0, [sp, #4]
    b43a:	a908      	add	r1, sp, #32
    b43c:	4b63      	ldr	r3, [pc, #396]	; (b5cc <VUnmarshalArgs+0x294>)
    b43e:	4798      	blx	r3
    b440:	4680      	mov	r8, r0
			//	printf("VUnmarshalArgs(): AJ_UnmarshalArg status = %s\n",AJ_StatusText(status) );

                if (status != AJ_OK) 
    b442:	2800      	cmp	r0, #0
    b444:	d000      	beq.n	b448 <VUnmarshalArgs+0x110>
    b446:	e0aa      	b.n	b59e <VUnmarshalArgs+0x266>
				{
                    break;
                }
                *ptr = arg.val.v_data;
    b448:	ab08      	add	r3, sp, #32
    b44a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b44c:	6022      	str	r2, [r4, #0]
                *len = arg.len;
    b44e:	885b      	ldrh	r3, [r3, #2]
    b450:	602b      	str	r3, [r5, #0]
                continue;
    b452:	e091      	b.n	b578 <VUnmarshalArgs+0x240>
            }
            if ((typeId == AJ_STRUCT_CLOSE) || (typeId == AJ_DICT_ENTRY_CLOSE)) 
    b454:	2c29      	cmp	r4, #41	; 0x29
    b456:	d100      	bne.n	b45a <VUnmarshalArgs+0x122>
    b458:	e099      	b.n	b58e <VUnmarshalArgs+0x256>
    b45a:	2c7d      	cmp	r4, #125	; 0x7d
    b45c:	d100      	bne.n	b460 <VUnmarshalArgs+0x128>
    b45e:	e099      	b.n	b594 <VUnmarshalArgs+0x25c>
			{
                break;
            }
            if (typeId == AJ_ARG_VARIANT) 
    b460:	2c76      	cmp	r4, #118	; 0x76
    b462:	d127      	bne.n	b4b4 <VUnmarshalArgs+0x17c>
			{
                const char* vsigExpect = va_arg(argp, const char*);
    b464:	9b03      	ldr	r3, [sp, #12]
    b466:	1d1a      	adds	r2, r3, #4
    b468:	9203      	str	r2, [sp, #12]
    b46a:	681d      	ldr	r5, [r3, #0]
                const char* vsig;
                status = AJ_UnmarshalVariant(msg, &vsig);
    b46c:	9801      	ldr	r0, [sp, #4]
    b46e:	a902      	add	r1, sp, #8
    b470:	4b57      	ldr	r3, [pc, #348]	; (b5d0 <VUnmarshalArgs+0x298>)
    b472:	4798      	blx	r3
    b474:	1c04      	adds	r4, r0, #0
				printf("VUnmarshalArgs(): AJ_UnmarshalVariant status = %s\n",AJ_StatusText(status) );
    b476:	4b4f      	ldr	r3, [pc, #316]	; (b5b4 <VUnmarshalArgs+0x27c>)
    b478:	4798      	blx	r3
    b47a:	1c01      	adds	r1, r0, #0
    b47c:	4855      	ldr	r0, [pc, #340]	; (b5d4 <VUnmarshalArgs+0x29c>)
    b47e:	4b4f      	ldr	r3, [pc, #316]	; (b5bc <VUnmarshalArgs+0x284>)
    b480:	4798      	blx	r3
                if (status == AJ_OK)
    b482:	2c00      	cmp	r4, #0
    b484:	d116      	bne.n	b4b4 <VUnmarshalArgs+0x17c>
				{
                    if (strcmp(vsig, vsigExpect) != 0) 
    b486:	9802      	ldr	r0, [sp, #8]
    b488:	1c29      	adds	r1, r5, #0
    b48a:	4b53      	ldr	r3, [pc, #332]	; (b5d8 <VUnmarshalArgs+0x2a0>)
    b48c:	4798      	blx	r3
    b48e:	2800      	cmp	r0, #0
    b490:	d002      	beq.n	b498 <VUnmarshalArgs+0x160>
					{
                        status = AJ_ERR_SIGNATURE;
    b492:	2311      	movs	r3, #17
    b494:	4698      	mov	r8, r3
    b496:	e082      	b.n	b59e <VUnmarshalArgs+0x266>
                        break;
                    }
                    status = VUnmarshalArgs(msg, &vsig, &argp);
    b498:	9801      	ldr	r0, [sp, #4]
    b49a:	a902      	add	r1, sp, #8
    b49c:	aa03      	add	r2, sp, #12
    b49e:	f7ff ff4b 	bl	b338 <VUnmarshalArgs>
    b4a2:	1c04      	adds	r4, r0, #0
					printf("VUnmarshalArgs(): VUnmarshalArgs status = %s\n",AJ_StatusText(status) );
    b4a4:	4b43      	ldr	r3, [pc, #268]	; (b5b4 <VUnmarshalArgs+0x27c>)
    b4a6:	4798      	blx	r3
    b4a8:	1c01      	adds	r1, r0, #0
    b4aa:	4845      	ldr	r0, [pc, #276]	; (b5c0 <VUnmarshalArgs+0x288>)
    b4ac:	4b43      	ldr	r3, [pc, #268]	; (b5bc <VUnmarshalArgs+0x284>)
    b4ae:	4798      	blx	r3
                }
                if (status == AJ_OK) 
    b4b0:	2c00      	cmp	r4, #0
    b4b2:	d061      	beq.n	b578 <VUnmarshalArgs+0x240>
				{
                    continue;
                }
            }
            AJ_ErrPrintf(("AJ_UnmarshalArgs(): AJ_ERR_UNEXPECTED\n"));
    b4b4:	2001      	movs	r0, #1
    b4b6:	4949      	ldr	r1, [pc, #292]	; (b5dc <VUnmarshalArgs+0x2a4>)
    b4b8:	4a49      	ldr	r2, [pc, #292]	; (b5e0 <VUnmarshalArgs+0x2a8>)
    b4ba:	4b4a      	ldr	r3, [pc, #296]	; (b5e4 <VUnmarshalArgs+0x2ac>)
    b4bc:	4798      	blx	r3
            status = AJ_ERR_UNEXPECTED;
    b4be:	2302      	movs	r3, #2
    b4c0:	4698      	mov	r8, r3
                if (status == AJ_OK) 
				{
                    continue;
                }
            }
            AJ_ErrPrintf(("AJ_UnmarshalArgs(): AJ_ERR_UNEXPECTED\n"));
    b4c2:	2800      	cmp	r0, #0
    b4c4:	d06b      	beq.n	b59e <VUnmarshalArgs+0x266>
    b4c6:	4848      	ldr	r0, [pc, #288]	; (b5e8 <VUnmarshalArgs+0x2b0>)
    b4c8:	4b48      	ldr	r3, [pc, #288]	; (b5ec <VUnmarshalArgs+0x2b4>)
    b4ca:	4798      	blx	r3
    b4cc:	e067      	b.n	b59e <VUnmarshalArgs+0x266>
            status = AJ_ERR_UNEXPECTED;
            break;
        }
		//!!!!!!!!!!
        status = AJ_UnmarshalArg(msg, &arg);
    b4ce:	9801      	ldr	r0, [sp, #4]
    b4d0:	a908      	add	r1, sp, #32
    b4d2:	4b3e      	ldr	r3, [pc, #248]	; (b5cc <VUnmarshalArgs+0x294>)
    b4d4:	4798      	blx	r3
    b4d6:	4680      	mov	r8, r0
		//printf("VUnmarshalArgs(): AJ_UnmarshalArg status = %s\n",AJ_StatusText(status) );

        if (status != AJ_OK)
    b4d8:	2800      	cmp	r0, #0
    b4da:	d160      	bne.n	b59e <VUnmarshalArgs+0x266>
		{
            break;
        }
        if (arg.typeId != typeId) 
    b4dc:	ab08      	add	r3, sp, #32
    b4de:	781b      	ldrb	r3, [r3, #0]
    b4e0:	42a3      	cmp	r3, r4
    b4e2:	d00d      	beq.n	b500 <VUnmarshalArgs+0x1c8>
		{
            AJ_ErrPrintf(("AJ_UnmarshalArgs(): AJ_ERR_UNMARSHAL\n"));
    b4e4:	2001      	movs	r0, #1
    b4e6:	493d      	ldr	r1, [pc, #244]	; (b5dc <VUnmarshalArgs+0x2a4>)
    b4e8:	22d8      	movs	r2, #216	; 0xd8
    b4ea:	00d2      	lsls	r2, r2, #3
    b4ec:	4b3d      	ldr	r3, [pc, #244]	; (b5e4 <VUnmarshalArgs+0x2ac>)
    b4ee:	4798      	blx	r3
            status = AJ_ERR_UNMARSHAL;
    b4f0:	2309      	movs	r3, #9
    b4f2:	4698      	mov	r8, r3
		{
            break;
        }
        if (arg.typeId != typeId) 
		{
            AJ_ErrPrintf(("AJ_UnmarshalArgs(): AJ_ERR_UNMARSHAL\n"));
    b4f4:	2800      	cmp	r0, #0
    b4f6:	d052      	beq.n	b59e <VUnmarshalArgs+0x266>
    b4f8:	483d      	ldr	r0, [pc, #244]	; (b5f0 <VUnmarshalArgs+0x2b8>)
    b4fa:	4b3c      	ldr	r3, [pc, #240]	; (b5ec <VUnmarshalArgs+0x2b4>)
    b4fc:	4798      	blx	r3
    b4fe:	e04e      	b.n	b59e <VUnmarshalArgs+0x266>
            status = AJ_ERR_UNMARSHAL;
            break;
        }
        val = va_arg(argp, void*);
    b500:	9a03      	ldr	r2, [sp, #12]
    b502:	1d11      	adds	r1, r2, #4
    b504:	9103      	str	r1, [sp, #12]
    b506:	6811      	ldr	r1, [r2, #0]
        if (IsScalarType(typeId)) 
    b508:	2d01      	cmp	r5, #1
    b50a:	d805      	bhi.n	b518 <VUnmarshalArgs+0x1e0>
    b50c:	3b28      	subs	r3, #40	; 0x28
    b50e:	4a27      	ldr	r2, [pc, #156]	; (b5ac <VUnmarshalArgs+0x274>)
    b510:	5cd2      	ldrb	r2, [r2, r3]
    b512:	06d2      	lsls	r2, r2, #27
    b514:	d40b      	bmi.n	b52e <VUnmarshalArgs+0x1f6>
    b516:	e02d      	b.n	b574 <VUnmarshalArgs+0x23c>
    b518:	1c1a      	adds	r2, r3, #0
    b51a:	3a61      	subs	r2, #97	; 0x61
    b51c:	2a1c      	cmp	r2, #28
    b51e:	d829      	bhi.n	b574 <VUnmarshalArgs+0x23c>
    b520:	4a22      	ldr	r2, [pc, #136]	; (b5ac <VUnmarshalArgs+0x274>)
    b522:	18d2      	adds	r2, r2, r3
    b524:	3a5f      	subs	r2, #95	; 0x5f
    b526:	7812      	ldrb	r2, [r2, #0]
    b528:	06d2      	lsls	r2, r2, #27
    b52a:	d436      	bmi.n	b59a <VUnmarshalArgs+0x262>
    b52c:	e022      	b.n	b574 <VUnmarshalArgs+0x23c>
		{
            switch (SizeOfType(typeId)) 
    b52e:	4a1f      	ldr	r2, [pc, #124]	; (b5ac <VUnmarshalArgs+0x274>)
    b530:	5cd3      	ldrb	r3, [r2, r3]
    b532:	220f      	movs	r2, #15
    b534:	4013      	ands	r3, r2
    b536:	2b02      	cmp	r3, #2
    b538:	d00e      	beq.n	b558 <VUnmarshalArgs+0x220>
    b53a:	b2da      	uxtb	r2, r3
    b53c:	2a02      	cmp	r2, #2
    b53e:	d802      	bhi.n	b546 <VUnmarshalArgs+0x20e>
    b540:	2b01      	cmp	r3, #1
    b542:	d005      	beq.n	b550 <VUnmarshalArgs+0x218>
    b544:	e018      	b.n	b578 <VUnmarshalArgs+0x240>
    b546:	2b04      	cmp	r3, #4
    b548:	d00a      	beq.n	b560 <VUnmarshalArgs+0x228>
    b54a:	2b08      	cmp	r3, #8
    b54c:	d00c      	beq.n	b568 <VUnmarshalArgs+0x230>
    b54e:	e013      	b.n	b578 <VUnmarshalArgs+0x240>
			{
            case 1:
                *((uint8_t*)val) = *arg.val.v_byte;
    b550:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b552:	781b      	ldrb	r3, [r3, #0]
    b554:	700b      	strb	r3, [r1, #0]
                break;
    b556:	e00f      	b.n	b578 <VUnmarshalArgs+0x240>

            case 2:
                *((uint16_t*)val) = *arg.val.v_uint16;
    b558:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b55a:	881b      	ldrh	r3, [r3, #0]
    b55c:	800b      	strh	r3, [r1, #0]
                break;
    b55e:	e00b      	b.n	b578 <VUnmarshalArgs+0x240>

            case 4:
                *((uint32_t*)val) = *arg.val.v_uint32;
    b560:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b562:	681b      	ldr	r3, [r3, #0]
    b564:	600b      	str	r3, [r1, #0]
                break;
    b566:	e007      	b.n	b578 <VUnmarshalArgs+0x240>

            case 8:
                *((uint64_t*)val) = *arg.val.v_uint64;
    b568:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b56a:	685c      	ldr	r4, [r3, #4]
    b56c:	681b      	ldr	r3, [r3, #0]
    b56e:	600b      	str	r3, [r1, #0]
    b570:	604c      	str	r4, [r1, #4]
                break;
    b572:	e001      	b.n	b578 <VUnmarshalArgs+0x240>
            }
        }
		else 
		{
            *((const char**)val) = arg.val.v_string;
    b574:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b576:	600b      	str	r3, [r1, #0]

    __va_copy(argp, *argpp);

    container.typeId = AJ_ARG_INVALID;

    while (**sig)
    b578:	683b      	ldr	r3, [r7, #0]
    b57a:	781a      	ldrb	r2, [r3, #0]
    b57c:	2a00      	cmp	r2, #0
    b57e:	d000      	beq.n	b582 <VUnmarshalArgs+0x24a>
    b580:	e6e7      	b.n	b352 <VUnmarshalArgs+0x1a>
    b582:	2300      	movs	r3, #0
    b584:	4698      	mov	r8, r3
    b586:	e00a      	b.n	b59e <VUnmarshalArgs+0x266>
                            break;
                        }
                    } 
					else 
					{
                        status = AJ_ERR_UNMARSHAL;
    b588:	2309      	movs	r3, #9
    b58a:	4698      	mov	r8, r3
    b58c:	e007      	b.n	b59e <VUnmarshalArgs+0x266>
    b58e:	2300      	movs	r3, #0
    b590:	4698      	mov	r8, r3
    b592:	e004      	b.n	b59e <VUnmarshalArgs+0x266>
    b594:	2300      	movs	r3, #0
    b596:	4698      	mov	r8, r3
    b598:	e001      	b.n	b59e <VUnmarshalArgs+0x266>
            break;
        }
        val = va_arg(argp, void*);
        if (IsScalarType(typeId)) 
		{
            switch (SizeOfType(typeId)) 
    b59a:	3b5f      	subs	r3, #95	; 0x5f
    b59c:	e7c7      	b.n	b52e <VUnmarshalArgs+0x1f6>
		else 
		{
            *((const char**)val) = arg.val.v_string;
        }
    }
    __va_copy(*argpp, argp);
    b59e:	9b03      	ldr	r3, [sp, #12]
    b5a0:	6033      	str	r3, [r6, #0]
    return status;
}
    b5a2:	4640      	mov	r0, r8
    b5a4:	b00c      	add	sp, #48	; 0x30
    b5a6:	bc04      	pop	{r2}
    b5a8:	4690      	mov	r8, r2
    b5aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b5ac:	0001dac0 	.word	0x0001dac0
    b5b0:	0000a951 	.word	0x0000a951
    b5b4:	000063c5 	.word	0x000063c5
    b5b8:	0001d814 	.word	0x0001d814
    b5bc:	00016e3d 	.word	0x00016e3d
    b5c0:	0001d84c 	.word	0x0001d84c
    b5c4:	0000a9d9 	.word	0x0000a9d9
    b5c8:	0001d87c 	.word	0x0001d87c
    b5cc:	0000a855 	.word	0x0000a855
    b5d0:	0000b319 	.word	0x0000b319
    b5d4:	0001d8b8 	.word	0x0001d8b8
    b5d8:	00017137 	.word	0x00017137
    b5dc:	0001d2d8 	.word	0x0001d2d8
    b5e0:	000006b2 	.word	0x000006b2
    b5e4:	0000636d 	.word	0x0000636d
    b5e8:	0001d8ec 	.word	0x0001d8ec
    b5ec:	00016f5d 	.word	0x00016f5d
    b5f0:	0001d914 	.word	0x0001d914

0000b5f4 <AJ_UnmarshalArgs>:

AJ_Status AJ_UnmarshalArgs(AJ_Message* msg, const char* sig, ...)
{
    b5f4:	b40e      	push	{r1, r2, r3}
    b5f6:	b500      	push	{lr}
    b5f8:	b082      	sub	sp, #8
    AJ_Status status;
    va_list argp;

    va_start(argp, sig);
    b5fa:	ab04      	add	r3, sp, #16
    b5fc:	9301      	str	r3, [sp, #4]
    status = VUnmarshalArgs(msg, &sig, &argp);
    b5fe:	a903      	add	r1, sp, #12
    b600:	aa01      	add	r2, sp, #4
    b602:	4b03      	ldr	r3, [pc, #12]	; (b610 <AJ_UnmarshalArgs+0x1c>)
    b604:	4798      	blx	r3
    va_end(argp);

    return status;
}
    b606:	b002      	add	sp, #8
    b608:	bc08      	pop	{r3}
    b60a:	b003      	add	sp, #12
    b60c:	4718      	bx	r3
    b60e:	46c0      	nop			; (mov r8, r8)
    b610:	0000b339 	.word	0x0000b339

0000b614 <AJ_MarshalArg>:
    }
    return status;
}

AJ_Status AJ_MarshalArg(AJ_Message* msg, AJ_Arg* arg)
{
    b614:	b5f0      	push	{r4, r5, r6, r7, lr}
    b616:	b083      	sub	sp, #12
    b618:	1c04      	adds	r4, r0, #0
    b61a:	1c0a      	adds	r2, r1, #0
    AJ_Status status;
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    b61c:	6b06      	ldr	r6, [r0, #48]	; 0x30
    uint8_t* argStart = ioBuf->writePtr;
    b61e:	6a77      	ldr	r7, [r6, #36]	; 0x24

    if (msg->varOffset) 
    b620:	232d      	movs	r3, #45	; 0x2d
    b622:	5cc3      	ldrb	r3, [r0, r3]
    b624:	2b00      	cmp	r3, #0
    b626:	d009      	beq.n	b63c <AJ_MarshalArg+0x28>
	{
        // Marshaling a variant - get the signature from the I/O buffer
        const char* sig = (const char*)(argStart - msg->varOffset);
    b628:	1afb      	subs	r3, r7, r3
    b62a:	9301      	str	r3, [sp, #4]
        msg->varOffset = 0;
    b62c:	2100      	movs	r1, #0
    b62e:	232d      	movs	r3, #45	; 0x2d
    b630:	54c1      	strb	r1, [r0, r3]
        status = Marshal(msg, &sig, arg);
    b632:	a901      	add	r1, sp, #4
    b634:	4b1d      	ldr	r3, [pc, #116]	; (b6ac <AJ_MarshalArg+0x98>)
    b636:	4798      	blx	r3
    b638:	1c05      	adds	r5, r0, #0
    b63a:	e028      	b.n	b68e <AJ_MarshalArg+0x7a>
//		 printf("AJ_MarshalArg 1 status= %s\n",AJ_StatusText(status));
    } 
	else if (msg->outer) 
    b63c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b63e:	2b00      	cmp	r3, #0
    b640:	d011      	beq.n	b666 <AJ_MarshalArg+0x52>
	{
        // Marshaling a component of a container use the container's signature
        const char* sig = msg->outer->sigPtr;
    b642:	689b      	ldr	r3, [r3, #8]
    b644:	9301      	str	r3, [sp, #4]
        if (!*sig) 
    b646:	781b      	ldrb	r3, [r3, #0]
    b648:	2b00      	cmp	r3, #0
    b64a:	d101      	bne.n	b650 <AJ_MarshalArg+0x3c>
		{
  //          printf("AJ_MarshalArg(): AJ_ERR_END_OF_DATA\n");
            return AJ_ERR_END_OF_DATA;
    b64c:	200a      	movs	r0, #10
    b64e:	e02b      	b.n	b6a8 <AJ_MarshalArg+0x94>
        }
        status = Marshal(msg, &sig, arg);
    b650:	a901      	add	r1, sp, #4
    b652:	4b16      	ldr	r3, [pc, #88]	; (b6ac <AJ_MarshalArg+0x98>)
    b654:	4798      	blx	r3
    b656:	1c05      	adds	r5, r0, #0
	//	printf("AJ_MarshalArg 2 status= %s\n",AJ_StatusText(status));
        // Only advance the signature for struct elements
        if (msg->outer->typeId != AJ_ARG_ARRAY) 
    b658:	6b63      	ldr	r3, [r4, #52]	; 0x34
    b65a:	781a      	ldrb	r2, [r3, #0]
    b65c:	2a61      	cmp	r2, #97	; 0x61
    b65e:	d016      	beq.n	b68e <AJ_MarshalArg+0x7a>
		{
            msg->outer->sigPtr = sig;
    b660:	9a01      	ldr	r2, [sp, #4]
    b662:	609a      	str	r2, [r3, #8]
    b664:	e013      	b.n	b68e <AJ_MarshalArg+0x7a>
        }
    } 
	else
	{
        const char* sig = msg->signature + msg->sigOffset;
    b666:	232c      	movs	r3, #44	; 0x2c
    b668:	5cc3      	ldrb	r3, [r0, r3]
    b66a:	69c1      	ldr	r1, [r0, #28]
    b66c:	468c      	mov	ip, r1
    b66e:	4463      	add	r3, ip
    b670:	9301      	str	r3, [sp, #4]
        //Marshalling anything else use the message signature
        if (!*sig) 
    b672:	781b      	ldrb	r3, [r3, #0]
    b674:	2b00      	cmp	r3, #0
    b676:	d101      	bne.n	b67c <AJ_MarshalArg+0x68>
		{
   //          printf("AJ_MarshalArg(): AJ_ERR_END_OF_DATA\n");
            return AJ_ERR_END_OF_DATA;
    b678:	200a      	movs	r0, #10
    b67a:	e015      	b.n	b6a8 <AJ_MarshalArg+0x94>
        }
        status = Marshal(msg, &sig, arg);
    b67c:	a901      	add	r1, sp, #4
    b67e:	4b0b      	ldr	r3, [pc, #44]	; (b6ac <AJ_MarshalArg+0x98>)
    b680:	4798      	blx	r3
    b682:	1c05      	adds	r5, r0, #0
	//	printf("AJ_MarshalArg 3 status= %s\n",AJ_StatusText(status));
        msg->sigOffset = (uint8_t)(sig - msg->signature);
    b684:	9b01      	ldr	r3, [sp, #4]
    b686:	69e2      	ldr	r2, [r4, #28]
    b688:	1a9b      	subs	r3, r3, r2
    b68a:	222c      	movs	r2, #44	; 0x2c
    b68c:	54a3      	strb	r3, [r4, r2]
    }
    if (status == AJ_OK) 
    b68e:	2d00      	cmp	r5, #0
    b690:	d106      	bne.n	b6a0 <AJ_MarshalArg+0x8c>
	{
        msg->bodyBytes += (uint16_t)(ioBuf->writePtr - argStart);
    b692:	6a73      	ldr	r3, [r6, #36]	; 0x24
    b694:	1bdf      	subs	r7, r3, r7
    b696:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    b698:	18ff      	adds	r7, r7, r3
    b69a:	85e7      	strh	r7, [r4, #46]	; 0x2e
    }
	else
	{
        AJ_ReleaseReplyContext(msg);
    }
    return status;
    b69c:	2000      	movs	r0, #0
    b69e:	e003      	b.n	b6a8 <AJ_MarshalArg+0x94>
	{
        msg->bodyBytes += (uint16_t)(ioBuf->writePtr - argStart);
    }
	else
	{
        AJ_ReleaseReplyContext(msg);
    b6a0:	1c20      	adds	r0, r4, #0
    b6a2:	4b03      	ldr	r3, [pc, #12]	; (b6b0 <AJ_MarshalArg+0x9c>)
    b6a4:	4798      	blx	r3
    }
    return status;
    b6a6:	1c28      	adds	r0, r5, #0
}
    b6a8:	b003      	add	sp, #12
    b6aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b6ac:	00009fbd 	.word	0x00009fbd
    b6b0:	00008a0d 	.word	0x00008a0d

0000b6b4 <AJ_InitArg>:

AJ_Arg* AJ_InitArg(AJ_Arg* arg, uint8_t typeId, uint8_t flags, const void* val, size_t len)
{
    b6b4:	b538      	push	{r3, r4, r5, lr}
    if (!IsBasicType(typeId))
    b6b6:	1c0c      	adds	r4, r1, #0
    b6b8:	3c28      	subs	r4, #40	; 0x28
    b6ba:	2c01      	cmp	r4, #1
    b6bc:	d801      	bhi.n	b6c2 <AJ_InitArg+0xe>
    b6be:	1c25      	adds	r5, r4, #0
    b6c0:	e006      	b.n	b6d0 <AJ_InitArg+0x1c>
    b6c2:	251e      	movs	r5, #30
    b6c4:	1c0c      	adds	r4, r1, #0
    b6c6:	3c61      	subs	r4, #97	; 0x61
    b6c8:	2c1c      	cmp	r4, #28
    b6ca:	d801      	bhi.n	b6d0 <AJ_InitArg+0x1c>
    b6cc:	1c0d      	adds	r5, r1, #0
    b6ce:	3d5f      	subs	r5, #95	; 0x5f
    b6d0:	4c09      	ldr	r4, [pc, #36]	; (b6f8 <AJ_InitArg+0x44>)
    b6d2:	5d64      	ldrb	r4, [r4, r5]
    b6d4:	2550      	movs	r5, #80	; 0x50
    b6d6:	4225      	tst	r5, r4
    b6d8:	d105      	bne.n	b6e6 <AJ_InitArg+0x32>
	{
        memset(arg, 0, sizeof(AJ_Arg));
    b6da:	2100      	movs	r1, #0
    b6dc:	2210      	movs	r2, #16
    b6de:	4b07      	ldr	r3, [pc, #28]	; (b6fc <AJ_InitArg+0x48>)
    b6e0:	4798      	blx	r3
        return NULL;
    b6e2:	2000      	movs	r0, #0
    b6e4:	e007      	b.n	b6f6 <AJ_InitArg+0x42>
    }
	else 
	{
        arg->typeId = typeId;
    b6e6:	7001      	strb	r1, [r0, #0]
        arg->flags = flags;
    b6e8:	7042      	strb	r2, [r0, #1]
        arg->len = (uint16_t)len;
    b6ea:	9a04      	ldr	r2, [sp, #16]
    b6ec:	8042      	strh	r2, [r0, #2]
        arg->val.v_data = (void*)val;
    b6ee:	6043      	str	r3, [r0, #4]
        arg->sigPtr = NULL;
    b6f0:	2300      	movs	r3, #0
    b6f2:	6083      	str	r3, [r0, #8]
        arg->container = NULL;
    b6f4:	60c3      	str	r3, [r0, #12]
        return arg;
    }
}
    b6f6:	bd38      	pop	{r3, r4, r5, pc}
    b6f8:	0001dac0 	.word	0x0001dac0
    b6fc:	00016773 	.word	0x00016773

0000b700 <AJ_DeliverMsgPartial>:

    return status;
}

AJ_Status AJ_DeliverMsgPartial(AJ_Message* msg, uint32_t bytesRemaining)
{
    b700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b702:	1c04      	adds	r4, r0, #0
    b704:	1c0d      	adds	r5, r1, #0
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    b706:	6b01      	ldr	r1, [r0, #48]	; 0x30
    uint8_t typeId = msg->signature[msg->sigOffset];
    b708:	232c      	movs	r3, #44	; 0x2c
    b70a:	5cc3      	ldrb	r3, [r0, r3]
    b70c:	69c2      	ldr	r2, [r0, #28]
    b70e:	5cd0      	ldrb	r0, [r2, r3]
    size_t pad;

    AJ_ASSERT(!msg->outer);
    b710:	6b63      	ldr	r3, [r4, #52]	; 0x34
    b712:	2b00      	cmp	r3, #0
    b714:	d005      	beq.n	b722 <AJ_DeliverMsgPartial+0x22>
    b716:	4831      	ldr	r0, [pc, #196]	; (b7dc <AJ_DeliverMsgPartial+0xdc>)
    b718:	4931      	ldr	r1, [pc, #196]	; (b7e0 <AJ_DeliverMsgPartial+0xe0>)
    b71a:	4a32      	ldr	r2, [pc, #200]	; (b7e4 <AJ_DeliverMsgPartial+0xe4>)
    b71c:	4b32      	ldr	r3, [pc, #200]	; (b7e8 <AJ_DeliverMsgPartial+0xe8>)
    b71e:	4c33      	ldr	r4, [pc, #204]	; (b7ec <AJ_DeliverMsgPartial+0xec>)
    b720:	47a0      	blx	r4

    if (!msg->hdr || !bytesRemaining) 
    b722:	6863      	ldr	r3, [r4, #4]
    b724:	2b00      	cmp	r3, #0
    b726:	d001      	beq.n	b72c <AJ_DeliverMsgPartial+0x2c>
    b728:	2d00      	cmp	r5, #0
    b72a:	d10c      	bne.n	b746 <AJ_DeliverMsgPartial+0x46>
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_UNEXPECTED\n"));
    b72c:	2001      	movs	r0, #1
    b72e:	492b      	ldr	r1, [pc, #172]	; (b7dc <AJ_DeliverMsgPartial+0xdc>)
    b730:	4a2f      	ldr	r2, [pc, #188]	; (b7f0 <AJ_DeliverMsgPartial+0xf0>)
    b732:	4b30      	ldr	r3, [pc, #192]	; (b7f4 <AJ_DeliverMsgPartial+0xf4>)
    b734:	4798      	blx	r3
        return AJ_ERR_UNEXPECTED;
    b736:	2302      	movs	r3, #2

    AJ_ASSERT(!msg->outer);

    if (!msg->hdr || !bytesRemaining) 
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_UNEXPECTED\n"));
    b738:	2800      	cmp	r0, #0
    b73a:	d04d      	beq.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    b73c:	482e      	ldr	r0, [pc, #184]	; (b7f8 <AJ_DeliverMsgPartial+0xf8>)
    b73e:	4b2f      	ldr	r3, [pc, #188]	; (b7fc <AJ_DeliverMsgPartial+0xfc>)
    b740:	4798      	blx	r3
        return AJ_ERR_UNEXPECTED;
    b742:	2302      	movs	r3, #2
    b744:	e048      	b.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    }
    // Partial delivery not currently supported for messages that must be encrypted.
    if (msg->hdr->flags & AJ_FLAG_ENCRYPTED) 
    b746:	789b      	ldrb	r3, [r3, #2]
    b748:	2b7f      	cmp	r3, #127	; 0x7f
    b74a:	d90c      	bls.n	b766 <AJ_DeliverMsgPartial+0x66>
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_SECURITY\n"));
    b74c:	2001      	movs	r0, #1
    b74e:	4923      	ldr	r1, [pc, #140]	; (b7dc <AJ_DeliverMsgPartial+0xdc>)
    b750:	4a2b      	ldr	r2, [pc, #172]	; (b800 <AJ_DeliverMsgPartial+0x100>)
    b752:	4b28      	ldr	r3, [pc, #160]	; (b7f4 <AJ_DeliverMsgPartial+0xf4>)
    b754:	4798      	blx	r3
        return AJ_ERR_SECURITY;
    b756:	230d      	movs	r3, #13
        return AJ_ERR_UNEXPECTED;
    }
    // Partial delivery not currently supported for messages that must be encrypted.
    if (msg->hdr->flags & AJ_FLAG_ENCRYPTED) 
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_SECURITY\n"));
    b758:	2800      	cmp	r0, #0
    b75a:	d03d      	beq.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    b75c:	4829      	ldr	r0, [pc, #164]	; (b804 <AJ_DeliverMsgPartial+0x104>)
    b75e:	4b27      	ldr	r3, [pc, #156]	; (b7fc <AJ_DeliverMsgPartial+0xfc>)
    b760:	4798      	blx	r3
        return AJ_ERR_SECURITY;
    b762:	230d      	movs	r3, #13
    b764:	e038      	b.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    }
    // There must be arguments to marshal
    if (!typeId) 
    b766:	2800      	cmp	r0, #0
    b768:	d10c      	bne.n	b784 <AJ_DeliverMsgPartial+0x84>
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_SIGNATURE\n"));
    b76a:	3001      	adds	r0, #1
    b76c:	491b      	ldr	r1, [pc, #108]	; (b7dc <AJ_DeliverMsgPartial+0xdc>)
    b76e:	4a26      	ldr	r2, [pc, #152]	; (b808 <AJ_DeliverMsgPartial+0x108>)
    b770:	4b20      	ldr	r3, [pc, #128]	; (b7f4 <AJ_DeliverMsgPartial+0xf4>)
    b772:	4798      	blx	r3
        return AJ_ERR_SIGNATURE;
    b774:	2311      	movs	r3, #17
        return AJ_ERR_SECURITY;
    }
    // There must be arguments to marshal
    if (!typeId) 
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_SIGNATURE\n"));
    b776:	2800      	cmp	r0, #0
    b778:	d02e      	beq.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    b77a:	4824      	ldr	r0, [pc, #144]	; (b80c <AJ_DeliverMsgPartial+0x10c>)
    b77c:	4b1f      	ldr	r3, [pc, #124]	; (b7fc <AJ_DeliverMsgPartial+0xfc>)
    b77e:	4798      	blx	r3
        return AJ_ERR_SIGNATURE;
    b780:	2311      	movs	r3, #17
    b782:	e029      	b.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    return status;
}

AJ_Status AJ_DeliverMsgPartial(AJ_Message* msg, uint32_t bytesRemaining)
{
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    b784:	3118      	adds	r1, #24
	{
        AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_ERR_SIGNATURE\n"));
        return AJ_ERR_SIGNATURE;
    }
    // Pad to the start of the argument.
    pad = PadForType(typeId, ioBuf);
    b786:	4b22      	ldr	r3, [pc, #136]	; (b810 <AJ_DeliverMsgPartial+0x110>)
    b788:	4798      	blx	r3
    b78a:	1e07      	subs	r7, r0, #0
    if (pad) 
    b78c:	d018      	beq.n	b7c0 <AJ_DeliverMsgPartial+0xc0>
	{
        AJ_Status status = WritePad(msg, pad);
    b78e:	1c20      	adds	r0, r4, #0
    b790:	2100      	movs	r1, #0
    b792:	2200      	movs	r2, #0
    b794:	1c3b      	adds	r3, r7, #0
    b796:	4e1f      	ldr	r6, [pc, #124]	; (b814 <AJ_DeliverMsgPartial+0x114>)
    b798:	47b0      	blx	r6
    b79a:	1e06      	subs	r6, r0, #0
        if (status != AJ_OK) 
    b79c:	d010      	beq.n	b7c0 <AJ_DeliverMsgPartial+0xc0>
		{
            AJ_ErrPrintf(("AJ_DeliverMsgPartial(): status=%s\n", AJ_StatusText(status)));
    b79e:	2001      	movs	r0, #1
    b7a0:	490e      	ldr	r1, [pc, #56]	; (b7dc <AJ_DeliverMsgPartial+0xdc>)
    b7a2:	4a1d      	ldr	r2, [pc, #116]	; (b818 <AJ_DeliverMsgPartial+0x118>)
    b7a4:	4b13      	ldr	r3, [pc, #76]	; (b7f4 <AJ_DeliverMsgPartial+0xf4>)
    b7a6:	4798      	blx	r3
            return status;
    b7a8:	1c33      	adds	r3, r6, #0
    if (pad) 
	{
        AJ_Status status = WritePad(msg, pad);
        if (status != AJ_OK) 
		{
            AJ_ErrPrintf(("AJ_DeliverMsgPartial(): status=%s\n", AJ_StatusText(status)));
    b7aa:	2800      	cmp	r0, #0
    b7ac:	d014      	beq.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
    b7ae:	1c30      	adds	r0, r6, #0
    b7b0:	4b1a      	ldr	r3, [pc, #104]	; (b81c <AJ_DeliverMsgPartial+0x11c>)
    b7b2:	4798      	blx	r3
    b7b4:	1c01      	adds	r1, r0, #0
    b7b6:	481a      	ldr	r0, [pc, #104]	; (b820 <AJ_DeliverMsgPartial+0x120>)
    b7b8:	4b1a      	ldr	r3, [pc, #104]	; (b824 <AJ_DeliverMsgPartial+0x124>)
    b7ba:	4798      	blx	r3
            return status;
    b7bc:	1c33      	adds	r3, r6, #0
    b7be:	e00b      	b.n	b7d8 <AJ_DeliverMsgPartial+0xd8>
        }
    }
    // Set the body length in the header buffer.
    msg->hdr->bodyLen = (uint32_t)(msg->bodyBytes + pad + bytesRemaining);
    b7c0:	6862      	ldr	r2, [r4, #4]
    b7c2:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    b7c4:	18eb      	adds	r3, r5, r3
    b7c6:	19df      	adds	r7, r3, r7
    b7c8:	6057      	str	r7, [r2, #4]
    AJ_DumpMsg("SENDING(partial)", msg, FALSE);
    /*
        * The buffer space occupied by the header is going to be overwritten
        *  so the header is going to become invalid.
     */
    msg->hdr = NULL;
    b7ca:	2300      	movs	r3, #0
    b7cc:	6063      	str	r3, [r4, #4]
    // From now on we are going to count down the remaining body bytes
    msg->bodyBytes = (uint32_t)bytesRemaining;
    b7ce:	85e5      	strh	r5, [r4, #46]	; 0x2e
    // Standard signature matching is now meaningless
    msg->signature = "";
    b7d0:	4a15      	ldr	r2, [pc, #84]	; (b828 <AJ_DeliverMsgPartial+0x128>)
    b7d2:	61e2      	str	r2, [r4, #28]
    msg->sigOffset = 0;
    b7d4:	222c      	movs	r2, #44	; 0x2c
    b7d6:	54a3      	strb	r3, [r4, r2]
//	printf("msg->bodyBytes = %d\n", msg->bodyBytes);

 //   AJ_ErrPrintf(("AJ_DeliverMsgPartial(): AJ_OK\n"));
    return AJ_OK;
}
    b7d8:	1c18      	adds	r0, r3, #0
    b7da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b7dc:	0001d2d8 	.word	0x0001d2d8
    b7e0:	00000984 	.word	0x00000984
    b7e4:	0001d2a8 	.word	0x0001d2a8
    b7e8:	0001d93c 	.word	0x0001d93c
    b7ec:	00016629 	.word	0x00016629
    b7f0:	00000988 	.word	0x00000988
    b7f4:	0000636d 	.word	0x0000636d
    b7f8:	0001d948 	.word	0x0001d948
    b7fc:	00016f5d 	.word	0x00016f5d
    b800:	0000098e 	.word	0x0000098e
    b804:	0001d974 	.word	0x0001d974
    b808:	00000994 	.word	0x00000994
    b80c:	0001d99c 	.word	0x0001d99c
    b810:	000099d9 	.word	0x000099d9
    b814:	00009b45 	.word	0x00009b45
    b818:	0000099e 	.word	0x0000099e
    b81c:	000063c5 	.word	0x000063c5
    b820:	0001d9c8 	.word	0x0001d9c8
    b824:	00016e3d 	.word	0x00016e3d
    b828:	0001d368 	.word	0x0001d368

0000b82c <AJ_MarshalRaw>:

AJ_Status AJ_MarshalRaw(AJ_Message* msg, const void* data, size_t len)
{
    b82c:	b510      	push	{r4, lr}
    if (msg->hdr) 
    b82e:	6843      	ldr	r3, [r0, #4]
    b830:	2b00      	cmp	r3, #0
    b832:	d00c      	beq.n	b84e <AJ_MarshalRaw+0x22>
	{
        AJ_ErrPrintf(("AJ_MarshalRaw(): AJ_ERR_SECURITY\n"));
    b834:	2001      	movs	r0, #1
    b836:	4912      	ldr	r1, [pc, #72]	; (b880 <AJ_MarshalRaw+0x54>)
    b838:	4a12      	ldr	r2, [pc, #72]	; (b884 <AJ_MarshalRaw+0x58>)
    b83a:	4b13      	ldr	r3, [pc, #76]	; (b888 <AJ_MarshalRaw+0x5c>)
    b83c:	4798      	blx	r3
        return AJ_ERR_UNEXPECTED;
    b83e:	2302      	movs	r3, #2

AJ_Status AJ_MarshalRaw(AJ_Message* msg, const void* data, size_t len)
{
    if (msg->hdr) 
	{
        AJ_ErrPrintf(("AJ_MarshalRaw(): AJ_ERR_SECURITY\n"));
    b840:	2800      	cmp	r0, #0
    b842:	d01a      	beq.n	b87a <AJ_MarshalRaw+0x4e>
    b844:	4811      	ldr	r0, [pc, #68]	; (b88c <AJ_MarshalRaw+0x60>)
    b846:	4b12      	ldr	r3, [pc, #72]	; (b890 <AJ_MarshalRaw+0x64>)
    b848:	4798      	blx	r3
        return AJ_ERR_UNEXPECTED;
    b84a:	2302      	movs	r3, #2
    b84c:	e015      	b.n	b87a <AJ_MarshalRaw+0x4e>
    }
    // It is a fatal error to write too many bytes
    if (len > msg->bodyBytes) 
    b84e:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
    b850:	4293      	cmp	r3, r2
    b852:	d20c      	bcs.n	b86e <AJ_MarshalRaw+0x42>
	{
        AJ_ErrPrintf(("AJ_MarshalRaw(): AJ_ERR_WRITE\n"));
    b854:	2001      	movs	r0, #1
    b856:	490a      	ldr	r1, [pc, #40]	; (b880 <AJ_MarshalRaw+0x54>)
    b858:	4a0e      	ldr	r2, [pc, #56]	; (b894 <AJ_MarshalRaw+0x68>)
    b85a:	4b0b      	ldr	r3, [pc, #44]	; (b888 <AJ_MarshalRaw+0x5c>)
    b85c:	4798      	blx	r3
        return AJ_ERR_WRITE;
    b85e:	2306      	movs	r3, #6
        return AJ_ERR_UNEXPECTED;
    }
    // It is a fatal error to write too many bytes
    if (len > msg->bodyBytes) 
	{
        AJ_ErrPrintf(("AJ_MarshalRaw(): AJ_ERR_WRITE\n"));
    b860:	2800      	cmp	r0, #0
    b862:	d00a      	beq.n	b87a <AJ_MarshalRaw+0x4e>
    b864:	480c      	ldr	r0, [pc, #48]	; (b898 <AJ_MarshalRaw+0x6c>)
    b866:	4b0a      	ldr	r3, [pc, #40]	; (b890 <AJ_MarshalRaw+0x64>)
    b868:	4798      	blx	r3
        return AJ_ERR_WRITE;
    b86a:	2306      	movs	r3, #6
    b86c:	e005      	b.n	b87a <AJ_MarshalRaw+0x4e>
    }
    msg->bodyBytes -= (uint32_t)len;
    b86e:	1a9b      	subs	r3, r3, r2
    b870:	85c3      	strh	r3, [r0, #46]	; 0x2e
   // AJ_ErrPrintf(("AJ_MarshalRaw(): WriteBytes len= %d\n",len));
    return WriteBytes(msg, data, len, 0);
    b872:	2300      	movs	r3, #0
    b874:	4c09      	ldr	r4, [pc, #36]	; (b89c <AJ_MarshalRaw+0x70>)
    b876:	47a0      	blx	r4
    b878:	1c03      	adds	r3, r0, #0
}
    b87a:	1c18      	adds	r0, r3, #0
    b87c:	bd10      	pop	{r4, pc}
    b87e:	46c0      	nop			; (mov r8, r8)
    b880:	0001d2d8 	.word	0x0001d2d8
    b884:	000009b9 	.word	0x000009b9
    b888:	0000636d 	.word	0x0000636d
    b88c:	0001d9ec 	.word	0x0001d9ec
    b890:	00016f5d 	.word	0x00016f5d
    b894:	000009bf 	.word	0x000009bf
    b898:	0001da10 	.word	0x0001da10
    b89c:	00009b45 	.word	0x00009b45

0000b8a0 <AJ_MarshalContainer>:

AJ_Status AJ_MarshalContainer(AJ_Message* msg, AJ_Arg* arg, uint8_t typeId)
{
    b8a0:	b538      	push	{r3, r4, r5, lr}
    b8a2:	1c05      	adds	r5, r0, #0
    b8a4:	1e0c      	subs	r4, r1, #0
static AJ_Message* currentMsg = NULL;
#endif

static void InitArg(AJ_Arg* arg, uint8_t typeId, const void* val)
{
    if (arg) 
    b8a6:	d006      	beq.n	b8b6 <AJ_MarshalContainer+0x16>
	{
        arg->typeId = typeId;
    b8a8:	700a      	strb	r2, [r1, #0]
        arg->flags = 0;
    b8aa:	2300      	movs	r3, #0
    b8ac:	704b      	strb	r3, [r1, #1]
        arg->len = 0;
    b8ae:	804b      	strh	r3, [r1, #2]
        arg->val.v_data = (void*)val;
    b8b0:	604b      	str	r3, [r1, #4]
        arg->sigPtr = NULL;
    b8b2:	608b      	str	r3, [r1, #8]
        arg->container = NULL;
    b8b4:	60cb      	str	r3, [r1, #12]
AJ_Status AJ_MarshalContainer(AJ_Message* msg, AJ_Arg* arg, uint8_t typeId)
{
    AJ_Status status;

    InitArg(arg, typeId, NULL);
    status = AJ_MarshalArg(msg, arg);
    b8b6:	1c28      	adds	r0, r5, #0
    b8b8:	1c21      	adds	r1, r4, #0
    b8ba:	4b04      	ldr	r3, [pc, #16]	; (b8cc <AJ_MarshalContainer+0x2c>)
    b8bc:	4798      	blx	r3
    if (status == AJ_OK)
    b8be:	2800      	cmp	r0, #0
    b8c0:	d102      	bne.n	b8c8 <AJ_MarshalContainer+0x28>
	{
        arg->container = msg->outer;
    b8c2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    b8c4:	60e3      	str	r3, [r4, #12]
        msg->outer = arg;
    b8c6:	636c      	str	r4, [r5, #52]	; 0x34
    }
    return status;
}
    b8c8:	bd38      	pop	{r3, r4, r5, pc}
    b8ca:	46c0      	nop			; (mov r8, r8)
    b8cc:	0000b615 	.word	0x0000b615

0000b8d0 <AJ_MarshalCloseContainer>:

AJ_Status AJ_MarshalCloseContainer(AJ_Message* msg, AJ_Arg* arg)
{
    b8d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    AJ_IOBuffer* ioBuf = &msg->bus->sock.tx;
    b8d2:	6b05      	ldr	r5, [r0, #48]	; 0x30
    AJ_Status status = AJ_OK;

    AJ_ASSERT(TYPE_FLAG(arg->typeId) & AJ_CONTAINER);
    b8d4:	780b      	ldrb	r3, [r1, #0]
    b8d6:	1c1a      	adds	r2, r3, #0
    b8d8:	3a28      	subs	r2, #40	; 0x28
    b8da:	2a01      	cmp	r2, #1
    b8dc:	d801      	bhi.n	b8e2 <AJ_MarshalCloseContainer+0x12>
    b8de:	1c14      	adds	r4, r2, #0
    b8e0:	e006      	b.n	b8f0 <AJ_MarshalCloseContainer+0x20>
    b8e2:	241e      	movs	r4, #30
    b8e4:	1c1a      	adds	r2, r3, #0
    b8e6:	3a61      	subs	r2, #97	; 0x61
    b8e8:	2a1c      	cmp	r2, #28
    b8ea:	d801      	bhi.n	b8f0 <AJ_MarshalCloseContainer+0x20>
    b8ec:	3b5f      	subs	r3, #95	; 0x5f
    b8ee:	1c1c      	adds	r4, r3, #0
    b8f0:	4b35      	ldr	r3, [pc, #212]	; (b9c8 <AJ_MarshalCloseContainer+0xf8>)
    b8f2:	5d1b      	ldrb	r3, [r3, r4]
    b8f4:	069b      	lsls	r3, r3, #26
    b8f6:	d405      	bmi.n	b904 <AJ_MarshalCloseContainer+0x34>
    b8f8:	4834      	ldr	r0, [pc, #208]	; (b9cc <AJ_MarshalCloseContainer+0xfc>)
    b8fa:	4935      	ldr	r1, [pc, #212]	; (b9d0 <AJ_MarshalCloseContainer+0x100>)
    b8fc:	4a35      	ldr	r2, [pc, #212]	; (b9d4 <AJ_MarshalCloseContainer+0x104>)
    b8fe:	4b36      	ldr	r3, [pc, #216]	; (b9d8 <AJ_MarshalCloseContainer+0x108>)
    b900:	4c36      	ldr	r4, [pc, #216]	; (b9dc <AJ_MarshalCloseContainer+0x10c>)
    b902:	47a0      	blx	r4
    AJ_ASSERT(msg->outer == arg);
    b904:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b906:	428b      	cmp	r3, r1
    b908:	d005      	beq.n	b916 <AJ_MarshalCloseContainer+0x46>
    b90a:	4830      	ldr	r0, [pc, #192]	; (b9cc <AJ_MarshalCloseContainer+0xfc>)
    b90c:	4934      	ldr	r1, [pc, #208]	; (b9e0 <AJ_MarshalCloseContainer+0x110>)
    b90e:	4a31      	ldr	r2, [pc, #196]	; (b9d4 <AJ_MarshalCloseContainer+0x104>)
    b910:	4b34      	ldr	r3, [pc, #208]	; (b9e4 <AJ_MarshalCloseContainer+0x114>)
    b912:	4c32      	ldr	r4, [pc, #200]	; (b9dc <AJ_MarshalCloseContainer+0x10c>)
    b914:	47a0      	blx	r4

    msg->outer = arg->container;
    b916:	68da      	ldr	r2, [r3, #12]
    b918:	6342      	str	r2, [r0, #52]	; 0x34

    if (arg->typeId == AJ_ARG_ARRAY)
    b91a:	781a      	ldrb	r2, [r3, #0]
    b91c:	2a61      	cmp	r2, #97	; 0x61
    b91e:	d127      	bne.n	b970 <AJ_MarshalCloseContainer+0xa0>
	{
        uint32_t lenOffset = (uint32_t)((uint8_t*)arg->val.v_data - ioBuf->bufStart);
    b920:	685e      	ldr	r6, [r3, #4]
    b922:	69ef      	ldr	r7, [r5, #28]
        //The length we marshal does not include the length field itself.
        arg->len = (uint16_t)(ioBuf->writePtr - (uint8_t*)arg->val.v_data) - 4;
    b924:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    b926:	1b92      	subs	r2, r2, r6
    b928:	b292      	uxth	r2, r2
    b92a:	1f11      	subs	r1, r2, #4
    b92c:	b289      	uxth	r1, r1
    b92e:	8059      	strh	r1, [r3, #2]
        /*
		 * If the array element is 8 byte aligned and the array is not empty check if there was
	     * padding after the length. The length we marshal should not include the padding.
	    */
        if ((ALIGNMENT(*arg->sigPtr) == 8) && !(lenOffset & 4) && arg->len) 
    b930:	6898      	ldr	r0, [r3, #8]
    b932:	7800      	ldrb	r0, [r0, #0]
    b934:	1c04      	adds	r4, r0, #0
    b936:	3c28      	subs	r4, #40	; 0x28
    b938:	2c01      	cmp	r4, #1
    b93a:	d801      	bhi.n	b940 <AJ_MarshalCloseContainer+0x70>
    b93c:	1c25      	adds	r5, r4, #0
    b93e:	e006      	b.n	b94e <AJ_MarshalCloseContainer+0x7e>
    b940:	251e      	movs	r5, #30
    b942:	1c04      	adds	r4, r0, #0
    b944:	3c61      	subs	r4, #97	; 0x61
    b946:	2c1c      	cmp	r4, #28
    b948:	d801      	bhi.n	b94e <AJ_MarshalCloseContainer+0x7e>
    b94a:	385f      	subs	r0, #95	; 0x5f
    b94c:	1c05      	adds	r5, r0, #0
    b94e:	481e      	ldr	r0, [pc, #120]	; (b9c8 <AJ_MarshalCloseContainer+0xf8>)
    b950:	5d40      	ldrb	r0, [r0, r5]
    b952:	240f      	movs	r4, #15
    b954:	4020      	ands	r0, r4
    b956:	2808      	cmp	r0, #8
    b958:	d106      	bne.n	b968 <AJ_MarshalCloseContainer+0x98>

    msg->outer = arg->container;

    if (arg->typeId == AJ_ARG_ARRAY)
	{
        uint32_t lenOffset = (uint32_t)((uint8_t*)arg->val.v_data - ioBuf->bufStart);
    b95a:	1bf7      	subs	r7, r6, r7
        arg->len = (uint16_t)(ioBuf->writePtr - (uint8_t*)arg->val.v_data) - 4;
        /*
		 * If the array element is 8 byte aligned and the array is not empty check if there was
	     * padding after the length. The length we marshal should not include the padding.
	    */
        if ((ALIGNMENT(*arg->sigPtr) == 8) && !(lenOffset & 4) && arg->len) 
    b95c:	0778      	lsls	r0, r7, #29
    b95e:	d403      	bmi.n	b968 <AJ_MarshalCloseContainer+0x98>
    b960:	2900      	cmp	r1, #0
    b962:	d001      	beq.n	b968 <AJ_MarshalCloseContainer+0x98>
		{
            arg->len -= 4;
    b964:	3a08      	subs	r2, #8
    b966:	805a      	strh	r2, [r3, #2]
        }
        // Write array length into the buffer
        *(arg->val.v_uint32) = arg->len;
    b968:	885b      	ldrh	r3, [r3, #2]
    b96a:	6033      	str	r3, [r6, #0]
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return status;
    b96c:	2000      	movs	r0, #0
    b96e:	e02a      	b.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
        // Write array length into the buffer
        *(arg->val.v_uint32) = arg->len;
    }
	else
	{
        arg->len = 0;
    b970:	2100      	movs	r1, #0
    b972:	8059      	strh	r1, [r3, #2]
        // Check the signature is correctly closed.
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
    b974:	2a28      	cmp	r2, #40	; 0x28
    b976:	d112      	bne.n	b99e <AJ_MarshalCloseContainer+0xce>
    b978:	689b      	ldr	r3, [r3, #8]
    b97a:	781b      	ldrb	r3, [r3, #0]
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return status;
    b97c:	2000      	movs	r0, #0
    }
	else
	{
        arg->len = 0;
        // Check the signature is correctly closed.
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
    b97e:	2b29      	cmp	r3, #41	; 0x29
    b980:	d021      	beq.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    b982:	3001      	adds	r0, #1
    b984:	4911      	ldr	r1, [pc, #68]	; (b9cc <AJ_MarshalCloseContainer+0xfc>)
    b986:	4a18      	ldr	r2, [pc, #96]	; (b9e8 <AJ_MarshalCloseContainer+0x118>)
    b988:	4b18      	ldr	r3, [pc, #96]	; (b9ec <AJ_MarshalCloseContainer+0x11c>)
    b98a:	4798      	blx	r3
    b98c:	1c03      	adds	r3, r0, #0
            return AJ_ERR_SIGNATURE;
    b98e:	2011      	movs	r0, #17
	{
        arg->len = 0;
        // Check the signature is correctly closed.
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    b990:	2b00      	cmp	r3, #0
    b992:	d018      	beq.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
    b994:	4816      	ldr	r0, [pc, #88]	; (b9f0 <AJ_MarshalCloseContainer+0x120>)
    b996:	4b17      	ldr	r3, [pc, #92]	; (b9f4 <AJ_MarshalCloseContainer+0x124>)
    b998:	4798      	blx	r3
            return AJ_ERR_SIGNATURE;
    b99a:	2011      	movs	r0, #17
    b99c:	e013      	b.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
    }
    return status;
    b99e:	2000      	movs	r0, #0
        if ((arg->typeId == AJ_ARG_STRUCT) && (*arg->sigPtr != AJ_STRUCT_CLOSE)) 
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
        if ((arg->typeId == AJ_ARG_DICT_ENTRY) && (*arg->sigPtr != AJ_DICT_ENTRY_CLOSE)) 
    b9a0:	2a7b      	cmp	r2, #123	; 0x7b
    b9a2:	d110      	bne.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
    b9a4:	689b      	ldr	r3, [r3, #8]
    b9a6:	781b      	ldrb	r3, [r3, #0]
    b9a8:	2b7d      	cmp	r3, #125	; 0x7d
    b9aa:	d00c      	beq.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    b9ac:	3001      	adds	r0, #1
    b9ae:	4907      	ldr	r1, [pc, #28]	; (b9cc <AJ_MarshalCloseContainer+0xfc>)
    b9b0:	4a11      	ldr	r2, [pc, #68]	; (b9f8 <AJ_MarshalCloseContainer+0x128>)
    b9b2:	4b0e      	ldr	r3, [pc, #56]	; (b9ec <AJ_MarshalCloseContainer+0x11c>)
    b9b4:	4798      	blx	r3
    b9b6:	1c03      	adds	r3, r0, #0
            return AJ_ERR_SIGNATURE;
    b9b8:	2011      	movs	r0, #17
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
            return AJ_ERR_SIGNATURE;
        }
        if ((arg->typeId == AJ_ARG_DICT_ENTRY) && (*arg->sigPtr != AJ_DICT_ENTRY_CLOSE)) 
		{
            AJ_ErrPrintf(("AJ_MarshalCloseContainer(): AJ_ERR_SIGNATURE\n"));
    b9ba:	2b00      	cmp	r3, #0
    b9bc:	d003      	beq.n	b9c6 <AJ_MarshalCloseContainer+0xf6>
    b9be:	480c      	ldr	r0, [pc, #48]	; (b9f0 <AJ_MarshalCloseContainer+0x120>)
    b9c0:	4b0c      	ldr	r3, [pc, #48]	; (b9f4 <AJ_MarshalCloseContainer+0x124>)
    b9c2:	4798      	blx	r3
            return AJ_ERR_SIGNATURE;
    b9c4:	2011      	movs	r0, #17
        }
    }
    return status;
}
    b9c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b9c8:	0001dac0 	.word	0x0001dac0
    b9cc:	0001d2d8 	.word	0x0001d2d8
    b9d0:	000009da 	.word	0x000009da
    b9d4:	0001dae0 	.word	0x0001dae0
    b9d8:	0001d594 	.word	0x0001d594
    b9dc:	00016629 	.word	0x00016629
    b9e0:	000009db 	.word	0x000009db
    b9e4:	0001d648 	.word	0x0001d648
    b9e8:	000009f5 	.word	0x000009f5
    b9ec:	0000636d 	.word	0x0000636d
    b9f0:	0001da30 	.word	0x0001da30
    b9f4:	00016f5d 	.word	0x00016f5d
    b9f8:	000009fa 	.word	0x000009fa

0000b9fc <AJ_MarshalVariant>:

AJ_Status AJ_MarshalVariant(AJ_Message* msg, const char* sig)
{
    b9fc:	b570      	push	{r4, r5, r6, lr}
    b9fe:	b084      	sub	sp, #16
    ba00:	1c05      	adds	r5, r0, #0
    ba02:	1c0c      	adds	r4, r1, #0
    AJ_Arg arg;

    // A variant type must be a single complete type
    if (CompleteTypeSigLen(sig) != strlen(sig)) 
    ba04:	1c08      	adds	r0, r1, #0
    ba06:	4b0d      	ldr	r3, [pc, #52]	; (ba3c <AJ_MarshalVariant+0x40>)
    ba08:	4798      	blx	r3
    ba0a:	1c06      	adds	r6, r0, #0
    ba0c:	1c20      	adds	r0, r4, #0
    ba0e:	4b0c      	ldr	r3, [pc, #48]	; (ba40 <AJ_MarshalVariant+0x44>)
    ba10:	4798      	blx	r3
	{
        //AJ_ErrPrintf(("AJ_MarshalVariant(): AJ_ERR_UNEXPECTED\n"));
        return AJ_ERR_UNEXPECTED;
    ba12:	2302      	movs	r3, #2
AJ_Status AJ_MarshalVariant(AJ_Message* msg, const char* sig)
{
    AJ_Arg arg;

    // A variant type must be a single complete type
    if (CompleteTypeSigLen(sig) != strlen(sig)) 
    ba14:	4286      	cmp	r6, r0
    ba16:	d10d      	bne.n	ba34 <AJ_MarshalVariant+0x38>

static void InitArg(AJ_Arg* arg, uint8_t typeId, const void* val)
{
    if (arg) 
	{
        arg->typeId = typeId;
    ba18:	3374      	adds	r3, #116	; 0x74
    ba1a:	466a      	mov	r2, sp
    ba1c:	7013      	strb	r3, [r2, #0]
        arg->flags = 0;
    ba1e:	2300      	movs	r3, #0
    ba20:	7053      	strb	r3, [r2, #1]
        arg->len = 0;
    ba22:	8053      	strh	r3, [r2, #2]
        arg->val.v_data = (void*)val;
    ba24:	9401      	str	r4, [sp, #4]
        arg->sigPtr = NULL;
    ba26:	9302      	str	r3, [sp, #8]
        arg->container = NULL;
    ba28:	9303      	str	r3, [sp, #12]
	{
        //AJ_ErrPrintf(("AJ_MarshalVariant(): AJ_ERR_UNEXPECTED\n"));
        return AJ_ERR_UNEXPECTED;
    }
    InitArg(&arg, AJ_ARG_VARIANT, sig);
    return AJ_MarshalArg(msg, &arg);
    ba2a:	1c28      	adds	r0, r5, #0
    ba2c:	4669      	mov	r1, sp
    ba2e:	4b05      	ldr	r3, [pc, #20]	; (ba44 <AJ_MarshalVariant+0x48>)
    ba30:	4798      	blx	r3
    ba32:	1c03      	adds	r3, r0, #0
}
    ba34:	1c18      	adds	r0, r3, #0
    ba36:	b004      	add	sp, #16
    ba38:	bd70      	pop	{r4, r5, r6, pc}
    ba3a:	46c0      	nop			; (mov r8, r8)
    ba3c:	00009b01 	.word	0x00009b01
    ba40:	0001715b 	.word	0x0001715b
    ba44:	0000b615 	.word	0x0000b615

0000ba48 <VMarshalArgs>:
        return arg;
    }
}

static AJ_Status VMarshalArgs(AJ_Message* msg, const char** sig, va_list* argpp)
{
    ba48:	b5f0      	push	{r4, r5, r6, r7, lr}
    ba4a:	b095      	sub	sp, #84	; 0x54
    ba4c:	9003      	str	r0, [sp, #12]
    ba4e:	1c0d      	adds	r5, r1, #0
    ba50:	1c16      	adds	r6, r2, #0
    AJ_Status status = AJ_ERR_UNEXPECTED;
    AJ_Arg arg;
    AJ_Arg container;
    va_list argp;
    __va_copy(argp, *argpp);
    ba52:	6813      	ldr	r3, [r2, #0]
    ba54:	930b      	str	r3, [sp, #44]	; 0x2c

    container.typeId = AJ_ARG_INVALID;
    ba56:	2200      	movs	r2, #0
    ba58:	ab0c      	add	r3, sp, #48	; 0x30
    ba5a:	701a      	strb	r2, [r3, #0]
    }
}

static AJ_Status VMarshalArgs(AJ_Message* msg, const char** sig, va_list* argpp)
{
    AJ_Status status = AJ_ERR_UNEXPECTED;
    ba5c:	2002      	movs	r0, #2
    va_list argp;
    __va_copy(argp, *argpp);

    container.typeId = AJ_ARG_INVALID;

    while (**sig) 
    ba5e:	e0dc      	b.n	bc1a <VMarshalArgs+0x1d2>
        uint8_t u8;
        uint16_t u16;
        uint32_t u32;
        uint64_t u64;
        double d;
        uint8_t typeId = (uint8_t)*((*sig)++);
    ba60:	1c4b      	adds	r3, r1, #1
    ba62:	602b      	str	r3, [r5, #0]
    ba64:	780a      	ldrb	r2, [r1, #0]
        void* val;

        if (!IsBasicType(typeId))
    ba66:	1c13      	adds	r3, r2, #0
    ba68:	3b28      	subs	r3, #40	; 0x28
    ba6a:	2b01      	cmp	r3, #1
    ba6c:	d806      	bhi.n	ba7c <VMarshalArgs+0x34>
    ba6e:	1c1f      	adds	r7, r3, #0
    ba70:	4b79      	ldr	r3, [pc, #484]	; (bc58 <VMarshalArgs+0x210>)
    ba72:	5ddb      	ldrb	r3, [r3, r7]
    ba74:	2450      	movs	r4, #80	; 0x50
    ba76:	421c      	tst	r4, r3
    ba78:	d00c      	beq.n	ba94 <VMarshalArgs+0x4c>
    ba7a:	e078      	b.n	bb6e <VMarshalArgs+0x126>
    ba7c:	1c13      	adds	r3, r2, #0
    ba7e:	3b61      	subs	r3, #97	; 0x61
    ba80:	2b1c      	cmp	r3, #28
    ba82:	d807      	bhi.n	ba94 <VMarshalArgs+0x4c>
    ba84:	4b74      	ldr	r3, [pc, #464]	; (bc58 <VMarshalArgs+0x210>)
    ba86:	189b      	adds	r3, r3, r2
    ba88:	3b5f      	subs	r3, #95	; 0x5f
    ba8a:	781b      	ldrb	r3, [r3, #0]
    ba8c:	2750      	movs	r7, #80	; 0x50
    ba8e:	421f      	tst	r7, r3
    ba90:	d000      	beq.n	ba94 <VMarshalArgs+0x4c>
    ba92:	e0c8      	b.n	bc26 <VMarshalArgs+0x1de>
		 {
            if ((typeId == AJ_ARG_STRUCT) || (typeId == AJ_ARG_DICT_ENTRY))
    ba94:	2a28      	cmp	r2, #40	; 0x28
    ba96:	d001      	beq.n	ba9c <VMarshalArgs+0x54>
    ba98:	2a7b      	cmp	r2, #123	; 0x7b
    ba9a:	d117      	bne.n	bacc <VMarshalArgs+0x84>
			 {
                status = AJ_MarshalContainer(msg, &container, typeId);
    ba9c:	9c03      	ldr	r4, [sp, #12]
    ba9e:	1c20      	adds	r0, r4, #0
    baa0:	a90c      	add	r1, sp, #48	; 0x30
    baa2:	4b6e      	ldr	r3, [pc, #440]	; (bc5c <VMarshalArgs+0x214>)
    baa4:	4798      	blx	r3
                if (status != AJ_OK) 
    baa6:	2800      	cmp	r0, #0
    baa8:	d000      	beq.n	baac <VMarshalArgs+0x64>
    baaa:	e0d1      	b.n	bc50 <VMarshalArgs+0x208>
				{
		//			printf("VMarshalArgs 1 status= %s\n",AJ_StatusText(status));
                    break;
                }
                status = VMarshalArgs(msg, sig, &argp);
    baac:	1c20      	adds	r0, r4, #0
    baae:	1c29      	adds	r1, r5, #0
    bab0:	aa0b      	add	r2, sp, #44	; 0x2c
    bab2:	f7ff ffc9 	bl	ba48 <VMarshalArgs>
                /*
                 * Upon successful return from a nested call, continue from
                 * where the inner call advanced in the signature.
                 */
                if (status == AJ_OK) 
    bab6:	2800      	cmp	r0, #0
    bab8:	d000      	beq.n	babc <VMarshalArgs+0x74>
    baba:	e0c9      	b.n	bc50 <VMarshalArgs+0x208>
				{
                    status = AJ_MarshalCloseContainer(msg, &container);
    babc:	9803      	ldr	r0, [sp, #12]
    babe:	a90c      	add	r1, sp, #48	; 0x30
    bac0:	4b67      	ldr	r3, [pc, #412]	; (bc60 <VMarshalArgs+0x218>)
    bac2:	4798      	blx	r3
                }
                if (status != AJ_OK)
    bac4:	2800      	cmp	r0, #0
    bac6:	d100      	bne.n	baca <VMarshalArgs+0x82>
    bac8:	e0a7      	b.n	bc1a <VMarshalArgs+0x1d2>
    baca:	e0c1      	b.n	bc50 <VMarshalArgs+0x208>
		//			printf("VMarshalArgs 2 status= %s\n",AJ_StatusText(status));
                    break;
                }
                continue;
            }
            if ((typeId == AJ_ARG_ARRAY) && IsBasicType(**sig)) 
    bacc:	2a61      	cmp	r2, #97	; 0x61
    bace:	d127      	bne.n	bb20 <VMarshalArgs+0xd8>
    bad0:	784b      	ldrb	r3, [r1, #1]
    bad2:	1c1a      	adds	r2, r3, #0
    bad4:	3a28      	subs	r2, #40	; 0x28
    bad6:	2a01      	cmp	r2, #1
    bad8:	d801      	bhi.n	bade <VMarshalArgs+0x96>
    bada:	1c10      	adds	r0, r2, #0
    badc:	e006      	b.n	baec <VMarshalArgs+0xa4>
    bade:	201e      	movs	r0, #30
    bae0:	1c1a      	adds	r2, r3, #0
    bae2:	3a61      	subs	r2, #97	; 0x61
    bae4:	2a1c      	cmp	r2, #28
    bae6:	d801      	bhi.n	baec <VMarshalArgs+0xa4>
    bae8:	3b5f      	subs	r3, #95	; 0x5f
    baea:	1c18      	adds	r0, r3, #0
    baec:	4b5a      	ldr	r3, [pc, #360]	; (bc58 <VMarshalArgs+0x210>)
    baee:	5c1b      	ldrb	r3, [r3, r0]
    baf0:	2250      	movs	r2, #80	; 0x50
    baf2:	421a      	tst	r2, r3
    baf4:	d02d      	beq.n	bb52 <VMarshalArgs+0x10a>
			{
                const void* aval = va_arg(argp, const void*);
    baf6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    baf8:	1d13      	adds	r3, r2, #4
    bafa:	930b      	str	r3, [sp, #44]	; 0x2c
    bafc:	6813      	ldr	r3, [r2, #0]
                size_t len = va_arg(argp, size_t);
    bafe:	1c10      	adds	r0, r2, #0
    bb00:	3008      	adds	r0, #8
    bb02:	900b      	str	r0, [sp, #44]	; 0x2c
    bb04:	6852      	ldr	r2, [r2, #4]

                AJ_InitArg(&arg, (uint8_t)*((*sig)++), AJ_ARRAY_FLAG, aval, len);
    bb06:	1c88      	adds	r0, r1, #2
    bb08:	6028      	str	r0, [r5, #0]
    bb0a:	7849      	ldrb	r1, [r1, #1]
    bb0c:	9200      	str	r2, [sp, #0]
    bb0e:	a810      	add	r0, sp, #64	; 0x40
    bb10:	2201      	movs	r2, #1
    bb12:	4f54      	ldr	r7, [pc, #336]	; (bc64 <VMarshalArgs+0x21c>)
    bb14:	47b8      	blx	r7
                status = AJ_MarshalArg(msg, &arg);
    bb16:	9803      	ldr	r0, [sp, #12]
    bb18:	a910      	add	r1, sp, #64	; 0x40
    bb1a:	4b53      	ldr	r3, [pc, #332]	; (bc68 <VMarshalArgs+0x220>)
    bb1c:	4798      	blx	r3
		//		printf("VMarshalArgs 3 status= %s\n",AJ_StatusText(status));
                continue;
    bb1e:	e07c      	b.n	bc1a <VMarshalArgs+0x1d2>
            }
            if ((typeId == AJ_STRUCT_CLOSE) || (typeId == AJ_DICT_ENTRY_CLOSE)) 
    bb20:	2a29      	cmp	r2, #41	; 0x29
    bb22:	d100      	bne.n	bb26 <VMarshalArgs+0xde>
    bb24:	e094      	b.n	bc50 <VMarshalArgs+0x208>
    bb26:	2a7d      	cmp	r2, #125	; 0x7d
    bb28:	d100      	bne.n	bb2c <VMarshalArgs+0xe4>
    bb2a:	e091      	b.n	bc50 <VMarshalArgs+0x208>
			{
                break;
            }
            if (typeId == AJ_ARG_VARIANT)
    bb2c:	2a76      	cmp	r2, #118	; 0x76
    bb2e:	d110      	bne.n	bb52 <VMarshalArgs+0x10a>
			{				
                const char* vsig = va_arg(argp, const char*);
    bb30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bb32:	1d1a      	adds	r2, r3, #4
    bb34:	920b      	str	r2, [sp, #44]	; 0x2c
    bb36:	6819      	ldr	r1, [r3, #0]
    bb38:	9108      	str	r1, [sp, #32]
                status = AJ_MarshalVariant(msg, vsig);
    bb3a:	9803      	ldr	r0, [sp, #12]
    bb3c:	4b4b      	ldr	r3, [pc, #300]	; (bc6c <VMarshalArgs+0x224>)
    bb3e:	4798      	blx	r3
                if (status == AJ_OK) 
    bb40:	2800      	cmp	r0, #0
    bb42:	d106      	bne.n	bb52 <VMarshalArgs+0x10a>
				{
		//			printf("VMarshalArgs 4 status= %s\n",AJ_StatusText(status));
                    status = VMarshalArgs(msg, &vsig, &argp);
    bb44:	9803      	ldr	r0, [sp, #12]
    bb46:	a908      	add	r1, sp, #32
    bb48:	aa0b      	add	r2, sp, #44	; 0x2c
    bb4a:	f7ff ff7d 	bl	ba48 <VMarshalArgs>
                }
                if (status == AJ_OK) 
    bb4e:	2800      	cmp	r0, #0
    bb50:	d063      	beq.n	bc1a <VMarshalArgs+0x1d2>
				{
                    continue;
                }
            }
            AJ_ErrPrintf(("AJ_MarshalArgs(): AJ_ERR_UNEXPECTED\n"));
    bb52:	2001      	movs	r0, #1
    bb54:	4946      	ldr	r1, [pc, #280]	; (bc70 <VMarshalArgs+0x228>)
    bb56:	4a47      	ldr	r2, [pc, #284]	; (bc74 <VMarshalArgs+0x22c>)
    bb58:	4b47      	ldr	r3, [pc, #284]	; (bc78 <VMarshalArgs+0x230>)
    bb5a:	4798      	blx	r3
    bb5c:	1c03      	adds	r3, r0, #0
            status = AJ_ERR_UNEXPECTED;
    bb5e:	2002      	movs	r0, #2
                if (status == AJ_OK) 
				{
                    continue;
                }
            }
            AJ_ErrPrintf(("AJ_MarshalArgs(): AJ_ERR_UNEXPECTED\n"));
    bb60:	2b00      	cmp	r3, #0
    bb62:	d075      	beq.n	bc50 <VMarshalArgs+0x208>
    bb64:	4845      	ldr	r0, [pc, #276]	; (bc7c <VMarshalArgs+0x234>)
    bb66:	4b46      	ldr	r3, [pc, #280]	; (bc80 <VMarshalArgs+0x238>)
    bb68:	4798      	blx	r3
            status = AJ_ERR_UNEXPECTED;
    bb6a:	2002      	movs	r0, #2
    bb6c:	e070      	b.n	bc50 <VMarshalArgs+0x208>
            break;
        }
        if (IsScalarType(typeId)) 
    bb6e:	06d9      	lsls	r1, r3, #27
    bb70:	d542      	bpl.n	bbf8 <VMarshalArgs+0x1b0>
		{
            if (SizeOfType(typeId) == 8) 
    bb72:	210f      	movs	r1, #15
    bb74:	400b      	ands	r3, r1
    bb76:	2b08      	cmp	r3, #8
    bb78:	d11b      	bne.n	bbb2 <VMarshalArgs+0x16a>
			{
                if (typeId == 'd') 
    bb7a:	2a64      	cmp	r2, #100	; 0x64
    bb7c:	d10c      	bne.n	bb98 <VMarshalArgs+0x150>
				{
                    d = va_arg(argp, double);
    bb7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bb80:	3307      	adds	r3, #7
    bb82:	2107      	movs	r1, #7
    bb84:	438b      	bics	r3, r1
    bb86:	1c19      	adds	r1, r3, #0
    bb88:	3108      	adds	r1, #8
    bb8a:	910b      	str	r1, [sp, #44]	; 0x2c
    bb8c:	685c      	ldr	r4, [r3, #4]
    bb8e:	681b      	ldr	r3, [r3, #0]
    bb90:	9308      	str	r3, [sp, #32]
    bb92:	9409      	str	r4, [sp, #36]	; 0x24
                    val = &d;
    bb94:	a808      	add	r0, sp, #32
    bb96:	e033      	b.n	bc00 <VMarshalArgs+0x1b8>
                } 
				else 
				{
                    u64 = va_arg(argp, uint64_t);
    bb98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bb9a:	3307      	adds	r3, #7
    bb9c:	2107      	movs	r1, #7
    bb9e:	438b      	bics	r3, r1
    bba0:	1c19      	adds	r1, r3, #0
    bba2:	3108      	adds	r1, #8
    bba4:	910b      	str	r1, [sp, #44]	; 0x2c
    bba6:	685c      	ldr	r4, [r3, #4]
    bba8:	681b      	ldr	r3, [r3, #0]
    bbaa:	9306      	str	r3, [sp, #24]
    bbac:	9407      	str	r4, [sp, #28]
                    val = &u64;
    bbae:	a806      	add	r0, sp, #24
    bbb0:	e026      	b.n	bc00 <VMarshalArgs+0x1b8>
                }
            }
			else if (SizeOfType(typeId) == 4) 
    bbb2:	2b04      	cmp	r3, #4
    bbb4:	d106      	bne.n	bbc4 <VMarshalArgs+0x17c>
			{
                u32 = va_arg(argp, uint32_t);
    bbb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bbb8:	1d19      	adds	r1, r3, #4
    bbba:	910b      	str	r1, [sp, #44]	; 0x2c
    bbbc:	681b      	ldr	r3, [r3, #0]
    bbbe:	9305      	str	r3, [sp, #20]
                val = &u32;
    bbc0:	a805      	add	r0, sp, #20
    bbc2:	e01d      	b.n	bc00 <VMarshalArgs+0x1b8>
            }
			else if (SizeOfType(typeId) == 2) 
    bbc4:	4b24      	ldr	r3, [pc, #144]	; (bc58 <VMarshalArgs+0x210>)
    bbc6:	5ddb      	ldrb	r3, [r3, r7]
    bbc8:	210f      	movs	r1, #15
    bbca:	400b      	ands	r3, r1
    bbcc:	2b02      	cmp	r3, #2
    bbce:	d109      	bne.n	bbe4 <VMarshalArgs+0x19c>
			{
                u16 = (uint16_t)va_arg(argp, uint32_t);
    bbd0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bbd2:	1d19      	adds	r1, r3, #4
    bbd4:	910b      	str	r1, [sp, #44]	; 0x2c
    bbd6:	200a      	movs	r0, #10
    bbd8:	a902      	add	r1, sp, #8
    bbda:	468c      	mov	ip, r1
    bbdc:	4460      	add	r0, ip
    bbde:	681b      	ldr	r3, [r3, #0]
    bbe0:	8003      	strh	r3, [r0, #0]
    bbe2:	e00d      	b.n	bc00 <VMarshalArgs+0x1b8>
                val = &u16;
            } 
			else 
			{
                u8 = (uint8_t)va_arg(argp, uint32_t);
    bbe4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bbe6:	1d19      	adds	r1, r3, #4
    bbe8:	910b      	str	r1, [sp, #44]	; 0x2c
    bbea:	2009      	movs	r0, #9
    bbec:	a902      	add	r1, sp, #8
    bbee:	468c      	mov	ip, r1
    bbf0:	4460      	add	r0, ip
    bbf2:	681b      	ldr	r3, [r3, #0]
    bbf4:	7003      	strb	r3, [r0, #0]
    bbf6:	e003      	b.n	bc00 <VMarshalArgs+0x1b8>
                val = &u8;
            }
        } 
		else 
		{
            val = va_arg(argp, char*);
    bbf8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bbfa:	1d19      	adds	r1, r3, #4
    bbfc:	910b      	str	r1, [sp, #44]	; 0x2c
    bbfe:	6818      	ldr	r0, [r3, #0]

static void InitArg(AJ_Arg* arg, uint8_t typeId, const void* val)
{
    if (arg) 
	{
        arg->typeId = typeId;
    bc00:	a910      	add	r1, sp, #64	; 0x40
    bc02:	700a      	strb	r2, [r1, #0]
        arg->flags = 0;
    bc04:	2300      	movs	r3, #0
    bc06:	704b      	strb	r3, [r1, #1]
        arg->len = 0;
    bc08:	804b      	strh	r3, [r1, #2]
        arg->val.v_data = (void*)val;
    bc0a:	6048      	str	r0, [r1, #4]
        arg->sigPtr = NULL;
    bc0c:	608b      	str	r3, [r1, #8]
        arg->container = NULL;
    bc0e:	60cb      	str	r3, [r1, #12]
		{
            val = va_arg(argp, char*);
        }
        InitArg(&arg, typeId, val);
		
        status = AJ_MarshalArg(msg, &arg);
    bc10:	9803      	ldr	r0, [sp, #12]
    bc12:	4b15      	ldr	r3, [pc, #84]	; (bc68 <VMarshalArgs+0x220>)
    bc14:	4798      	blx	r3
        if (status != AJ_OK)
    bc16:	2800      	cmp	r0, #0
    bc18:	d11a      	bne.n	bc50 <VMarshalArgs+0x208>
    va_list argp;
    __va_copy(argp, *argpp);

    container.typeId = AJ_ARG_INVALID;

    while (**sig) 
    bc1a:	6829      	ldr	r1, [r5, #0]
    bc1c:	780b      	ldrb	r3, [r1, #0]
    bc1e:	2b00      	cmp	r3, #0
    bc20:	d000      	beq.n	bc24 <VMarshalArgs+0x1dc>
    bc22:	e71d      	b.n	ba60 <VMarshalArgs+0x18>
    bc24:	e014      	b.n	bc50 <VMarshalArgs+0x208>
            }
            AJ_ErrPrintf(("AJ_MarshalArgs(): AJ_ERR_UNEXPECTED\n"));
            status = AJ_ERR_UNEXPECTED;
            break;
        }
        if (IsScalarType(typeId)) 
    bc26:	4b0c      	ldr	r3, [pc, #48]	; (bc58 <VMarshalArgs+0x210>)
    bc28:	189b      	adds	r3, r3, r2
    bc2a:	3b5f      	subs	r3, #95	; 0x5f
    bc2c:	781b      	ldrb	r3, [r3, #0]
    bc2e:	06db      	lsls	r3, r3, #27
    bc30:	d5e2      	bpl.n	bbf8 <VMarshalArgs+0x1b0>
		{
            if (SizeOfType(typeId) == 8) 
    bc32:	4b09      	ldr	r3, [pc, #36]	; (bc58 <VMarshalArgs+0x210>)
    bc34:	189b      	adds	r3, r3, r2
    bc36:	3b5f      	subs	r3, #95	; 0x5f
    bc38:	7819      	ldrb	r1, [r3, #0]
    bc3a:	230f      	movs	r3, #15
    bc3c:	400b      	ands	r3, r1
    bc3e:	2b08      	cmp	r3, #8
    bc40:	d09b      	beq.n	bb7a <VMarshalArgs+0x132>
				{
                    u64 = va_arg(argp, uint64_t);
                    val = &u64;
                }
            }
			else if (SizeOfType(typeId) == 4) 
    bc42:	230f      	movs	r3, #15
    bc44:	400b      	ands	r3, r1
    bc46:	2b04      	cmp	r3, #4
    bc48:	d0b5      	beq.n	bbb6 <VMarshalArgs+0x16e>
			{
                u32 = va_arg(argp, uint32_t);
                val = &u32;
            }
			else if (SizeOfType(typeId) == 2) 
    bc4a:	1c17      	adds	r7, r2, #0
    bc4c:	3f5f      	subs	r7, #95	; 0x5f
    bc4e:	e7b9      	b.n	bbc4 <VMarshalArgs+0x17c>
	//		printf("------------VMarshalArgs ----------------\n");
  //          printf("VMarshalArgs 5 status= %s\n",AJ_StatusText(status));
            break;
        }
    }
    __va_copy(*argpp, argp);
    bc50:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    bc52:	6033      	str	r3, [r6, #0]
    return status;
}
    bc54:	b015      	add	sp, #84	; 0x54
    bc56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bc58:	0001dac0 	.word	0x0001dac0
    bc5c:	0000b8a1 	.word	0x0000b8a1
    bc60:	0000b8d1 	.word	0x0000b8d1
    bc64:	0000b6b5 	.word	0x0000b6b5
    bc68:	0000b615 	.word	0x0000b615
    bc6c:	0000b9fd 	.word	0x0000b9fd
    bc70:	0001d2d8 	.word	0x0001d2d8
    bc74:	0000093d 	.word	0x0000093d
    bc78:	0000636d 	.word	0x0000636d
    bc7c:	0001da60 	.word	0x0001da60
    bc80:	00016f5d 	.word	0x00016f5d

0000bc84 <AJ_MarshalArgs>:

AJ_Status AJ_MarshalArgs(AJ_Message* msg, const char* sig, ...)
{
    bc84:	b40e      	push	{r1, r2, r3}
    bc86:	b500      	push	{lr}
    bc88:	b082      	sub	sp, #8
    AJ_Status status;
    va_list argp;

    va_start(argp, sig);
    bc8a:	ab04      	add	r3, sp, #16
    bc8c:	9301      	str	r3, [sp, #4]
    status = VMarshalArgs(msg, &sig, &argp);
    bc8e:	a903      	add	r1, sp, #12
    bc90:	aa01      	add	r2, sp, #4
    bc92:	4b03      	ldr	r3, [pc, #12]	; (bca0 <AJ_MarshalArgs+0x1c>)
    bc94:	4798      	blx	r3
    va_end(argp);

    return status;
}
    bc96:	b002      	add	sp, #8
    bc98:	bc08      	pop	{r3}
    bc9a:	b003      	add	sp, #12
    bc9c:	4718      	bx	r3
    bc9e:	46c0      	nop			; (mov r8, r8)
    bca0:	0000ba49 	.word	0x0000ba49

0000bca4 <AJ_MarshalMethodCall>:
    InitArg(&arg, AJ_ARG_VARIANT, sig);
    return AJ_MarshalArg(msg, &arg);
}

AJ_Status AJ_MarshalMethodCall(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t msgId, const char* destination, AJ_SessionId sessionId, uint8_t flags, uint32_t timeout)
{
    bca4:	b5f0      	push	{r4, r5, r6, r7, lr}
    bca6:	464f      	mov	r7, r9
    bca8:	b480      	push	{r7}
    bcaa:	b082      	sub	sp, #8
    bcac:	4681      	mov	r9, r0
    bcae:	1c0c      	adds	r4, r1, #0
    bcb0:	9201      	str	r2, [sp, #4]
    bcb2:	1c1e      	adds	r6, r3, #0
    bcb4:	ab08      	add	r3, sp, #32
    bcb6:	cb80      	ldmia	r3!, {r7}
    bcb8:	781d      	ldrb	r5, [r3, #0]
    AJ_Status status;

    memset(msg, 0, sizeof(AJ_Message));
    bcba:	1c08      	adds	r0, r1, #0
    bcbc:	2100      	movs	r1, #0
    bcbe:	2240      	movs	r2, #64	; 0x40
    bcc0:	4b0b      	ldr	r3, [pc, #44]	; (bcf0 <AJ_MarshalMethodCall+0x4c>)
    bcc2:	4798      	blx	r3
    msg->bus = bus;
    bcc4:	464b      	mov	r3, r9
    bcc6:	6323      	str	r3, [r4, #48]	; 0x30
    msg->destination = destination;
    bcc8:	61a6      	str	r6, [r4, #24]
    msg->sessionId = sessionId;
    bcca:	6227      	str	r7, [r4, #32]
    msg->ttl = timeout;
    bccc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    bcce:	62a3      	str	r3, [r4, #40]	; 0x28
    status = MarshalMsg(msg, AJ_MSG_METHOD_CALL, msgId, flags);
    bcd0:	1c20      	adds	r0, r4, #0
    bcd2:	2101      	movs	r1, #1
    bcd4:	9a01      	ldr	r2, [sp, #4]
    bcd6:	1c2b      	adds	r3, r5, #0
    bcd8:	4d06      	ldr	r5, [pc, #24]	; (bcf4 <AJ_MarshalMethodCall+0x50>)
    bcda:	47a8      	blx	r5
    if (status == AJ_OK) 
    bcdc:	2800      	cmp	r0, #0
    bcde:	d103      	bne.n	bce8 <AJ_MarshalMethodCall+0x44>
	{
        status = AJ_AllocReplyContext(msg, timeout);
    bce0:	1c20      	adds	r0, r4, #0
    bce2:	990a      	ldr	r1, [sp, #40]	; 0x28
    bce4:	4b04      	ldr	r3, [pc, #16]	; (bcf8 <AJ_MarshalMethodCall+0x54>)
    bce6:	4798      	blx	r3
    }
    return status;
}
    bce8:	b002      	add	sp, #8
    bcea:	bc04      	pop	{r2}
    bcec:	4691      	mov	r9, r2
    bcee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bcf0:	00016773 	.word	0x00016773
    bcf4:	0000a239 	.word	0x0000a239
    bcf8:	0000890d 	.word	0x0000890d

0000bcfc <AJ_MarshalSignal>:

AJ_Status AJ_MarshalSignal(AJ_BusAttachment* bus, AJ_Message* msg, uint32_t msgId, const char* destination, AJ_SessionId sessionId, uint8_t flags, uint32_t ttl)
{
    bcfc:	b5f0      	push	{r4, r5, r6, r7, lr}
    bcfe:	464f      	mov	r7, r9
    bd00:	b480      	push	{r7}
    bd02:	b082      	sub	sp, #8
    bd04:	4681      	mov	r9, r0
    bd06:	1c0c      	adds	r4, r1, #0
    bd08:	9201      	str	r2, [sp, #4]
    bd0a:	1c1e      	adds	r6, r3, #0
    bd0c:	ab08      	add	r3, sp, #32
    bd0e:	cb80      	ldmia	r3!, {r7}
    bd10:	781d      	ldrb	r5, [r3, #0]
    memset(msg, 0, sizeof(AJ_Message));
    bd12:	1c08      	adds	r0, r1, #0
    bd14:	2100      	movs	r1, #0
    bd16:	2240      	movs	r2, #64	; 0x40
    bd18:	4b08      	ldr	r3, [pc, #32]	; (bd3c <AJ_MarshalSignal+0x40>)
    bd1a:	4798      	blx	r3
    msg->bus = bus;
    bd1c:	464b      	mov	r3, r9
    bd1e:	6323      	str	r3, [r4, #48]	; 0x30
    msg->destination = destination;
    bd20:	61a6      	str	r6, [r4, #24]
    msg->sessionId = sessionId;
    bd22:	6227      	str	r7, [r4, #32]
    msg->ttl = ttl;
    bd24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    bd26:	62a3      	str	r3, [r4, #40]	; 0x28
    return MarshalMsg(msg, AJ_MSG_SIGNAL, msgId, flags);
    bd28:	1c20      	adds	r0, r4, #0
    bd2a:	2104      	movs	r1, #4
    bd2c:	9a01      	ldr	r2, [sp, #4]
    bd2e:	1c2b      	adds	r3, r5, #0
    bd30:	4c03      	ldr	r4, [pc, #12]	; (bd40 <AJ_MarshalSignal+0x44>)
    bd32:	47a0      	blx	r4
}
    bd34:	b002      	add	sp, #8
    bd36:	bc04      	pop	{r2}
    bd38:	4691      	mov	r9, r2
    bd3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bd3c:	00016773 	.word	0x00016773
    bd40:	0000a239 	.word	0x0000a239

0000bd44 <AJ_MarshalReplyMsg>:

AJ_Status AJ_MarshalReplyMsg(const AJ_Message* methodCall, AJ_Message* reply)
{
    bd44:	b538      	push	{r3, r4, r5, lr}
    bd46:	1c04      	adds	r4, r0, #0
    bd48:	1c0d      	adds	r5, r1, #0
    AJ_ASSERT(methodCall->hdr->msgType == AJ_MSG_METHOD_CALL);
    bd4a:	6843      	ldr	r3, [r0, #4]
    bd4c:	785b      	ldrb	r3, [r3, #1]
    bd4e:	2b01      	cmp	r3, #1
    bd50:	d005      	beq.n	bd5e <AJ_MarshalReplyMsg+0x1a>
    bd52:	4810      	ldr	r0, [pc, #64]	; (bd94 <AJ_MarshalReplyMsg+0x50>)
    bd54:	4910      	ldr	r1, [pc, #64]	; (bd98 <AJ_MarshalReplyMsg+0x54>)
    bd56:	4a11      	ldr	r2, [pc, #68]	; (bd9c <AJ_MarshalReplyMsg+0x58>)
    bd58:	4b11      	ldr	r3, [pc, #68]	; (bda0 <AJ_MarshalReplyMsg+0x5c>)
    bd5a:	4c12      	ldr	r4, [pc, #72]	; (bda4 <AJ_MarshalReplyMsg+0x60>)
    bd5c:	47a0      	blx	r4
    memset(reply, 0, sizeof(AJ_Message));
    bd5e:	1c08      	adds	r0, r1, #0
    bd60:	2100      	movs	r1, #0
    bd62:	2240      	movs	r2, #64	; 0x40
    bd64:	4b10      	ldr	r3, [pc, #64]	; (bda8 <AJ_MarshalReplyMsg+0x64>)
    bd66:	4798      	blx	r3
    reply->bus = methodCall->bus;
    bd68:	6b23      	ldr	r3, [r4, #48]	; 0x30
    bd6a:	632b      	str	r3, [r5, #48]	; 0x30
    reply->destination = methodCall->sender;
    bd6c:	6963      	ldr	r3, [r4, #20]
    bd6e:	61ab      	str	r3, [r5, #24]
    reply->sessionId = methodCall->sessionId;
    bd70:	6a23      	ldr	r3, [r4, #32]
    bd72:	622b      	str	r3, [r5, #32]
    reply->replySerial = methodCall->hdr->serialNum;
    bd74:	6863      	ldr	r3, [r4, #4]
    bd76:	689b      	ldr	r3, [r3, #8]
    bd78:	60ab      	str	r3, [r5, #8]
    reply->ttl = 0;
    bd7a:	2300      	movs	r3, #0
    bd7c:	62ab      	str	r3, [r5, #40]	; 0x28
    return MarshalMsg(reply, AJ_MSG_METHOD_RET, methodCall->msgId, methodCall->hdr->flags & AJ_FLAG_ENCRYPTED);
    bd7e:	6822      	ldr	r2, [r4, #0]
    bd80:	6863      	ldr	r3, [r4, #4]
    bd82:	789b      	ldrb	r3, [r3, #2]
    bd84:	217f      	movs	r1, #127	; 0x7f
    bd86:	438b      	bics	r3, r1
    bd88:	1c28      	adds	r0, r5, #0
    bd8a:	397d      	subs	r1, #125	; 0x7d
    bd8c:	4c07      	ldr	r4, [pc, #28]	; (bdac <AJ_MarshalReplyMsg+0x68>)
    bd8e:	47a0      	blx	r4
}
    bd90:	bd38      	pop	{r3, r4, r5, pc}
    bd92:	46c0      	nop			; (mov r8, r8)
    bd94:	0001d2d8 	.word	0x0001d2d8
    bd98:	00000a2c 	.word	0x00000a2c
    bd9c:	0001d294 	.word	0x0001d294
    bda0:	0001da84 	.word	0x0001da84
    bda4:	00016629 	.word	0x00016629
    bda8:	00016773 	.word	0x00016773
    bdac:	0000a239 	.word	0x0000a239

0000bdb0 <AJ_MarshalErrorMsgWithInfo>:

AJ_Status AJ_MarshalErrorMsgWithInfo(const AJ_Message* methodCall, AJ_Message* reply, const char* error, const char* info)
{
    bdb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bdb2:	1c05      	adds	r5, r0, #0
    bdb4:	1c0c      	adds	r4, r1, #0
    bdb6:	1c17      	adds	r7, r2, #0
    bdb8:	1c1e      	adds	r6, r3, #0
    AJ_Status status;

    AJ_ASSERT(methodCall->hdr->msgType == AJ_MSG_METHOD_CALL);
    bdba:	6843      	ldr	r3, [r0, #4]
    bdbc:	785b      	ldrb	r3, [r3, #1]
    bdbe:	2b01      	cmp	r3, #1
    bdc0:	d005      	beq.n	bdce <AJ_MarshalErrorMsgWithInfo+0x1e>
    bdc2:	481b      	ldr	r0, [pc, #108]	; (be30 <AJ_MarshalErrorMsgWithInfo+0x80>)
    bdc4:	491b      	ldr	r1, [pc, #108]	; (be34 <AJ_MarshalErrorMsgWithInfo+0x84>)
    bdc6:	4a1c      	ldr	r2, [pc, #112]	; (be38 <AJ_MarshalErrorMsgWithInfo+0x88>)
    bdc8:	4b1c      	ldr	r3, [pc, #112]	; (be3c <AJ_MarshalErrorMsgWithInfo+0x8c>)
    bdca:	4c1d      	ldr	r4, [pc, #116]	; (be40 <AJ_MarshalErrorMsgWithInfo+0x90>)
    bdcc:	47a0      	blx	r4
    memset(reply, 0, sizeof(AJ_Message));
    bdce:	1c08      	adds	r0, r1, #0
    bdd0:	2100      	movs	r1, #0
    bdd2:	2240      	movs	r2, #64	; 0x40
    bdd4:	4b1b      	ldr	r3, [pc, #108]	; (be44 <AJ_MarshalErrorMsgWithInfo+0x94>)
    bdd6:	4798      	blx	r3
    reply->bus = methodCall->bus;
    bdd8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    bdda:	6323      	str	r3, [r4, #48]	; 0x30
    reply->destination = methodCall->sender;
    bddc:	696b      	ldr	r3, [r5, #20]
    bdde:	61a3      	str	r3, [r4, #24]
    reply->sessionId = methodCall->sessionId;
    bde0:	6a2b      	ldr	r3, [r5, #32]
    bde2:	6223      	str	r3, [r4, #32]
    reply->replySerial = methodCall->hdr->serialNum;
    bde4:	686b      	ldr	r3, [r5, #4]
    bde6:	689b      	ldr	r3, [r3, #8]
    bde8:	60a3      	str	r3, [r4, #8]
    reply->error = error;
    bdea:	60e7      	str	r7, [r4, #12]
    reply->ttl = 0;
    bdec:	2300      	movs	r3, #0
    bdee:	62a3      	str	r3, [r4, #40]	; 0x28
    if (info) 
    bdf0:	2e00      	cmp	r6, #0
    bdf2:	d00d      	beq.n	be10 <AJ_MarshalErrorMsgWithInfo+0x60>
	{
        reply->signature = "s";
    bdf4:	4b14      	ldr	r3, [pc, #80]	; (be48 <AJ_MarshalErrorMsgWithInfo+0x98>)
    bdf6:	61e3      	str	r3, [r4, #28]
    }
    status = MarshalMsg(reply, AJ_MSG_ERROR, methodCall->msgId, methodCall->hdr->flags & AJ_FLAG_ENCRYPTED);
    bdf8:	682a      	ldr	r2, [r5, #0]
    bdfa:	686b      	ldr	r3, [r5, #4]
    bdfc:	789b      	ldrb	r3, [r3, #2]
    bdfe:	217f      	movs	r1, #127	; 0x7f
    be00:	438b      	bics	r3, r1
    be02:	1c20      	adds	r0, r4, #0
    be04:	397c      	subs	r1, #124	; 0x7c
    be06:	4d11      	ldr	r5, [pc, #68]	; (be4c <AJ_MarshalErrorMsgWithInfo+0x9c>)
    be08:	47a8      	blx	r5
    if ((status == AJ_OK) && info) 
    be0a:	2800      	cmp	r0, #0
    be0c:	d00a      	beq.n	be24 <AJ_MarshalErrorMsgWithInfo+0x74>
    be0e:	e00e      	b.n	be2e <AJ_MarshalErrorMsgWithInfo+0x7e>
    reply->ttl = 0;
    if (info) 
	{
        reply->signature = "s";
    }
    status = MarshalMsg(reply, AJ_MSG_ERROR, methodCall->msgId, methodCall->hdr->flags & AJ_FLAG_ENCRYPTED);
    be10:	682a      	ldr	r2, [r5, #0]
    be12:	686b      	ldr	r3, [r5, #4]
    be14:	789b      	ldrb	r3, [r3, #2]
    be16:	217f      	movs	r1, #127	; 0x7f
    be18:	438b      	bics	r3, r1
    be1a:	1c20      	adds	r0, r4, #0
    be1c:	397c      	subs	r1, #124	; 0x7c
    be1e:	4c0b      	ldr	r4, [pc, #44]	; (be4c <AJ_MarshalErrorMsgWithInfo+0x9c>)
    be20:	47a0      	blx	r4
    be22:	e004      	b.n	be2e <AJ_MarshalErrorMsgWithInfo+0x7e>
    if ((status == AJ_OK) && info) 
	{
        status = AJ_MarshalArgs(reply, "s", info);
    be24:	1c20      	adds	r0, r4, #0
    be26:	4908      	ldr	r1, [pc, #32]	; (be48 <AJ_MarshalErrorMsgWithInfo+0x98>)
    be28:	1c32      	adds	r2, r6, #0
    be2a:	4b09      	ldr	r3, [pc, #36]	; (be50 <AJ_MarshalErrorMsgWithInfo+0xa0>)
    be2c:	4798      	blx	r3
    }
    return status;
}
    be2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    be30:	0001d2d8 	.word	0x0001d2d8
    be34:	00000a3a 	.word	0x00000a3a
    be38:	0001daa4 	.word	0x0001daa4
    be3c:	0001da84 	.word	0x0001da84
    be40:	00016629 	.word	0x00016629
    be44:	00016773 	.word	0x00016773
    be48:	0001f054 	.word	0x0001f054
    be4c:	0000a239 	.word	0x0000a239
    be50:	0000bc85 	.word	0x0000bc85

0000be54 <AJ_MarshalErrorMsg>:

AJ_Status AJ_MarshalErrorMsg(const AJ_Message* methodCall, AJ_Message* reply, const char* error)
{
    be54:	b510      	push	{r4, lr}
    return AJ_MarshalErrorMsgWithInfo(methodCall, reply, error, NULL);
    be56:	2300      	movs	r3, #0
    be58:	4c01      	ldr	r4, [pc, #4]	; (be60 <AJ_MarshalErrorMsg+0xc>)
    be5a:	47a0      	blx	r4
}
    be5c:	bd10      	pop	{r4, pc}
    be5e:	46c0      	nop			; (mov r8, r8)
    be60:	0000bdb1 	.word	0x0000bdb1

0000be64 <AJ_MarshalStatusMsg>:

AJ_Status AJ_MarshalStatusMsg(const AJ_Message* methodCall, AJ_Message* reply, AJ_Status status)
{
    be64:	b538      	push	{r3, r4, r5, lr}
    be66:	1c05      	adds	r5, r0, #0
    be68:	1c0c      	adds	r4, r1, #0
    switch (status) 
    be6a:	2a0d      	cmp	r2, #13
    be6c:	d005      	beq.n	be7a <AJ_MarshalStatusMsg+0x16>
    be6e:	2a10      	cmp	r2, #16
    be70:	d10c      	bne.n	be8c <AJ_MarshalStatusMsg+0x28>
	{
    case AJ_ERR_NO_MATCH:
        status = AJ_MarshalErrorMsg(methodCall, reply, AJ_ErrServiceUnknown);
    be72:	4a0b      	ldr	r2, [pc, #44]	; (bea0 <AJ_MarshalStatusMsg+0x3c>)
    be74:	4b0b      	ldr	r3, [pc, #44]	; (bea4 <AJ_MarshalStatusMsg+0x40>)
    be76:	4798      	blx	r3
        break;
    be78:	e011      	b.n	be9e <AJ_MarshalStatusMsg+0x3a>

    case  AJ_ERR_SECURITY:
        status = AJ_MarshalErrorMsg(methodCall, reply, AJ_ErrSecurityViolation);
    be7a:	4a0b      	ldr	r2, [pc, #44]	; (bea8 <AJ_MarshalStatusMsg+0x44>)
    be7c:	4b09      	ldr	r3, [pc, #36]	; (bea4 <AJ_MarshalStatusMsg+0x40>)
    be7e:	4798      	blx	r3
        /*
               * We get a security violation error so if we encrypt the error message the receiver
               * won't be able to decrypt it. We can fix this by clearing the header flags.
              */
        if (status == AJ_OK) 
    be80:	2800      	cmp	r0, #0
    be82:	d10c      	bne.n	be9e <AJ_MarshalStatusMsg+0x3a>
		{
            reply->hdr->flags = 0;
    be84:	6863      	ldr	r3, [r4, #4]
    be86:	2200      	movs	r2, #0
    be88:	709a      	strb	r2, [r3, #2]
    be8a:	e008      	b.n	be9e <AJ_MarshalStatusMsg+0x3a>
        }
        break;

    default:
        status = AJ_MarshalErrorMsgWithInfo(methodCall, reply, AJ_ErrRejected, AJ_StatusText(status));
    be8c:	1c10      	adds	r0, r2, #0
    be8e:	4b07      	ldr	r3, [pc, #28]	; (beac <AJ_MarshalStatusMsg+0x48>)
    be90:	4798      	blx	r3
    be92:	1c03      	adds	r3, r0, #0
    be94:	1c28      	adds	r0, r5, #0
    be96:	1c21      	adds	r1, r4, #0
    be98:	4a05      	ldr	r2, [pc, #20]	; (beb0 <AJ_MarshalStatusMsg+0x4c>)
    be9a:	4c06      	ldr	r4, [pc, #24]	; (beb4 <AJ_MarshalStatusMsg+0x50>)
    be9c:	47a0      	blx	r4
        break;
    }
    return status;
}
    be9e:	bd38      	pop	{r3, r4, r5, pc}
    bea0:	0001eab0 	.word	0x0001eab0
    bea4:	0000be55 	.word	0x0000be55
    bea8:	0001eb70 	.word	0x0001eb70
    beac:	000063c5 	.word	0x000063c5
    beb0:	0001e924 	.word	0x0001e924
    beb4:	0000bdb1 	.word	0x0000bdb1

0000beb8 <AJ_Net_Send>:
extern volatile uint8_t tcp_ready_to_send;
extern volatile uint16_t tcp_rx_ready;
extern volatile uint8_t tcp_tx_ready;
//-----------------------------------------------------------------------------
AJ_Status AJ_Net_Send(AJ_IOBuffer* buf)
{
    beb8:	b538      	push	{r3, r4, r5, lr}
    beba:	1c04      	adds	r4, r0, #0
    uint32_t ret;
    uint32_t tx = AJ_IO_BUF_AVAIL(buf);
    bebc:	68c3      	ldr	r3, [r0, #12]
    bebe:	6882      	ldr	r2, [r0, #8]
    bec0:	1a9d      	subs	r5, r3, r2

    printf("AJ_Net_Send(buf=0x%p)\n", buf);
    bec2:	480c      	ldr	r0, [pc, #48]	; (bef4 <AJ_Net_Send+0x3c>)
    bec4:	1c21      	adds	r1, r4, #0
    bec6:	4b0c      	ldr	r3, [pc, #48]	; (bef8 <AJ_Net_Send+0x40>)
    bec8:	4798      	blx	r3
 //   printf("tcp_client_socket=%d", tcp_client_socket);
    if (tx > 0) 
    beca:	2d00      	cmp	r5, #0
    becc:	d00b      	beq.n	bee6 <AJ_Net_Send+0x2e>
	{
      //  ret = g_client.write(buf->readPtr, tx);
		send(tcp_client_socket, buf->readPtr, tx, 0);
    bece:	4b0b      	ldr	r3, [pc, #44]	; (befc <AJ_Net_Send+0x44>)
    bed0:	2000      	movs	r0, #0
    bed2:	5618      	ldrsb	r0, [r3, r0]
    bed4:	b2aa      	uxth	r2, r5
    bed6:	68a1      	ldr	r1, [r4, #8]
    bed8:	2300      	movs	r3, #0
    beda:	4d09      	ldr	r5, [pc, #36]	; (bf00 <AJ_Net_Send+0x48>)
    bedc:	47a8      	blx	r5
		{
            //AJ_ErrPrintf(("AJ_Net_Send(): send() failed. error=%d, status=AJ_ERR_WRITE\n", g_client.getWriteError()));
            return AJ_ERR_WRITE;
        }*/
		
        buf->readPtr += tcp_tx_ready;
    bede:	4b09      	ldr	r3, [pc, #36]	; (bf04 <AJ_Net_Send+0x4c>)
    bee0:	781a      	ldrb	r2, [r3, #0]
		tcp_tx_ready=0;
    bee2:	2200      	movs	r2, #0
    bee4:	701a      	strb	r2, [r3, #0]
    }
 //   if (AJ_IO_BUF_AVAIL(buf) == 0)
//	{
	       AJ_IO_BUF_RESET(buf);
    bee6:	6863      	ldr	r3, [r4, #4]
    bee8:	60a3      	str	r3, [r4, #8]
    beea:	60e3      	str	r3, [r4, #12]
    beec:	2300      	movs	r3, #0
    beee:	7063      	strb	r3, [r4, #1]
//	}
    //printf("AJ_Net_Send end\n");
    return AJ_OK;
}
    bef0:	2000      	movs	r0, #0
    bef2:	bd38      	pop	{r3, r4, r5, pc}
    bef4:	0001db1c 	.word	0x0001db1c
    bef8:	00016e3d 	.word	0x00016e3d
    befc:	20000272 	.word	0x20000272
    bf00:	00012e85 	.word	0x00012e85
    bf04:	20001349 	.word	0x20001349

0000bf08 <AJ_Net_Recv>:

AJ_Status AJ_Net_Recv(AJ_IOBuffer* buf, uint32_t len, uint32_t timeout)
{
    bf08:	b5f0      	push	{r4, r5, r6, r7, lr}
    bf0a:	465f      	mov	r7, fp
    bf0c:	4656      	mov	r6, sl
    bf0e:	464d      	mov	r5, r9
    bf10:	4644      	mov	r4, r8
    bf12:	b4f0      	push	{r4, r5, r6, r7}
    bf14:	b083      	sub	sp, #12
    bf16:	4681      	mov	r9, r0
    bf18:	1c15      	adds	r5, r2, #0
    AJ_Status status = AJ_ERR_READ;
    uint32_t ret;
    uint32_t rx = AJ_IO_BUF_SPACE(buf);
    bf1a:	8842      	ldrh	r2, [r0, #2]
    bf1c:	6841      	ldr	r1, [r0, #4]
    bf1e:	68c3      	ldr	r3, [r0, #12]
    bf20:	1acb      	subs	r3, r1, r3
    bf22:	4690      	mov	r8, r2
    bf24:	4498      	add	r8, r3
    uint32_t recvd = 0;
    unsigned long Recv_lastCall = millis();
    bf26:	4b51      	ldr	r3, [pc, #324]	; (c06c <AJ_Net_Recv+0x164>)
    bf28:	4798      	blx	r3
    bf2a:	1c04      	adds	r4, r0, #0

    // first we need to clear out our buffer
    uint32_t M = 0;
	//printf("AJ_Net_Recv(buf=0x%p, len=%d., timeout=%d.)\n", buf, len, timeout);
    if (rxLeftover != 0)
    bf2c:	4b50      	ldr	r3, [pc, #320]	; (c070 <AJ_Net_Recv+0x168>)
    bf2e:	881e      	ldrh	r6, [r3, #0]
    uint32_t rx = AJ_IO_BUF_SPACE(buf);
    uint32_t recvd = 0;
    unsigned long Recv_lastCall = millis();

    // first we need to clear out our buffer
    uint32_t M = 0;
    bf30:	2300      	movs	r3, #0
    bf32:	469a      	mov	sl, r3
	//printf("AJ_Net_Recv(buf=0x%p, len=%d., timeout=%d.)\n", buf, len, timeout);
    if (rxLeftover != 0)
    bf34:	2e00      	cmp	r6, #0
    bf36:	d025      	beq.n	bf84 <AJ_Net_Recv+0x7c>
	{
	// there was something leftover from before,
	//    printf("AJ_NetRecv(): leftover was: %d\n", rxLeftover);
		M = min(rx, rxLeftover);
    bf38:	46c2      	mov	sl, r8
    bf3a:	45b0      	cmp	r8, r6
    bf3c:	d900      	bls.n	bf40 <AJ_Net_Recv+0x38>
    bf3e:	46b2      	mov	sl, r6
		memcpy(buf->writePtr, rxDataStash, M);  // copy leftover into buffer.
    bf40:	4f4c      	ldr	r7, [pc, #304]	; (c074 <AJ_Net_Recv+0x16c>)
    bf42:	464b      	mov	r3, r9
    bf44:	68d8      	ldr	r0, [r3, #12]
    bf46:	1c39      	adds	r1, r7, #0
    bf48:	4652      	mov	r2, sl
    bf4a:	4b4b      	ldr	r3, [pc, #300]	; (c078 <AJ_Net_Recv+0x170>)
    bf4c:	4798      	blx	r3
		buf->writePtr += M;  // move the data pointer over
    bf4e:	464b      	mov	r3, r9
    bf50:	68db      	ldr	r3, [r3, #12]
    bf52:	4453      	add	r3, sl
    bf54:	464a      	mov	r2, r9
    bf56:	60d3      	str	r3, [r2, #12]
		memmove(rxDataStash, rxDataStash + M, rxLeftover - M); // shift left-overs toward the start.
    bf58:	4653      	mov	r3, sl
    bf5a:	18f9      	adds	r1, r7, r3
    bf5c:	1af2      	subs	r2, r6, r3
    bf5e:	1c38      	adds	r0, r7, #0
    bf60:	4b46      	ldr	r3, [pc, #280]	; (c07c <AJ_Net_Recv+0x174>)
    bf62:	4798      	blx	r3
		rxLeftover -= M;
    bf64:	4653      	mov	r3, sl
    bf66:	1af2      	subs	r2, r6, r3
    bf68:	b292      	uxth	r2, r2
    bf6a:	4b41      	ldr	r3, [pc, #260]	; (c070 <AJ_Net_Recv+0x168>)
    bf6c:	801a      	strh	r2, [r3, #0]
		recvd += M;
		// we have read as many bytes as we can
		// higher level isn't requesting any more
		if (recvd == rx)
    bf6e:	45d0      	cmp	r8, sl
    bf70:	d070      	beq.n	c054 <AJ_Net_Recv+0x14c>
		{
	//		printf("AJ_Net_Recv(): status=AJ_OK\n");
			return AJ_OK;
		}
	}
	if ((M != 0) && (rxLeftover != 0)) 
    bf72:	4653      	mov	r3, sl
    bf74:	2b00      	cmp	r3, #0
    bf76:	d005      	beq.n	bf84 <AJ_Net_Recv+0x7c>
    bf78:	2a00      	cmp	r2, #0
    bf7a:	d003      	beq.n	bf84 <AJ_Net_Recv+0x7c>
	{
	   printf("AJ_Net_REcv(): M was: %d, rxLeftover was: %d\n", M, rxLeftover);
    bf7c:	4840      	ldr	r0, [pc, #256]	; (c080 <AJ_Net_Recv+0x178>)
    bf7e:	4651      	mov	r1, sl
    bf80:	4b40      	ldr	r3, [pc, #256]	; (c084 <AJ_Net_Recv+0x17c>)
    bf82:	4798      	blx	r3
	}
	//printf("NetRecv before while: tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
	while ((tcp_rx_ready==0) && (millis() - Recv_lastCall < timeout))
    bf84:	4b40      	ldr	r3, [pc, #256]	; (c088 <AJ_Net_Recv+0x180>)
    bf86:	881b      	ldrh	r3, [r3, #0]
    bf88:	b29b      	uxth	r3, r3
    bf8a:	2b00      	cmp	r3, #0
    bf8c:	d012      	beq.n	bfb4 <AJ_Net_Recv+0xac>
    bf8e:	e018      	b.n	bfc2 <AJ_Net_Recv+0xba>
	{
	//	recv(tcp_client_socket, gau8SocketTestBuffer, sizeof(gau8SocketTestBuffer), 0);
		recv(tcp_client_socket, tcp_data_rx, sizeof(tcp_data_rx), 0);
    bf90:	465b      	mov	r3, fp
    bf92:	2000      	movs	r0, #0
    bf94:	5618      	ldrsb	r0, [r3, r0]
    bf96:	493d      	ldr	r1, [pc, #244]	; (c08c <AJ_Net_Recv+0x184>)
    bf98:	22af      	movs	r2, #175	; 0xaf
    bf9a:	00d2      	lsls	r2, r2, #3
    bf9c:	2300      	movs	r3, #0
    bf9e:	4f3c      	ldr	r7, [pc, #240]	; (c090 <AJ_Net_Recv+0x188>)
    bfa0:	47b8      	blx	r7
	//	recv(tcp_client_socket, buf->writePtr, sizeof(tcp_data_rx), 0);
		
		m2m_wifi_handle_events(NULL);
    bfa2:	2000      	movs	r0, #0
    bfa4:	4b3b      	ldr	r3, [pc, #236]	; (c094 <AJ_Net_Recv+0x18c>)
    bfa6:	4798      	blx	r3
	if ((M != 0) && (rxLeftover != 0)) 
	{
	   printf("AJ_Net_REcv(): M was: %d, rxLeftover was: %d\n", M, rxLeftover);
	}
	//printf("NetRecv before while: tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
	while ((tcp_rx_ready==0) && (millis() - Recv_lastCall < timeout))
    bfa8:	4b37      	ldr	r3, [pc, #220]	; (c088 <AJ_Net_Recv+0x180>)
    bfaa:	881b      	ldrh	r3, [r3, #0]
    bfac:	b29b      	uxth	r3, r3
    bfae:	2b00      	cmp	r3, #0
    bfb0:	d003      	beq.n	bfba <AJ_Net_Recv+0xb2>
    bfb2:	e006      	b.n	bfc2 <AJ_Net_Recv+0xba>
    bfb4:	4e2d      	ldr	r6, [pc, #180]	; (c06c <AJ_Net_Recv+0x164>)
	{
	//	recv(tcp_client_socket, gau8SocketTestBuffer, sizeof(gau8SocketTestBuffer), 0);
		recv(tcp_client_socket, tcp_data_rx, sizeof(tcp_data_rx), 0);
    bfb6:	4b38      	ldr	r3, [pc, #224]	; (c098 <AJ_Net_Recv+0x190>)
    bfb8:	469b      	mov	fp, r3
	if ((M != 0) && (rxLeftover != 0)) 
	{
	   printf("AJ_Net_REcv(): M was: %d, rxLeftover was: %d\n", M, rxLeftover);
	}
	//printf("NetRecv before while: tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
	while ((tcp_rx_ready==0) && (millis() - Recv_lastCall < timeout))
    bfba:	47b0      	blx	r6
    bfbc:	1b00      	subs	r0, r0, r4
    bfbe:	42a8      	cmp	r0, r5
    bfc0:	d3e6      	bcc.n	bf90 <AJ_Net_Recv+0x88>
	//	recv(tcp_client_socket, buf->writePtr, sizeof(tcp_data_rx), 0);
		
		m2m_wifi_handle_events(NULL);
	}
//	printf("NetRecv: tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
    if (tcp_rx_ready==0) 
    bfc2:	4b31      	ldr	r3, [pc, #196]	; (c088 <AJ_Net_Recv+0x180>)
    bfc4:	881b      	ldrh	r3, [r3, #0]
    bfc6:	b29b      	uxth	r3, r3
    bfc8:	2b00      	cmp	r3, #0
    bfca:	d104      	bne.n	bfd6 <AJ_Net_Recv+0xce>
	{
		printf("AJ_Net_Recv(): timeout. status=AJ_ERR_TIMEOUT\n");
    bfcc:	4833      	ldr	r0, [pc, #204]	; (c09c <AJ_Net_Recv+0x194>)
    bfce:	4b34      	ldr	r3, [pc, #208]	; (c0a0 <AJ_Net_Recv+0x198>)
    bfd0:	4798      	blx	r3
        status = AJ_ERR_TIMEOUT;
    bfd2:	2007      	movs	r0, #7
    bfd4:	e03a      	b.n	c04c <AJ_Net_Recv+0x144>
    } 
	else
	{    
	   memcpy(AJ_in_data_tcp, tcp_data_rx,tcp_rx_ready);
    bfd6:	4c2c      	ldr	r4, [pc, #176]	; (c088 <AJ_Net_Recv+0x180>)
    bfd8:	8822      	ldrh	r2, [r4, #0]
    bfda:	b292      	uxth	r2, r2
    bfdc:	4831      	ldr	r0, [pc, #196]	; (c0a4 <AJ_Net_Recv+0x19c>)
    bfde:	492b      	ldr	r1, [pc, #172]	; (c08c <AJ_Net_Recv+0x184>)
    bfe0:	4b25      	ldr	r3, [pc, #148]	; (c078 <AJ_Net_Recv+0x170>)
    bfe2:	4798      	blx	r3
	   uint32_t askFor = rx;
	   askFor -= M;
    bfe4:	4643      	mov	r3, r8
    bfe6:	4652      	mov	r2, sl
    bfe8:	1a9e      	subs	r6, r3, r2
	   ret=tcp_rx_ready;
    bfea:	8824      	ldrh	r4, [r4, #0]
    bfec:	b2a4      	uxth	r4, r4
	 //  printf("AJ_Net_Recv(): ask for: %d\n", askFor);
	   if (askFor < ret) 
    bfee:	42a6      	cmp	r6, r4
    bff0:	d232      	bcs.n	c058 <AJ_Net_Recv+0x150>
	   {
		   printf("AJ_Net_Recv(): BUFFER OVERRUN: askFor=%u, ret=%u\n", askFor, ret);
    bff2:	482d      	ldr	r0, [pc, #180]	; (c0a8 <AJ_Net_Recv+0x1a0>)
    bff4:	1c31      	adds	r1, r6, #0
    bff6:	1c22      	adds	r2, r4, #0
    bff8:	4b22      	ldr	r3, [pc, #136]	; (c084 <AJ_Net_Recv+0x17c>)
    bffa:	4798      	blx	r3
	   }
       if (ret == -1) 
    bffc:	1c63      	adds	r3, r4, #1
    bffe:	d104      	bne.n	c00a <AJ_Net_Recv+0x102>
	   {
	        printf("AJ_Net_Recv(): read() failed. status=AJ_ERR_READ\n");
    c000:	482a      	ldr	r0, [pc, #168]	; (c0ac <AJ_Net_Recv+0x1a4>)
    c002:	4b27      	ldr	r3, [pc, #156]	; (c0a0 <AJ_Net_Recv+0x198>)
    c004:	4798      	blx	r3
	        status = AJ_ERR_READ;
    c006:	2005      	movs	r0, #5
    c008:	e020      	b.n	c04c <AJ_Net_Recv+0x144>
	    //    printf("AJ_Net_Recv(): ret now %d\n", ret);
	        AJ_DumpBytes("Recv", buf->writePtr, ret);

	        if (ret > askFor) 
			{
		        printf("AJ_Net_Recv(): new leftover %d\n", ret - askFor);
    c00a:	1ba3      	subs	r3, r4, r6
    c00c:	4828      	ldr	r0, [pc, #160]	; (c0b0 <AJ_Net_Recv+0x1a8>)
    c00e:	9301      	str	r3, [sp, #4]
    c010:	1c19      	adds	r1, r3, #0
    c012:	4b1c      	ldr	r3, [pc, #112]	; (c084 <AJ_Net_Recv+0x17c>)
    c014:	4798      	blx	r3
		        // now shove the extra into the stash
		        memcpy(rxDataStash + rxLeftover, buf->writePtr + askFor, ret - askFor);
    c016:	4d16      	ldr	r5, [pc, #88]	; (c070 <AJ_Net_Recv+0x168>)
    c018:	882f      	ldrh	r7, [r5, #0]
    c01a:	4816      	ldr	r0, [pc, #88]	; (c074 <AJ_Net_Recv+0x16c>)
    c01c:	19c0      	adds	r0, r0, r7
    c01e:	4649      	mov	r1, r9
    c020:	68c9      	ldr	r1, [r1, #12]
    c022:	1989      	adds	r1, r1, r6
    c024:	9a01      	ldr	r2, [sp, #4]
    c026:	4b14      	ldr	r3, [pc, #80]	; (c078 <AJ_Net_Recv+0x170>)
    c028:	4798      	blx	r3
    c02a:	193c      	adds	r4, r7, r4
		        rxLeftover += (ret - askFor);
    c02c:	1ba6      	subs	r6, r4, r6
    c02e:	802e      	strh	r6, [r5, #0]
		        buf->writePtr += rx;
    c030:	464b      	mov	r3, r9
    c032:	68db      	ldr	r3, [r3, #12]
    c034:	4443      	add	r3, r8
    c036:	464a      	mov	r2, r9
    c038:	60d3      	str	r3, [r2, #12]
		    }
			else
			{
		        buf->writePtr += ret;
	        }
	        status = AJ_OK;
    c03a:	2000      	movs	r0, #0
    c03c:	e006      	b.n	c04c <AJ_Net_Recv+0x144>
		        rxLeftover += (ret - askFor);
		        buf->writePtr += rx;
		    }
			else
			{
		        buf->writePtr += ret;
    c03e:	464b      	mov	r3, r9
    c040:	68db      	ldr	r3, [r3, #12]
    c042:	469c      	mov	ip, r3
    c044:	4464      	add	r4, ip
    c046:	464b      	mov	r3, r9
    c048:	60dc      	str	r4, [r3, #12]
	        }
	        status = AJ_OK;
    c04a:	2000      	movs	r0, #0
        }
    }
  //  printf("!!!!!!!!!!!!!!!buf->writePtr=%x\n",buf->writePtr);
    tcp_rx_ready=0;
    c04c:	2200      	movs	r2, #0
    c04e:	4b0e      	ldr	r3, [pc, #56]	; (c088 <AJ_Net_Recv+0x180>)
    c050:	801a      	strh	r2, [r3, #0]
    return status;
    c052:	e004      	b.n	c05e <AJ_Net_Recv+0x156>
		// we have read as many bytes as we can
		// higher level isn't requesting any more
		if (recvd == rx)
		{
	//		printf("AJ_Net_Recv(): status=AJ_OK\n");
			return AJ_OK;
    c054:	2000      	movs	r0, #0
    c056:	e002      	b.n	c05e <AJ_Net_Recv+0x156>
	 //  printf("AJ_Net_Recv(): ask for: %d\n", askFor);
	   if (askFor < ret) 
	   {
		   printf("AJ_Net_Recv(): BUFFER OVERRUN: askFor=%u, ret=%u\n", askFor, ret);
	   }
       if (ret == -1) 
    c058:	1c63      	adds	r3, r4, #1
    c05a:	d1f0      	bne.n	c03e <AJ_Net_Recv+0x136>
    c05c:	e7d0      	b.n	c000 <AJ_Net_Recv+0xf8>
        }
    }
  //  printf("!!!!!!!!!!!!!!!buf->writePtr=%x\n",buf->writePtr);
    tcp_rx_ready=0;
    return status;
}
    c05e:	b003      	add	sp, #12
    c060:	bc3c      	pop	{r2, r3, r4, r5}
    c062:	4690      	mov	r8, r2
    c064:	4699      	mov	r9, r3
    c066:	46a2      	mov	sl, r4
    c068:	46ab      	mov	fp, r5
    c06a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c06c:	00014279 	.word	0x00014279
    c070:	20000ffc 	.word	0x20000ffc
    c074:	20000984 	.word	0x20000984
    c078:	00016739 	.word	0x00016739
    c07c:	0001674b 	.word	0x0001674b
    c080:	0001db34 	.word	0x0001db34
    c084:	00016e3d 	.word	0x00016e3d
    c088:	20001ecc 	.word	0x20001ecc
    c08c:	20001ed0 	.word	0x20001ed0
    c090:	00012fe1 	.word	0x00012fe1
    c094:	0001147d 	.word	0x0001147d
    c098:	20000272 	.word	0x20000272
    c09c:	0001db64 	.word	0x0001db64
    c0a0:	00016f5d 	.word	0x00016f5d
    c0a4:	20000a84 	.word	0x20000a84
    c0a8:	0001db94 	.word	0x0001db94
    c0ac:	0001dbc8 	.word	0x0001dbc8
    c0b0:	0001dbfc 	.word	0x0001dbfc

0000c0b4 <AJ_Net_SendTo>:
}
extern volatile int sock_rx_state;
extern volatile uint8_t sock_tx_state;

AJ_Status AJ_Net_SendTo(AJ_IOBuffer* buf)
{
    c0b4:	b530      	push	{r4, r5, lr}
    c0b6:	b083      	sub	sp, #12
    c0b8:	1c04      	adds	r4, r0, #0
    int ret;
    uint32_t tx = AJ_IO_BUF_AVAIL(buf);
    c0ba:	6881      	ldr	r1, [r0, #8]
    c0bc:	68c3      	ldr	r3, [r0, #12]
    c0be:	1a5a      	subs	r2, r3, r1

    //AJ_InfoPrintf(("AJ_Net_SendTo(buf=0x%p)\n", buf));

    if (tx > 0)
    c0c0:	d012      	beq.n	c0e8 <AJ_Net_SendTo+0x34>
	{
  	    ret = sendto(rx_socket, buf->readPtr, tx, 0, (struct sockaddr *)&addr, sizeof(addr));
    c0c2:	4b0d      	ldr	r3, [pc, #52]	; (c0f8 <AJ_Net_SendTo+0x44>)
    c0c4:	2000      	movs	r0, #0
    c0c6:	5618      	ldrsb	r0, [r3, r0]
    c0c8:	b292      	uxth	r2, r2
    c0ca:	4b0c      	ldr	r3, [pc, #48]	; (c0fc <AJ_Net_SendTo+0x48>)
    c0cc:	9300      	str	r3, [sp, #0]
    c0ce:	2310      	movs	r3, #16
    c0d0:	9301      	str	r3, [sp, #4]
    c0d2:	2300      	movs	r3, #0
    c0d4:	4d0a      	ldr	r5, [pc, #40]	; (c100 <AJ_Net_SendTo+0x4c>)
    c0d6:	47a8      	blx	r5
		m2m_wifi_handle_events(NULL);
    c0d8:	2000      	movs	r0, #0
    c0da:	4b0a      	ldr	r3, [pc, #40]	; (c104 <AJ_Net_SendTo+0x50>)
    c0dc:	4798      	blx	r3
        //AJ_InfoPrintf(("AJ_Net_SendTo(): SendTo write %d\n", ret));
        if (sock_tx_state != 1) 
    c0de:	4b0a      	ldr	r3, [pc, #40]	; (c108 <AJ_Net_SendTo+0x54>)
    c0e0:	781b      	ldrb	r3, [r3, #0]
		{
            //AJ_ErrPrintf(("AJ_Net_Sendto(): no bytes. status=AJ_ERR_WRITE\n"));
            return AJ_ERR_WRITE;
    c0e2:	2006      	movs	r0, #6
    if (tx > 0)
	{
  	    ret = sendto(rx_socket, buf->readPtr, tx, 0, (struct sockaddr *)&addr, sizeof(addr));
		m2m_wifi_handle_events(NULL);
        //AJ_InfoPrintf(("AJ_Net_SendTo(): SendTo write %d\n", ret));
        if (sock_tx_state != 1) 
    c0e4:	2b01      	cmp	r3, #1
    c0e6:	d105      	bne.n	c0f4 <AJ_Net_SendTo+0x40>
        }

        buf->readPtr += ret;

    }
    AJ_IO_BUF_RESET(buf);
    c0e8:	6863      	ldr	r3, [r4, #4]
    c0ea:	60a3      	str	r3, [r4, #8]
    c0ec:	60e3      	str	r3, [r4, #12]
    c0ee:	2300      	movs	r3, #0
    c0f0:	7063      	strb	r3, [r4, #1]
    //AJ_InfoPrintf(("AJ_Net_SendTo(): status=AJ_OK\n"));
    return AJ_OK;
    c0f2:	2000      	movs	r0, #0
}
    c0f4:	b003      	add	sp, #12
    c0f6:	bd30      	pop	{r4, r5, pc}
    c0f8:	20000271 	.word	0x20000271
    c0fc:	20002c48 	.word	0x20002c48
    c100:	00012f21 	.word	0x00012f21
    c104:	0001147d 	.word	0x0001147d
    c108:	20001ece 	.word	0x20001ece

0000c10c <AJ_Net_RecvFrom>:

AJ_Status AJ_Net_RecvFrom(AJ_IOBuffer* buf, uint32_t len, uint32_t timeout)
{
    c10c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c10e:	464f      	mov	r7, r9
    c110:	4646      	mov	r6, r8
    c112:	b4c0      	push	{r6, r7}
    c114:	4680      	mov	r8, r0
    c116:	1c15      	adds	r5, r2, #0
    //AJ_InfoPrintf(("AJ_Net_RecvFrom(buf=0x%p, len=%d., timeout=%d.)\n", buf, len, timeout));

    AJ_Status status = AJ_OK;
    int ret;
    uint32_t rx = AJ_IO_BUF_SPACE(buf);
    unsigned long Recv_lastCall = millis();
    c118:	4b1d      	ldr	r3, [pc, #116]	; (c190 <AJ_Net_RecvFrom+0x84>)
    c11a:	4798      	blx	r3
    c11c:	1c04      	adds	r4, r0, #0

  //  printf("AJ_Net_RecvFrom(): len %d, rx %d, timeout %d\n", len, rx, timeout);
	
  //  rx = min(rx, len);

   while ((sock_rx_state==0) && (millis() - Recv_lastCall < timeout))
    c11e:	4b1d      	ldr	r3, [pc, #116]	; (c194 <AJ_Net_RecvFrom+0x88>)
    c120:	681b      	ldr	r3, [r3, #0]
    c122:	2b00      	cmp	r3, #0
    c124:	d010      	beq.n	c148 <AJ_Net_RecvFrom+0x3c>
    c126:	e016      	b.n	c156 <AJ_Net_RecvFrom+0x4a>
    {
		//printf("millis() - Recv_lastCall = %d \n", (millis() - Recv_lastCall));
		recv(rx_socket, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
    c128:	464b      	mov	r3, r9
    c12a:	2000      	movs	r0, #0
    c12c:	5618      	ldrsb	r0, [r3, r0]
    c12e:	491a      	ldr	r1, [pc, #104]	; (c198 <AJ_Net_RecvFrom+0x8c>)
    c130:	4a1a      	ldr	r2, [pc, #104]	; (c19c <AJ_Net_RecvFrom+0x90>)
    c132:	2300      	movs	r3, #0
    c134:	4f1a      	ldr	r7, [pc, #104]	; (c1a0 <AJ_Net_RecvFrom+0x94>)
    c136:	47b8      	blx	r7
		m2m_wifi_handle_events(NULL);
    c138:	2000      	movs	r0, #0
    c13a:	4b1a      	ldr	r3, [pc, #104]	; (c1a4 <AJ_Net_RecvFrom+0x98>)
    c13c:	4798      	blx	r3

  //  printf("AJ_Net_RecvFrom(): len %d, rx %d, timeout %d\n", len, rx, timeout);
	
  //  rx = min(rx, len);

   while ((sock_rx_state==0) && (millis() - Recv_lastCall < timeout))
    c13e:	4b15      	ldr	r3, [pc, #84]	; (c194 <AJ_Net_RecvFrom+0x88>)
    c140:	681b      	ldr	r3, [r3, #0]
    c142:	2b00      	cmp	r3, #0
    c144:	d003      	beq.n	c14e <AJ_Net_RecvFrom+0x42>
    c146:	e006      	b.n	c156 <AJ_Net_RecvFrom+0x4a>
    c148:	4e11      	ldr	r6, [pc, #68]	; (c190 <AJ_Net_RecvFrom+0x84>)
    {
		//printf("millis() - Recv_lastCall = %d \n", (millis() - Recv_lastCall));
		recv(rx_socket, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
    c14a:	4b17      	ldr	r3, [pc, #92]	; (c1a8 <AJ_Net_RecvFrom+0x9c>)
    c14c:	4699      	mov	r9, r3

  //  printf("AJ_Net_RecvFrom(): len %d, rx %d, timeout %d\n", len, rx, timeout);
	
  //  rx = min(rx, len);

   while ((sock_rx_state==0) && (millis() - Recv_lastCall < timeout))
    c14e:	47b0      	blx	r6
    c150:	1b00      	subs	r0, r0, r4
    c152:	42a8      	cmp	r0, r5
    c154:	d3e8      	bcc.n	c128 <AJ_Net_RecvFrom+0x1c>
		//printf("millis() - Recv_lastCall = %d \n", (millis() - Recv_lastCall));
		recv(rx_socket, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
		m2m_wifi_handle_events(NULL);
		
   }
   ret=sock_rx_state;
    c156:	4b0f      	ldr	r3, [pc, #60]	; (c194 <AJ_Net_RecvFrom+0x88>)
    c158:	681b      	ldr	r3, [r3, #0]
  // printf("AJ_Net_RecvFrom(): millis %d, Last_call %d, timeout %d, Avail %d\n", millis(), Recv_lastCall, timeout, g_clientUDP.available());
    //ret = g_clientUDP.read(buf->writePtr, rx);
	
    //AJ_InfoPrintf(("AJ_Net_RecvFrom(): read() returns %d, rx %d\n", ret, rx));

    if (ret == -1) 
    c15a:	1c5a      	adds	r2, r3, #1
    c15c:	d104      	bne.n	c168 <AJ_Net_RecvFrom+0x5c>
	{
        printf("AJ_Net_RecvFrom(): read() fails. status=AJ_ERR_READ\n");
    c15e:	4813      	ldr	r0, [pc, #76]	; (c1ac <AJ_Net_RecvFrom+0xa0>)
    c160:	4b13      	ldr	r3, [pc, #76]	; (c1b0 <AJ_Net_RecvFrom+0xa4>)
    c162:	4798      	blx	r3
        status = AJ_ERR_READ;
    c164:	2405      	movs	r4, #5
    c166:	e006      	b.n	c176 <AJ_Net_RecvFrom+0x6a>
	{
        if (ret != -1) 
		{
            AJ_DumpBytes("AJ_Net_RecvFrom", buf->writePtr, ret);
        }
        buf->writePtr += ret;
    c168:	4642      	mov	r2, r8
    c16a:	68d2      	ldr	r2, [r2, #12]
    c16c:	4694      	mov	ip, r2
    c16e:	4463      	add	r3, ip
    c170:	4642      	mov	r2, r8
    c172:	60d3      	str	r3, [r2, #12]
     //   printf("AJ_Net_RecvFrom(): status=AJ_OK\n");
        status = AJ_OK;
    c174:	2400      	movs	r4, #0
    }
    printf("AJ_Net_RecvFrom(): status=%s\n", AJ_StatusText(status));
    c176:	1c20      	adds	r0, r4, #0
    c178:	4b0e      	ldr	r3, [pc, #56]	; (c1b4 <AJ_Net_RecvFrom+0xa8>)
    c17a:	4798      	blx	r3
    c17c:	1c01      	adds	r1, r0, #0
    c17e:	480e      	ldr	r0, [pc, #56]	; (c1b8 <AJ_Net_RecvFrom+0xac>)
    c180:	4b0e      	ldr	r3, [pc, #56]	; (c1bc <AJ_Net_RecvFrom+0xb0>)
    c182:	4798      	blx	r3
    return /*sock_rx_state;*/status;
}
    c184:	1c20      	adds	r0, r4, #0
    c186:	bc0c      	pop	{r2, r3}
    c188:	4690      	mov	r8, r2
    c18a:	4699      	mov	r9, r3
    c18c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c18e:	46c0      	nop			; (mov r8, r8)
    c190:	00014279 	.word	0x00014279
    c194:	20001ec8 	.word	0x20001ec8
    c198:	20001914 	.word	0x20001914
    c19c:	000005b4 	.word	0x000005b4
    c1a0:	00012fe1 	.word	0x00012fe1
    c1a4:	0001147d 	.word	0x0001147d
    c1a8:	20000271 	.word	0x20000271
    c1ac:	0001dc1c 	.word	0x0001dc1c
    c1b0:	00016f5d 	.word	0x00016f5d
    c1b4:	000063c5 	.word	0x000063c5
    c1b8:	0001dc50 	.word	0x0001dc50
    c1bc:	00016e3d 	.word	0x00016e3d

0000c1c0 <AJ_Net_Connect>:
 * Type II overhead.  1500 - 8 -20 - 18 = 1454.  txData buffer size needs to
 * be big enough to hold a NS WHO-HAS for one name (4 + 2 + 256 = 262) in UDP
 * mode.  TCP buffer size dominates in that case.
 */
AJ_Status AJ_Net_Connect(AJ_BusAttachment* bus, const AJ_Service* service)
{
    c1c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    c1c2:	4647      	mov	r7, r8
    c1c4:	b480      	push	{r7}
    int ret;
    //  IPAddress ip(service->ipv4);

    if (!(service->addrTypes & AJ_ADDR_TCP4)) 
    c1c6:	780a      	ldrb	r2, [r1, #0]
	{
  //      AJ_ErrPrintf(("AJ_Net_Connect(): only IPV4 TCP supported\n", ret));
        return AJ_ERR_CONNECT;
    c1c8:	230e      	movs	r3, #14
AJ_Status AJ_Net_Connect(AJ_BusAttachment* bus, const AJ_Service* service)
{
    int ret;
    //  IPAddress ip(service->ipv4);

    if (!(service->addrTypes & AJ_ADDR_TCP4)) 
    c1ca:	0752      	lsls	r2, r2, #29
    c1cc:	d556      	bpl.n	c27c <AJ_Net_Connect+0xbc>
    c1ce:	1c0c      	adds	r4, r1, #0
    c1d0:	1c05      	adds	r5, r0, #0
  //      AJ_ErrPrintf(("AJ_Net_Connect(): only IPV4 TCP supported\n", ret));
        return AJ_ERR_CONNECT;
    }
 //   printf("AJ_Net_Connect(netSock=0x%p, addrType=%d.)\n", netSock, addrType);
   
    printf("AJ_Net_Connect()\n");
    c1d2:	482c      	ldr	r0, [pc, #176]	; (c284 <AJ_Net_Connect+0xc4>)
    c1d4:	4f2c      	ldr	r7, [pc, #176]	; (c288 <AJ_Net_Connect+0xc8>)
    c1d6:	47b8      	blx	r7
    // ret = g_client.connect(ip, service->ipv4port);
	//   	addr.sin_port = _htons(48256);
	//   	addr.sin_addr.s_addr = _htonl(0xc0a8141d);
   	addr.sin_port = _htons(service->ipv4port);
    c1d8:	88a3      	ldrh	r3, [r4, #4]
    c1da:	021a      	lsls	r2, r3, #8
    c1dc:	0a1b      	lsrs	r3, r3, #8
    c1de:	4313      	orrs	r3, r2
    c1e0:	b29a      	uxth	r2, r3
    c1e2:	4e2a      	ldr	r6, [pc, #168]	; (c28c <AJ_Net_Connect+0xcc>)
    c1e4:	8072      	strh	r2, [r6, #2]
    addr.sin_addr.s_addr = _htonl(service->ipv4);
    c1e6:	68a4      	ldr	r4, [r4, #8]
    c1e8:	0e21      	lsrs	r1, r4, #24
    c1ea:	0623      	lsls	r3, r4, #24
    c1ec:	4319      	orrs	r1, r3
    c1ee:	20ff      	movs	r0, #255	; 0xff
    c1f0:	0200      	lsls	r0, r0, #8
    c1f2:	4020      	ands	r0, r4
    c1f4:	0200      	lsls	r0, r0, #8
    c1f6:	4301      	orrs	r1, r0
    c1f8:	23ff      	movs	r3, #255	; 0xff
    c1fa:	041b      	lsls	r3, r3, #16
    c1fc:	4023      	ands	r3, r4
    c1fe:	0a1b      	lsrs	r3, r3, #8
    c200:	4319      	orrs	r1, r3
    c202:	6071      	str	r1, [r6, #4]
	printf("AJ_Net_Connect(): ipv4= %x, port = %d\n",addr.sin_addr.s_addr,	addr.sin_port);
    c204:	4822      	ldr	r0, [pc, #136]	; (c290 <AJ_Net_Connect+0xd0>)
    c206:	4b23      	ldr	r3, [pc, #140]	; (c294 <AJ_Net_Connect+0xd4>)
    c208:	4798      	blx	r3
    tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0);
    c20a:	2002      	movs	r0, #2
    c20c:	2101      	movs	r1, #1
    c20e:	2200      	movs	r2, #0
    c210:	4b21      	ldr	r3, [pc, #132]	; (c298 <AJ_Net_Connect+0xd8>)
    c212:	4798      	blx	r3
    c214:	4b21      	ldr	r3, [pc, #132]	; (c29c <AJ_Net_Connect+0xdc>)
    c216:	7018      	strb	r0, [r3, #0]
	ret=connect(tcp_client_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
    c218:	1c31      	adds	r1, r6, #0
    c21a:	2210      	movs	r2, #16
    c21c:	4b20      	ldr	r3, [pc, #128]	; (c2a0 <AJ_Net_Connect+0xe0>)
    c21e:	4798      	blx	r3
    c220:	4680      	mov	r8, r0
	 printf("AJ_Net_Connect(): connect\n");
    c222:	4820      	ldr	r0, [pc, #128]	; (c2a4 <AJ_Net_Connect+0xe4>)
    c224:	47b8      	blx	r7
	// 
	while(tcp_ready_to_send==0)
    c226:	4b20      	ldr	r3, [pc, #128]	; (c2a8 <AJ_Net_Connect+0xe8>)
    c228:	781b      	ldrb	r3, [r3, #0]
    c22a:	2b00      	cmp	r3, #0
    c22c:	d106      	bne.n	c23c <AJ_Net_Connect+0x7c>
	{
		m2m_wifi_handle_events(NULL);
    c22e:	4e1f      	ldr	r6, [pc, #124]	; (c2ac <AJ_Net_Connect+0xec>)
	printf("AJ_Net_Connect(): ipv4= %x, port = %d\n",addr.sin_addr.s_addr,	addr.sin_port);
    tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0);
	ret=connect(tcp_client_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
	 printf("AJ_Net_Connect(): connect\n");
	// 
	while(tcp_ready_to_send==0)
    c230:	4c1d      	ldr	r4, [pc, #116]	; (c2a8 <AJ_Net_Connect+0xe8>)
	{
		m2m_wifi_handle_events(NULL);
    c232:	2000      	movs	r0, #0
    c234:	47b0      	blx	r6
	printf("AJ_Net_Connect(): ipv4= %x, port = %d\n",addr.sin_addr.s_addr,	addr.sin_port);
    tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0);
	ret=connect(tcp_client_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
	 printf("AJ_Net_Connect(): connect\n");
	// 
	while(tcp_ready_to_send==0)
    c236:	7823      	ldrb	r3, [r4, #0]
    c238:	2b00      	cmp	r3, #0
    c23a:	d0fa      	beq.n	c232 <AJ_Net_Connect+0x72>
	{
		m2m_wifi_handle_events(NULL);
	}
	 printf("AJ_Net_Connect(): connect OK\n");
    c23c:	481c      	ldr	r0, [pc, #112]	; (c2b0 <AJ_Net_Connect+0xf0>)
    c23e:	4b12      	ldr	r3, [pc, #72]	; (c288 <AJ_Net_Connect+0xc8>)
    c240:	4798      	blx	r3
    if (ret == -1) 
	{
        //AJ_ErrPrintf(("AJ_Net_Connect(): connect() failed: %d: status=AJ_ERR_CONNECT\n", ret));
        return AJ_ERR_CONNECT;
    c242:	230e      	movs	r3, #14
	while(tcp_ready_to_send==0)
	{
		m2m_wifi_handle_events(NULL);
	}
	 printf("AJ_Net_Connect(): connect OK\n");
    if (ret == -1) 
    c244:	4642      	mov	r2, r8
    c246:	3201      	adds	r2, #1
    c248:	d018      	beq.n	c27c <AJ_Net_Connect+0xbc>
        return AJ_ERR_CONNECT;
    } 
	else
	{
       //AJ_IOBufInit(&netSock->rx, rxData, sizeof(rxData), AJ_IO_BUF_RX, (void*)&g_clientUDP);
       bus->sock.rx.bufStart = AJ_in_data_tcp;
    c24a:	4b1a      	ldr	r3, [pc, #104]	; (c2b4 <AJ_Net_Connect+0xf4>)
    c24c:	636b      	str	r3, [r5, #52]	; 0x34
       bus->sock.rx.bufSize = sizeof(AJ_in_data_tcp);
    c24e:	22af      	movs	r2, #175	; 0xaf
    c250:	00d2      	lsls	r2, r2, #3
    c252:	866a      	strh	r2, [r5, #50]	; 0x32
       bus->sock.rx.readPtr = AJ_in_data_tcp;
    c254:	63ab      	str	r3, [r5, #56]	; 0x38
       bus->sock.rx.writePtr = AJ_in_data_tcp;
    c256:	63eb      	str	r3, [r5, #60]	; 0x3c
       bus->sock.rx.direction = AJ_IO_BUF_RX;
    c258:	2101      	movs	r1, #1
    c25a:	2330      	movs	r3, #48	; 0x30
    c25c:	54e9      	strb	r1, [r5, r3]
       bus->sock.rx.recv = AJ_Net_Recv;
    c25e:	4b16      	ldr	r3, [pc, #88]	; (c2b8 <AJ_Net_Connect+0xf8>)
    c260:	642b      	str	r3, [r5, #64]	; 0x40
       //   AJ_IOBufInit(&netSock->tx, txData, sizeof(txData), AJ_IO_BUF_TX, (void*)&g_clientUDP);
       bus->sock.tx.bufStart = tcp_data_tx;
    c262:	4b16      	ldr	r3, [pc, #88]	; (c2bc <AJ_Net_Connect+0xfc>)
    c264:	61eb      	str	r3, [r5, #28]
       bus->sock.tx.bufSize = sizeof(tcp_data_tx);
    c266:	836a      	strh	r2, [r5, #26]
       bus->sock.tx.readPtr = tcp_data_tx;
    c268:	622b      	str	r3, [r5, #32]
       bus->sock.tx.writePtr = tcp_data_tx;
    c26a:	626b      	str	r3, [r5, #36]	; 0x24
       bus->sock.tx.direction = AJ_IO_BUF_TX;
    c26c:	2302      	movs	r3, #2
    c26e:	762b      	strb	r3, [r5, #24]
       bus->sock.tx.send = AJ_Net_Send;
    c270:	4b13      	ldr	r3, [pc, #76]	; (c2c0 <AJ_Net_Connect+0x100>)
    c272:	62ab      	str	r3, [r5, #40]	; 0x28
        printf("AJ_Net_Connect(): connect() success: status=AJ_OK\n");
    c274:	4813      	ldr	r0, [pc, #76]	; (c2c4 <AJ_Net_Connect+0x104>)
    c276:	4b04      	ldr	r3, [pc, #16]	; (c288 <AJ_Net_Connect+0xc8>)
    c278:	4798      	blx	r3
        return AJ_OK;
    c27a:	2300      	movs	r3, #0
    }
    printf("AJ_Net_Connect(): connect() failed: %d: status=AJ_ERR_CONNECT\n", ret);
    return AJ_ERR_CONNECT;
}
    c27c:	1c18      	adds	r0, r3, #0
    c27e:	bc04      	pop	{r2}
    c280:	4690      	mov	r8, r2
    c282:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c284:	0001dc70 	.word	0x0001dc70
    c288:	00016f5d 	.word	0x00016f5d
    c28c:	20002c48 	.word	0x20002c48
    c290:	0001dc84 	.word	0x0001dc84
    c294:	00016e3d 	.word	0x00016e3d
    c298:	00012cb1 	.word	0x00012cb1
    c29c:	20000272 	.word	0x20000272
    c2a0:	00012ded 	.word	0x00012ded
    c2a4:	0001dcac 	.word	0x0001dcac
    c2a8:	20001348 	.word	0x20001348
    c2ac:	0001147d 	.word	0x0001147d
    c2b0:	0001dcc8 	.word	0x0001dcc8
    c2b4:	20000a84 	.word	0x20000a84
    c2b8:	0000bf09 	.word	0x0000bf09
    c2bc:	2000244c 	.word	0x2000244c
    c2c0:	0000beb9 	.word	0x0000beb9
    c2c4:	0001dce8 	.word	0x0001dce8

0000c2c8 <AJ_Net_Disconnect>:

void AJ_Net_Disconnect(AJ_NetSocket* netSock)
{
    c2c8:	b510      	push	{r4, lr}
 //   printf("AJ_Net_Disconnect(nexSock=0x%p)\n", netSock);
    close(tcp_client_socket);
    c2ca:	4c06      	ldr	r4, [pc, #24]	; (c2e4 <AJ_Net_Disconnect+0x1c>)
    c2cc:	2000      	movs	r0, #0
    c2ce:	5620      	ldrsb	r0, [r4, r0]
    c2d0:	4b05      	ldr	r3, [pc, #20]	; (c2e8 <AJ_Net_Disconnect+0x20>)
    c2d2:	4798      	blx	r3
	tcp_client_socket = -1;
    c2d4:	23ff      	movs	r3, #255	; 0xff
    c2d6:	7023      	strb	r3, [r4, #0]
	tcp_ready_to_send=0;
    c2d8:	2300      	movs	r3, #0
    c2da:	4a04      	ldr	r2, [pc, #16]	; (c2ec <AJ_Net_Disconnect+0x24>)
    c2dc:	7013      	strb	r3, [r2, #0]
	tcp_tx_ready=0;
    c2de:	4a04      	ldr	r2, [pc, #16]	; (c2f0 <AJ_Net_Disconnect+0x28>)
    c2e0:	7013      	strb	r3, [r2, #0]
    //g_client.stop();
}
    c2e2:	bd10      	pop	{r4, pc}
    c2e4:	20000272 	.word	0x20000272
    c2e8:	00013085 	.word	0x00013085
    c2ec:	20001348 	.word	0x20001348
    c2f0:	20001349 	.word	0x20001349

0000c2f4 <AJ_Net_MCastUp>:
    }
	else 
	{
		// aj_bufio    ,      ,   
        //AJ_IOBufInit(&netSock->rx, rxData, sizeof(rxData), AJ_IO_BUF_RX, (void*)&g_clientUDP);
		netSock->rx.bufStart = udp_data_rx;
    c2f4:	4b0a      	ldr	r3, [pc, #40]	; (c320 <AJ_Net_MCastUp+0x2c>)
    c2f6:	61c3      	str	r3, [r0, #28]
		netSock->rx.bufSize = sizeof(udp_data_rx);
    c2f8:	4a0a      	ldr	r2, [pc, #40]	; (c324 <AJ_Net_MCastUp+0x30>)
    c2fa:	8342      	strh	r2, [r0, #26]
		netSock->rx.readPtr = udp_data_rx;
    c2fc:	6203      	str	r3, [r0, #32]
		netSock->rx.writePtr = udp_data_rx;
    c2fe:	6243      	str	r3, [r0, #36]	; 0x24
		netSock->rx.direction = AJ_IO_BUF_RX;
    c300:	2301      	movs	r3, #1
    c302:	7603      	strb	r3, [r0, #24]
        netSock->rx.recv = AJ_Net_RecvFrom;
    c304:	4b08      	ldr	r3, [pc, #32]	; (c328 <AJ_Net_MCastUp+0x34>)
    c306:	6283      	str	r3, [r0, #40]	; 0x28
        //   AJ_IOBufInit(&netSock->tx, txData, sizeof(txData), AJ_IO_BUF_TX, (void*)&g_clientUDP);
		netSock->tx.bufStart = udp_data_tx;
    c308:	4b08      	ldr	r3, [pc, #32]	; (c32c <AJ_Net_MCastUp+0x38>)
    c30a:	6043      	str	r3, [r0, #4]
		netSock->tx.bufSize = sizeof(udp_data_tx);
    c30c:	8042      	strh	r2, [r0, #2]
		netSock->tx.readPtr = udp_data_tx;
    c30e:	6083      	str	r3, [r0, #8]
		netSock->tx.writePtr = udp_data_tx;
    c310:	60c3      	str	r3, [r0, #12]
		netSock->tx.direction = AJ_IO_BUF_TX;
    c312:	2302      	movs	r3, #2
    c314:	7003      	strb	r3, [r0, #0]
        netSock->tx.send = AJ_Net_SendTo;
    c316:	4b06      	ldr	r3, [pc, #24]	; (c330 <AJ_Net_MCastUp+0x3c>)
    c318:	6103      	str	r3, [r0, #16]
    }

    //AJ_InfoPrintf(("AJ_Net_MCastUp(): status=AJ_OK\n"));
    return AJ_OK;
}
    c31a:	2000      	movs	r0, #0
    c31c:	4770      	bx	lr
    c31e:	46c0      	nop			; (mov r8, r8)
    c320:	20001914 	.word	0x20001914
    c324:	000005b4 	.word	0x000005b4
    c328:	0000c10d 	.word	0x0000c10d
    c32c:	20001350 	.word	0x20001350
    c330:	0000c0b5 	.word	0x0000c0b5

0000c334 <AJ_Net_MCastDown>:
   // printf("AJ_Net_MCastDown(nexSock=0x%p)\n", netSock);
    //g_clientUDP.flush();
    //g_clientUDP.stop();
	//close(tx_socket);
	//close(rx_socket);
}
    c334:	4770      	bx	lr
    c336:	46c0      	nop			; (mov r8, r8)

0000c338 <GenSessionKey>:
    HandshakeComplete(AJ_ERR_SECURITY);
    return AJ_ERR_SECURITY;
}

static AJ_Status GenSessionKey(AJ_Message* msg)
{
    c338:	b570      	push	{r4, r5, r6, lr}
    c33a:	b0a2      	sub	sp, #136	; 0x88
    c33c:	1c03      	adds	r3, r0, #0
    char guidStr[33];
    AJ_GUID localGuid;

   // AJ_InfoPrintf(("GenSessionKey(msg=%p)\n", msg));

    AJ_MarshalMethodCall(msg->bus, &call, AJ_METHOD_GEN_SESSION_KEY, msg->sender, 0, AJ_NO_FLAGS, AJ_CALL_TIMEOUT);
    c33e:	6b00      	ldr	r0, [r0, #48]	; 0x30
    c340:	695b      	ldr	r3, [r3, #20]
    c342:	2200      	movs	r2, #0
    c344:	9200      	str	r2, [sp, #0]
    c346:	9201      	str	r2, [sp, #4]
    c348:	4a13      	ldr	r2, [pc, #76]	; (c398 <GenSessionKey+0x60>)
    c34a:	9202      	str	r2, [sp, #8]
    c34c:	a912      	add	r1, sp, #72	; 0x48
    c34e:	4a13      	ldr	r2, [pc, #76]	; (c39c <GenSessionKey+0x64>)
    c350:	4c13      	ldr	r4, [pc, #76]	; (c3a0 <GenSessionKey+0x68>)
    c352:	47a0      	blx	r4
    /*
     * Marshal local peer GUID, remote peer GUID, and local peer's GUID
     */
    AJ_GetLocalGUID(&localGuid);
    c354:	a805      	add	r0, sp, #20
    c356:	4b13      	ldr	r3, [pc, #76]	; (c3a4 <GenSessionKey+0x6c>)
    c358:	4798      	blx	r3
    AJ_GUID_ToString(&localGuid, guidStr, sizeof(guidStr));
    c35a:	a805      	add	r0, sp, #20
    c35c:	a909      	add	r1, sp, #36	; 0x24
    c35e:	2221      	movs	r2, #33	; 0x21
    c360:	4e11      	ldr	r6, [pc, #68]	; (c3a8 <GenSessionKey+0x70>)
    c362:	47b0      	blx	r6
    AJ_MarshalArgs(&call, "s", guidStr);
    c364:	a812      	add	r0, sp, #72	; 0x48
    c366:	4911      	ldr	r1, [pc, #68]	; (c3ac <GenSessionKey+0x74>)
    c368:	aa09      	add	r2, sp, #36	; 0x24
    c36a:	4d11      	ldr	r5, [pc, #68]	; (c3b0 <GenSessionKey+0x78>)
    c36c:	47a8      	blx	r5
    AJ_GUID_ToString(peerContext.peerGuid, guidStr, sizeof(guidStr));
    c36e:	4c11      	ldr	r4, [pc, #68]	; (c3b4 <GenSessionKey+0x7c>)
    c370:	68e0      	ldr	r0, [r4, #12]
    c372:	a909      	add	r1, sp, #36	; 0x24
    c374:	2221      	movs	r2, #33	; 0x21
    c376:	47b0      	blx	r6
    AJ_RandHex(peerContext.nonce, sizeof(peerContext.nonce), AJ_NONCE_LEN);
    c378:	341c      	adds	r4, #28
    c37a:	1c20      	adds	r0, r4, #0
    c37c:	2139      	movs	r1, #57	; 0x39
    c37e:	221c      	movs	r2, #28
    c380:	4b0d      	ldr	r3, [pc, #52]	; (c3b8 <GenSessionKey+0x80>)
    c382:	4798      	blx	r3
    AJ_MarshalArgs(&call, "ss", guidStr, peerContext.nonce);
    c384:	a812      	add	r0, sp, #72	; 0x48
    c386:	490d      	ldr	r1, [pc, #52]	; (c3bc <GenSessionKey+0x84>)
    c388:	aa09      	add	r2, sp, #36	; 0x24
    c38a:	1c23      	adds	r3, r4, #0
    c38c:	47a8      	blx	r5

    return AJ_DeliverMsg(&call);
    c38e:	a812      	add	r0, sp, #72	; 0x48
    c390:	4b0b      	ldr	r3, [pc, #44]	; (c3c0 <GenSessionKey+0x88>)
    c392:	4798      	blx	r3
}
    c394:	b022      	add	sp, #136	; 0x88
    c396:	bd70      	pop	{r4, r5, r6, pc}
    c398:	00001388 	.word	0x00001388
    c39c:	00020101 	.word	0x00020101
    c3a0:	0000bca5 	.word	0x0000bca5
    c3a4:	00004431 	.word	0x00004431
    c3a8:	00007a7d 	.word	0x00007a7d
    c3ac:	0001f054 	.word	0x0001f054
    c3b0:	0000bc85 	.word	0x0000bc85
    c3b4:	20001128 	.word	0x20001128
    c3b8:	00004a3d 	.word	0x00004a3d
    c3bc:	00018490 	.word	0x00018490
    c3c0:	0000a539 	.word	0x0000a539

0000c3c4 <SaveMasterSecret>:

    AJ_ClearAuthContext();
}

static AJ_Status SaveMasterSecret(const AJ_GUID* peerGuid, uint32_t expiration)
{
    c3c4:	b538      	push	{r3, r4, r5, lr}
    c3c6:	1c04      	adds	r4, r0, #0
    c3c8:	1c0d      	adds	r5, r1, #0
    AJ_Status status;

    printf("SaveMasterSecret(peerGuid=%p, expiration=%d)\n", peerGuid, expiration);
    c3ca:	480f      	ldr	r0, [pc, #60]	; (c408 <SaveMasterSecret+0x44>)
    c3cc:	1c21      	adds	r1, r4, #0
    c3ce:	1c2a      	adds	r2, r5, #0
    c3d0:	4b0e      	ldr	r3, [pc, #56]	; (c40c <SaveMasterSecret+0x48>)
    c3d2:	4798      	blx	r3

    if (peerGuid) 
    c3d4:	2c00      	cmp	r4, #0
    c3d6:	d014      	beq.n	c402 <SaveMasterSecret+0x3e>
	{
        /*
        * If the authentication was succesful write the credentials for the authenticated peer to
        * NVRAM otherwise delete any stale credentials that might be stored.
        */
        if (AJ_AUTH_SUCCESS == peerContext.state) 
    c3d8:	4b0d      	ldr	r3, [pc, #52]	; (c410 <SaveMasterSecret+0x4c>)
    c3da:	781b      	ldrb	r3, [r3, #0]
    c3dc:	2b02      	cmp	r3, #2
    c3de:	d107      	bne.n	c3f0 <SaveMasterSecret+0x2c>
		{
            status = AJ_StorePeerSecret(peerGuid, authContext.mastersecret, AJ_MASTER_SECRET_LEN, expiration);
    c3e0:	1c20      	adds	r0, r4, #0
    c3e2:	490c      	ldr	r1, [pc, #48]	; (c414 <SaveMasterSecret+0x50>)
    c3e4:	31f0      	adds	r1, #240	; 0xf0
    c3e6:	2230      	movs	r2, #48	; 0x30
    c3e8:	1c2b      	adds	r3, r5, #0
    c3ea:	4c0b      	ldr	r4, [pc, #44]	; (c418 <SaveMasterSecret+0x54>)
    c3ec:	47a0      	blx	r4
    c3ee:	e009      	b.n	c404 <SaveMasterSecret+0x40>
        }
		else 
		{
            printf("SaveMasterSecret(peerGuid=%p, expiration=%d): Invalid state\n", peerGuid, expiration);
    c3f0:	480a      	ldr	r0, [pc, #40]	; (c41c <SaveMasterSecret+0x58>)
    c3f2:	1c21      	adds	r1, r4, #0
    c3f4:	1c2a      	adds	r2, r5, #0
    c3f6:	4b05      	ldr	r3, [pc, #20]	; (c40c <SaveMasterSecret+0x48>)
    c3f8:	4798      	blx	r3
            status = AJ_DeletePeerCredential(peerGuid);
    c3fa:	1c20      	adds	r0, r4, #0
    c3fc:	4b08      	ldr	r3, [pc, #32]	; (c420 <SaveMasterSecret+0x5c>)
    c3fe:	4798      	blx	r3
    c400:	e000      	b.n	c404 <SaveMasterSecret+0x40>
        }
    } 
	else 
	{
        status = AJ_ERR_SECURITY;
    c402:	200d      	movs	r0, #13
    }

    return status;
}
    c404:	bd38      	pop	{r3, r4, r5, pc}
    c406:	46c0      	nop			; (mov r8, r8)
    c408:	0001dd1c 	.word	0x0001dd1c
    c40c:	00016e3d 	.word	0x00016e3d
    c410:	20001128 	.word	0x20001128
    c414:	20001000 	.word	0x20001000
    c418:	0000437d 	.word	0x0000437d
    c41c:	0001dd4c 	.word	0x0001dd4c
    c420:	000043f5 	.word	0x000043f5

0000c424 <KeyGen>:
    }
    return REQUIRED_AUTH_VERSION;
}

static AJ_Status KeyGen(const char* peerName, uint8_t role, const char* nonce1, const char* nonce2, uint8_t* outBuf, uint32_t len)
{
    c424:	b5f0      	push	{r4, r5, r6, r7, lr}
    c426:	b08d      	sub	sp, #52	; 0x34
    c428:	1c05      	adds	r5, r0, #0
    c42a:	9005      	str	r0, [sp, #20]
    c42c:	9104      	str	r1, [sp, #16]
    c42e:	1c17      	adds	r7, r2, #0
    c430:	1c1e      	adds	r6, r3, #0
    AJ_Status status;
    const uint8_t* data[4];
    uint8_t lens[4];
    const AJ_GUID* peerGuid = AJ_GUID_Find(peerName);
    c432:	4b35      	ldr	r3, [pc, #212]	; (c508 <KeyGen+0xe4>)
    c434:	4798      	blx	r3
    c436:	1c04      	adds	r4, r0, #0

    printf("KeyGen(peerName=\"%s\", role=%d., nonce1=\"%s\", nonce2=\"%s\", outbuf=%p, len=%d.)\n",
    c438:	9600      	str	r6, [sp, #0]
    c43a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c43c:	9301      	str	r3, [sp, #4]
    c43e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c440:	9302      	str	r3, [sp, #8]
    c442:	4832      	ldr	r0, [pc, #200]	; (c50c <KeyGen+0xe8>)
    c444:	1c29      	adds	r1, r5, #0
    c446:	9a04      	ldr	r2, [sp, #16]
    c448:	1c3b      	adds	r3, r7, #0
    c44a:	4d31      	ldr	r5, [pc, #196]	; (c510 <KeyGen+0xec>)
    c44c:	47a8      	blx	r5
                   peerName, role, nonce1, nonce2, outBuf, len);

    if (NULL == peerGuid)
    c44e:	2c00      	cmp	r4, #0
    c450:	d10d      	bne.n	c46e <KeyGen+0x4a>
	{
        AJ_ErrPrintf(("KeyGen(): AJ_ERR_UNEXPECTED\n"));
    c452:	2001      	movs	r0, #1
    c454:	492f      	ldr	r1, [pc, #188]	; (c514 <KeyGen+0xf0>)
    c456:	227a      	movs	r2, #122	; 0x7a
    c458:	4b2f      	ldr	r3, [pc, #188]	; (c518 <KeyGen+0xf4>)
    c45a:	4798      	blx	r3
    c45c:	1c03      	adds	r3, r0, #0
        return AJ_ERR_UNEXPECTED;
    c45e:	2002      	movs	r0, #2
    printf("KeyGen(peerName=\"%s\", role=%d., nonce1=\"%s\", nonce2=\"%s\", outbuf=%p, len=%d.)\n",
                   peerName, role, nonce1, nonce2, outBuf, len);

    if (NULL == peerGuid)
	{
        AJ_ErrPrintf(("KeyGen(): AJ_ERR_UNEXPECTED\n"));
    c460:	2b00      	cmp	r3, #0
    c462:	d04f      	beq.n	c504 <KeyGen+0xe0>
    c464:	482d      	ldr	r0, [pc, #180]	; (c51c <KeyGen+0xf8>)
    c466:	4b2e      	ldr	r3, [pc, #184]	; (c520 <KeyGen+0xfc>)
    c468:	4798      	blx	r3
        return AJ_ERR_UNEXPECTED;
    c46a:	2002      	movs	r0, #2
    c46c:	e04a      	b.n	c504 <KeyGen+0xe0>
    }

    data[0] = authContext.mastersecret;
    c46e:	4b2d      	ldr	r3, [pc, #180]	; (c524 <KeyGen+0x100>)
    c470:	33f0      	adds	r3, #240	; 0xf0
    c472:	9308      	str	r3, [sp, #32]
    lens[0] = (uint32_t)AJ_MASTER_SECRET_LEN;
    c474:	ac07      	add	r4, sp, #28
    c476:	2330      	movs	r3, #48	; 0x30
    c478:	7023      	strb	r3, [r4, #0]
    data[1] = (uint8_t*)"session key";
    c47a:	4b2b      	ldr	r3, [pc, #172]	; (c528 <KeyGen+0x104>)
    c47c:	9309      	str	r3, [sp, #36]	; 0x24
    lens[1] = 11;
    c47e:	230b      	movs	r3, #11
    c480:	7063      	strb	r3, [r4, #1]
    data[2] = (uint8_t*)nonce1;
    c482:	970a      	str	r7, [sp, #40]	; 0x28
    lens[2] = (uint32_t)strlen(nonce1);
    c484:	1c38      	adds	r0, r7, #0
    c486:	4f29      	ldr	r7, [pc, #164]	; (c52c <KeyGen+0x108>)
    c488:	47b8      	blx	r7
    c48a:	70a0      	strb	r0, [r4, #2]
    data[3] = (uint8_t*)nonce2;
    c48c:	960b      	str	r6, [sp, #44]	; 0x2c
    lens[3] = (uint32_t)strlen(nonce2);
    c48e:	1c30      	adds	r0, r6, #0
    c490:	47b8      	blx	r7
    c492:	70e0      	strb	r0, [r4, #3]

    /*
     * We use the outBuf to store both the key and verifier string.
     * Check that there is enough space to do so.
     */
    if (len < (AES_KEY_LEN + AJ_VERIFIER_LEN))
    c494:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c496:	2b1b      	cmp	r3, #27
    c498:	d80d      	bhi.n	c4b6 <KeyGen+0x92>
	{
        AJ_ErrPrintf(("KeyGen(): AJ_ERR_RESOURCES\n"));
    c49a:	2001      	movs	r0, #1
    c49c:	491d      	ldr	r1, [pc, #116]	; (c514 <KeyGen+0xf0>)
    c49e:	228d      	movs	r2, #141	; 0x8d
    c4a0:	4b1d      	ldr	r3, [pc, #116]	; (c518 <KeyGen+0xf4>)
    c4a2:	4798      	blx	r3
    c4a4:	1c03      	adds	r3, r0, #0
        return AJ_ERR_RESOURCES;
    c4a6:	200b      	movs	r0, #11
     * We use the outBuf to store both the key and verifier string.
     * Check that there is enough space to do so.
     */
    if (len < (AES_KEY_LEN + AJ_VERIFIER_LEN))
	{
        AJ_ErrPrintf(("KeyGen(): AJ_ERR_RESOURCES\n"));
    c4a8:	2b00      	cmp	r3, #0
    c4aa:	d02b      	beq.n	c504 <KeyGen+0xe0>
    c4ac:	4820      	ldr	r0, [pc, #128]	; (c530 <KeyGen+0x10c>)
    c4ae:	4b1c      	ldr	r3, [pc, #112]	; (c520 <KeyGen+0xfc>)
    c4b0:	4798      	blx	r3
        return AJ_ERR_RESOURCES;
    c4b2:	200b      	movs	r0, #11
    c4b4:	e026      	b.n	c504 <KeyGen+0xe0>
    }
    status = AJ_Crypto_PRF_SHA256(data, lens, ArraySize(data), outBuf, AES_KEY_LEN + AJ_VERIFIER_LEN);
    c4b6:	231c      	movs	r3, #28
    c4b8:	9300      	str	r3, [sp, #0]
    c4ba:	a808      	add	r0, sp, #32
    c4bc:	a907      	add	r1, sp, #28
    c4be:	2204      	movs	r2, #4
    c4c0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c4c2:	4c1c      	ldr	r4, [pc, #112]	; (c534 <KeyGen+0x110>)
    c4c4:	47a0      	blx	r4
    c4c6:	1e04      	subs	r4, r0, #0
    // Store the session key and compose the verifier string.
    if (status == AJ_OK) 
    c4c8:	d117      	bne.n	c4fa <KeyGen+0xd6>
	{
        status = AJ_SetSessionKey(peerName, outBuf, role, authContext.version);
    c4ca:	4b16      	ldr	r3, [pc, #88]	; (c524 <KeyGen+0x100>)
    c4cc:	68db      	ldr	r3, [r3, #12]
    c4ce:	9805      	ldr	r0, [sp, #20]
    c4d0:	9912      	ldr	r1, [sp, #72]	; 0x48
    c4d2:	9a04      	ldr	r2, [sp, #16]
    c4d4:	4c18      	ldr	r4, [pc, #96]	; (c538 <KeyGen+0x114>)
    c4d6:	47a0      	blx	r4
    c4d8:	1e04      	subs	r4, r0, #0
    }
    if (status == AJ_OK) 
    c4da:	d10e      	bne.n	c4fa <KeyGen+0xd6>
	{
        memmove(outBuf, outBuf + AES_KEY_LEN, AJ_VERIFIER_LEN);
    c4dc:	9912      	ldr	r1, [sp, #72]	; 0x48
    c4de:	3110      	adds	r1, #16
    c4e0:	9812      	ldr	r0, [sp, #72]	; 0x48
    c4e2:	220c      	movs	r2, #12
    c4e4:	4b15      	ldr	r3, [pc, #84]	; (c53c <KeyGen+0x118>)
    c4e6:	4798      	blx	r3
        status = AJ_RawToHex(outBuf, AJ_VERIFIER_LEN, (char*) outBuf, len, FALSE);
    c4e8:	2300      	movs	r3, #0
    c4ea:	9300      	str	r3, [sp, #0]
    c4ec:	9812      	ldr	r0, [sp, #72]	; 0x48
    c4ee:	210c      	movs	r1, #12
    c4f0:	1c02      	adds	r2, r0, #0
    c4f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c4f4:	4c12      	ldr	r4, [pc, #72]	; (c540 <KeyGen+0x11c>)
    c4f6:	47a0      	blx	r4
    c4f8:	1c04      	adds	r4, r0, #0
    }
	//char dummy[24]="23607A08BDCE4FE100ECB867";
	//memcpy(outBuf,dummy,sizeof(dummy));
    printf("KeyGen Verifier = %s\n", outBuf);
    c4fa:	4812      	ldr	r0, [pc, #72]	; (c544 <KeyGen+0x120>)
    c4fc:	9912      	ldr	r1, [sp, #72]	; 0x48
    c4fe:	4b04      	ldr	r3, [pc, #16]	; (c510 <KeyGen+0xec>)
    c500:	4798      	blx	r3
    return status;
    c502:	1c20      	adds	r0, r4, #0
}
    c504:	b00d      	add	sp, #52	; 0x34
    c506:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c508:	00007bdd 	.word	0x00007bdd
    c50c:	0001dd8c 	.word	0x0001dd8c
    c510:	00016e3d 	.word	0x00016e3d
    c514:	0001dddc 	.word	0x0001dddc
    c518:	0000636d 	.word	0x0000636d
    c51c:	0001de04 	.word	0x0001de04
    c520:	00016f5d 	.word	0x00016f5d
    c524:	20001000 	.word	0x20001000
    c528:	0001de20 	.word	0x0001de20
    c52c:	0001715b 	.word	0x0001715b
    c530:	0001de2c 	.word	0x0001de2c
    c534:	00006299 	.word	0x00006299
    c538:	00007c35 	.word	0x00007c35
    c53c:	00016739 	.word	0x00016739
    c540:	0000d86d 	.word	0x0000d86d
    c544:	0001de48 	.word	0x0001de48

0000c548 <AJ_ClearAuthContext>:

void AJ_ClearAuthContext()
{
    c548:	b510      	push	{r4, lr}
    memset(&peerContext, 0, sizeof (PeerContext));
    c54a:	4805      	ldr	r0, [pc, #20]	; (c560 <AJ_ClearAuthContext+0x18>)
    c54c:	2100      	movs	r1, #0
    c54e:	2258      	movs	r2, #88	; 0x58
    c550:	4c04      	ldr	r4, [pc, #16]	; (c564 <AJ_ClearAuthContext+0x1c>)
    c552:	47a0      	blx	r4
    memset(&authContext, 0, sizeof (AJ_AuthenticationContext));
    c554:	4804      	ldr	r0, [pc, #16]	; (c568 <AJ_ClearAuthContext+0x20>)
    c556:	2100      	movs	r1, #0
    c558:	2294      	movs	r2, #148	; 0x94
    c55a:	0052      	lsls	r2, r2, #1
    c55c:	47a0      	blx	r4
}
    c55e:	bd10      	pop	{r4, pc}
    c560:	20001128 	.word	0x20001128
    c564:	00016773 	.word	0x00016773
    c568:	20001000 	.word	0x20001000

0000c56c <HandshakeComplete>:

static void HandshakeComplete(AJ_Status status)
{
    c56c:	b508      	push	{r3, lr}
    c56e:	1c01      	adds	r1, r0, #0

 //   AJ_InfoPrintf(("HandshakeComplete(status=%d.)\n", status));

    if (peerContext.callback) 
    c570:	4b04      	ldr	r3, [pc, #16]	; (c584 <HandshakeComplete+0x18>)
    c572:	685b      	ldr	r3, [r3, #4]
    c574:	2b00      	cmp	r3, #0
    c576:	d002      	beq.n	c57e <HandshakeComplete+0x12>
	{
        peerContext.callback(peerContext.cbContext, status);
    c578:	4a02      	ldr	r2, [pc, #8]	; (c584 <HandshakeComplete+0x18>)
    c57a:	6890      	ldr	r0, [r2, #8]
    c57c:	4798      	blx	r3
    }

    AJ_ClearAuthContext();
    c57e:	4b02      	ldr	r3, [pc, #8]	; (c588 <HandshakeComplete+0x1c>)
    c580:	4798      	blx	r3
}
    c582:	bd08      	pop	{r3, pc}
    c584:	20001128 	.word	0x20001128
    c588:	0000c549 	.word	0x0000c549

0000c58c <HandshakeTimeout>:

    return status;
}

static AJ_Status HandshakeTimeout() 
{
    c58c:	b570      	push	{r4, r5, r6, lr}
    c58e:	b084      	sub	sp, #16
    uint8_t zero[sizeof (AJ_GUID)];
    memset(zero, 0, sizeof (zero));
    c590:	2300      	movs	r3, #0
    c592:	9300      	str	r3, [sp, #0]
    c594:	9301      	str	r3, [sp, #4]
    c596:	9302      	str	r3, [sp, #8]
    c598:	9303      	str	r3, [sp, #12]
    /*
     * If handshake started, check peer is still around
     * If peer disappeared, AJ_GUID_DeleteNameMapping writes zeros
     */
	printf("peerContext.peerGuid= %x\n",peerContext.peerGuid);
    c59a:	4c1d      	ldr	r4, [pc, #116]	; (c610 <HandshakeTimeout+0x84>)
    c59c:	481d      	ldr	r0, [pc, #116]	; (c614 <HandshakeTimeout+0x88>)
    c59e:	68e1      	ldr	r1, [r4, #12]
    c5a0:	4b1d      	ldr	r3, [pc, #116]	; (c618 <HandshakeTimeout+0x8c>)
    c5a2:	4798      	blx	r3
    if (peerContext.peerGuid)
    c5a4:	68e0      	ldr	r0, [r4, #12]
    c5a6:	2800      	cmp	r0, #0
    c5a8:	d010      	beq.n	c5cc <HandshakeTimeout+0x40>
	{
        if (!memcmp(peerContext.peerGuid, zero, sizeof (zero))) 
    c5aa:	4669      	mov	r1, sp
    c5ac:	2210      	movs	r2, #16
    c5ae:	4b1b      	ldr	r3, [pc, #108]	; (c61c <HandshakeTimeout+0x90>)
    c5b0:	4798      	blx	r3
    c5b2:	2800      	cmp	r0, #0
    c5b4:	d10a      	bne.n	c5cc <HandshakeTimeout+0x40>
		{
            printf("AJ_HandshakeTimeout(): Peer disappeared\n");
    c5b6:	481a      	ldr	r0, [pc, #104]	; (c620 <HandshakeTimeout+0x94>)
    c5b8:	4b1a      	ldr	r3, [pc, #104]	; (c624 <HandshakeTimeout+0x98>)
    c5ba:	4798      	blx	r3
            peerContext.peerGuid = NULL;
    c5bc:	2200      	movs	r2, #0
    c5be:	4b14      	ldr	r3, [pc, #80]	; (c610 <HandshakeTimeout+0x84>)
    c5c0:	60da      	str	r2, [r3, #12]
            HandshakeComplete(AJ_ERR_TIMEOUT);
    c5c2:	2007      	movs	r0, #7
    c5c4:	4b18      	ldr	r3, [pc, #96]	; (c628 <HandshakeTimeout+0x9c>)
    c5c6:	4798      	blx	r3
            return AJ_ERR_TIMEOUT;
    c5c8:	2007      	movs	r0, #7
    c5ca:	e01e      	b.n	c60a <HandshakeTimeout+0x7e>
        }
    }
	printf("AJ_GetElapsedTime(&peerContext.timer, TRUE) = %d\n", AJ_GetElapsedTime(&peerContext.timer, TRUE));
    c5cc:	4c10      	ldr	r4, [pc, #64]	; (c610 <HandshakeTimeout+0x84>)
    c5ce:	3414      	adds	r4, #20
    c5d0:	1c20      	adds	r0, r4, #0
    c5d2:	2101      	movs	r1, #1
    c5d4:	4d15      	ldr	r5, [pc, #84]	; (c62c <HandshakeTimeout+0xa0>)
    c5d6:	47a8      	blx	r5
    c5d8:	1c01      	adds	r1, r0, #0
    c5da:	4815      	ldr	r0, [pc, #84]	; (c630 <HandshakeTimeout+0xa4>)
    c5dc:	4e0e      	ldr	r6, [pc, #56]	; (c618 <HandshakeTimeout+0x8c>)
    c5de:	47b0      	blx	r6
	printf("AJ_MAX_AUTH_TIME = %d\n", AJ_MAX_AUTH_TIME);
    c5e0:	4814      	ldr	r0, [pc, #80]	; (c634 <HandshakeTimeout+0xa8>)
    c5e2:	4915      	ldr	r1, [pc, #84]	; (c638 <HandshakeTimeout+0xac>)
    c5e4:	47b0      	blx	r6
    if (AJ_GetElapsedTime(&peerContext.timer, TRUE) >= AJ_MAX_AUTH_TIME) 
    c5e6:	1c20      	adds	r0, r4, #0
    c5e8:	2101      	movs	r1, #1
    c5ea:	47a8      	blx	r5
    c5ec:	4b13      	ldr	r3, [pc, #76]	; (c63c <HandshakeTimeout+0xb0>)
    c5ee:	4298      	cmp	r0, r3
    c5f0:	d907      	bls.n	c602 <HandshakeTimeout+0x76>
	{
        printf("AJ_HandshakeTimeout(): AJ_ERR_TIMEOUT\n");
    c5f2:	4813      	ldr	r0, [pc, #76]	; (c640 <HandshakeTimeout+0xb4>)
    c5f4:	4b0b      	ldr	r3, [pc, #44]	; (c624 <HandshakeTimeout+0x98>)
    c5f6:	4798      	blx	r3
        HandshakeComplete(AJ_ERR_TIMEOUT);
    c5f8:	2007      	movs	r0, #7
    c5fa:	4b0b      	ldr	r3, [pc, #44]	; (c628 <HandshakeTimeout+0x9c>)
    c5fc:	4798      	blx	r3
        return AJ_ERR_TIMEOUT;
    c5fe:	2007      	movs	r0, #7
    c600:	e003      	b.n	c60a <HandshakeTimeout+0x7e>
    }
	printf("AJ_HandshakeTimeout(): AJ_OK\n");
    c602:	4810      	ldr	r0, [pc, #64]	; (c644 <HandshakeTimeout+0xb8>)
    c604:	4b07      	ldr	r3, [pc, #28]	; (c624 <HandshakeTimeout+0x98>)
    c606:	4798      	blx	r3
    return AJ_OK;
    c608:	2000      	movs	r0, #0
}
    c60a:	b004      	add	sp, #16
    c60c:	bd70      	pop	{r4, r5, r6, pc}
    c60e:	46c0      	nop			; (mov r8, r8)
    c610:	20001128 	.word	0x20001128
    c614:	0001de60 	.word	0x0001de60
    c618:	00016e3d 	.word	0x00016e3d
    c61c:	0001671b 	.word	0x0001671b
    c620:	0001de7c 	.word	0x0001de7c
    c624:	00016f5d 	.word	0x00016f5d
    c628:	0000c56d 	.word	0x0000c56d
    c62c:	0000d769 	.word	0x0000d769
    c630:	0001dea4 	.word	0x0001dea4
    c634:	0001ded8 	.word	0x0001ded8
    c638:	000493e0 	.word	0x000493e0
    c63c:	000493df 	.word	0x000493df
    c640:	0001def0 	.word	0x0001def0
    c644:	0001df18 	.word	0x0001df18

0000c648 <HandshakeValid>:

static AJ_Status HandshakeValid(const AJ_GUID* peerGuid)
{
    c648:	b510      	push	{r4, lr}
    c64a:	1c02      	adds	r2, r0, #0
    // Handshake not yet started
    if (!peerContext.peerGuid) 
    c64c:	4b0b      	ldr	r3, [pc, #44]	; (c67c <HandshakeValid+0x34>)
    c64e:	68db      	ldr	r3, [r3, #12]
	{
  //      AJ_InfoPrintf(("AJ_HandshakeValid(peerGuid=%p): Invalid peer guid\n", peerGuid));
        return AJ_ERR_SECURITY;
    c650:	200d      	movs	r0, #13
}

static AJ_Status HandshakeValid(const AJ_GUID* peerGuid)
{
    // Handshake not yet started
    if (!peerContext.peerGuid) 
    c652:	2b00      	cmp	r3, #0
    c654:	d010      	beq.n	c678 <HandshakeValid+0x30>
    c656:	1c14      	adds	r4, r2, #0
	{
  //      AJ_InfoPrintf(("AJ_HandshakeValid(peerGuid=%p): Invalid peer guid\n", peerGuid));
        return AJ_ERR_SECURITY;
    }
    // Handshake timed out
    if (AJ_OK != HandshakeTimeout()) 
    c658:	4b09      	ldr	r3, [pc, #36]	; (c680 <HandshakeValid+0x38>)
    c65a:	4798      	blx	r3
    c65c:	2800      	cmp	r0, #0
    c65e:	d106      	bne.n	c66e <HandshakeValid+0x26>
	{
     //   AJ_InfoPrintf(("AJ_HandshakeValid(peerGuid=%p): Handshake timed out\n", peerGuid));
        return AJ_ERR_TIMEOUT;
    }
    // Handshake call from different peer
    if (!peerGuid || (peerGuid != peerContext.peerGuid)) 
    c660:	2c00      	cmp	r4, #0
    c662:	d006      	beq.n	c672 <HandshakeValid+0x2a>
    c664:	4b05      	ldr	r3, [pc, #20]	; (c67c <HandshakeValid+0x34>)
    c666:	68db      	ldr	r3, [r3, #12]
    c668:	42a3      	cmp	r3, r4
    c66a:	d104      	bne.n	c676 <HandshakeValid+0x2e>
    c66c:	e004      	b.n	c678 <HandshakeValid+0x30>
    }
    // Handshake timed out
    if (AJ_OK != HandshakeTimeout()) 
	{
     //   AJ_InfoPrintf(("AJ_HandshakeValid(peerGuid=%p): Handshake timed out\n", peerGuid));
        return AJ_ERR_TIMEOUT;
    c66e:	2007      	movs	r0, #7
    c670:	e002      	b.n	c678 <HandshakeValid+0x30>
    }
    // Handshake call from different peer
    if (!peerGuid || (peerGuid != peerContext.peerGuid)) 
	{
     //   AJ_WarnPrintf(("AJ_HandshakeValid(peerGuid=%p): Invalid peer guid\n", peerGuid));
        return AJ_ERR_RESOURCES;
    c672:	200b      	movs	r0, #11
    c674:	e000      	b.n	c678 <HandshakeValid+0x30>
    c676:	200b      	movs	r0, #11
    }

    return AJ_OK;
}
    c678:	bd10      	pop	{r4, pc}
    c67a:	46c0      	nop			; (mov r8, r8)
    c67c:	20001128 	.word	0x20001128
    c680:	0000c58d 	.word	0x0000c58d

0000c684 <AJ_PeerHandleExchangeGUIDs>:
    return AJ_OK;
#endif
}

AJ_Status AJ_PeerHandleExchangeGUIDs(AJ_Message* msg, AJ_Message* reply)
{
    c684:	b5f0      	push	{r4, r5, r6, r7, lr}
    c686:	b095      	sub	sp, #84	; 0x54
    c688:	1c04      	adds	r4, r0, #0
    c68a:	1c0d      	adds	r5, r1, #0
    AJ_GUID localGuid;
	//bf a9 aa 3f
	// 2e ce 2e fd 
	// a2 1b b5 b1 
	//63 2b 4f 77
	localGuid.val[0]=0xbf;
    c68c:	ab02      	add	r3, sp, #8
    c68e:	22bf      	movs	r2, #191	; 0xbf
    c690:	701a      	strb	r2, [r3, #0]
	localGuid.val[1]=0xa9;
    c692:	3a16      	subs	r2, #22
    c694:	705a      	strb	r2, [r3, #1]
	localGuid.val[2]=0xaa;
    c696:	3201      	adds	r2, #1
    c698:	709a      	strb	r2, [r3, #2]
	localGuid.val[3]=0x3f;
    c69a:	3a6b      	subs	r2, #107	; 0x6b
    c69c:	70da      	strb	r2, [r3, #3]
	
	localGuid.val[4]=0x2e;
    c69e:	3a11      	subs	r2, #17
    c6a0:	711a      	strb	r2, [r3, #4]
	localGuid.val[5]=0xce;
    c6a2:	21ce      	movs	r1, #206	; 0xce
    c6a4:	7159      	strb	r1, [r3, #5]
	localGuid.val[6]=0x2e;
    c6a6:	719a      	strb	r2, [r3, #6]
	localGuid.val[7]=0xfd;
    c6a8:	32cf      	adds	r2, #207	; 0xcf
    c6aa:	71da      	strb	r2, [r3, #7]
	
	localGuid.val[8]=0xa2;
    c6ac:	3a5b      	subs	r2, #91	; 0x5b
    c6ae:	721a      	strb	r2, [r3, #8]
	localGuid.val[9]=0x1b;
    c6b0:	3a87      	subs	r2, #135	; 0x87
    c6b2:	725a      	strb	r2, [r3, #9]
	localGuid.val[10]=0xb5;
    c6b4:	329a      	adds	r2, #154	; 0x9a
    c6b6:	729a      	strb	r2, [r3, #10]
	localGuid.val[11]=0xb1;
    c6b8:	3a04      	subs	r2, #4
    c6ba:	72da      	strb	r2, [r3, #11]
	
	localGuid.val[12]=0x63;
    c6bc:	3a4e      	subs	r2, #78	; 0x4e
    c6be:	731a      	strb	r2, [r3, #12]
	localGuid.val[13]=0x2b;
    c6c0:	3a38      	subs	r2, #56	; 0x38
    c6c2:	735a      	strb	r2, [r3, #13]
	localGuid.val[14]=0x4f;
    c6c4:	3224      	adds	r2, #36	; 0x24
    c6c6:	739a      	strb	r2, [r3, #14]
	localGuid.val[15]=0x77;
    c6c8:	3228      	adds	r2, #40	; 0x28
    c6ca:	73da      	strb	r2, [r3, #15]
                                            
    AJ_PeerCred* cred;

    printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p)\n", msg, reply);
    c6cc:	486d      	ldr	r0, [pc, #436]	; (c884 <AJ_PeerHandleExchangeGUIDs+0x200>)
    c6ce:	1c21      	adds	r1, r4, #0
    c6d0:	1c2a      	adds	r2, r5, #0
    c6d2:	4b6d      	ldr	r3, [pc, #436]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c6d4:	4798      	blx	r3

    // If handshake in progress and not timed-out
    if (peerContext.peerGuid) 
    c6d6:	4b6d      	ldr	r3, [pc, #436]	; (c88c <AJ_PeerHandleExchangeGUIDs+0x208>)
    c6d8:	68db      	ldr	r3, [r3, #12]
    c6da:	2b00      	cmp	r3, #0
    c6dc:	d011      	beq.n	c702 <AJ_PeerHandleExchangeGUIDs+0x7e>
	{
		printf("AJ_PeerHandleExchangeGuids if (peerContext.peerGuid) \n");
    c6de:	486c      	ldr	r0, [pc, #432]	; (c890 <AJ_PeerHandleExchangeGUIDs+0x20c>)
    c6e0:	4b6c      	ldr	r3, [pc, #432]	; (c894 <AJ_PeerHandleExchangeGUIDs+0x210>)
    c6e2:	4798      	blx	r3
        status = HandshakeTimeout();
    c6e4:	4b6c      	ldr	r3, [pc, #432]	; (c898 <AJ_PeerHandleExchangeGUIDs+0x214>)
    c6e6:	4798      	blx	r3
        if (AJ_ERR_TIMEOUT != status)
    c6e8:	2807      	cmp	r0, #7
    c6ea:	d00a      	beq.n	c702 <AJ_PeerHandleExchangeGUIDs+0x7e>
		{
            printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p): Handshake in progress\n", msg, reply);
    c6ec:	486b      	ldr	r0, [pc, #428]	; (c89c <AJ_PeerHandleExchangeGUIDs+0x218>)
    c6ee:	1c21      	adds	r1, r4, #0
    c6f0:	1c2a      	adds	r2, r5, #0
    c6f2:	4b65      	ldr	r3, [pc, #404]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c6f4:	4798      	blx	r3
            return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    c6f6:	1c20      	adds	r0, r4, #0
    c6f8:	1c29      	adds	r1, r5, #0
    c6fa:	4a69      	ldr	r2, [pc, #420]	; (c8a0 <AJ_PeerHandleExchangeGUIDs+0x21c>)
    c6fc:	4b69      	ldr	r3, [pc, #420]	; (c8a4 <AJ_PeerHandleExchangeGUIDs+0x220>)
    c6fe:	4798      	blx	r3
    c700:	e0bd      	b.n	c87e <AJ_PeerHandleExchangeGUIDs+0x1fa>
        }
    }

    // No handshake in progress or previous timed-out
    AJ_ClearAuthContext();
    c702:	4b69      	ldr	r3, [pc, #420]	; (c8a8 <AJ_PeerHandleExchangeGUIDs+0x224>)
    c704:	4798      	blx	r3
    AJ_InitTimer(&peerContext.timer);
    c706:	4861      	ldr	r0, [pc, #388]	; (c88c <AJ_PeerHandleExchangeGUIDs+0x208>)
    c708:	3014      	adds	r0, #20
    c70a:	4b68      	ldr	r3, [pc, #416]	; (c8ac <AJ_PeerHandleExchangeGUIDs+0x228>)
    c70c:	4798      	blx	r3
    authContext.bus = msg->bus;
    c70e:	4868      	ldr	r0, [pc, #416]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c710:	6b23      	ldr	r3, [r4, #48]	; 0x30
    c712:	6003      	str	r3, [r0, #0]
    authContext.role = AUTH_SERVER;
    c714:	2301      	movs	r3, #1
    c716:	7103      	strb	r3, [r0, #4]
    AJ_SHA256_Init(&authContext.hash);
    c718:	3010      	adds	r0, #16
    c71a:	4b66      	ldr	r3, [pc, #408]	; (c8b4 <AJ_PeerHandleExchangeGUIDs+0x230>)
    c71c:	4798      	blx	r3
    if (msg->bus->pwdCallback)
    c71e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    c720:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    c722:	2b00      	cmp	r3, #0
    c724:	d002      	beq.n	c72c <AJ_PeerHandleExchangeGUIDs+0xa8>
	{
        AJ_EnableSuite(AUTH_SUITE_ECDHE_PSK);
    c726:	4864      	ldr	r0, [pc, #400]	; (c8b8 <AJ_PeerHandleExchangeGUIDs+0x234>)
    c728:	4b64      	ldr	r3, [pc, #400]	; (c8bc <AJ_PeerHandleExchangeGUIDs+0x238>)
    c72a:	4798      	blx	r3
    }

    status = AJ_UnmarshalArgs(msg, "su", &str, &authContext.version);
    c72c:	1c20      	adds	r0, r4, #0
    c72e:	4964      	ldr	r1, [pc, #400]	; (c8c0 <AJ_PeerHandleExchangeGUIDs+0x23c>)
    c730:	aa0a      	add	r2, sp, #40	; 0x28
    c732:	4b5f      	ldr	r3, [pc, #380]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c734:	330c      	adds	r3, #12
    c736:	4e63      	ldr	r6, [pc, #396]	; (c8c4 <AJ_PeerHandleExchangeGUIDs+0x240>)
    c738:	47b0      	blx	r6
    if (AJ_OK != status)
    c73a:	2800      	cmp	r0, #0
    c73c:	d00d      	beq.n	c75a <AJ_PeerHandleExchangeGUIDs+0xd6>
	{
		printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p): Unmarshal error\n", msg, reply);
    c73e:	4862      	ldr	r0, [pc, #392]	; (c8c8 <AJ_PeerHandleExchangeGUIDs+0x244>)
    c740:	1c21      	adds	r1, r4, #0
    c742:	1c2a      	adds	r2, r5, #0
    c744:	4b50      	ldr	r3, [pc, #320]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c746:	4798      	blx	r3
        HandshakeComplete(AJ_ERR_SECURITY);
    c748:	200d      	movs	r0, #13
    c74a:	4b60      	ldr	r3, [pc, #384]	; (c8cc <AJ_PeerHandleExchangeGUIDs+0x248>)
    c74c:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    c74e:	1c20      	adds	r0, r4, #0
    c750:	1c29      	adds	r1, r5, #0
    c752:	4a5f      	ldr	r2, [pc, #380]	; (c8d0 <AJ_PeerHandleExchangeGUIDs+0x24c>)
    c754:	4b53      	ldr	r3, [pc, #332]	; (c8a4 <AJ_PeerHandleExchangeGUIDs+0x220>)
    c756:	4798      	blx	r3
    c758:	e091      	b.n	c87e <AJ_PeerHandleExchangeGUIDs+0x1fa>
    }
    status = AJ_GUID_FromString(&remoteGuid, str);
    c75a:	a806      	add	r0, sp, #24
    c75c:	990a      	ldr	r1, [sp, #40]	; 0x28
    c75e:	4b5d      	ldr	r3, [pc, #372]	; (c8d4 <AJ_PeerHandleExchangeGUIDs+0x250>)
    c760:	4798      	blx	r3
    c762:	1c06      	adds	r6, r0, #0
	printf("AJ_GUID_FromString: str=%s\n",str);
    c764:	485c      	ldr	r0, [pc, #368]	; (c8d8 <AJ_PeerHandleExchangeGUIDs+0x254>)
    c766:	990a      	ldr	r1, [sp, #40]	; 0x28
    c768:	4b47      	ldr	r3, [pc, #284]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c76a:	4798      	blx	r3
    if (AJ_OK != status) 
    c76c:	2e00      	cmp	r6, #0
    c76e:	d00d      	beq.n	c78c <AJ_PeerHandleExchangeGUIDs+0x108>
	{
		printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p): Invalid GUID\n", msg, reply);
    c770:	485a      	ldr	r0, [pc, #360]	; (c8dc <AJ_PeerHandleExchangeGUIDs+0x258>)
    c772:	1c21      	adds	r1, r4, #0
    c774:	1c2a      	adds	r2, r5, #0
    c776:	4b44      	ldr	r3, [pc, #272]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c778:	4798      	blx	r3
        HandshakeComplete(AJ_ERR_SECURITY);
    c77a:	200d      	movs	r0, #13
    c77c:	4b53      	ldr	r3, [pc, #332]	; (c8cc <AJ_PeerHandleExchangeGUIDs+0x248>)
    c77e:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    c780:	1c20      	adds	r0, r4, #0
    c782:	1c29      	adds	r1, r5, #0
    c784:	4a52      	ldr	r2, [pc, #328]	; (c8d0 <AJ_PeerHandleExchangeGUIDs+0x24c>)
    c786:	4b47      	ldr	r3, [pc, #284]	; (c8a4 <AJ_PeerHandleExchangeGUIDs+0x220>)
    c788:	4798      	blx	r3
    c78a:	e078      	b.n	c87e <AJ_PeerHandleExchangeGUIDs+0x1fa>
    }
    status = AJ_GUID_AddNameMapping(msg->bus, &remoteGuid, msg->sender, NULL);
    c78c:	6b20      	ldr	r0, [r4, #48]	; 0x30
    c78e:	a906      	add	r1, sp, #24
    c790:	6962      	ldr	r2, [r4, #20]
    c792:	2300      	movs	r3, #0
    c794:	4e52      	ldr	r6, [pc, #328]	; (c8e0 <AJ_PeerHandleExchangeGUIDs+0x25c>)
    c796:	47b0      	blx	r6
    if (AJ_OK != status) 
    c798:	2800      	cmp	r0, #0
    c79a:	d00d      	beq.n	c7b8 <AJ_PeerHandleExchangeGUIDs+0x134>
	{
	    printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p): Add name mapping error\n", msg, reply);
    c79c:	4851      	ldr	r0, [pc, #324]	; (c8e4 <AJ_PeerHandleExchangeGUIDs+0x260>)
    c79e:	1c21      	adds	r1, r4, #0
    c7a0:	1c2a      	adds	r2, r5, #0
    c7a2:	4b39      	ldr	r3, [pc, #228]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c7a4:	4798      	blx	r3
        HandshakeComplete(AJ_ERR_RESOURCES);
    c7a6:	200b      	movs	r0, #11
    c7a8:	4b48      	ldr	r3, [pc, #288]	; (c8cc <AJ_PeerHandleExchangeGUIDs+0x248>)
    c7aa:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    c7ac:	1c20      	adds	r0, r4, #0
    c7ae:	1c29      	adds	r1, r5, #0
    c7b0:	4a3b      	ldr	r2, [pc, #236]	; (c8a0 <AJ_PeerHandleExchangeGUIDs+0x21c>)
    c7b2:	4b3c      	ldr	r3, [pc, #240]	; (c8a4 <AJ_PeerHandleExchangeGUIDs+0x220>)
    c7b4:	4798      	blx	r3
    c7b6:	e062      	b.n	c87e <AJ_PeerHandleExchangeGUIDs+0x1fa>
    }
	printf("AJ_GUID_Find peerContext.peerGuid= %d\n",peerContext.peerGuid);
    c7b8:	4e34      	ldr	r6, [pc, #208]	; (c88c <AJ_PeerHandleExchangeGUIDs+0x208>)
    c7ba:	484b      	ldr	r0, [pc, #300]	; (c8e8 <AJ_PeerHandleExchangeGUIDs+0x264>)
    c7bc:	68f1      	ldr	r1, [r6, #12]
    c7be:	4f32      	ldr	r7, [pc, #200]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c7c0:	47b8      	blx	r7
    peerContext.peerGuid = AJ_GUID_Find(msg->sender);
    c7c2:	6960      	ldr	r0, [r4, #20]
    c7c4:	4b49      	ldr	r3, [pc, #292]	; (c8ec <AJ_PeerHandleExchangeGUIDs+0x268>)
    c7c6:	4798      	blx	r3
    c7c8:	60f0      	str	r0, [r6, #12]

    //If we have a mastersecret stored - use it
     
    status = AJ_GetPeerCredential(peerContext.peerGuid, &cred);
    c7ca:	a901      	add	r1, sp, #4
    c7cc:	4b48      	ldr	r3, [pc, #288]	; (c8f0 <AJ_PeerHandleExchangeGUIDs+0x26c>)
    c7ce:	4798      	blx	r3
    c7d0:	1c06      	adds	r6, r0, #0
	printf("AJ_GUID_Find  AJ_GetPeerCredential status= %s\n",AJ_StatusText(status));
    c7d2:	4b48      	ldr	r3, [pc, #288]	; (c8f4 <AJ_PeerHandleExchangeGUIDs+0x270>)
    c7d4:	4798      	blx	r3
    c7d6:	1c01      	adds	r1, r0, #0
    c7d8:	4847      	ldr	r0, [pc, #284]	; (c8f8 <AJ_PeerHandleExchangeGUIDs+0x274>)
    c7da:	47b8      	blx	r7
    if (AJ_OK == status)
    c7dc:	2e00      	cmp	r6, #0
    c7de:	d11d      	bne.n	c81c <AJ_PeerHandleExchangeGUIDs+0x198>
	 {
        status = AJ_CredentialExpired(cred);
    c7e0:	9801      	ldr	r0, [sp, #4]
    c7e2:	4b46      	ldr	r3, [pc, #280]	; (c8fc <AJ_PeerHandleExchangeGUIDs+0x278>)
    c7e4:	4798      	blx	r3
    c7e6:	1c06      	adds	r6, r0, #0
		printf("AJ_GUID_Find  AJ_CredentialExpired status= %s\n",AJ_StatusText(status));
    c7e8:	4b42      	ldr	r3, [pc, #264]	; (c8f4 <AJ_PeerHandleExchangeGUIDs+0x270>)
    c7ea:	4798      	blx	r3
    c7ec:	1c01      	adds	r1, r0, #0
    c7ee:	4844      	ldr	r0, [pc, #272]	; (c900 <AJ_PeerHandleExchangeGUIDs+0x27c>)
    c7f0:	4b25      	ldr	r3, [pc, #148]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c7f2:	4798      	blx	r3
        if (AJ_ERR_KEY_EXPIRED != status) 
    c7f4:	2e23      	cmp	r6, #35	; 0x23
    c7f6:	d00a      	beq.n	c80e <AJ_PeerHandleExchangeGUIDs+0x18a>
		{
            //secret not expired or time unknown 
            peerContext.state = AJ_AUTH_SUCCESS;
    c7f8:	2202      	movs	r2, #2
    c7fa:	4b24      	ldr	r3, [pc, #144]	; (c88c <AJ_PeerHandleExchangeGUIDs+0x208>)
    c7fc:	701a      	strb	r2, [r3, #0]
            // assert that MASTER_SECRET_LEN == cred->dataLen 
            memcpy(authContext.mastersecret, cred->data, cred->dataLen);
    c7fe:	9b01      	ldr	r3, [sp, #4]
    c800:	8a9a      	ldrh	r2, [r3, #20]
    c802:	6999      	ldr	r1, [r3, #24]
    c804:	482a      	ldr	r0, [pc, #168]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c806:	30f0      	adds	r0, #240	; 0xf0
    c808:	4b3e      	ldr	r3, [pc, #248]	; (c904 <AJ_PeerHandleExchangeGUIDs+0x280>)
    c80a:	4798      	blx	r3
    c80c:	e003      	b.n	c816 <AJ_PeerHandleExchangeGUIDs+0x192>
        } 
		else 
		{
            AJ_DeletePeerCredential(peerContext.peerGuid);
    c80e:	4b1f      	ldr	r3, [pc, #124]	; (c88c <AJ_PeerHandleExchangeGUIDs+0x208>)
    c810:	68d8      	ldr	r0, [r3, #12]
    c812:	4b3d      	ldr	r3, [pc, #244]	; (c908 <AJ_PeerHandleExchangeGUIDs+0x284>)
    c814:	4798      	blx	r3
        }
        AJ_FreeCredential(cred);
    c816:	9801      	ldr	r0, [sp, #4]
    c818:	4b3c      	ldr	r3, [pc, #240]	; (c90c <AJ_PeerHandleExchangeGUIDs+0x288>)
    c81a:	4798      	blx	r3
    }

    // We are not currently negotiating versions so we tell the peer what version we require.
    authContext.version = GetAcceptableVersion(authContext.version);
    c81c:	4b24      	ldr	r3, [pc, #144]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c81e:	68da      	ldr	r2, [r3, #12]
static PeerContext peerContext;
static AJ_AuthenticationContext authContext;

static uint32_t GetAcceptableVersion(uint32_t srcV)
{
    uint16_t authV = srcV >> 16;
    c820:	0c11      	lsrs	r1, r2, #16
    uint16_t keyV = srcV & 0xFFFF;

    if ((authV < MIN_AUTH_VERSION) || (authV > MAX_AUTH_VERSION)) 
    c822:	1e8b      	subs	r3, r1, #2
    c824:	b29b      	uxth	r3, r3
    c826:	2b01      	cmp	r3, #1
    c828:	d806      	bhi.n	c838 <AJ_PeerHandleExchangeGUIDs+0x1b4>
	{
        return 0;
    }
    if (keyV > MAX_KEYGEN_VERSION) 
    c82a:	b293      	uxth	r3, r2
    c82c:	2b00      	cmp	r3, #0
    c82e:	d103      	bne.n	c838 <AJ_PeerHandleExchangeGUIDs+0x1b4>
	{
        return 0;
    }

    if (authV < MAX_AUTH_VERSION)
    c830:	2902      	cmp	r1, #2
    c832:	d81f      	bhi.n	c874 <AJ_PeerHandleExchangeGUIDs+0x1f0>
        AJ_FreeCredential(cred);
    }

    // We are not currently negotiating versions so we tell the peer what version we require.
    authContext.version = GetAcceptableVersion(authContext.version);
    if (0 == authContext.version)
    c834:	2a00      	cmp	r2, #0
    c836:	d103      	bne.n	c840 <AJ_PeerHandleExchangeGUIDs+0x1bc>
   {
        authContext.version = REQUIRED_AUTH_VERSION;
    c838:	22c0      	movs	r2, #192	; 0xc0
    c83a:	0292      	lsls	r2, r2, #10
    c83c:	4b1c      	ldr	r3, [pc, #112]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c83e:	60da      	str	r2, [r3, #12]
    }
	printf("AJ_PeerHandleExchangeGuids(msg=%p, reply=%p): Version %x\n", msg, reply, authContext.version);
    c840:	4e1b      	ldr	r6, [pc, #108]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c842:	4833      	ldr	r0, [pc, #204]	; (c910 <AJ_PeerHandleExchangeGUIDs+0x28c>)
    c844:	1c21      	adds	r1, r4, #0
    c846:	1c2a      	adds	r2, r5, #0
    c848:	68f3      	ldr	r3, [r6, #12]
    c84a:	4f0f      	ldr	r7, [pc, #60]	; (c888 <AJ_PeerHandleExchangeGUIDs+0x204>)
    c84c:	47b8      	blx	r7

    AJ_MarshalReplyMsg(msg, reply);
    c84e:	1c20      	adds	r0, r4, #0
    c850:	1c29      	adds	r1, r5, #0
    c852:	4b30      	ldr	r3, [pc, #192]	; (c914 <AJ_PeerHandleExchangeGUIDs+0x290>)
    c854:	4798      	blx	r3
    AJ_GetLocalGUID(&localGuid);
    c856:	a802      	add	r0, sp, #8
    c858:	4b2f      	ldr	r3, [pc, #188]	; (c918 <AJ_PeerHandleExchangeGUIDs+0x294>)
    c85a:	4798      	blx	r3
    AJ_GUID_ToString(&localGuid, guidStr, sizeof(guidStr));
    c85c:	a802      	add	r0, sp, #8
    c85e:	a90b      	add	r1, sp, #44	; 0x2c
    c860:	2221      	movs	r2, #33	; 0x21
    c862:	4b2e      	ldr	r3, [pc, #184]	; (c91c <AJ_PeerHandleExchangeGUIDs+0x298>)
    c864:	4798      	blx	r3
    return AJ_MarshalArgs(reply, "su", guidStr, authContext.version);
    c866:	68f3      	ldr	r3, [r6, #12]
    c868:	1c28      	adds	r0, r5, #0
    c86a:	4915      	ldr	r1, [pc, #84]	; (c8c0 <AJ_PeerHandleExchangeGUIDs+0x23c>)
    c86c:	aa0b      	add	r2, sp, #44	; 0x2c
    c86e:	4c2c      	ldr	r4, [pc, #176]	; (c920 <AJ_PeerHandleExchangeGUIDs+0x29c>)
    c870:	47a0      	blx	r4
    c872:	e004      	b.n	c87e <AJ_PeerHandleExchangeGUIDs+0x1fa>
        }
        AJ_FreeCredential(cred);
    }

    // We are not currently negotiating versions so we tell the peer what version we require.
    authContext.version = GetAcceptableVersion(authContext.version);
    c874:	22c0      	movs	r2, #192	; 0xc0
    c876:	0292      	lsls	r2, r2, #10
    c878:	4b0d      	ldr	r3, [pc, #52]	; (c8b0 <AJ_PeerHandleExchangeGUIDs+0x22c>)
    c87a:	60da      	str	r2, [r3, #12]
    c87c:	e7e0      	b.n	c840 <AJ_PeerHandleExchangeGUIDs+0x1bc>

    AJ_MarshalReplyMsg(msg, reply);
    AJ_GetLocalGUID(&localGuid);
    AJ_GUID_ToString(&localGuid, guidStr, sizeof(guidStr));
    return AJ_MarshalArgs(reply, "su", guidStr, authContext.version);
}
    c87e:	b015      	add	sp, #84	; 0x54
    c880:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c882:	46c0      	nop			; (mov r8, r8)
    c884:	0001df38 	.word	0x0001df38
    c888:	00016e3d 	.word	0x00016e3d
    c88c:	20001128 	.word	0x20001128
    c890:	0001df68 	.word	0x0001df68
    c894:	00016f5d 	.word	0x00016f5d
    c898:	0000c58d 	.word	0x0000c58d
    c89c:	0001dfa0 	.word	0x0001dfa0
    c8a0:	0001e714 	.word	0x0001e714
    c8a4:	0000be55 	.word	0x0000be55
    c8a8:	0000c549 	.word	0x0000c549
    c8ac:	0000d7ad 	.word	0x0000d7ad
    c8b0:	20001000 	.word	0x20001000
    c8b4:	0000612d 	.word	0x0000612d
    c8b8:	00400002 	.word	0x00400002
    c8bc:	00002711 	.word	0x00002711
    c8c0:	0001a578 	.word	0x0001a578
    c8c4:	0000b5f5 	.word	0x0000b5f5
    c8c8:	0001dfe8 	.word	0x0001dfe8
    c8cc:	0000c56d 	.word	0x0000c56d
    c8d0:	0001eb70 	.word	0x0001eb70
    c8d4:	00007a99 	.word	0x00007a99
    c8d8:	0001e028 	.word	0x0001e028
    c8dc:	0001e044 	.word	0x0001e044
    c8e0:	00007aad 	.word	0x00007aad
    c8e4:	0001e080 	.word	0x0001e080
    c8e8:	0001e0c8 	.word	0x0001e0c8
    c8ec:	00007bdd 	.word	0x00007bdd
    c8f0:	00004419 	.word	0x00004419
    c8f4:	000063c5 	.word	0x000063c5
    c8f8:	0001e0f0 	.word	0x0001e0f0
    c8fc:	000044dd 	.word	0x000044dd
    c900:	0001e120 	.word	0x0001e120
    c904:	00016739 	.word	0x00016739
    c908:	000043f5 	.word	0x000043f5
    c90c:	00004475 	.word	0x00004475
    c910:	0001e150 	.word	0x0001e150
    c914:	0000bd45 	.word	0x0000bd45
    c918:	00004431 	.word	0x00004431
    c91c:	00007a7d 	.word	0x00007a7d
    c920:	0000bc85 	.word	0x0000bc85

0000c924 <AJ_PeerHandleExchangeSuites>:

    return AJ_DeliverMsg(&call);
}

AJ_Status AJ_PeerHandleExchangeSuites(AJ_Message* msg, AJ_Message* reply)
{
    c924:	b5f0      	push	{r4, r5, r6, r7, lr}
    c926:	464f      	mov	r7, r9
    c928:	b480      	push	{r7}
    c92a:	b088      	sub	sp, #32
    c92c:	1c07      	adds	r7, r0, #0
    c92e:	1c0d      	adds	r5, r1, #0
    c930:	9101      	str	r1, [sp, #4]
    AJ_Status status;
    AJ_Arg array;
    uint32_t* suites;
    size_t numsuites;
    uint32_t i;
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    c932:	6940      	ldr	r0, [r0, #20]
    c934:	4b38      	ldr	r3, [pc, #224]	; (ca18 <AJ_PeerHandleExchangeSuites+0xf4>)
    c936:	4798      	blx	r3
    c938:	1c04      	adds	r4, r0, #0

    printf("AJ_PeerHandleExchangeSuites(msg=%p, reply=%p)\n", msg, reply);
    c93a:	4838      	ldr	r0, [pc, #224]	; (ca1c <AJ_PeerHandleExchangeSuites+0xf8>)
    c93c:	1c39      	adds	r1, r7, #0
    c93e:	1c2a      	adds	r2, r5, #0
    c940:	4b37      	ldr	r3, [pc, #220]	; (ca20 <AJ_PeerHandleExchangeSuites+0xfc>)
    c942:	4798      	blx	r3

    status = HandshakeValid(peerGuid);
    c944:	1c20      	adds	r0, r4, #0
    c946:	4b37      	ldr	r3, [pc, #220]	; (ca24 <AJ_PeerHandleExchangeSuites+0x100>)
    c948:	4798      	blx	r3
    if (AJ_OK != status) 
    c94a:	2800      	cmp	r0, #0
    c94c:	d005      	beq.n	c95a <AJ_PeerHandleExchangeSuites+0x36>
	{
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    c94e:	1c38      	adds	r0, r7, #0
    c950:	9901      	ldr	r1, [sp, #4]
    c952:	4a35      	ldr	r2, [pc, #212]	; (ca28 <AJ_PeerHandleExchangeSuites+0x104>)
    c954:	4b35      	ldr	r3, [pc, #212]	; (ca2c <AJ_PeerHandleExchangeSuites+0x108>)
    c956:	4798      	blx	r3
    c958:	e059      	b.n	ca0e <AJ_PeerHandleExchangeSuites+0xea>
    }

    authContext.role = AUTH_SERVER;
    c95a:	4835      	ldr	r0, [pc, #212]	; (ca30 <AJ_PeerHandleExchangeSuites+0x10c>)
    c95c:	2301      	movs	r3, #1
    c95e:	7103      	strb	r3, [r0, #4]
    AJ_SHA256_Init(&authContext.hash);
    c960:	3010      	adds	r0, #16
    c962:	4b34      	ldr	r3, [pc, #208]	; (ca34 <AJ_PeerHandleExchangeSuites+0x110>)
    c964:	4798      	blx	r3

    // Receive suites
    status = AJ_UnmarshalArgs(msg, "au", &suites, &numsuites);
    c966:	1c38      	adds	r0, r7, #0
    c968:	4933      	ldr	r1, [pc, #204]	; (ca38 <AJ_PeerHandleExchangeSuites+0x114>)
    c96a:	aa03      	add	r2, sp, #12
    c96c:	ab02      	add	r3, sp, #8
    c96e:	4c33      	ldr	r4, [pc, #204]	; (ca3c <AJ_PeerHandleExchangeSuites+0x118>)
    c970:	47a0      	blx	r4
    if (AJ_OK != status) 
    c972:	2800      	cmp	r0, #0
    c974:	d005      	beq.n	c982 <AJ_PeerHandleExchangeSuites+0x5e>
	{
        printf("AJ_PeerHandleExchangeSuites(msg=%p, reply=%p): Unmarshal error\n", msg, reply);
    c976:	4832      	ldr	r0, [pc, #200]	; (ca40 <AJ_PeerHandleExchangeSuites+0x11c>)
    c978:	1c39      	adds	r1, r7, #0
    c97a:	9a01      	ldr	r2, [sp, #4]
    c97c:	4b28      	ldr	r3, [pc, #160]	; (ca20 <AJ_PeerHandleExchangeSuites+0xfc>)
    c97e:	4798      	blx	r3
        goto Exit;
    c980:	e03d      	b.n	c9fe <AJ_PeerHandleExchangeSuites+0xda>
    }
    numsuites /= sizeof (uint32_t);
    c982:	9b02      	ldr	r3, [sp, #8]
    c984:	089b      	lsrs	r3, r3, #2
    c986:	9302      	str	r3, [sp, #8]

    // Calculate common suites
    AJ_MarshalReplyMsg(msg, reply);
    c988:	1c38      	adds	r0, r7, #0
    c98a:	9c01      	ldr	r4, [sp, #4]
    c98c:	1c21      	adds	r1, r4, #0
    c98e:	4b2d      	ldr	r3, [pc, #180]	; (ca44 <AJ_PeerHandleExchangeSuites+0x120>)
    c990:	4798      	blx	r3
    status = AJ_MarshalContainer(reply, &array, AJ_ARG_ARRAY);
    c992:	1c20      	adds	r0, r4, #0
    c994:	a904      	add	r1, sp, #16
    c996:	2261      	movs	r2, #97	; 0x61
    c998:	4b2b      	ldr	r3, [pc, #172]	; (ca48 <AJ_PeerHandleExchangeSuites+0x124>)
    c99a:	4798      	blx	r3
    /* Iterate through the available suites.
     * If it's enabled, marshal the suite to send to the other peer.
    */
    for (i = 0; i < numsuites; i++) 
    c99c:	9b02      	ldr	r3, [sp, #8]
    c99e:	2b00      	cmp	r3, #0
    c9a0:	d015      	beq.n	c9ce <AJ_PeerHandleExchangeSuites+0xaa>
    c9a2:	2400      	movs	r4, #0
    {
        if (AJ_IsSuiteEnabled(suites[i], authContext.version >> 16)) 
    c9a4:	4b22      	ldr	r3, [pc, #136]	; (ca30 <AJ_PeerHandleExchangeSuites+0x10c>)
    c9a6:	4699      	mov	r9, r3
    c9a8:	4e28      	ldr	r6, [pc, #160]	; (ca4c <AJ_PeerHandleExchangeSuites+0x128>)
    c9aa:	00a5      	lsls	r5, r4, #2
    c9ac:	9b03      	ldr	r3, [sp, #12]
    c9ae:	5958      	ldr	r0, [r3, r5]
    c9b0:	464b      	mov	r3, r9
    c9b2:	89d9      	ldrh	r1, [r3, #14]
    c9b4:	47b0      	blx	r6
    c9b6:	2800      	cmp	r0, #0
    c9b8:	d005      	beq.n	c9c6 <AJ_PeerHandleExchangeSuites+0xa2>
		{
            status = AJ_MarshalArgs(reply, "u", suites[i]);
    c9ba:	9b03      	ldr	r3, [sp, #12]
    c9bc:	595a      	ldr	r2, [r3, r5]
    c9be:	9801      	ldr	r0, [sp, #4]
    c9c0:	4923      	ldr	r1, [pc, #140]	; (ca50 <AJ_PeerHandleExchangeSuites+0x12c>)
    c9c2:	4b24      	ldr	r3, [pc, #144]	; (ca54 <AJ_PeerHandleExchangeSuites+0x130>)
    c9c4:	4798      	blx	r3
    AJ_MarshalReplyMsg(msg, reply);
    status = AJ_MarshalContainer(reply, &array, AJ_ARG_ARRAY);
    /* Iterate through the available suites.
     * If it's enabled, marshal the suite to send to the other peer.
    */
    for (i = 0; i < numsuites; i++) 
    c9c6:	3401      	adds	r4, #1
    c9c8:	9b02      	ldr	r3, [sp, #8]
    c9ca:	42a3      	cmp	r3, r4
    c9cc:	d8ed      	bhi.n	c9aa <AJ_PeerHandleExchangeSuites+0x86>
        if (AJ_IsSuiteEnabled(suites[i], authContext.version >> 16)) 
		{
            status = AJ_MarshalArgs(reply, "u", suites[i]);
        }
    }
    status = AJ_MarshalCloseContainer(reply, &array);
    c9ce:	9801      	ldr	r0, [sp, #4]
    c9d0:	a904      	add	r1, sp, #16
    c9d2:	4b21      	ldr	r3, [pc, #132]	; (ca58 <AJ_PeerHandleExchangeSuites+0x134>)
    c9d4:	4798      	blx	r3
    if (AJ_OK != status)
    c9d6:	2800      	cmp	r0, #0
    c9d8:	d00c      	beq.n	c9f4 <AJ_PeerHandleExchangeSuites+0xd0>
	 {
        AJ_WarnPrintf(("AJ_PeerHandleExchangeSuites(msg=%p, reply=%p): Marshal error\n", msg, reply));
    c9da:	2002      	movs	r0, #2
    c9dc:	491f      	ldr	r1, [pc, #124]	; (ca5c <AJ_PeerHandleExchangeSuites+0x138>)
    c9de:	4a20      	ldr	r2, [pc, #128]	; (ca60 <AJ_PeerHandleExchangeSuites+0x13c>)
    c9e0:	4b20      	ldr	r3, [pc, #128]	; (ca64 <AJ_PeerHandleExchangeSuites+0x140>)
    c9e2:	4798      	blx	r3
    c9e4:	2800      	cmp	r0, #0
    c9e6:	d00a      	beq.n	c9fe <AJ_PeerHandleExchangeSuites+0xda>
    c9e8:	481f      	ldr	r0, [pc, #124]	; (ca68 <AJ_PeerHandleExchangeSuites+0x144>)
    c9ea:	1c39      	adds	r1, r7, #0
    c9ec:	9a01      	ldr	r2, [sp, #4]
    c9ee:	4b0c      	ldr	r3, [pc, #48]	; (ca20 <AJ_PeerHandleExchangeSuites+0xfc>)
    c9f0:	4798      	blx	r3
    c9f2:	e004      	b.n	c9fe <AJ_PeerHandleExchangeSuites+0xda>
        goto Exit;
    }

    printf("Exchange Suites Complete\n");
    c9f4:	481d      	ldr	r0, [pc, #116]	; (ca6c <AJ_PeerHandleExchangeSuites+0x148>)
    c9f6:	4b1e      	ldr	r3, [pc, #120]	; (ca70 <AJ_PeerHandleExchangeSuites+0x14c>)
    c9f8:	4798      	blx	r3
    return status;
    c9fa:	2000      	movs	r0, #0
    c9fc:	e007      	b.n	ca0e <AJ_PeerHandleExchangeSuites+0xea>

Exit:

    HandshakeComplete(AJ_ERR_SECURITY);
    c9fe:	200d      	movs	r0, #13
    ca00:	4b1c      	ldr	r3, [pc, #112]	; (ca74 <AJ_PeerHandleExchangeSuites+0x150>)
    ca02:	4798      	blx	r3
    return AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    ca04:	1c38      	adds	r0, r7, #0
    ca06:	9901      	ldr	r1, [sp, #4]
    ca08:	4a1b      	ldr	r2, [pc, #108]	; (ca78 <AJ_PeerHandleExchangeSuites+0x154>)
    ca0a:	4b08      	ldr	r3, [pc, #32]	; (ca2c <AJ_PeerHandleExchangeSuites+0x108>)
    ca0c:	4798      	blx	r3
}
    ca0e:	b008      	add	sp, #32
    ca10:	bc04      	pop	{r2}
    ca12:	4691      	mov	r9, r2
    ca14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ca16:	46c0      	nop			; (mov r8, r8)
    ca18:	00007bdd 	.word	0x00007bdd
    ca1c:	0001e1c8 	.word	0x0001e1c8
    ca20:	00016e3d 	.word	0x00016e3d
    ca24:	0000c649 	.word	0x0000c649
    ca28:	0001e714 	.word	0x0001e714
    ca2c:	0000be55 	.word	0x0000be55
    ca30:	20001000 	.word	0x20001000
    ca34:	0000612d 	.word	0x0000612d
    ca38:	00021b1c 	.word	0x00021b1c
    ca3c:	0000b5f5 	.word	0x0000b5f5
    ca40:	0001e1f8 	.word	0x0001e1f8
    ca44:	0000bd45 	.word	0x0000bd45
    ca48:	0000b8a1 	.word	0x0000b8a1
    ca4c:	000026b9 	.word	0x000026b9
    ca50:	0002192c 	.word	0x0002192c
    ca54:	0000bc85 	.word	0x0000bc85
    ca58:	0000b8d1 	.word	0x0000b8d1
    ca5c:	0001dddc 	.word	0x0001dddc
    ca60:	0000026a 	.word	0x0000026a
    ca64:	0000636d 	.word	0x0000636d
    ca68:	0001e238 	.word	0x0001e238
    ca6c:	0001e278 	.word	0x0001e278
    ca70:	00016f5d 	.word	0x00016f5d
    ca74:	0000c56d 	.word	0x0000c56d
    ca78:	0001eb70 	.word	0x0001eb70

0000ca7c <AJ_PeerHandleKeyExchange>:
    HandshakeComplete(AJ_ERR_SECURITY);
    return AJ_ERR_SECURITY;
}

AJ_Status AJ_PeerHandleKeyExchange(AJ_Message* msg, AJ_Message* reply)
{
    ca7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ca7e:	b083      	sub	sp, #12
    ca80:	1c04      	adds	r4, r0, #0
    ca82:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    uint8_t suiteb8[sizeof (uint32_t)];
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    ca84:	6940      	ldr	r0, [r0, #20]
    ca86:	4b3e      	ldr	r3, [pc, #248]	; (cb80 <AJ_PeerHandleKeyExchange+0x104>)
    ca88:	4798      	blx	r3
    ca8a:	1c06      	adds	r6, r0, #0

    printf("AJ_PeerHandleKeyExchange(msg=%p, reply=%p)\n", msg, reply);
    ca8c:	483d      	ldr	r0, [pc, #244]	; (cb84 <AJ_PeerHandleKeyExchange+0x108>)
    ca8e:	1c21      	adds	r1, r4, #0
    ca90:	1c2a      	adds	r2, r5, #0
    ca92:	4f3d      	ldr	r7, [pc, #244]	; (cb88 <AJ_PeerHandleKeyExchange+0x10c>)
    ca94:	47b8      	blx	r7

    status = HandshakeValid(peerGuid);
    ca96:	1c30      	adds	r0, r6, #0
    ca98:	4b3c      	ldr	r3, [pc, #240]	; (cb8c <AJ_PeerHandleKeyExchange+0x110>)
    ca9a:	4798      	blx	r3
    ca9c:	1c06      	adds	r6, r0, #0
	printf("AJ_PeerHandleKeyExchange HandshakeValid status=%s\n",AJ_StatusText(status));
    ca9e:	4b3c      	ldr	r3, [pc, #240]	; (cb90 <AJ_PeerHandleKeyExchange+0x114>)
    caa0:	4798      	blx	r3
    caa2:	1c01      	adds	r1, r0, #0
    caa4:	483b      	ldr	r0, [pc, #236]	; (cb94 <AJ_PeerHandleKeyExchange+0x118>)
    caa6:	47b8      	blx	r7
    if (AJ_OK != status) 
    caa8:	2e00      	cmp	r6, #0
    caaa:	d005      	beq.n	cab8 <AJ_PeerHandleKeyExchange+0x3c>
	{
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    caac:	1c20      	adds	r0, r4, #0
    caae:	1c29      	adds	r1, r5, #0
    cab0:	4a39      	ldr	r2, [pc, #228]	; (cb98 <AJ_PeerHandleKeyExchange+0x11c>)
    cab2:	4b3a      	ldr	r3, [pc, #232]	; (cb9c <AJ_PeerHandleKeyExchange+0x120>)
    cab4:	4798      	blx	r3
    cab6:	e061      	b.n	cb7c <AJ_PeerHandleKeyExchange+0x100>
    }

    //Receive suite
    AJ_UnmarshalArgs(msg, "u", &authContext.suite);
    cab8:	4e39      	ldr	r6, [pc, #228]	; (cba0 <AJ_PeerHandleKeyExchange+0x124>)
    caba:	1c32      	adds	r2, r6, #0
    cabc:	3208      	adds	r2, #8
    cabe:	1c20      	adds	r0, r4, #0
    cac0:	4938      	ldr	r1, [pc, #224]	; (cba4 <AJ_PeerHandleKeyExchange+0x128>)
    cac2:	4b39      	ldr	r3, [pc, #228]	; (cba8 <AJ_PeerHandleKeyExchange+0x12c>)
    cac4:	4798      	blx	r3
	//printf("AJ_PeerHandleKeyExchange AJ_UnmarshalArgs end \n");
    if (!AJ_IsSuiteEnabled(authContext.suite, authContext.version >> 16)) 
    cac6:	68b0      	ldr	r0, [r6, #8]
    cac8:	89f1      	ldrh	r1, [r6, #14]
    caca:	4b38      	ldr	r3, [pc, #224]	; (cbac <AJ_PeerHandleKeyExchange+0x130>)
    cacc:	4798      	blx	r3
    cace:	2800      	cmp	r0, #0
    cad0:	d103      	bne.n	cada <AJ_PeerHandleKeyExchange+0x5e>
    {
		printf("AJ_PeerHandleKeyExchange AJ_IsSuiteEnabled error \n");
    cad2:	4837      	ldr	r0, [pc, #220]	; (cbb0 <AJ_PeerHandleKeyExchange+0x134>)
    cad4:	4b37      	ldr	r3, [pc, #220]	; (cbb4 <AJ_PeerHandleKeyExchange+0x138>)
    cad6:	4798      	blx	r3
        goto Exit;
    cad8:	e048      	b.n	cb6c <AJ_PeerHandleKeyExchange+0xf0>
    }
    HostU32ToBigEndianU8(&authContext.suite, sizeof (authContext.suite), suiteb8);
    cada:	4e31      	ldr	r6, [pc, #196]	; (cba0 <AJ_PeerHandleKeyExchange+0x124>)
    cadc:	1c30      	adds	r0, r6, #0
    cade:	3008      	adds	r0, #8
    cae0:	2104      	movs	r1, #4
    cae2:	aa01      	add	r2, sp, #4
    cae4:	4b34      	ldr	r3, [pc, #208]	; (cbb8 <AJ_PeerHandleKeyExchange+0x13c>)
    cae6:	4798      	blx	r3
//	printf("AJ_PeerHandleKeyExchange HostU32ToBigEndianU8 end \n");
    AJ_SHA256_Update(&authContext.hash, suiteb8, sizeof (suiteb8));
    cae8:	1c30      	adds	r0, r6, #0
    caea:	3010      	adds	r0, #16
    caec:	a901      	add	r1, sp, #4
    caee:	2204      	movs	r2, #4
    caf0:	4b32      	ldr	r3, [pc, #200]	; (cbbc <AJ_PeerHandleKeyExchange+0x140>)
    caf2:	4798      	blx	r3
//	printf("AJ_PeerHandleKeyExchange AJ_SHA256_Update end \n");

    // Receive key material
    status = AJ_KeyExchangeUnmarshal(&authContext, msg);
    caf4:	1c30      	adds	r0, r6, #0
    caf6:	1c21      	adds	r1, r4, #0
    caf8:	4b31      	ldr	r3, [pc, #196]	; (cbc0 <AJ_PeerHandleKeyExchange+0x144>)
    cafa:	4798      	blx	r3
    cafc:	1c06      	adds	r6, r0, #0
	printf("AJ_PeerHandleKeyExchange status=%s\n",AJ_StatusText(status));
    cafe:	4b24      	ldr	r3, [pc, #144]	; (cb90 <AJ_PeerHandleKeyExchange+0x114>)
    cb00:	4798      	blx	r3
    cb02:	1c01      	adds	r1, r0, #0
    cb04:	482f      	ldr	r0, [pc, #188]	; (cbc4 <AJ_PeerHandleKeyExchange+0x148>)
    cb06:	4b20      	ldr	r3, [pc, #128]	; (cb88 <AJ_PeerHandleKeyExchange+0x10c>)
    cb08:	4798      	blx	r3
    if (AJ_OK != status) 
    cb0a:	2e00      	cmp	r6, #0
    cb0c:	d12e      	bne.n	cb6c <AJ_PeerHandleKeyExchange+0xf0>
	{
        goto Exit;
    }

    // Send key material
    AJ_MarshalReplyMsg(msg, reply);
    cb0e:	1c20      	adds	r0, r4, #0
    cb10:	1c29      	adds	r1, r5, #0
    cb12:	4b2d      	ldr	r3, [pc, #180]	; (cbc8 <AJ_PeerHandleKeyExchange+0x14c>)
    cb14:	4798      	blx	r3
    status = AJ_MarshalArgs(reply, "u", authContext.suite);
    cb16:	4b22      	ldr	r3, [pc, #136]	; (cba0 <AJ_PeerHandleKeyExchange+0x124>)
    cb18:	689a      	ldr	r2, [r3, #8]
    cb1a:	1c28      	adds	r0, r5, #0
    cb1c:	4921      	ldr	r1, [pc, #132]	; (cba4 <AJ_PeerHandleKeyExchange+0x128>)
    cb1e:	4b2b      	ldr	r3, [pc, #172]	; (cbcc <AJ_PeerHandleKeyExchange+0x150>)
    cb20:	4798      	blx	r3
    cb22:	1c06      	adds	r6, r0, #0
	printf("AJ_PeerHandleKeyExchange AJ_MarshalArgs status=%s\n",AJ_StatusText(status));
    cb24:	4b1a      	ldr	r3, [pc, #104]	; (cb90 <AJ_PeerHandleKeyExchange+0x114>)
    cb26:	4798      	blx	r3
    cb28:	1c01      	adds	r1, r0, #0
    cb2a:	4829      	ldr	r0, [pc, #164]	; (cbd0 <AJ_PeerHandleKeyExchange+0x154>)
    cb2c:	4b16      	ldr	r3, [pc, #88]	; (cb88 <AJ_PeerHandleKeyExchange+0x10c>)
    cb2e:	4798      	blx	r3
    if (AJ_OK != status) 
    cb30:	2e00      	cmp	r6, #0
    cb32:	d11b      	bne.n	cb6c <AJ_PeerHandleKeyExchange+0xf0>
	{
		
        goto Exit;
    }
    AJ_SHA256_Update(&authContext.hash, (uint8_t*) suiteb8, sizeof (suiteb8));
    cb34:	4e1a      	ldr	r6, [pc, #104]	; (cba0 <AJ_PeerHandleKeyExchange+0x124>)
    cb36:	1c30      	adds	r0, r6, #0
    cb38:	3010      	adds	r0, #16
    cb3a:	a901      	add	r1, sp, #4
    cb3c:	2204      	movs	r2, #4
    cb3e:	4b1f      	ldr	r3, [pc, #124]	; (cbbc <AJ_PeerHandleKeyExchange+0x140>)
    cb40:	4798      	blx	r3
    status = AJ_KeyExchangeMarshal(&authContext, reply);
    cb42:	1c30      	adds	r0, r6, #0
    cb44:	1c29      	adds	r1, r5, #0
    cb46:	4b23      	ldr	r3, [pc, #140]	; (cbd4 <AJ_PeerHandleKeyExchange+0x158>)
    cb48:	4798      	blx	r3
    cb4a:	1c06      	adds	r6, r0, #0
	printf("AJ_PeerHandleKeyExchange AJ_KeyExchangeMarshal status=%s\n", AJ_StatusText(status));
    cb4c:	4b10      	ldr	r3, [pc, #64]	; (cb90 <AJ_PeerHandleKeyExchange+0x114>)
    cb4e:	4798      	blx	r3
    cb50:	1c01      	adds	r1, r0, #0
    cb52:	4821      	ldr	r0, [pc, #132]	; (cbd8 <AJ_PeerHandleKeyExchange+0x15c>)
    cb54:	4b0c      	ldr	r3, [pc, #48]	; (cb88 <AJ_PeerHandleKeyExchange+0x10c>)
    cb56:	4798      	blx	r3

    if (AJ_OK != status) 
    cb58:	2e00      	cmp	r6, #0
    cb5a:	d107      	bne.n	cb6c <AJ_PeerHandleKeyExchange+0xf0>
	{
        goto Exit;
    }
    peerContext.state = AJ_AUTH_EXCHANGED;
    cb5c:	2201      	movs	r2, #1
    cb5e:	4b1f      	ldr	r3, [pc, #124]	; (cbdc <AJ_PeerHandleKeyExchange+0x160>)
    cb60:	701a      	strb	r2, [r3, #0]
    printf("Key Exchange Complete\n");
    cb62:	481f      	ldr	r0, [pc, #124]	; (cbe0 <AJ_PeerHandleKeyExchange+0x164>)
    cb64:	4b13      	ldr	r3, [pc, #76]	; (cbb4 <AJ_PeerHandleKeyExchange+0x138>)
    cb66:	4798      	blx	r3
    return status;
    cb68:	2000      	movs	r0, #0
    cb6a:	e007      	b.n	cb7c <AJ_PeerHandleKeyExchange+0x100>

Exit:
    HandshakeComplete(AJ_ERR_SECURITY);
    cb6c:	200d      	movs	r0, #13
    cb6e:	4b1d      	ldr	r3, [pc, #116]	; (cbe4 <AJ_PeerHandleKeyExchange+0x168>)
    cb70:	4798      	blx	r3
    return AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    cb72:	1c20      	adds	r0, r4, #0
    cb74:	1c29      	adds	r1, r5, #0
    cb76:	4a1c      	ldr	r2, [pc, #112]	; (cbe8 <AJ_PeerHandleKeyExchange+0x16c>)
    cb78:	4b08      	ldr	r3, [pc, #32]	; (cb9c <AJ_PeerHandleKeyExchange+0x120>)
    cb7a:	4798      	blx	r3
}
    cb7c:	b003      	add	sp, #12
    cb7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cb80:	00007bdd 	.word	0x00007bdd
    cb84:	0001e294 	.word	0x0001e294
    cb88:	00016e3d 	.word	0x00016e3d
    cb8c:	0000c649 	.word	0x0000c649
    cb90:	000063c5 	.word	0x000063c5
    cb94:	0001e2c0 	.word	0x0001e2c0
    cb98:	0001e714 	.word	0x0001e714
    cb9c:	0000be55 	.word	0x0000be55
    cba0:	20001000 	.word	0x20001000
    cba4:	0002192c 	.word	0x0002192c
    cba8:	0000b5f5 	.word	0x0000b5f5
    cbac:	000026b9 	.word	0x000026b9
    cbb0:	0001e2f4 	.word	0x0001e2f4
    cbb4:	00016f5d 	.word	0x00016f5d
    cbb8:	00003139 	.word	0x00003139
    cbbc:	00006139 	.word	0x00006139
    cbc0:	00001d4d 	.word	0x00001d4d
    cbc4:	0001e328 	.word	0x0001e328
    cbc8:	0000bd45 	.word	0x0000bd45
    cbcc:	0000bc85 	.word	0x0000bc85
    cbd0:	0001e34c 	.word	0x0001e34c
    cbd4:	00001c01 	.word	0x00001c01
    cbd8:	0001e380 	.word	0x0001e380
    cbdc:	20001128 	.word	0x20001128
    cbe0:	0001e3bc 	.word	0x0001e3bc
    cbe4:	0000c56d 	.word	0x0000c56d
    cbe8:	0001eb70 	.word	0x0001eb70

0000cbec <AJ_PeerHandleKeyAuthentication>:
    HandshakeComplete(AJ_ERR_SECURITY);
    return AJ_ERR_SECURITY;
}

AJ_Status AJ_PeerHandleKeyAuthentication(AJ_Message* msg, AJ_Message* reply)
{
    cbec:	b570      	push	{r4, r5, r6, lr}
    cbee:	1c04      	adds	r4, r0, #0
    cbf0:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    cbf2:	6940      	ldr	r0, [r0, #20]
    cbf4:	4b25      	ldr	r3, [pc, #148]	; (cc8c <AJ_PeerHandleKeyAuthentication+0xa0>)
    cbf6:	4798      	blx	r3
    cbf8:	1c06      	adds	r6, r0, #0

    printf("AJ_PeerHandleKeyAuthentication(msg=%p, reply=%p)\n", msg, reply);
    cbfa:	4825      	ldr	r0, [pc, #148]	; (cc90 <AJ_PeerHandleKeyAuthentication+0xa4>)
    cbfc:	1c21      	adds	r1, r4, #0
    cbfe:	1c2a      	adds	r2, r5, #0
    cc00:	4b24      	ldr	r3, [pc, #144]	; (cc94 <AJ_PeerHandleKeyAuthentication+0xa8>)
    cc02:	4798      	blx	r3

    status = HandshakeValid(peerGuid);
    cc04:	1c30      	adds	r0, r6, #0
    cc06:	4b24      	ldr	r3, [pc, #144]	; (cc98 <AJ_PeerHandleKeyAuthentication+0xac>)
    cc08:	4798      	blx	r3
    if (AJ_OK != status) 
    cc0a:	2800      	cmp	r0, #0
    cc0c:	d005      	beq.n	cc1a <AJ_PeerHandleKeyAuthentication+0x2e>
	{
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    cc0e:	1c20      	adds	r0, r4, #0
    cc10:	1c29      	adds	r1, r5, #0
    cc12:	4a22      	ldr	r2, [pc, #136]	; (cc9c <AJ_PeerHandleKeyAuthentication+0xb0>)
    cc14:	4b22      	ldr	r3, [pc, #136]	; (cca0 <AJ_PeerHandleKeyAuthentication+0xb4>)
    cc16:	4798      	blx	r3
    cc18:	e037      	b.n	cc8a <AJ_PeerHandleKeyAuthentication+0x9e>
    }

    if (AJ_AUTH_EXCHANGED != peerContext.state) 
    cc1a:	4b22      	ldr	r3, [pc, #136]	; (cca4 <AJ_PeerHandleKeyAuthentication+0xb8>)
    cc1c:	781b      	ldrb	r3, [r3, #0]
    cc1e:	2b01      	cmp	r3, #1
    cc20:	d12f      	bne.n	cc82 <AJ_PeerHandleKeyAuthentication+0x96>
        goto Exit;
    }

    // Receive authentication material

    status = AJ_KeyAuthenticationUnmarshal(&authContext, msg);
    cc22:	4821      	ldr	r0, [pc, #132]	; (cca8 <AJ_PeerHandleKeyAuthentication+0xbc>)
    cc24:	1c21      	adds	r1, r4, #0
    cc26:	4b21      	ldr	r3, [pc, #132]	; (ccac <AJ_PeerHandleKeyAuthentication+0xc0>)
    cc28:	4798      	blx	r3
    if (AJ_OK != status)
    cc2a:	2800      	cmp	r0, #0
    cc2c:	d129      	bne.n	cc82 <AJ_PeerHandleKeyAuthentication+0x96>
   //     AJ_InfoPrintf(("AJ_PeerHandleKeyAuthentication(msg=%p, reply=%p): Key authentication unmarshal error\n", msg, reply));
        goto Exit;
    }

    // Send authentication material
    AJ_MarshalReplyMsg(msg, reply);
    cc2e:	1c20      	adds	r0, r4, #0
    cc30:	1c29      	adds	r1, r5, #0
    cc32:	4b1f      	ldr	r3, [pc, #124]	; (ccb0 <AJ_PeerHandleKeyAuthentication+0xc4>)
    cc34:	4798      	blx	r3
    status = AJ_KeyAuthenticationMarshal(&authContext, reply);
    cc36:	481c      	ldr	r0, [pc, #112]	; (cca8 <AJ_PeerHandleKeyAuthentication+0xbc>)
    cc38:	1c29      	adds	r1, r5, #0
    cc3a:	4b1e      	ldr	r3, [pc, #120]	; (ccb4 <AJ_PeerHandleKeyAuthentication+0xc8>)
    cc3c:	4798      	blx	r3
    if (AJ_OK != status) 
    cc3e:	2800      	cmp	r0, #0
    cc40:	d11f      	bne.n	cc82 <AJ_PeerHandleKeyAuthentication+0x96>
   //     AJ_WarnPrintf(("AJ_PeerHandleKeyAuthentication(msg=%p, reply=%p): Key authentication marshal error\n", msg, reply));
        goto Exit;
    }

  //  AJ_InfoPrintf(("Key Authentication Complete\n"));
    peerContext.state = AJ_AUTH_SUCCESS;
    cc42:	2202      	movs	r2, #2
    cc44:	4b17      	ldr	r3, [pc, #92]	; (cca4 <AJ_PeerHandleKeyAuthentication+0xb8>)
    cc46:	701a      	strb	r2, [r3, #0]

    if (authContext.expiration) 
    cc48:	2390      	movs	r3, #144	; 0x90
    cc4a:	005b      	lsls	r3, r3, #1
    cc4c:	4a16      	ldr	r2, [pc, #88]	; (cca8 <AJ_PeerHandleKeyAuthentication+0xbc>)
    cc4e:	58d1      	ldr	r1, [r2, r3]
    cc50:	2900      	cmp	r1, #0
    cc52:	d01a      	beq.n	cc8a <AJ_PeerHandleKeyAuthentication+0x9e>
	{
        status = SaveMasterSecret(peerGuid, authContext.expiration);
    cc54:	1c30      	adds	r0, r6, #0
    cc56:	4b18      	ldr	r3, [pc, #96]	; (ccb8 <AJ_PeerHandleKeyAuthentication+0xcc>)
    cc58:	4798      	blx	r3
    cc5a:	1c06      	adds	r6, r0, #0
    cc5c:	2000      	movs	r0, #0
        if (AJ_OK != status) 
    cc5e:	2e00      	cmp	r6, #0
    cc60:	d013      	beq.n	cc8a <AJ_PeerHandleKeyAuthentication+0x9e>
		{
            AJ_WarnPrintf(("AJ_PeerHandleKeyAuthentication(msg=%p, reply=%p): Save master secret error\n", msg, reply));
    cc62:	3002      	adds	r0, #2
    cc64:	4915      	ldr	r1, [pc, #84]	; (ccbc <AJ_PeerHandleKeyAuthentication+0xd0>)
    cc66:	4a16      	ldr	r2, [pc, #88]	; (ccc0 <AJ_PeerHandleKeyAuthentication+0xd4>)
    cc68:	4b16      	ldr	r3, [pc, #88]	; (ccc4 <AJ_PeerHandleKeyAuthentication+0xd8>)
    cc6a:	4798      	blx	r3
    cc6c:	1c03      	adds	r3, r0, #0
  //  AJ_InfoPrintf(("Key Authentication Complete\n"));
    peerContext.state = AJ_AUTH_SUCCESS;

    if (authContext.expiration) 
	{
        status = SaveMasterSecret(peerGuid, authContext.expiration);
    cc6e:	1c30      	adds	r0, r6, #0
        if (AJ_OK != status) 
		{
            AJ_WarnPrintf(("AJ_PeerHandleKeyAuthentication(msg=%p, reply=%p): Save master secret error\n", msg, reply));
    cc70:	2b00      	cmp	r3, #0
    cc72:	d00a      	beq.n	cc8a <AJ_PeerHandleKeyAuthentication+0x9e>
    cc74:	4814      	ldr	r0, [pc, #80]	; (ccc8 <AJ_PeerHandleKeyAuthentication+0xdc>)
    cc76:	1c21      	adds	r1, r4, #0
    cc78:	1c2a      	adds	r2, r5, #0
    cc7a:	4b06      	ldr	r3, [pc, #24]	; (cc94 <AJ_PeerHandleKeyAuthentication+0xa8>)
    cc7c:	4798      	blx	r3
  //  AJ_InfoPrintf(("Key Authentication Complete\n"));
    peerContext.state = AJ_AUTH_SUCCESS;

    if (authContext.expiration) 
	{
        status = SaveMasterSecret(peerGuid, authContext.expiration);
    cc7e:	1c30      	adds	r0, r6, #0
    cc80:	e003      	b.n	cc8a <AJ_PeerHandleKeyAuthentication+0x9e>
    }

   return status;

Exit:
    HandshakeComplete(AJ_ERR_SECURITY);
    cc82:	200d      	movs	r0, #13
    cc84:	4b11      	ldr	r3, [pc, #68]	; (cccc <AJ_PeerHandleKeyAuthentication+0xe0>)
    cc86:	4798      	blx	r3
    return 0;//AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    cc88:	2000      	movs	r0, #0
}
    cc8a:	bd70      	pop	{r4, r5, r6, pc}
    cc8c:	00007bdd 	.word	0x00007bdd
    cc90:	0001e40c 	.word	0x0001e40c
    cc94:	00016e3d 	.word	0x00016e3d
    cc98:	0000c649 	.word	0x0000c649
    cc9c:	0001e714 	.word	0x0001e714
    cca0:	0000be55 	.word	0x0000be55
    cca4:	20001128 	.word	0x20001128
    cca8:	20001000 	.word	0x20001000
    ccac:	00002265 	.word	0x00002265
    ccb0:	0000bd45 	.word	0x0000bd45
    ccb4:	00001eb9 	.word	0x00001eb9
    ccb8:	0000c3c5 	.word	0x0000c3c5
    ccbc:	0001dddc 	.word	0x0001dddc
    ccc0:	000003a3 	.word	0x000003a3
    ccc4:	0000636d 	.word	0x0000636d
    ccc8:	0001e440 	.word	0x0001e440
    cccc:	0000c56d 	.word	0x0000c56d

0000ccd0 <AJ_PeerHandleKeyAuthenticationReply>:

AJ_Status AJ_PeerHandleKeyAuthenticationReply(AJ_Message* msg)
{
    ccd0:	b538      	push	{r3, r4, r5, lr}
    ccd2:	1c04      	adds	r4, r0, #0
    AJ_Status status;
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    ccd4:	6940      	ldr	r0, [r0, #20]
    ccd6:	4b2f      	ldr	r3, [pc, #188]	; (cd94 <AJ_PeerHandleKeyAuthenticationReply+0xc4>)
    ccd8:	4798      	blx	r3
    ccda:	1c05      	adds	r5, r0, #0

    printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p)\n", msg);
    ccdc:	482e      	ldr	r0, [pc, #184]	; (cd98 <AJ_PeerHandleKeyAuthenticationReply+0xc8>)
    ccde:	1c21      	adds	r1, r4, #0
    cce0:	4b2e      	ldr	r3, [pc, #184]	; (cd9c <AJ_PeerHandleKeyAuthenticationReply+0xcc>)
    cce2:	4798      	blx	r3

    if (msg->hdr->msgType == AJ_MSG_ERROR) 
    cce4:	6863      	ldr	r3, [r4, #4]
    cce6:	785b      	ldrb	r3, [r3, #1]
    cce8:	2b03      	cmp	r3, #3
    ccea:	d111      	bne.n	cd10 <AJ_PeerHandleKeyAuthenticationReply+0x40>
	{
        printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p): error=%s.\n", msg, msg->error);
    ccec:	482c      	ldr	r0, [pc, #176]	; (cda0 <AJ_PeerHandleKeyAuthenticationReply+0xd0>)
    ccee:	1c21      	adds	r1, r4, #0
    ccf0:	68e2      	ldr	r2, [r4, #12]
    ccf2:	4b2a      	ldr	r3, [pc, #168]	; (cd9c <AJ_PeerHandleKeyAuthenticationReply+0xcc>)
    ccf4:	4798      	blx	r3
        if (0 == strncmp(msg->error, AJ_ErrResources, sizeof(AJ_ErrResources))) 
    ccf6:	68e0      	ldr	r0, [r4, #12]
    ccf8:	492a      	ldr	r1, [pc, #168]	; (cda4 <AJ_PeerHandleKeyAuthenticationReply+0xd4>)
    ccfa:	221a      	movs	r2, #26
    ccfc:	4b2a      	ldr	r3, [pc, #168]	; (cda8 <AJ_PeerHandleKeyAuthenticationReply+0xd8>)
    ccfe:	4798      	blx	r3
		{
            status = AJ_ERR_RESOURCES;
    cd00:	230b      	movs	r3, #11
    printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p)\n", msg);

    if (msg->hdr->msgType == AJ_MSG_ERROR) 
	{
        printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p): error=%s.\n", msg, msg->error);
        if (0 == strncmp(msg->error, AJ_ErrResources, sizeof(AJ_ErrResources))) 
    cd02:	2800      	cmp	r0, #0
    cd04:	d044      	beq.n	cd90 <AJ_PeerHandleKeyAuthenticationReply+0xc0>
            status = AJ_ERR_RESOURCES;
        } 
		else 
		{
            status = AJ_ERR_SECURITY;
            HandshakeComplete(status);
    cd06:	200d      	movs	r0, #13
    cd08:	4b28      	ldr	r3, [pc, #160]	; (cdac <AJ_PeerHandleKeyAuthenticationReply+0xdc>)
    cd0a:	4798      	blx	r3
		{
            status = AJ_ERR_RESOURCES;
        } 
		else 
		{
            status = AJ_ERR_SECURITY;
    cd0c:	230d      	movs	r3, #13
    cd0e:	e03f      	b.n	cd90 <AJ_PeerHandleKeyAuthenticationReply+0xc0>
            HandshakeComplete(status);
        }
        return status;
    }

    status = HandshakeValid(peerGuid);
    cd10:	1c28      	adds	r0, r5, #0
    cd12:	4b27      	ldr	r3, [pc, #156]	; (cdb0 <AJ_PeerHandleKeyAuthenticationReply+0xe0>)
    cd14:	4798      	blx	r3
    if (AJ_OK != status) 
	{
        return status;
    cd16:	1e03      	subs	r3, r0, #0
        }
        return status;
    }

    status = HandshakeValid(peerGuid);
    if (AJ_OK != status) 
    cd18:	d13a      	bne.n	cd90 <AJ_PeerHandleKeyAuthenticationReply+0xc0>
	{
        return status;
    }

    if (AJ_AUTH_EXCHANGED != peerContext.state)
    cd1a:	4b26      	ldr	r3, [pc, #152]	; (cdb4 <AJ_PeerHandleKeyAuthenticationReply+0xe4>)
    cd1c:	781b      	ldrb	r3, [r3, #0]
    cd1e:	2b01      	cmp	r3, #1
    cd20:	d004      	beq.n	cd2c <AJ_PeerHandleKeyAuthenticationReply+0x5c>
	{
        printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p): Invalid state\n", msg);
    cd22:	4825      	ldr	r0, [pc, #148]	; (cdb8 <AJ_PeerHandleKeyAuthenticationReply+0xe8>)
    cd24:	1c21      	adds	r1, r4, #0
    cd26:	4b1d      	ldr	r3, [pc, #116]	; (cd9c <AJ_PeerHandleKeyAuthenticationReply+0xcc>)
    cd28:	4798      	blx	r3
        goto Exit;
    cd2a:	e02b      	b.n	cd84 <AJ_PeerHandleKeyAuthenticationReply+0xb4>
    }

    // Receive authentication material
    status = AJ_KeyAuthenticationUnmarshal(&authContext, msg);
    cd2c:	4823      	ldr	r0, [pc, #140]	; (cdbc <AJ_PeerHandleKeyAuthenticationReply+0xec>)
    cd2e:	1c21      	adds	r1, r4, #0
    cd30:	4b23      	ldr	r3, [pc, #140]	; (cdc0 <AJ_PeerHandleKeyAuthenticationReply+0xf0>)
    cd32:	4798      	blx	r3
    if (AJ_OK != status)
    cd34:	2800      	cmp	r0, #0
    cd36:	d004      	beq.n	cd42 <AJ_PeerHandleKeyAuthenticationReply+0x72>
	{
		printf("AJ_PeerHandleKeyAuthenticationReply(msg=%p): Key authentication unmarshal error\n", msg);
    cd38:	4822      	ldr	r0, [pc, #136]	; (cdc4 <AJ_PeerHandleKeyAuthenticationReply+0xf4>)
    cd3a:	1c21      	adds	r1, r4, #0
    cd3c:	4b17      	ldr	r3, [pc, #92]	; (cd9c <AJ_PeerHandleKeyAuthenticationReply+0xcc>)
    cd3e:	4798      	blx	r3
        goto Exit;
    cd40:	e020      	b.n	cd84 <AJ_PeerHandleKeyAuthenticationReply+0xb4>
    }

    // Key authentication complete - start the session
	 printf("Key Authentication Complete\n");
    cd42:	4821      	ldr	r0, [pc, #132]	; (cdc8 <AJ_PeerHandleKeyAuthenticationReply+0xf8>)
    cd44:	4b21      	ldr	r3, [pc, #132]	; (cdcc <AJ_PeerHandleKeyAuthenticationReply+0xfc>)
    cd46:	4798      	blx	r3
    peerContext.state = AJ_AUTH_SUCCESS;
    cd48:	2202      	movs	r2, #2
    cd4a:	4b1a      	ldr	r3, [pc, #104]	; (cdb4 <AJ_PeerHandleKeyAuthenticationReply+0xe4>)
    cd4c:	701a      	strb	r2, [r3, #0]

    if (authContext.expiration)
    cd4e:	2390      	movs	r3, #144	; 0x90
    cd50:	005b      	lsls	r3, r3, #1
    cd52:	4a1a      	ldr	r2, [pc, #104]	; (cdbc <AJ_PeerHandleKeyAuthenticationReply+0xec>)
    cd54:	58d1      	ldr	r1, [r2, r3]
    cd56:	2900      	cmp	r1, #0
    cd58:	d00f      	beq.n	cd7a <AJ_PeerHandleKeyAuthenticationReply+0xaa>
   {
        status = SaveMasterSecret(peerGuid, authContext.expiration);
    cd5a:	1c28      	adds	r0, r5, #0
    cd5c:	4b1c      	ldr	r3, [pc, #112]	; (cdd0 <AJ_PeerHandleKeyAuthenticationReply+0x100>)
    cd5e:	4798      	blx	r3
        if (AJ_OK != status) 
    cd60:	2800      	cmp	r0, #0
    cd62:	d00a      	beq.n	cd7a <AJ_PeerHandleKeyAuthenticationReply+0xaa>
		{
            AJ_WarnPrintf(("AJ_PeerHandleKeyAuthenticationReply(msg=%p): Save master secret error\n", msg));
    cd64:	2002      	movs	r0, #2
    cd66:	491b      	ldr	r1, [pc, #108]	; (cdd4 <AJ_PeerHandleKeyAuthenticationReply+0x104>)
    cd68:	4a1b      	ldr	r2, [pc, #108]	; (cdd8 <AJ_PeerHandleKeyAuthenticationReply+0x108>)
    cd6a:	4b1c      	ldr	r3, [pc, #112]	; (cddc <AJ_PeerHandleKeyAuthenticationReply+0x10c>)
    cd6c:	4798      	blx	r3
    cd6e:	2800      	cmp	r0, #0
    cd70:	d003      	beq.n	cd7a <AJ_PeerHandleKeyAuthenticationReply+0xaa>
    cd72:	481b      	ldr	r0, [pc, #108]	; (cde0 <AJ_PeerHandleKeyAuthenticationReply+0x110>)
    cd74:	1c21      	adds	r1, r4, #0
    cd76:	4b09      	ldr	r3, [pc, #36]	; (cd9c <AJ_PeerHandleKeyAuthenticationReply+0xcc>)
    cd78:	4798      	blx	r3
        }
    }

    status = GenSessionKey(msg);
    cd7a:	1c20      	adds	r0, r4, #0
    cd7c:	4b19      	ldr	r3, [pc, #100]	; (cde4 <AJ_PeerHandleKeyAuthenticationReply+0x114>)
    cd7e:	4798      	blx	r3
    if (AJ_OK != status)
    cd80:	2800      	cmp	r0, #0
    cd82:	d004      	beq.n	cd8e <AJ_PeerHandleKeyAuthenticationReply+0xbe>
    }

    return status;

Exit:
    HandshakeComplete(AJ_ERR_SECURITY);
    cd84:	200d      	movs	r0, #13
    cd86:	4b09      	ldr	r3, [pc, #36]	; (cdac <AJ_PeerHandleKeyAuthenticationReply+0xdc>)
    cd88:	4798      	blx	r3
    return AJ_ERR_SECURITY;
    cd8a:	230d      	movs	r3, #13
    cd8c:	e000      	b.n	cd90 <AJ_PeerHandleKeyAuthenticationReply+0xc0>
    if (AJ_OK != status)
	{
        goto Exit;
    }

    return status;
    cd8e:	2300      	movs	r3, #0

Exit:
    HandshakeComplete(AJ_ERR_SECURITY);
    return AJ_ERR_SECURITY;
}
    cd90:	1c18      	adds	r0, r3, #0
    cd92:	bd38      	pop	{r3, r4, r5, pc}
    cd94:	00007bdd 	.word	0x00007bdd
    cd98:	0001e48c 	.word	0x0001e48c
    cd9c:	00016e3d 	.word	0x00016e3d
    cda0:	0001e4bc 	.word	0x0001e4bc
    cda4:	0001e714 	.word	0x0001e714
    cda8:	00017169 	.word	0x00017169
    cdac:	0000c56d 	.word	0x0000c56d
    cdb0:	0000c649 	.word	0x0000c649
    cdb4:	20001128 	.word	0x20001128
    cdb8:	0001e4f4 	.word	0x0001e4f4
    cdbc:	20001000 	.word	0x20001000
    cdc0:	00002265 	.word	0x00002265
    cdc4:	0001e530 	.word	0x0001e530
    cdc8:	0001e584 	.word	0x0001e584
    cdcc:	00016f5d 	.word	0x00016f5d
    cdd0:	0000c3c5 	.word	0x0000c3c5
    cdd4:	0001dddc 	.word	0x0001dddc
    cdd8:	000003e1 	.word	0x000003e1
    cddc:	0000636d 	.word	0x0000636d
    cde0:	0001e5a0 	.word	0x0001e5a0
    cde4:	0000c339 	.word	0x0000c339

0000cde8 <AJ_PeerHandleGenSessionKey>:

    return AJ_DeliverMsg(&call);
}

AJ_Status AJ_PeerHandleGenSessionKey(AJ_Message* msg, AJ_Message* reply)
{
    cde8:	b570      	push	{r4, r5, r6, lr}
    cdea:	b094      	sub	sp, #80	; 0x50
    cdec:	1c04      	adds	r4, r0, #0
    cdee:	1c0d      	adds	r5, r1, #0
    char* remGuid;
    char* locGuid;
    char* nonce;
    AJ_GUID guid;
    AJ_GUID localGuid;
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    cdf0:	6940      	ldr	r0, [r0, #20]
    cdf2:	4b48      	ldr	r3, [pc, #288]	; (cf14 <AJ_PeerHandleGenSessionKey+0x12c>)
    cdf4:	4798      	blx	r3
    cdf6:	1c06      	adds	r6, r0, #0
	localGuid.val[0]=0xbf;
    cdf8:	ab09      	add	r3, sp, #36	; 0x24
    cdfa:	22bf      	movs	r2, #191	; 0xbf
    cdfc:	701a      	strb	r2, [r3, #0]
	localGuid.val[1]=0xa9;
    cdfe:	3a16      	subs	r2, #22
    ce00:	705a      	strb	r2, [r3, #1]
	localGuid.val[2]=0xaa;
    ce02:	3201      	adds	r2, #1
    ce04:	709a      	strb	r2, [r3, #2]
	localGuid.val[3]=0x3f;
    ce06:	3a6b      	subs	r2, #107	; 0x6b
    ce08:	70da      	strb	r2, [r3, #3]
	
	localGuid.val[4]=0x2e;
    ce0a:	3a11      	subs	r2, #17
    ce0c:	711a      	strb	r2, [r3, #4]
	localGuid.val[5]=0xce;
    ce0e:	21ce      	movs	r1, #206	; 0xce
    ce10:	7159      	strb	r1, [r3, #5]
	localGuid.val[6]=0x2e;
    ce12:	719a      	strb	r2, [r3, #6]
	localGuid.val[7]=0xfd;
    ce14:	32cf      	adds	r2, #207	; 0xcf
    ce16:	71da      	strb	r2, [r3, #7]
	
	localGuid.val[8]=0xa2;
    ce18:	3a5b      	subs	r2, #91	; 0x5b
    ce1a:	721a      	strb	r2, [r3, #8]
	localGuid.val[9]=0x1b;
    ce1c:	3a87      	subs	r2, #135	; 0x87
    ce1e:	725a      	strb	r2, [r3, #9]
	localGuid.val[10]=0xb5;
    ce20:	329a      	adds	r2, #154	; 0x9a
    ce22:	729a      	strb	r2, [r3, #10]
	localGuid.val[11]=0xb1;
    ce24:	3a04      	subs	r2, #4
    ce26:	72da      	strb	r2, [r3, #11]
	
	localGuid.val[12]=0x63;
    ce28:	3a4e      	subs	r2, #78	; 0x4e
    ce2a:	731a      	strb	r2, [r3, #12]
	localGuid.val[13]=0x2b;
    ce2c:	3a38      	subs	r2, #56	; 0x38
    ce2e:	735a      	strb	r2, [r3, #13]
	localGuid.val[14]=0x4f;
    ce30:	3224      	adds	r2, #36	; 0x24
    ce32:	739a      	strb	r2, [r3, #14]
	localGuid.val[15]=0x77;
    ce34:	3228      	adds	r2, #40	; 0x28
    ce36:	73da      	strb	r2, [r3, #15]
     * (to store 16 bytes key in addition to the 12 bytes verifier).
     * Hence we allocate, the maximum of (12 * 2 + 1) and (16 + 12).
     */
    char verifier[AES_KEY_LEN + AJ_VERIFIER_LEN];

    printf("AJ_PeerHandleGenSessionKey(msg=%p, reply=%p)\n", msg, reply);
    ce38:	4837      	ldr	r0, [pc, #220]	; (cf18 <AJ_PeerHandleGenSessionKey+0x130>)
    ce3a:	1c21      	adds	r1, r4, #0
    ce3c:	1c2a      	adds	r2, r5, #0
    ce3e:	4b37      	ldr	r3, [pc, #220]	; (cf1c <AJ_PeerHandleGenSessionKey+0x134>)
    ce40:	4798      	blx	r3

    status = HandshakeValid(peerGuid);
    ce42:	1c30      	adds	r0, r6, #0
    ce44:	4b36      	ldr	r3, [pc, #216]	; (cf20 <AJ_PeerHandleGenSessionKey+0x138>)
    ce46:	4798      	blx	r3
    if (AJ_OK != status) 
    ce48:	2800      	cmp	r0, #0
    ce4a:	d008      	beq.n	ce5e <AJ_PeerHandleGenSessionKey+0x76>
	{
		 printf("AJ_PeerHandleGenSessionKey: HandshakeValid\n");
    ce4c:	4835      	ldr	r0, [pc, #212]	; (cf24 <AJ_PeerHandleGenSessionKey+0x13c>)
    ce4e:	4b36      	ldr	r3, [pc, #216]	; (cf28 <AJ_PeerHandleGenSessionKey+0x140>)
    ce50:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrResources);
    ce52:	1c20      	adds	r0, r4, #0
    ce54:	1c29      	adds	r1, r5, #0
    ce56:	4a35      	ldr	r2, [pc, #212]	; (cf2c <AJ_PeerHandleGenSessionKey+0x144>)
    ce58:	4b35      	ldr	r3, [pc, #212]	; (cf30 <AJ_PeerHandleGenSessionKey+0x148>)
    ce5a:	4798      	blx	r3
    ce5c:	e058      	b.n	cf10 <AJ_PeerHandleGenSessionKey+0x128>
    }
    if (AJ_AUTH_SUCCESS != peerContext.state) 
    ce5e:	4b35      	ldr	r3, [pc, #212]	; (cf34 <AJ_PeerHandleGenSessionKey+0x14c>)
    ce60:	781b      	ldrb	r3, [r3, #0]
    ce62:	2b02      	cmp	r3, #2
    ce64:	d00a      	beq.n	ce7c <AJ_PeerHandleGenSessionKey+0x94>
	{
        // We don't have a saved master secret and we haven't generated one yet
        printf("AJ_PeerHandleGenSessionKey(msg=%p, reply=%p): Key not available\n", msg, reply);
    ce66:	4834      	ldr	r0, [pc, #208]	; (cf38 <AJ_PeerHandleGenSessionKey+0x150>)
    ce68:	1c21      	adds	r1, r4, #0
    ce6a:	1c2a      	adds	r2, r5, #0
    ce6c:	4b2b      	ldr	r3, [pc, #172]	; (cf1c <AJ_PeerHandleGenSessionKey+0x134>)
    ce6e:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrRejected);
    ce70:	1c20      	adds	r0, r4, #0
    ce72:	1c29      	adds	r1, r5, #0
    ce74:	4a31      	ldr	r2, [pc, #196]	; (cf3c <AJ_PeerHandleGenSessionKey+0x154>)
    ce76:	4b2e      	ldr	r3, [pc, #184]	; (cf30 <AJ_PeerHandleGenSessionKey+0x148>)
    ce78:	4798      	blx	r3
    ce7a:	e049      	b.n	cf10 <AJ_PeerHandleGenSessionKey+0x128>
    }

    // Remote peer GUID, Local peer GUID and Remote peer's nonce
    AJ_UnmarshalArgs(msg, "sss", &remGuid, &locGuid, &nonce);
    ce7c:	ab11      	add	r3, sp, #68	; 0x44
    ce7e:	9300      	str	r3, [sp, #0]
    ce80:	1c20      	adds	r0, r4, #0
    ce82:	492f      	ldr	r1, [pc, #188]	; (cf40 <AJ_PeerHandleGenSessionKey+0x158>)
    ce84:	aa13      	add	r2, sp, #76	; 0x4c
    ce86:	ab12      	add	r3, sp, #72	; 0x48
    ce88:	4e2e      	ldr	r6, [pc, #184]	; (cf44 <AJ_PeerHandleGenSessionKey+0x15c>)
    ce8a:	47b0      	blx	r6
    // We expect arg[1] to be the local GUID
    status = AJ_GUID_FromString(&guid, locGuid);
    ce8c:	a80d      	add	r0, sp, #52	; 0x34
    ce8e:	9912      	ldr	r1, [sp, #72]	; 0x48
    ce90:	4b2d      	ldr	r3, [pc, #180]	; (cf48 <AJ_PeerHandleGenSessionKey+0x160>)
    ce92:	4798      	blx	r3
    if (AJ_OK == status) 
    ce94:	2800      	cmp	r0, #0
    ce96:	d10b      	bne.n	ceb0 <AJ_PeerHandleGenSessionKey+0xc8>
	{
        status = AJ_GetLocalGUID(&localGuid);
    ce98:	a809      	add	r0, sp, #36	; 0x24
    ce9a:	4b2c      	ldr	r3, [pc, #176]	; (cf4c <AJ_PeerHandleGenSessionKey+0x164>)
    ce9c:	4798      	blx	r3
    }
    if ((status != AJ_OK) || (memcmp(&guid, &localGuid, sizeof(AJ_GUID)) != 0)) 
    ce9e:	2800      	cmp	r0, #0
    cea0:	d106      	bne.n	ceb0 <AJ_PeerHandleGenSessionKey+0xc8>
    cea2:	a80d      	add	r0, sp, #52	; 0x34
    cea4:	a909      	add	r1, sp, #36	; 0x24
    cea6:	2210      	movs	r2, #16
    cea8:	4b29      	ldr	r3, [pc, #164]	; (cf50 <AJ_PeerHandleGenSessionKey+0x168>)
    ceaa:	4798      	blx	r3
    ceac:	2800      	cmp	r0, #0
    ceae:	d008      	beq.n	cec2 <AJ_PeerHandleGenSessionKey+0xda>
	{
        HandshakeComplete(AJ_ERR_SECURITY);
    ceb0:	200d      	movs	r0, #13
    ceb2:	4b28      	ldr	r3, [pc, #160]	; (cf54 <AJ_PeerHandleGenSessionKey+0x16c>)
    ceb4:	4798      	blx	r3
        return AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    ceb6:	1c20      	adds	r0, r4, #0
    ceb8:	1c29      	adds	r1, r5, #0
    ceba:	4a27      	ldr	r2, [pc, #156]	; (cf58 <AJ_PeerHandleGenSessionKey+0x170>)
    cebc:	4b1c      	ldr	r3, [pc, #112]	; (cf30 <AJ_PeerHandleGenSessionKey+0x148>)
    cebe:	4798      	blx	r3
    cec0:	e026      	b.n	cf10 <AJ_PeerHandleGenSessionKey+0x128>
    }
    AJ_RandHex(peerContext.nonce, sizeof(peerContext.nonce), AJ_NONCE_LEN);
    cec2:	4e1c      	ldr	r6, [pc, #112]	; (cf34 <AJ_PeerHandleGenSessionKey+0x14c>)
    cec4:	361c      	adds	r6, #28
    cec6:	1c30      	adds	r0, r6, #0
    cec8:	2139      	movs	r1, #57	; 0x39
    ceca:	221c      	movs	r2, #28
    cecc:	4b23      	ldr	r3, [pc, #140]	; (cf5c <AJ_PeerHandleGenSessionKey+0x174>)
    cece:	4798      	blx	r3
//	char dummy[2 * AJ_NONCE_LEN + 1]="0FCA49DB6B207379992C89188B5A247A5DF4C03980792C56B71FCC95";
//	memcpy(peerContext.nonce,dummy,sizeof(peerContext.nonce) );
    status = KeyGen(msg->sender, AJ_ROLE_KEY_RESPONDER, nonce, peerContext.nonce, (uint8_t*)verifier, sizeof(verifier));
    ced0:	ab02      	add	r3, sp, #8
    ced2:	9300      	str	r3, [sp, #0]
    ced4:	231c      	movs	r3, #28
    ced6:	9301      	str	r3, [sp, #4]
    ced8:	6960      	ldr	r0, [r4, #20]
    ceda:	2102      	movs	r1, #2
    cedc:	9a11      	ldr	r2, [sp, #68]	; 0x44
    cede:	1c33      	adds	r3, r6, #0
    cee0:	4e1f      	ldr	r6, [pc, #124]	; (cf60 <AJ_PeerHandleGenSessionKey+0x178>)
    cee2:	47b0      	blx	r6
    if (status == AJ_OK) 
    cee4:	2800      	cmp	r0, #0
    cee6:	d10b      	bne.n	cf00 <AJ_PeerHandleGenSessionKey+0x118>
	{
        AJ_MarshalReplyMsg(msg, reply);
    cee8:	1c20      	adds	r0, r4, #0
    ceea:	1c29      	adds	r1, r5, #0
    ceec:	4b1d      	ldr	r3, [pc, #116]	; (cf64 <AJ_PeerHandleGenSessionKey+0x17c>)
    ceee:	4798      	blx	r3
        status = AJ_MarshalArgs(reply, "ss", peerContext.nonce, verifier);
    cef0:	1c28      	adds	r0, r5, #0
    cef2:	491d      	ldr	r1, [pc, #116]	; (cf68 <AJ_PeerHandleGenSessionKey+0x180>)
    cef4:	4a0f      	ldr	r2, [pc, #60]	; (cf34 <AJ_PeerHandleGenSessionKey+0x14c>)
    cef6:	321c      	adds	r2, #28
    cef8:	ab02      	add	r3, sp, #8
    cefa:	4c1c      	ldr	r4, [pc, #112]	; (cf6c <AJ_PeerHandleGenSessionKey+0x184>)
    cefc:	47a0      	blx	r4
    cefe:	e007      	b.n	cf10 <AJ_PeerHandleGenSessionKey+0x128>
    } 
	else
	{
        HandshakeComplete(AJ_ERR_SECURITY);
    cf00:	200d      	movs	r0, #13
    cf02:	4b14      	ldr	r3, [pc, #80]	; (cf54 <AJ_PeerHandleGenSessionKey+0x16c>)
    cf04:	4798      	blx	r3
        status = AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    cf06:	1c20      	adds	r0, r4, #0
    cf08:	1c29      	adds	r1, r5, #0
    cf0a:	4a13      	ldr	r2, [pc, #76]	; (cf58 <AJ_PeerHandleGenSessionKey+0x170>)
    cf0c:	4b08      	ldr	r3, [pc, #32]	; (cf30 <AJ_PeerHandleGenSessionKey+0x148>)
    cf0e:	4798      	blx	r3
    }
    return status;
}
    cf10:	b014      	add	sp, #80	; 0x50
    cf12:	bd70      	pop	{r4, r5, r6, pc}
    cf14:	00007bdd 	.word	0x00007bdd
    cf18:	0001e5e8 	.word	0x0001e5e8
    cf1c:	00016e3d 	.word	0x00016e3d
    cf20:	0000c649 	.word	0x0000c649
    cf24:	0001e618 	.word	0x0001e618
    cf28:	00016f5d 	.word	0x00016f5d
    cf2c:	0001e714 	.word	0x0001e714
    cf30:	0000be55 	.word	0x0000be55
    cf34:	20001128 	.word	0x20001128
    cf38:	0001e644 	.word	0x0001e644
    cf3c:	0001e924 	.word	0x0001e924
    cf40:	0001c97c 	.word	0x0001c97c
    cf44:	0000b5f5 	.word	0x0000b5f5
    cf48:	00007a99 	.word	0x00007a99
    cf4c:	00004431 	.word	0x00004431
    cf50:	0001671b 	.word	0x0001671b
    cf54:	0000c56d 	.word	0x0000c56d
    cf58:	0001eb70 	.word	0x0001eb70
    cf5c:	00004a3d 	.word	0x00004a3d
    cf60:	0000c425 	.word	0x0000c425
    cf64:	0000bd45 	.word	0x0000bd45
    cf68:	00018490 	.word	0x00018490
    cf6c:	0000bc85 	.word	0x0000bc85

0000cf70 <AJ_PeerHandleExchangeGroupKeys>:
    }
    return status;
}

AJ_Status AJ_PeerHandleExchangeGroupKeys(AJ_Message* msg, AJ_Message* reply)
{
    cf70:	b570      	push	{r4, r5, r6, lr}
    cf72:	b08a      	sub	sp, #40	; 0x28
    cf74:	1c04      	adds	r4, r0, #0
    cf76:	1c0d      	adds	r5, r1, #0
    AJ_Status status;
    AJ_Arg key;
    const AJ_GUID* peerGuid = AJ_GUID_Find(msg->sender);
    cf78:	6940      	ldr	r0, [r0, #20]
    cf7a:	4b20      	ldr	r3, [pc, #128]	; (cffc <AJ_PeerHandleExchangeGroupKeys+0x8c>)
    cf7c:	4798      	blx	r3
    cf7e:	1c06      	adds	r6, r0, #0

    printf("AJ_PeerHandleExchangeGroupKeys(msg=%p, reply=%p)\n", msg, reply);
    cf80:	481f      	ldr	r0, [pc, #124]	; (d000 <AJ_PeerHandleExchangeGroupKeys+0x90>)
    cf82:	1c21      	adds	r1, r4, #0
    cf84:	1c2a      	adds	r2, r5, #0
    cf86:	4b1f      	ldr	r3, [pc, #124]	; (d004 <AJ_PeerHandleExchangeGroupKeys+0x94>)
    cf88:	4798      	blx	r3

    status = HandshakeValid(peerGuid);
    cf8a:	1c30      	adds	r0, r6, #0
    cf8c:	4b1e      	ldr	r3, [pc, #120]	; (d008 <AJ_PeerHandleExchangeGroupKeys+0x98>)
    cf8e:	4798      	blx	r3
    cf90:	1e03      	subs	r3, r0, #0
    if (AJ_OK != status) 
    cf92:	d131      	bne.n	cff8 <AJ_PeerHandleExchangeGroupKeys+0x88>
	{
        return status;
    }

    AJ_UnmarshalArg(msg, &key);
    cf94:	ae06      	add	r6, sp, #24
    cf96:	1c20      	adds	r0, r4, #0
    cf98:	1c31      	adds	r1, r6, #0
    cf9a:	4b1c      	ldr	r3, [pc, #112]	; (d00c <AJ_PeerHandleExchangeGroupKeys+0x9c>)
    cf9c:	4798      	blx	r3
    //   We expect the key to be 16 bytes
    if (key.len != AES_KEY_LEN) 
    cf9e:	8873      	ldrh	r3, [r6, #2]
    cfa0:	2b10      	cmp	r3, #16
    cfa2:	d003      	beq.n	cfac <AJ_PeerHandleExchangeGroupKeys+0x3c>
	{
        printf("AJ_PeerHandleExchangeGroupKeys(): AJ_ERR_INVALID\n");
    cfa4:	481a      	ldr	r0, [pc, #104]	; (d010 <AJ_PeerHandleExchangeGroupKeys+0xa0>)
    cfa6:	4b1b      	ldr	r3, [pc, #108]	; (d014 <AJ_PeerHandleExchangeGroupKeys+0xa4>)
    cfa8:	4798      	blx	r3
    cfaa:	e01b      	b.n	cfe4 <AJ_PeerHandleExchangeGroupKeys+0x74>
        status = AJ_ERR_INVALID;
    } 
	else
	{
        status = AJ_SetGroupKey(msg->sender, key.val.v_byte);
    cfac:	6960      	ldr	r0, [r4, #20]
    cfae:	9907      	ldr	r1, [sp, #28]
    cfb0:	4b19      	ldr	r3, [pc, #100]	; (d018 <AJ_PeerHandleExchangeGroupKeys+0xa8>)
    cfb2:	4798      	blx	r3
    }
    if (status == AJ_OK) 
    cfb4:	2800      	cmp	r0, #0
    cfb6:	d115      	bne.n	cfe4 <AJ_PeerHandleExchangeGroupKeys+0x74>
	{
        uint8_t groupKey[AES_KEY_LEN];
        AJ_MarshalReplyMsg(msg, reply);
    cfb8:	1c20      	adds	r0, r4, #0
    cfba:	1c29      	adds	r1, r5, #0
    cfbc:	4b17      	ldr	r3, [pc, #92]	; (d01c <AJ_PeerHandleExchangeGroupKeys+0xac>)
    cfbe:	4798      	blx	r3
        AJ_GetGroupKey(NULL, groupKey);
    cfc0:	2000      	movs	r0, #0
    cfc2:	a902      	add	r1, sp, #8
    cfc4:	4b16      	ldr	r3, [pc, #88]	; (d020 <AJ_PeerHandleExchangeGroupKeys+0xb0>)
    cfc6:	4798      	blx	r3
        status = AJ_MarshalArg(reply, AJ_InitArg(&key, AJ_ARG_BYTE, AJ_ARRAY_FLAG, groupKey, sizeof(groupKey)));
    cfc8:	2310      	movs	r3, #16
    cfca:	9300      	str	r3, [sp, #0]
    cfcc:	a806      	add	r0, sp, #24
    cfce:	2179      	movs	r1, #121	; 0x79
    cfd0:	2201      	movs	r2, #1
    cfd2:	ab02      	add	r3, sp, #8
    cfd4:	4c13      	ldr	r4, [pc, #76]	; (d024 <AJ_PeerHandleExchangeGroupKeys+0xb4>)
    cfd6:	47a0      	blx	r4
    cfd8:	1c01      	adds	r1, r0, #0
    cfda:	1c28      	adds	r0, r5, #0
    cfdc:	4b12      	ldr	r3, [pc, #72]	; (d028 <AJ_PeerHandleExchangeGroupKeys+0xb8>)
    cfde:	4798      	blx	r3
    cfe0:	1c04      	adds	r4, r0, #0
    cfe2:	e005      	b.n	cff0 <AJ_PeerHandleExchangeGroupKeys+0x80>
    } 
	else 
	{
        status = AJ_MarshalErrorMsg(msg, reply, AJ_ErrSecurityViolation);
    cfe4:	1c20      	adds	r0, r4, #0
    cfe6:	1c29      	adds	r1, r5, #0
    cfe8:	4a10      	ldr	r2, [pc, #64]	; (d02c <AJ_PeerHandleExchangeGroupKeys+0xbc>)
    cfea:	4b11      	ldr	r3, [pc, #68]	; (d030 <AJ_PeerHandleExchangeGroupKeys+0xc0>)
    cfec:	4798      	blx	r3
    cfee:	1c04      	adds	r4, r0, #0
    }
    HandshakeComplete(status);
    cff0:	1c20      	adds	r0, r4, #0
    cff2:	4b10      	ldr	r3, [pc, #64]	; (d034 <AJ_PeerHandleExchangeGroupKeys+0xc4>)
    cff4:	4798      	blx	r3
    return status;
    cff6:	1c20      	adds	r0, r4, #0
}
    cff8:	b00a      	add	sp, #40	; 0x28
    cffa:	bd70      	pop	{r4, r5, r6, pc}
    cffc:	00007bdd 	.word	0x00007bdd
    d000:	0001e688 	.word	0x0001e688
    d004:	00016e3d 	.word	0x00016e3d
    d008:	0000c649 	.word	0x0000c649
    d00c:	0000a855 	.word	0x0000a855
    d010:	0001e6bc 	.word	0x0001e6bc
    d014:	00016f5d 	.word	0x00016f5d
    d018:	00007c0d 	.word	0x00007c0d
    d01c:	0000bd45 	.word	0x0000bd45
    d020:	00007cd9 	.word	0x00007cd9
    d024:	0000b6b5 	.word	0x0000b6b5
    d028:	0000b615 	.word	0x0000b615
    d02c:	0001eb70 	.word	0x0001eb70
    d030:	0000be55 	.word	0x0000be55
    d034:	0000c56d 	.word	0x0000c56d

0000d038 <EncryptRounds>:

#define ROUNDS 10


static void EncryptRounds(uint32_t* out, uint32_t* in, uint32_t* key)
{
    d038:	b5f0      	push	{r4, r5, r6, r7, lr}
    d03a:	465f      	mov	r7, fp
    d03c:	4656      	mov	r6, sl
    d03e:	464d      	mov	r5, r9
    d040:	4644      	mov	r4, r8
    d042:	b4f0      	push	{r4, r5, r6, r7}
    d044:	b089      	sub	sp, #36	; 0x24
    d046:	9007      	str	r0, [sp, #28]
    d048:	9206      	str	r2, [sp, #24]
    int i;
    uint32_t x0 = in[0];
    d04a:	680b      	ldr	r3, [r1, #0]
    d04c:	9304      	str	r3, [sp, #16]
    uint32_t x1 = in[1];
    d04e:	684b      	ldr	r3, [r1, #4]
    d050:	469b      	mov	fp, r3
    uint32_t x2 = in[2];
    d052:	688b      	ldr	r3, [r1, #8]
    d054:	9301      	str	r3, [sp, #4]
    uint32_t x3 = in[3];
    d056:	68cc      	ldr	r4, [r1, #12]
    d058:	4694      	mov	ip, r2
    d05a:	3280      	adds	r2, #128	; 0x80
    d05c:	9205      	str	r2, [sp, #20]
    uint32_t y2;
    uint32_t y3;

    for (i = 0; i < 4; i++) 
	{
        round(y0, y1, y2, y3, x0, x1, x2, x3, key);
    d05e:	4df6      	ldr	r5, [pc, #984]	; (d438 <EncryptRounds+0x400>)
    d060:	27ff      	movs	r7, #255	; 0xff
    d062:	2308      	movs	r3, #8
    d064:	469a      	mov	sl, r3
    d066:	3310      	adds	r3, #16
    d068:	4699      	mov	r9, r3
    d06a:	3b08      	subs	r3, #8
    d06c:	4698      	mov	r8, r3
    d06e:	465b      	mov	r3, fp
    d070:	9302      	str	r3, [sp, #8]
    d072:	9804      	ldr	r0, [sp, #16]
    d074:	1c02      	adds	r2, r0, #0
    d076:	403a      	ands	r2, r7
    d078:	0092      	lsls	r2, r2, #2
    d07a:	5956      	ldr	r6, [r2, r5]
    d07c:	4663      	mov	r3, ip
    d07e:	6819      	ldr	r1, [r3, #0]
    d080:	4071      	eors	r1, r6
    d082:	0e22      	lsrs	r2, r4, #24
    d084:	0092      	lsls	r2, r2, #2
    d086:	5952      	ldr	r2, [r2, r5]
    d088:	4653      	mov	r3, sl
    d08a:	41da      	rors	r2, r3
    d08c:	4051      	eors	r1, r2
    d08e:	1c0e      	adds	r6, r1, #0
    d090:	9a02      	ldr	r2, [sp, #8]
    d092:	0a12      	lsrs	r2, r2, #8
    d094:	403a      	ands	r2, r7
    d096:	0092      	lsls	r2, r2, #2
    d098:	5951      	ldr	r1, [r2, r5]
    d09a:	464b      	mov	r3, r9
    d09c:	41d9      	rors	r1, r3
    d09e:	404e      	eors	r6, r1
    d0a0:	9b01      	ldr	r3, [sp, #4]
    d0a2:	0c19      	lsrs	r1, r3, #16
    d0a4:	4039      	ands	r1, r7
    d0a6:	0089      	lsls	r1, r1, #2
    d0a8:	5949      	ldr	r1, [r1, r5]
    d0aa:	4643      	mov	r3, r8
    d0ac:	41d9      	rors	r1, r3
    d0ae:	4071      	eors	r1, r6
    d0b0:	1c3e      	adds	r6, r7, #0
    d0b2:	9a02      	ldr	r2, [sp, #8]
    d0b4:	4016      	ands	r6, r2
    d0b6:	00b2      	lsls	r2, r6, #2
    d0b8:	5956      	ldr	r6, [r2, r5]
    d0ba:	4663      	mov	r3, ip
    d0bc:	685b      	ldr	r3, [r3, #4]
    d0be:	405e      	eors	r6, r3
    d0c0:	0e02      	lsrs	r2, r0, #24
    d0c2:	0092      	lsls	r2, r2, #2
    d0c4:	5952      	ldr	r2, [r2, r5]
    d0c6:	4653      	mov	r3, sl
    d0c8:	41da      	rors	r2, r3
    d0ca:	4056      	eors	r6, r2
    d0cc:	9b01      	ldr	r3, [sp, #4]
    d0ce:	0a1a      	lsrs	r2, r3, #8
    d0d0:	403a      	ands	r2, r7
    d0d2:	0092      	lsls	r2, r2, #2
    d0d4:	5952      	ldr	r2, [r2, r5]
    d0d6:	464b      	mov	r3, r9
    d0d8:	41da      	rors	r2, r3
    d0da:	4056      	eors	r6, r2
    d0dc:	0c22      	lsrs	r2, r4, #16
    d0de:	403a      	ands	r2, r7
    d0e0:	0092      	lsls	r2, r2, #2
    d0e2:	5952      	ldr	r2, [r2, r5]
    d0e4:	4643      	mov	r3, r8
    d0e6:	41da      	rors	r2, r3
    d0e8:	4072      	eors	r2, r6
    d0ea:	9203      	str	r2, [sp, #12]
    d0ec:	1c3e      	adds	r6, r7, #0
    d0ee:	9b01      	ldr	r3, [sp, #4]
    d0f0:	401e      	ands	r6, r3
    d0f2:	00b6      	lsls	r6, r6, #2
    d0f4:	5976      	ldr	r6, [r6, r5]
    d0f6:	4663      	mov	r3, ip
    d0f8:	689a      	ldr	r2, [r3, #8]
    d0fa:	4072      	eors	r2, r6
    d0fc:	9e02      	ldr	r6, [sp, #8]
    d0fe:	0e36      	lsrs	r6, r6, #24
    d100:	00b6      	lsls	r6, r6, #2
    d102:	5976      	ldr	r6, [r6, r5]
    d104:	4653      	mov	r3, sl
    d106:	41de      	rors	r6, r3
    d108:	4056      	eors	r6, r2
    d10a:	0a23      	lsrs	r3, r4, #8
    d10c:	1c1a      	adds	r2, r3, #0
    d10e:	403a      	ands	r2, r7
    d110:	0093      	lsls	r3, r2, #2
    d112:	595b      	ldr	r3, [r3, r5]
    d114:	1c1a      	adds	r2, r3, #0
    d116:	464b      	mov	r3, r9
    d118:	41da      	rors	r2, r3
    d11a:	4056      	eors	r6, r2
    d11c:	1c02      	adds	r2, r0, #0
    d11e:	0c03      	lsrs	r3, r0, #16
    d120:	403b      	ands	r3, r7
    d122:	009b      	lsls	r3, r3, #2
    d124:	595b      	ldr	r3, [r3, r5]
    d126:	4640      	mov	r0, r8
    d128:	41c3      	rors	r3, r0
    d12a:	405e      	eors	r6, r3
    d12c:	403c      	ands	r4, r7
    d12e:	00a4      	lsls	r4, r4, #2
    d130:	5964      	ldr	r4, [r4, r5]
    d132:	4663      	mov	r3, ip
    d134:	68db      	ldr	r3, [r3, #12]
    d136:	405c      	eors	r4, r3
    d138:	9801      	ldr	r0, [sp, #4]
    d13a:	0e00      	lsrs	r0, r0, #24
    d13c:	0080      	lsls	r0, r0, #2
    d13e:	5940      	ldr	r0, [r0, r5]
    d140:	4653      	mov	r3, sl
    d142:	41d8      	rors	r0, r3
    d144:	4044      	eors	r4, r0
    d146:	0a10      	lsrs	r0, r2, #8
    d148:	4038      	ands	r0, r7
    d14a:	0080      	lsls	r0, r0, #2
    d14c:	5940      	ldr	r0, [r0, r5]
    d14e:	464b      	mov	r3, r9
    d150:	41d8      	rors	r0, r3
    d152:	4060      	eors	r0, r4
    d154:	9c02      	ldr	r4, [sp, #8]
    d156:	0c23      	lsrs	r3, r4, #16
    d158:	403b      	ands	r3, r7
    d15a:	009b      	lsls	r3, r3, #2
    d15c:	595c      	ldr	r4, [r3, r5]
    d15e:	4643      	mov	r3, r8
    d160:	41dc      	rors	r4, r3
    d162:	4044      	eors	r4, r0
    d164:	1c3b      	adds	r3, r7, #0
    d166:	400b      	ands	r3, r1
        round(x0, x1, x2, x3, y0, y1, y2, y3, key);
    d168:	009b      	lsls	r3, r3, #2
    d16a:	5958      	ldr	r0, [r3, r5]
    d16c:	4663      	mov	r3, ip
    d16e:	691b      	ldr	r3, [r3, #16]
    d170:	4058      	eors	r0, r3
    d172:	0e23      	lsrs	r3, r4, #24
    d174:	009b      	lsls	r3, r3, #2
    d176:	595b      	ldr	r3, [r3, r5]
    d178:	4652      	mov	r2, sl
    d17a:	41d3      	rors	r3, r2
    d17c:	4058      	eors	r0, r3
    d17e:	9b03      	ldr	r3, [sp, #12]
    d180:	0a1b      	lsrs	r3, r3, #8
    d182:	403b      	ands	r3, r7
    d184:	009b      	lsls	r3, r3, #2
    d186:	595b      	ldr	r3, [r3, r5]
    d188:	464a      	mov	r2, r9
    d18a:	41d3      	rors	r3, r2
    d18c:	4043      	eors	r3, r0
    d18e:	0c30      	lsrs	r0, r6, #16
    d190:	4038      	ands	r0, r7
    d192:	0080      	lsls	r0, r0, #2
    d194:	5940      	ldr	r0, [r0, r5]
    d196:	4642      	mov	r2, r8
    d198:	41d0      	rors	r0, r2
    d19a:	4043      	eors	r3, r0
    d19c:	9304      	str	r3, [sp, #16]
    d19e:	1c3b      	adds	r3, r7, #0
    d1a0:	9a03      	ldr	r2, [sp, #12]
    d1a2:	4013      	ands	r3, r2
    d1a4:	009b      	lsls	r3, r3, #2
    d1a6:	5958      	ldr	r0, [r3, r5]
    d1a8:	4663      	mov	r3, ip
    d1aa:	695b      	ldr	r3, [r3, #20]
    d1ac:	4058      	eors	r0, r3
    d1ae:	0e0b      	lsrs	r3, r1, #24
    d1b0:	009b      	lsls	r3, r3, #2
    d1b2:	595b      	ldr	r3, [r3, r5]
    d1b4:	4652      	mov	r2, sl
    d1b6:	41d3      	rors	r3, r2
    d1b8:	4058      	eors	r0, r3
    d1ba:	0a33      	lsrs	r3, r6, #8
    d1bc:	403b      	ands	r3, r7
    d1be:	009b      	lsls	r3, r3, #2
    d1c0:	595b      	ldr	r3, [r3, r5]
    d1c2:	464a      	mov	r2, r9
    d1c4:	41d3      	rors	r3, r2
    d1c6:	4058      	eors	r0, r3
    d1c8:	0c23      	lsrs	r3, r4, #16
    d1ca:	403b      	ands	r3, r7
    d1cc:	009b      	lsls	r3, r3, #2
    d1ce:	595b      	ldr	r3, [r3, r5]
    d1d0:	4642      	mov	r2, r8
    d1d2:	41d3      	rors	r3, r2
    d1d4:	4043      	eors	r3, r0
    d1d6:	9302      	str	r3, [sp, #8]
    d1d8:	1c38      	adds	r0, r7, #0
    d1da:	4030      	ands	r0, r6
    d1dc:	0080      	lsls	r0, r0, #2
    d1de:	5940      	ldr	r0, [r0, r5]
    d1e0:	4663      	mov	r3, ip
    d1e2:	699b      	ldr	r3, [r3, #24]
    d1e4:	4043      	eors	r3, r0
    d1e6:	469b      	mov	fp, r3
    d1e8:	9b03      	ldr	r3, [sp, #12]
    d1ea:	0e18      	lsrs	r0, r3, #24
    d1ec:	0080      	lsls	r0, r0, #2
    d1ee:	5940      	ldr	r0, [r0, r5]
    d1f0:	4653      	mov	r3, sl
    d1f2:	41d8      	rors	r0, r3
    d1f4:	465b      	mov	r3, fp
    d1f6:	4058      	eors	r0, r3
    d1f8:	0a23      	lsrs	r3, r4, #8
    d1fa:	403b      	ands	r3, r7
    d1fc:	009b      	lsls	r3, r3, #2
    d1fe:	595b      	ldr	r3, [r3, r5]
    d200:	464a      	mov	r2, r9
    d202:	41d3      	rors	r3, r2
    d204:	4058      	eors	r0, r3
    d206:	0c0b      	lsrs	r3, r1, #16
    d208:	403b      	ands	r3, r7
    d20a:	009b      	lsls	r3, r3, #2
    d20c:	595b      	ldr	r3, [r3, r5]
    d20e:	4642      	mov	r2, r8
    d210:	41d3      	rors	r3, r2
    d212:	4058      	eors	r0, r3
    d214:	9001      	str	r0, [sp, #4]
    d216:	403c      	ands	r4, r7
    d218:	00a4      	lsls	r4, r4, #2
    d21a:	5964      	ldr	r4, [r4, r5]
    d21c:	4663      	mov	r3, ip
    d21e:	69db      	ldr	r3, [r3, #28]
    d220:	405c      	eors	r4, r3
    d222:	0e36      	lsrs	r6, r6, #24
    d224:	00b6      	lsls	r6, r6, #2
    d226:	5976      	ldr	r6, [r6, r5]
    d228:	4653      	mov	r3, sl
    d22a:	41de      	rors	r6, r3
    d22c:	4074      	eors	r4, r6
    d22e:	0a09      	lsrs	r1, r1, #8
    d230:	4039      	ands	r1, r7
    d232:	0089      	lsls	r1, r1, #2
    d234:	594e      	ldr	r6, [r1, r5]
    d236:	464b      	mov	r3, r9
    d238:	41de      	rors	r6, r3
    d23a:	4066      	eors	r6, r4
    d23c:	9b03      	ldr	r3, [sp, #12]
    d23e:	0c1a      	lsrs	r2, r3, #16
    d240:	403a      	ands	r2, r7
    d242:	0092      	lsls	r2, r2, #2
    d244:	5954      	ldr	r4, [r2, r5]
    d246:	4643      	mov	r3, r8
    d248:	41dc      	rors	r4, r3
    d24a:	4074      	eors	r4, r6
    d24c:	2320      	movs	r3, #32
    d24e:	469b      	mov	fp, r3
    d250:	44dc      	add	ip, fp
    uint32_t y0;
    uint32_t y1;
    uint32_t y2;
    uint32_t y3;

    for (i = 0; i < 4; i++) 
    d252:	9b05      	ldr	r3, [sp, #20]
    d254:	459c      	cmp	ip, r3
    d256:	d000      	beq.n	d25a <EncryptRounds+0x222>
    d258:	e70b      	b.n	d072 <EncryptRounds+0x3a>
    d25a:	9b02      	ldr	r3, [sp, #8]
    d25c:	469b      	mov	fp, r3
	{
        round(y0, y1, y2, y3, x0, x1, x2, x3, key);
        round(x0, x1, x2, x3, y0, y1, y2, y3, key);
    }

    round(y0, y1, y2, y3, x0, x1, x2, x3, key);
    d25e:	4976      	ldr	r1, [pc, #472]	; (d438 <EncryptRounds+0x400>)
    d260:	22ff      	movs	r2, #255	; 0xff
    d262:	9804      	ldr	r0, [sp, #16]
    d264:	1c05      	adds	r5, r0, #0
    d266:	4015      	ands	r5, r2
    d268:	00ad      	lsls	r5, r5, #2
    d26a:	586e      	ldr	r6, [r5, r1]
    d26c:	2580      	movs	r5, #128	; 0x80
    d26e:	9f06      	ldr	r7, [sp, #24]
    d270:	597d      	ldr	r5, [r7, r5]
    d272:	4075      	eors	r5, r6
    d274:	0e26      	lsrs	r6, r4, #24
    d276:	00b6      	lsls	r6, r6, #2
    d278:	5877      	ldr	r7, [r6, r1]
    d27a:	2308      	movs	r3, #8
    d27c:	4699      	mov	r9, r3
    d27e:	41df      	rors	r7, r3
    d280:	407d      	eors	r5, r7
    d282:	1c2e      	adds	r6, r5, #0
    d284:	465b      	mov	r3, fp
    d286:	0a1d      	lsrs	r5, r3, #8
    d288:	4015      	ands	r5, r2
    d28a:	00ad      	lsls	r5, r5, #2
    d28c:	586f      	ldr	r7, [r5, r1]
    d28e:	2318      	movs	r3, #24
    d290:	4698      	mov	r8, r3
    d292:	41df      	rors	r7, r3
    d294:	1c35      	adds	r5, r6, #0
    d296:	407d      	eors	r5, r7
    d298:	9b01      	ldr	r3, [sp, #4]
    d29a:	0c1e      	lsrs	r6, r3, #16
    d29c:	4016      	ands	r6, r2
    d29e:	00b6      	lsls	r6, r6, #2
    d2a0:	5877      	ldr	r7, [r6, r1]
    d2a2:	2310      	movs	r3, #16
    d2a4:	469c      	mov	ip, r3
    d2a6:	41df      	rors	r7, r3
    d2a8:	406f      	eors	r7, r5
    d2aa:	9702      	str	r7, [sp, #8]
    d2ac:	1c15      	adds	r5, r2, #0
    d2ae:	465e      	mov	r6, fp
    d2b0:	4035      	ands	r5, r6
    d2b2:	00ad      	lsls	r5, r5, #2
    d2b4:	586e      	ldr	r6, [r5, r1]
    d2b6:	2584      	movs	r5, #132	; 0x84
    d2b8:	9f06      	ldr	r7, [sp, #24]
    d2ba:	597d      	ldr	r5, [r7, r5]
    d2bc:	4075      	eors	r5, r6
    d2be:	0e06      	lsrs	r6, r0, #24
    d2c0:	00b6      	lsls	r6, r6, #2
    d2c2:	5876      	ldr	r6, [r6, r1]
    d2c4:	464b      	mov	r3, r9
    d2c6:	41de      	rors	r6, r3
    d2c8:	4075      	eors	r5, r6
    d2ca:	9b01      	ldr	r3, [sp, #4]
    d2cc:	0a1e      	lsrs	r6, r3, #8
    d2ce:	4016      	ands	r6, r2
    d2d0:	00b6      	lsls	r6, r6, #2
    d2d2:	5876      	ldr	r6, [r6, r1]
    d2d4:	4643      	mov	r3, r8
    d2d6:	41de      	rors	r6, r3
    d2d8:	4075      	eors	r5, r6
    d2da:	0c26      	lsrs	r6, r4, #16
    d2dc:	4016      	ands	r6, r2
    d2de:	00b6      	lsls	r6, r6, #2
    d2e0:	5876      	ldr	r6, [r6, r1]
    d2e2:	4663      	mov	r3, ip
    d2e4:	41de      	rors	r6, r3
    d2e6:	406e      	eors	r6, r5
    d2e8:	9603      	str	r6, [sp, #12]
    d2ea:	1c15      	adds	r5, r2, #0
    d2ec:	9b01      	ldr	r3, [sp, #4]
    d2ee:	401d      	ands	r5, r3
    d2f0:	00ad      	lsls	r5, r5, #2
    d2f2:	586b      	ldr	r3, [r5, r1]
    d2f4:	2588      	movs	r5, #136	; 0x88
    d2f6:	597d      	ldr	r5, [r7, r5]
    d2f8:	406b      	eors	r3, r5
    d2fa:	469a      	mov	sl, r3
    d2fc:	465d      	mov	r5, fp
    d2fe:	0e2d      	lsrs	r5, r5, #24
    d300:	00ad      	lsls	r5, r5, #2
    d302:	586d      	ldr	r5, [r5, r1]
    d304:	464b      	mov	r3, r9
    d306:	41dd      	rors	r5, r3
    d308:	4653      	mov	r3, sl
    d30a:	405d      	eors	r5, r3
    d30c:	0a23      	lsrs	r3, r4, #8
    d30e:	4013      	ands	r3, r2
    d310:	009b      	lsls	r3, r3, #2
    d312:	585b      	ldr	r3, [r3, r1]
    d314:	4646      	mov	r6, r8
    d316:	41f3      	rors	r3, r6
    d318:	405d      	eors	r5, r3
    d31a:	0c03      	lsrs	r3, r0, #16
    d31c:	4013      	ands	r3, r2
    d31e:	009b      	lsls	r3, r3, #2
    d320:	585b      	ldr	r3, [r3, r1]
    d322:	4666      	mov	r6, ip
    d324:	41f3      	rors	r3, r6
    d326:	405d      	eors	r5, r3
    d328:	4014      	ands	r4, r2
    d32a:	00a4      	lsls	r4, r4, #2
    d32c:	5863      	ldr	r3, [r4, r1]
    d32e:	248c      	movs	r4, #140	; 0x8c
    d330:	593c      	ldr	r4, [r7, r4]
    d332:	405c      	eors	r4, r3
    d334:	9b01      	ldr	r3, [sp, #4]
    d336:	0e18      	lsrs	r0, r3, #24
    d338:	0080      	lsls	r0, r0, #2
    d33a:	5840      	ldr	r0, [r0, r1]
    d33c:	464b      	mov	r3, r9
    d33e:	41d8      	rors	r0, r3
    d340:	4044      	eors	r4, r0
    d342:	9804      	ldr	r0, [sp, #16]
    d344:	0a00      	lsrs	r0, r0, #8
    d346:	4010      	ands	r0, r2
    d348:	0080      	lsls	r0, r0, #2
    d34a:	5840      	ldr	r0, [r0, r1]
    d34c:	4643      	mov	r3, r8
    d34e:	41d8      	rors	r0, r3
    d350:	4044      	eors	r4, r0
    d352:	465b      	mov	r3, fp
    d354:	0c1b      	lsrs	r3, r3, #16
    d356:	4013      	ands	r3, r2
    d358:	009b      	lsls	r3, r3, #2
    d35a:	5858      	ldr	r0, [r3, r1]
    d35c:	41f0      	rors	r0, r6
    d35e:	4044      	eors	r4, r0
    lastround(x0, x1, x2, x3, y0, y1, y2, y3, key);
    d360:	4b36      	ldr	r3, [pc, #216]	; (d43c <EncryptRounds+0x404>)
    d362:	1c11      	adds	r1, r2, #0
    d364:	9803      	ldr	r0, [sp, #12]
    d366:	4001      	ands	r1, r0
    d368:	5c58      	ldrb	r0, [r3, r1]
    d36a:	2194      	movs	r1, #148	; 0x94
    d36c:	5879      	ldr	r1, [r7, r1]
    d36e:	4041      	eors	r1, r0
    d370:	9e02      	ldr	r6, [sp, #8]
    d372:	0e30      	lsrs	r0, r6, #24
    d374:	5c18      	ldrb	r0, [r3, r0]
    d376:	0600      	lsls	r0, r0, #24
    d378:	4041      	eors	r1, r0
    d37a:	0a28      	lsrs	r0, r5, #8
    d37c:	4010      	ands	r0, r2
    d37e:	5c18      	ldrb	r0, [r3, r0]
    d380:	0200      	lsls	r0, r0, #8
    d382:	4041      	eors	r1, r0
    d384:	0c20      	lsrs	r0, r4, #16
    d386:	4010      	ands	r0, r2
    d388:	5c18      	ldrb	r0, [r3, r0]
    d38a:	0400      	lsls	r0, r0, #16
    d38c:	4041      	eors	r1, r0
    d38e:	468c      	mov	ip, r1
    d390:	1c11      	adds	r1, r2, #0
    d392:	4029      	ands	r1, r5
    d394:	5c58      	ldrb	r0, [r3, r1]
    d396:	2198      	movs	r1, #152	; 0x98
    d398:	5879      	ldr	r1, [r7, r1]
    d39a:	4041      	eors	r1, r0
    d39c:	9803      	ldr	r0, [sp, #12]
    d39e:	0e00      	lsrs	r0, r0, #24
    d3a0:	5c18      	ldrb	r0, [r3, r0]
    d3a2:	0600      	lsls	r0, r0, #24
    d3a4:	4041      	eors	r1, r0
    d3a6:	0a20      	lsrs	r0, r4, #8
    d3a8:	4010      	ands	r0, r2
    d3aa:	5c18      	ldrb	r0, [r3, r0]
    d3ac:	0200      	lsls	r0, r0, #8
    d3ae:	4041      	eors	r1, r0
    d3b0:	0c30      	lsrs	r0, r6, #16
    d3b2:	4010      	ands	r0, r2
    d3b4:	5c18      	ldrb	r0, [r3, r0]
    d3b6:	0400      	lsls	r0, r0, #16
    d3b8:	1c06      	adds	r6, r0, #0
    d3ba:	404e      	eors	r6, r1
    d3bc:	46b1      	mov	r9, r6
    d3be:	1c11      	adds	r1, r2, #0
    d3c0:	4021      	ands	r1, r4
    d3c2:	5c59      	ldrb	r1, [r3, r1]
    d3c4:	4688      	mov	r8, r1
    d3c6:	219c      	movs	r1, #156	; 0x9c
    d3c8:	1c38      	adds	r0, r7, #0
    d3ca:	5879      	ldr	r1, [r7, r1]
    d3cc:	4647      	mov	r7, r8
    d3ce:	404f      	eors	r7, r1
    d3d0:	0e29      	lsrs	r1, r5, #24
    d3d2:	5c59      	ldrb	r1, [r3, r1]
    d3d4:	0609      	lsls	r1, r1, #24
    d3d6:	4079      	eors	r1, r7
    d3d8:	9f02      	ldr	r7, [sp, #8]
    d3da:	0a3e      	lsrs	r6, r7, #8
    d3dc:	1c37      	adds	r7, r6, #0
    d3de:	4017      	ands	r7, r2
    d3e0:	5dde      	ldrb	r6, [r3, r7]
    d3e2:	0236      	lsls	r6, r6, #8
    d3e4:	4071      	eors	r1, r6
    d3e6:	9e03      	ldr	r6, [sp, #12]
    d3e8:	0c36      	lsrs	r6, r6, #16
    d3ea:	1c37      	adds	r7, r6, #0
    d3ec:	4017      	ands	r7, r2
    d3ee:	5dde      	ldrb	r6, [r3, r7]
    d3f0:	0436      	lsls	r6, r6, #16
    d3f2:	4071      	eors	r1, r6
    d3f4:	9f02      	ldr	r7, [sp, #8]
    d3f6:	4017      	ands	r7, r2
    d3f8:	5dde      	ldrb	r6, [r3, r7]
    d3fa:	2790      	movs	r7, #144	; 0x90
    d3fc:	59c7      	ldr	r7, [r0, r7]
    d3fe:	1c30      	adds	r0, r6, #0
    d400:	4078      	eors	r0, r7
    d402:	0e24      	lsrs	r4, r4, #24
    d404:	5d1f      	ldrb	r7, [r3, r4]
    d406:	063f      	lsls	r7, r7, #24
    d408:	1c04      	adds	r4, r0, #0
    d40a:	407c      	eors	r4, r7
    d40c:	9803      	ldr	r0, [sp, #12]
    d40e:	0a06      	lsrs	r6, r0, #8
    d410:	4016      	ands	r6, r2
    d412:	5d9e      	ldrb	r6, [r3, r6]
    d414:	0236      	lsls	r6, r6, #8
    d416:	4074      	eors	r4, r6
    d418:	0c2d      	lsrs	r5, r5, #16
    d41a:	402a      	ands	r2, r5
    d41c:	5c9a      	ldrb	r2, [r3, r2]
    d41e:	0412      	lsls	r2, r2, #16
    d420:	1c23      	adds	r3, r4, #0
    d422:	4053      	eors	r3, r2

    out[0] = x0;
    d424:	9a07      	ldr	r2, [sp, #28]
    d426:	6013      	str	r3, [r2, #0]
    out[1] = x1;
    d428:	4663      	mov	r3, ip
    d42a:	6053      	str	r3, [r2, #4]
    out[2] = x2;
    d42c:	464b      	mov	r3, r9
    d42e:	6093      	str	r3, [r2, #8]
    out[3] = x3;
    d430:	60d1      	str	r1, [r2, #12]
}
    d432:	b009      	add	sp, #36	; 0x24
    d434:	e004      	b.n	d440 <EncryptRounds+0x408>
    d436:	46c0      	nop			; (mov r8, r8)
    d438:	0001f1a4 	.word	0x0001f1a4
    d43c:	0001f5bc 	.word	0x0001f5bc
    d440:	bc3c      	pop	{r2, r3, r4, r5}
    d442:	4690      	mov	r8, r2
    d444:	4699      	mov	r9, r3
    d446:	46a2      	mov	sl, r4
    d448:	46ab      	mov	fp, r5
    d44a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d44c <AJ_AES_Enable>:

void AJ_AES_Enable(const uint8_t* key)
{
    d44c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d44e:	464f      	mov	r7, r9
    d450:	4646      	mov	r6, r8
    d452:	b4c0      	push	{r6, r7}
    d454:	1c01      	adds	r1, r0, #0


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d456:	4c1c      	ldr	r4, [pc, #112]	; (d4c8 <AJ_AES_Enable+0x7c>)
    d458:	1c20      	adds	r0, r4, #0
    d45a:	2210      	movs	r2, #16
    d45c:	4b1b      	ldr	r3, [pc, #108]	; (d4cc <AJ_AES_Enable+0x80>)
    d45e:	4798      	blx	r3
    d460:	4e1b      	ldr	r6, [pc, #108]	; (d4d0 <AJ_AES_Enable+0x84>)
}

void AJ_AES_Enable(const uint8_t* key)
{
    int i;
    uint32_t* fkey = aes_context.fkey;
    d462:	1c20      	adds	r0, r4, #0

    Pack32(fkey, key);
    for (i = 0; i <= ROUNDS; ++i, fkey += 4) 
	{
        fkey[4] = fkey[0] ^ SubBytes(ROTL24(fkey[3])) ^ Rconst[i];
    d464:	2308      	movs	r3, #8
    d466:	469c      	mov	ip, r3
#endif
}

static uint32_t SubBytes(uint32_t a)
{
    return (uint32_t)sbox[(uint8_t)(a)] | (sbox[(uint8_t)(a >> 8)] << 8) | (sbox[(uint8_t)(a >> 16)] << 16) | (sbox[(uint8_t)(a >> 24)] << 24);
    d468:	4c1a      	ldr	r4, [pc, #104]	; (d4d4 <AJ_AES_Enable+0x88>)
    d46a:	25ff      	movs	r5, #255	; 0xff
{
    int i;
    uint32_t* fkey = aes_context.fkey;

    Pack32(fkey, key);
    for (i = 0; i <= ROUNDS; ++i, fkey += 4) 
    d46c:	4f16      	ldr	r7, [pc, #88]	; (d4c8 <AJ_AES_Enable+0x7c>)
    d46e:	33a8      	adds	r3, #168	; 0xa8
    d470:	4698      	mov	r8, r3
    d472:	44b8      	add	r8, r7
	{
        fkey[4] = fkey[0] ^ SubBytes(ROTL24(fkey[3])) ^ Rconst[i];
    d474:	68c2      	ldr	r2, [r0, #12]
    d476:	4663      	mov	r3, ip
    d478:	41da      	rors	r2, r3
    d47a:	ce08      	ldmia	r6!, {r3}
    d47c:	6801      	ldr	r1, [r0, #0]
    d47e:	4059      	eors	r1, r3
#endif
}

static uint32_t SubBytes(uint32_t a)
{
    return (uint32_t)sbox[(uint8_t)(a)] | (sbox[(uint8_t)(a >> 8)] << 8) | (sbox[(uint8_t)(a >> 16)] << 16) | (sbox[(uint8_t)(a >> 24)] << 24);
    d480:	0e13      	lsrs	r3, r2, #24
    d482:	5ce3      	ldrb	r3, [r4, r3]
    d484:	061b      	lsls	r3, r3, #24
    d486:	1c2f      	adds	r7, r5, #0
    d488:	4017      	ands	r7, r2
    d48a:	5de7      	ldrb	r7, [r4, r7]
    d48c:	431f      	orrs	r7, r3
    d48e:	0a13      	lsrs	r3, r2, #8
    d490:	402b      	ands	r3, r5
    d492:	5ce3      	ldrb	r3, [r4, r3]
    d494:	021b      	lsls	r3, r3, #8
    d496:	433b      	orrs	r3, r7
    d498:	0c12      	lsrs	r2, r2, #16
    d49a:	402a      	ands	r2, r5
    d49c:	5ca2      	ldrb	r2, [r4, r2]
    d49e:	0412      	lsls	r2, r2, #16
    d4a0:	4313      	orrs	r3, r2
    uint32_t* fkey = aes_context.fkey;

    Pack32(fkey, key);
    for (i = 0; i <= ROUNDS; ++i, fkey += 4) 
	{
        fkey[4] = fkey[0] ^ SubBytes(ROTL24(fkey[3])) ^ Rconst[i];
    d4a2:	404b      	eors	r3, r1
    d4a4:	6103      	str	r3, [r0, #16]
        fkey[5] = fkey[1] ^ fkey[4];
    d4a6:	6842      	ldr	r2, [r0, #4]
    d4a8:	4053      	eors	r3, r2
    d4aa:	6143      	str	r3, [r0, #20]
        fkey[6] = fkey[2] ^ fkey[5];
    d4ac:	6882      	ldr	r2, [r0, #8]
    d4ae:	4053      	eors	r3, r2
    d4b0:	6183      	str	r3, [r0, #24]
        fkey[7] = fkey[3] ^ fkey[6];
    d4b2:	68c1      	ldr	r1, [r0, #12]
    d4b4:	4059      	eors	r1, r3
    d4b6:	61c1      	str	r1, [r0, #28]
{
    int i;
    uint32_t* fkey = aes_context.fkey;

    Pack32(fkey, key);
    for (i = 0; i <= ROUNDS; ++i, fkey += 4) 
    d4b8:	3010      	adds	r0, #16
    d4ba:	4540      	cmp	r0, r8
    d4bc:	d1da      	bne.n	d474 <AJ_AES_Enable+0x28>
        fkey[4] = fkey[0] ^ SubBytes(ROTL24(fkey[3])) ^ Rconst[i];
        fkey[5] = fkey[1] ^ fkey[4];
        fkey[6] = fkey[2] ^ fkey[5];
        fkey[7] = fkey[3] ^ fkey[6];
    }
}
    d4be:	bc0c      	pop	{r2, r3}
    d4c0:	4690      	mov	r8, r2
    d4c2:	4699      	mov	r9, r3
    d4c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d4c6:	46c0      	nop			; (mov r8, r8)
    d4c8:	20001180 	.word	0x20001180
    d4cc:	00016739 	.word	0x00016739
    d4d0:	0001f6f8 	.word	0x0001f6f8
    d4d4:	0001f5bc 	.word	0x0001f5bc

0000d4d8 <AJ_AES_Disable>:

void AJ_AES_Disable(void)
{
    d4d8:	b508      	push	{r3, lr}
    memset(&aes_context, 0, sizeof(aes_context));
    d4da:	4803      	ldr	r0, [pc, #12]	; (d4e8 <AJ_AES_Disable+0x10>)
    d4dc:	2100      	movs	r1, #0
    d4de:	22c0      	movs	r2, #192	; 0xc0
    d4e0:	4b02      	ldr	r3, [pc, #8]	; (d4ec <AJ_AES_Disable+0x14>)
    d4e2:	4798      	blx	r3
}
    d4e4:	bd08      	pop	{r3, pc}
    d4e6:	46c0      	nop			; (mov r8, r8)
    d4e8:	20001180 	.word	0x20001180
    d4ec:	00016773 	.word	0x00016773

0000d4f0 <AJ_AES_CTR_128>:

void AJ_AES_CTR_128(const uint8_t* key, const uint8_t* in, uint8_t* out, uint32_t len, uint8_t* ctr)
{
    d4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d4f2:	464f      	mov	r7, r9
    d4f4:	4646      	mov	r6, r8
    d4f6:	b4c0      	push	{r6, r7}
    d4f8:	b08b      	sub	sp, #44	; 0x2c
    d4fa:	1c0d      	adds	r5, r1, #0
    d4fc:	1c17      	adds	r7, r2, #0
    d4fe:	4698      	mov	r8, r3


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d500:	a806      	add	r0, sp, #24
    d502:	9912      	ldr	r1, [sp, #72]	; 0x48
    d504:	2210      	movs	r2, #16
    d506:	4b20      	ldr	r3, [pc, #128]	; (d588 <AJ_AES_CTR_128+0x98>)
    d508:	4798      	blx	r3
{
    uint32_t counter[4];

    Pack32(counter, ctr);

    while (len) 
    d50a:	4643      	mov	r3, r8
    d50c:	2b00      	cmp	r3, #0
    d50e:	d031      	beq.n	d574 <AJ_AES_CTR_128+0x84>
        uint32_t n = min(len, 16);
        uint8_t* p = (uint8_t*)tmp;

        for (i = 0; i < 4; ++i) 
		{
            tmp[i] = counter[i] ^ aes_context.fkey[i];
    d510:	4e1e      	ldr	r6, [pc, #120]	; (d58c <AJ_AES_CTR_128+0x9c>)
        }
        EncryptRounds(tmp, tmp, &aes_context.fkey[4]);
    d512:	1c33      	adds	r3, r6, #0
    d514:	3310      	adds	r3, #16
    d516:	9301      	str	r3, [sp, #4]
    d518:	4b1d      	ldr	r3, [pc, #116]	; (d590 <AJ_AES_CTR_128+0xa0>)
    d51a:	4699      	mov	r9, r3

    while (len) 
	{
        uint32_t tmp[4];
        uint32_t i;
        uint32_t n = min(len, 16);
    d51c:	4644      	mov	r4, r8
    d51e:	2c10      	cmp	r4, #16
    d520:	d900      	bls.n	d524 <AJ_AES_CTR_128+0x34>
    d522:	2410      	movs	r4, #16
    d524:	2300      	movs	r3, #0
        uint8_t* p = (uint8_t*)tmp;

        for (i = 0; i < 4; ++i) 
		{
            tmp[i] = counter[i] ^ aes_context.fkey[i];
    d526:	aa06      	add	r2, sp, #24
    d528:	589a      	ldr	r2, [r3, r2]
    d52a:	5999      	ldr	r1, [r3, r6]
    d52c:	404a      	eors	r2, r1
    d52e:	a902      	add	r1, sp, #8
    d530:	505a      	str	r2, [r3, r1]
    d532:	3304      	adds	r3, #4
        uint32_t tmp[4];
        uint32_t i;
        uint32_t n = min(len, 16);
        uint8_t* p = (uint8_t*)tmp;

        for (i = 0; i < 4; ++i) 
    d534:	2b10      	cmp	r3, #16
    d536:	d1f6      	bne.n	d526 <AJ_AES_CTR_128+0x36>
		{
            tmp[i] = counter[i] ^ aes_context.fkey[i];
        }
        EncryptRounds(tmp, tmp, &aes_context.fkey[4]);
    d538:	1c08      	adds	r0, r1, #0
    d53a:	9a01      	ldr	r2, [sp, #4]
    d53c:	47c8      	blx	r9
        len -= n;
    d53e:	4643      	mov	r3, r8
    d540:	1b1b      	subs	r3, r3, r4
    d542:	4698      	mov	r8, r3
        while (n--) 
    d544:	2c00      	cmp	r4, #0
    d546:	d00a      	beq.n	d55e <AJ_AES_CTR_128+0x6e>
    d548:	2300      	movs	r3, #0
		{
            *out++ = *p++ ^ *in++;
    d54a:	5ce9      	ldrb	r1, [r5, r3]
    d54c:	aa02      	add	r2, sp, #8
    d54e:	5c9a      	ldrb	r2, [r3, r2]
    d550:	404a      	eors	r2, r1
    d552:	54fa      	strb	r2, [r7, r3]
    d554:	3301      	adds	r3, #1
		{
            tmp[i] = counter[i] ^ aes_context.fkey[i];
        }
        EncryptRounds(tmp, tmp, &aes_context.fkey[4]);
        len -= n;
        while (n--) 
    d556:	42a3      	cmp	r3, r4
    d558:	d1f7      	bne.n	d54a <AJ_AES_CTR_128+0x5a>
    d55a:	193f      	adds	r7, r7, r4
    d55c:	192d      	adds	r5, r5, r4
		{
            *out++ = *p++ ^ *in++;
        }
        // The counter field is big-endian
#if HOST_IS_LITTLE_ENDIAN
        counter[3] = AJ_ByteSwap32(1 + AJ_ByteSwap32(counter[3]));
    d55e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d560:	9300      	str	r3, [sp, #0]
    d562:	1c18      	adds	r0, r3, #0
    d564:	4c0b      	ldr	r4, [pc, #44]	; (d594 <AJ_AES_CTR_128+0xa4>)
    d566:	47a0      	blx	r4
    d568:	3001      	adds	r0, #1
    d56a:	47a0      	blx	r4
    d56c:	9009      	str	r0, [sp, #36]	; 0x24
{
    uint32_t counter[4];

    Pack32(counter, ctr);

    while (len) 
    d56e:	4643      	mov	r3, r8
    d570:	2b00      	cmp	r3, #0
    d572:	d1d3      	bne.n	d51c <AJ_AES_CTR_128+0x2c>
}

static void Unpack32(uint8_t* u8, const uint32_t* u32)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u8, u32, 16);
    d574:	9812      	ldr	r0, [sp, #72]	; 0x48
    d576:	a906      	add	r1, sp, #24
    d578:	2210      	movs	r2, #16
    d57a:	4b03      	ldr	r3, [pc, #12]	; (d588 <AJ_AES_CTR_128+0x98>)
    d57c:	4798      	blx	r3
        counter[3] += 1;
#endif
    }

    Unpack32(ctr, counter);
}
    d57e:	b00b      	add	sp, #44	; 0x2c
    d580:	bc0c      	pop	{r2, r3}
    d582:	4690      	mov	r8, r2
    d584:	4699      	mov	r9, r3
    d586:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d588:	00016739 	.word	0x00016739
    d58c:	20001180 	.word	0x20001180
    d590:	0000d039 	.word	0x0000d039
    d594:	0000d749 	.word	0x0000d749

0000d598 <AJ_AES_CBC_128_ENCRYPT>:

void AJ_AES_CBC_128_ENCRYPT(const uint8_t* key, const uint8_t* in, uint8_t* out, uint32_t len, uint8_t* iv)
{
    d598:	b5f0      	push	{r4, r5, r6, r7, lr}
    d59a:	4647      	mov	r7, r8
    d59c:	b480      	push	{r7}
    d59e:	b08a      	sub	sp, #40	; 0x28
    d5a0:	1c0f      	adds	r7, r1, #0
    d5a2:	1c15      	adds	r5, r2, #0
    d5a4:	1c1e      	adds	r6, r3, #0
    uint32_t xorbuf[4];
    uint32_t ivt[4];

    AJ_ASSERT((len % 16) == 0);
    d5a6:	0733      	lsls	r3, r6, #28
    d5a8:	d006      	beq.n	d5b8 <AJ_AES_CBC_128_ENCRYPT+0x20>
    d5aa:	481d      	ldr	r0, [pc, #116]	; (d620 <AJ_AES_CBC_128_ENCRYPT+0x88>)
    d5ac:	2181      	movs	r1, #129	; 0x81
    d5ae:	0049      	lsls	r1, r1, #1
    d5b0:	4a1c      	ldr	r2, [pc, #112]	; (d624 <AJ_AES_CBC_128_ENCRYPT+0x8c>)
    d5b2:	4b1d      	ldr	r3, [pc, #116]	; (d628 <AJ_AES_CBC_128_ENCRYPT+0x90>)
    d5b4:	4c1d      	ldr	r4, [pc, #116]	; (d62c <AJ_AES_CBC_128_ENCRYPT+0x94>)
    d5b6:	47a0      	blx	r4


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d5b8:	a802      	add	r0, sp, #8
    d5ba:	9910      	ldr	r1, [sp, #64]	; 0x40
    d5bc:	2210      	movs	r2, #16
    d5be:	4b1c      	ldr	r3, [pc, #112]	; (d630 <AJ_AES_CBC_128_ENCRYPT+0x98>)
    d5c0:	4798      	blx	r3
    uint32_t ivt[4];

    AJ_ASSERT((len % 16) == 0);

    Pack32(ivt, iv);
    while (len) 
    d5c2:	2e00      	cmp	r6, #0
    d5c4:	d023      	beq.n	d60e <AJ_AES_CBC_128_ENCRYPT+0x76>


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d5c6:	4b1a      	ldr	r3, [pc, #104]	; (d630 <AJ_AES_CBC_128_ENCRYPT+0x98>)
    d5c8:	4698      	mov	r8, r3
	{
        int i;
        Pack32(xorbuf, in);
        for (i = 0; i < 4; ++i) 
		{
            xorbuf[i] ^= ivt[i] ^ aes_context.fkey[i];
    d5ca:	4c1a      	ldr	r4, [pc, #104]	; (d634 <AJ_AES_CBC_128_ENCRYPT+0x9c>)
        }
        EncryptRounds(ivt, xorbuf, &aes_context.fkey[4]);
    d5cc:	1c23      	adds	r3, r4, #0
    d5ce:	3310      	adds	r3, #16
    d5d0:	9301      	str	r3, [sp, #4]


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d5d2:	a806      	add	r0, sp, #24
    d5d4:	1c39      	adds	r1, r7, #0
    d5d6:	2210      	movs	r2, #16
    d5d8:	47c0      	blx	r8
    d5da:	2300      	movs	r3, #0
	{
        int i;
        Pack32(xorbuf, in);
        for (i = 0; i < 4; ++i) 
		{
            xorbuf[i] ^= ivt[i] ^ aes_context.fkey[i];
    d5dc:	a906      	add	r1, sp, #24
    d5de:	aa02      	add	r2, sp, #8
    d5e0:	589a      	ldr	r2, [r3, r2]
    d5e2:	5858      	ldr	r0, [r3, r1]
    d5e4:	4042      	eors	r2, r0
    d5e6:	5918      	ldr	r0, [r3, r4]
    d5e8:	4042      	eors	r2, r0
    d5ea:	505a      	str	r2, [r3, r1]
    d5ec:	3304      	adds	r3, #4
    Pack32(ivt, iv);
    while (len) 
	{
        int i;
        Pack32(xorbuf, in);
        for (i = 0; i < 4; ++i) 
    d5ee:	2b10      	cmp	r3, #16
    d5f0:	d1f4      	bne.n	d5dc <AJ_AES_CBC_128_ENCRYPT+0x44>
		{
            xorbuf[i] ^= ivt[i] ^ aes_context.fkey[i];
        }
        EncryptRounds(ivt, xorbuf, &aes_context.fkey[4]);
    d5f2:	a802      	add	r0, sp, #8
    d5f4:	9a01      	ldr	r2, [sp, #4]
    d5f6:	4b10      	ldr	r3, [pc, #64]	; (d638 <AJ_AES_CBC_128_ENCRYPT+0xa0>)
    d5f8:	4798      	blx	r3
}

static void Unpack32(uint8_t* u8, const uint32_t* u32)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u8, u32, 16);
    d5fa:	1c28      	adds	r0, r5, #0
    d5fc:	a902      	add	r1, sp, #8
    d5fe:	2210      	movs	r2, #16
    d600:	4b0b      	ldr	r3, [pc, #44]	; (d630 <AJ_AES_CBC_128_ENCRYPT+0x98>)
    d602:	4798      	blx	r3
		{
            xorbuf[i] ^= ivt[i] ^ aes_context.fkey[i];
        }
        EncryptRounds(ivt, xorbuf, &aes_context.fkey[4]);
        Unpack32(out, ivt);
        out += 16;
    d604:	3510      	adds	r5, #16
        in += 16;
    d606:	3710      	adds	r7, #16
        len -= 16;
    d608:	3e10      	subs	r6, #16
    uint32_t ivt[4];

    AJ_ASSERT((len % 16) == 0);

    Pack32(ivt, iv);
    while (len) 
    d60a:	2e00      	cmp	r6, #0
    d60c:	d1e1      	bne.n	d5d2 <AJ_AES_CBC_128_ENCRYPT+0x3a>
}

static void Unpack32(uint8_t* u8, const uint32_t* u32)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u8, u32, 16);
    d60e:	9810      	ldr	r0, [sp, #64]	; 0x40
    d610:	a902      	add	r1, sp, #8
    d612:	2210      	movs	r2, #16
    d614:	4b06      	ldr	r3, [pc, #24]	; (d630 <AJ_AES_CBC_128_ENCRYPT+0x98>)
    d616:	4798      	blx	r3
        out += 16;
        in += 16;
        len -= 16;
    }
    Unpack32(iv, ivt);
}
    d618:	b00a      	add	sp, #40	; 0x28
    d61a:	bc04      	pop	{r2}
    d61c:	4690      	mov	r8, r2
    d61e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d620:	0001f6bc 	.word	0x0001f6bc
    d624:	0001f5a4 	.word	0x0001f5a4
    d628:	0001f6e8 	.word	0x0001f6e8
    d62c:	00016629 	.word	0x00016629
    d630:	00016739 	.word	0x00016739
    d634:	20001180 	.word	0x20001180
    d638:	0000d039 	.word	0x0000d039

0000d63c <AJ_AES_ECB_128_ENCRYPT>:

void AJ_AES_ECB_128_ENCRYPT(const uint8_t* key, const uint8_t* in, uint8_t* out)
{
    d63c:	b530      	push	{r4, r5, lr}
    d63e:	b089      	sub	sp, #36	; 0x24
    d640:	1c15      	adds	r5, r2, #0


static void Pack32(uint32_t* u32, const uint8_t* u8)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u32, u8, 16);
    d642:	a804      	add	r0, sp, #16
    d644:	2210      	movs	r2, #16
    d646:	4c07      	ldr	r4, [pc, #28]	; (d664 <AJ_AES_ECB_128_ENCRYPT+0x28>)
    d648:	47a0      	blx	r4
{
    uint32_t in32[4];
    uint32_t out32[4];

    Pack32(in32, in);
    EncryptRounds(out32, in32, &aes_context.fkey[4]);
    d64a:	4668      	mov	r0, sp
    d64c:	a904      	add	r1, sp, #16
    d64e:	4a06      	ldr	r2, [pc, #24]	; (d668 <AJ_AES_ECB_128_ENCRYPT+0x2c>)
    d650:	3210      	adds	r2, #16
    d652:	4b06      	ldr	r3, [pc, #24]	; (d66c <AJ_AES_ECB_128_ENCRYPT+0x30>)
    d654:	4798      	blx	r3
}

static void Unpack32(uint8_t* u8, const uint32_t* u32)
{
#if HOST_IS_LITTLE_ENDIAN
    memcpy(u8, u32, 16);
    d656:	1c28      	adds	r0, r5, #0
    d658:	4669      	mov	r1, sp
    d65a:	2210      	movs	r2, #16
    d65c:	47a0      	blx	r4
    uint32_t out32[4];

    Pack32(in32, in);
    EncryptRounds(out32, in32, &aes_context.fkey[4]);
    Unpack32(out, out32);
}
    d65e:	b009      	add	sp, #36	; 0x24
    d660:	bd30      	pop	{r4, r5, pc}
    d662:	46c0      	nop			; (mov r8, r8)
    d664:	00016739 	.word	0x00016739
    d668:	20001180 	.word	0x20001180
    d66c:	0000d039 	.word	0x0000d039

0000d670 <AJ_PlatformEntropy>:
 * The host has various ADC's. We are going to accumulate entropy by repeatedly
 * reading the ADC and accumulating the least significant bit or each reading.
 */

uint32_t AJ_PlatformEntropy(uint8_t* data, uint32_t size)
{
    d670:	b5f0      	push	{r4, r5, r6, r7, lr}
    d672:	b083      	sub	sp, #12
    d674:	9101      	str	r1, [sp, #4]
    int i;
    uint32_t val;

    // Start accumulating entropy one bit at a time
    for (i = 0; i < (8 * size); ++i) 
    d676:	00ce      	lsls	r6, r1, #3
    d678:	d012      	beq.n	d6a0 <AJ_PlatformEntropy+0x30>
    d67a:	2200      	movs	r2, #0
	{
        val = i;//analogRead(analogPin);
        data[i / 8] ^= ((val & 1) << (i & 7));
    d67c:	2101      	movs	r1, #1
    d67e:	2707      	movs	r7, #7
    d680:	17d3      	asrs	r3, r2, #31
    d682:	0f5b      	lsrs	r3, r3, #29
    d684:	189b      	adds	r3, r3, r2
    d686:	10db      	asrs	r3, r3, #3
    d688:	18c3      	adds	r3, r0, r3
    d68a:	1c0c      	adds	r4, r1, #0
    d68c:	4014      	ands	r4, r2
    d68e:	1c3d      	adds	r5, r7, #0
    d690:	4015      	ands	r5, r2
    d692:	40ac      	lsls	r4, r5
    d694:	781d      	ldrb	r5, [r3, #0]
    d696:	406c      	eors	r4, r5
    d698:	701c      	strb	r4, [r3, #0]
{
    int i;
    uint32_t val;

    // Start accumulating entropy one bit at a time
    for (i = 0; i < (8 * size); ++i) 
    d69a:	3201      	adds	r2, #1
    d69c:	42b2      	cmp	r2, r6
    d69e:	d1ef      	bne.n	d680 <AJ_PlatformEntropy+0x10>
	{
        val = i;//analogRead(analogPin);
        data[i / 8] ^= ((val & 1) << (i & 7));
    }
    return size;
}
    d6a0:	9801      	ldr	r0, [sp, #4]
    d6a2:	b003      	add	sp, #12
    d6a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d6a6:	46c0      	nop			; (mov r8, r8)

0000d6a8 <AJ_RandBytes>:

void AJ_RandBytes(uint8_t* rand, uint32_t size)
{
    d6a8:	b570      	push	{r4, r5, r6, lr}
    d6aa:	b088      	sub	sp, #32
    d6ac:	1c04      	adds	r4, r0, #0
    d6ae:	1c0d      	adds	r5, r1, #0
    AJ_Status status = AJ_ERR_SECURITY;
    uint8_t seed[SEEDLEN];

    if (rand && size) 
    d6b0:	2800      	cmp	r0, #0
    d6b2:	d018      	beq.n	d6e6 <AJ_RandBytes+0x3e>
    d6b4:	2900      	cmp	r1, #0
    d6b6:	d016      	beq.n	d6e6 <AJ_RandBytes+0x3e>
	{
        status = AES_CTR_DRBG_Generate(&drbgctx, rand, size);
    d6b8:	4813      	ldr	r0, [pc, #76]	; (d708 <AJ_RandBytes+0x60>)
    d6ba:	1c21      	adds	r1, r4, #0
    d6bc:	1c2a      	adds	r2, r5, #0
    d6be:	4b13      	ldr	r3, [pc, #76]	; (d70c <AJ_RandBytes+0x64>)
    d6c0:	4798      	blx	r3
        if (AJ_OK != status) 
    d6c2:	2800      	cmp	r0, #0
    d6c4:	d01e      	beq.n	d704 <AJ_RandBytes+0x5c>
		{
            // Reseed required
            AJ_PlatformEntropy(seed, sizeof (seed));
    d6c6:	4668      	mov	r0, sp
    d6c8:	2120      	movs	r1, #32
    d6ca:	4b11      	ldr	r3, [pc, #68]	; (d710 <AJ_RandBytes+0x68>)
    d6cc:	4798      	blx	r3
            AES_CTR_DRBG_Reseed(&drbgctx, seed, sizeof (seed));
    d6ce:	4e0e      	ldr	r6, [pc, #56]	; (d708 <AJ_RandBytes+0x60>)
    d6d0:	1c30      	adds	r0, r6, #0
    d6d2:	4669      	mov	r1, sp
    d6d4:	2220      	movs	r2, #32
    d6d6:	4b0f      	ldr	r3, [pc, #60]	; (d714 <AJ_RandBytes+0x6c>)
    d6d8:	4798      	blx	r3
            status = AES_CTR_DRBG_Generate(&drbgctx, rand, size);
    d6da:	1c30      	adds	r0, r6, #0
    d6dc:	1c21      	adds	r1, r4, #0
    d6de:	1c2a      	adds	r2, r5, #0
    d6e0:	4b0a      	ldr	r3, [pc, #40]	; (d70c <AJ_RandBytes+0x64>)
    d6e2:	4798      	blx	r3
    d6e4:	e00e      	b.n	d704 <AJ_RandBytes+0x5c>
        }
    } 
	else 
	{
        // This is the first call to initialize
        size = AJ_PlatformEntropy(seed, sizeof (seed));
    d6e6:	4668      	mov	r0, sp
    d6e8:	2120      	movs	r1, #32
    d6ea:	4b09      	ldr	r3, [pc, #36]	; (d710 <AJ_RandBytes+0x68>)
    d6ec:	4798      	blx	r3
        drbgctx.df = (SEEDLEN == size) ? 0 : 1;
    d6ee:	1c03      	adds	r3, r0, #0
    d6f0:	3b20      	subs	r3, #32
    d6f2:	1e58      	subs	r0, r3, #1
    d6f4:	4183      	sbcs	r3, r0
    d6f6:	b2db      	uxtb	r3, r3
    d6f8:	4803      	ldr	r0, [pc, #12]	; (d708 <AJ_RandBytes+0x60>)
    d6fa:	7003      	strb	r3, [r0, #0]
        AES_CTR_DRBG_Instantiate(&drbgctx, seed, sizeof (seed), drbgctx.df);
    d6fc:	4669      	mov	r1, sp
    d6fe:	2220      	movs	r2, #32
    d700:	4c05      	ldr	r4, [pc, #20]	; (d718 <AJ_RandBytes+0x70>)
    d702:	47a0      	blx	r4
    }
}
    d704:	b008      	add	sp, #32
    d706:	bd70      	pop	{r4, r5, r6, pc}
    d708:	20001240 	.word	0x20001240
    d70c:	00004bb5 	.word	0x00004bb5
    d710:	0000d671 	.word	0x0000d671
    d714:	00004a69 	.word	0x00004a69
    d718:	00004b7d 	.word	0x00004b7d

0000d71c <AJ_MemZeroSecure>:
} TIME_STRUCT;

void AJ_MemZeroSecure(void* s, size_t n)
{
	volatile unsigned char* p = s;
	while (n--) *p++ = '\0';
    d71c:	2900      	cmp	r1, #0
    d71e:	d005      	beq.n	d72c <AJ_MemZeroSecure+0x10>
    d720:	1841      	adds	r1, r0, r1
    d722:	2300      	movs	r3, #0
    d724:	7003      	strb	r3, [r0, #0]
    d726:	3001      	adds	r0, #1
    d728:	4288      	cmp	r0, r1
    d72a:	d1fb      	bne.n	d724 <AJ_MemZeroSecure+0x8>
	return;
}
    d72c:	4770      	bx	lr
    d72e:	46c0      	nop			; (mov r8, r8)

0000d730 <AJ_DecodeTime>:
	((w & 0x00ff0000) >> 8) |
	((w & 0x0000ff00) << 8) | ((w & 0x000000ff) << 24);
}

uint64_t AJ_DecodeTime(char* der, char* fmt)
{
    d730:	b500      	push	{lr}
    d732:	b08b      	sub	sp, #44	; 0x2c
	struct tm tm;
	if (!strptime(der, fmt, &tm))
    d734:	aa01      	add	r2, sp, #4
    d736:	4b03      	ldr	r3, [pc, #12]	; (d744 <AJ_DecodeTime+0x14>)
    d738:	4798      	blx	r3
	{
		return 0;
	}
	return 0;//(uint64_t)timegm(&tm);
}
    d73a:	2000      	movs	r0, #0
    d73c:	2100      	movs	r1, #0
    d73e:	b00b      	add	sp, #44	; 0x2c
    d740:	bd00      	pop	{pc}
    d742:	46c0      	nop			; (mov r8, r8)
    d744:	00017241 	.word	0x00017241

0000d748 <AJ_ByteSwap32>:

static inline uint32_t swap32(uint32_t w)
{
	return ((w & 0xff000000) >> 24) |
	((w & 0x00ff0000) >> 8) |
	((w & 0x0000ff00) << 8) | ((w & 0x000000ff) << 24);
    d748:	0602      	lsls	r2, r0, #24
	return;
}

static inline uint32_t swap32(uint32_t w)
{
	return ((w & 0xff000000) >> 24) |
    d74a:	0e03      	lsrs	r3, r0, #24
    d74c:	431a      	orrs	r2, r3
	((w & 0x00ff0000) >> 8) |
    d74e:	23ff      	movs	r3, #255	; 0xff
    d750:	041b      	lsls	r3, r3, #16
    d752:	4003      	ands	r3, r0
    d754:	0a1b      	lsrs	r3, r3, #8
    d756:	431a      	orrs	r2, r3
	((w & 0x0000ff00) << 8) | ((w & 0x000000ff) << 24);
    d758:	23ff      	movs	r3, #255	; 0xff
    d75a:	021b      	lsls	r3, r3, #8
    d75c:	4018      	ands	r0, r3
    d75e:	0200      	lsls	r0, r0, #8
	return;
}

static inline uint32_t swap32(uint32_t w)
{
	return ((w & 0xff000000) >> 24) |
    d760:	4310      	orrs	r0, r2


uint32_t AJ_ByteSwap32(uint32_t x)
{
	return swap32(x);
}
    d762:	4770      	bx	lr

0000d764 <AJ_Sleep>:

void AJ_Sleep(uint32_t time)
{
    //delay(time);
}
    d764:	4770      	bx	lr
    d766:	46c0      	nop			; (mov r8, r8)

0000d768 <AJ_GetElapsedTime>:

uint32_t AJ_GetElapsedTime(AJ_Time* timer, uint8_t cumulative)
{
    d768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d76a:	1c06      	adds	r6, r0, #0
    d76c:	1c0f      	adds	r7, r1, #0
    uint32_t elapsed;
    TIME_STRUCT now;

    now.milliseconds =  millis();
    d76e:	4b0c      	ldr	r3, [pc, #48]	; (d7a0 <AJ_GetElapsedTime+0x38>)
    d770:	4798      	blx	r3
    d772:	1c05      	adds	r5, r0, #0
    elapsed = (uint32_t)now.milliseconds - (timer->seconds * 1000 + timer->milliseconds);  // watch for wraparound
    d774:	24fa      	movs	r4, #250	; 0xfa
    d776:	00a4      	lsls	r4, r4, #2
    d778:	6873      	ldr	r3, [r6, #4]
    d77a:	435c      	muls	r4, r3
    d77c:	8833      	ldrh	r3, [r6, #0]
    d77e:	18e4      	adds	r4, r4, r3
    d780:	1b04      	subs	r4, r0, r4
    if (!cumulative) 
    d782:	2f00      	cmp	r7, #0
    d784:	d10a      	bne.n	d79c <AJ_GetElapsedTime+0x34>
	{
        timer->seconds = (uint32_t)(now.milliseconds / 1000);
    d786:	21fa      	movs	r1, #250	; 0xfa
    d788:	0089      	lsls	r1, r1, #2
    d78a:	4b06      	ldr	r3, [pc, #24]	; (d7a4 <AJ_GetElapsedTime+0x3c>)
    d78c:	4798      	blx	r3
    d78e:	6070      	str	r0, [r6, #4]
        timer->milliseconds = (uint16_t)(now.milliseconds % 1000);
    d790:	1c28      	adds	r0, r5, #0
    d792:	21fa      	movs	r1, #250	; 0xfa
    d794:	0089      	lsls	r1, r1, #2
    d796:	4b04      	ldr	r3, [pc, #16]	; (d7a8 <AJ_GetElapsedTime+0x40>)
    d798:	4798      	blx	r3
    d79a:	8031      	strh	r1, [r6, #0]
    }
    return elapsed;
}
    d79c:	1c20      	adds	r0, r4, #0
    d79e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d7a0:	00014279 	.word	0x00014279
    d7a4:	00014e9d 	.word	0x00014e9d
    d7a8:	00014fa9 	.word	0x00014fa9

0000d7ac <AJ_InitTimer>:
void AJ_InitTimer(AJ_Time* timer)
{
    d7ac:	b538      	push	{r3, r4, r5, lr}
    d7ae:	1c04      	adds	r4, r0, #0
    TIME_STRUCT now;
    now.milliseconds = millis();
    d7b0:	4b07      	ldr	r3, [pc, #28]	; (d7d0 <AJ_InitTimer+0x24>)
    d7b2:	4798      	blx	r3
    d7b4:	1c05      	adds	r5, r0, #0
    timer->seconds = (uint32_t)(now.milliseconds / 1000);
    d7b6:	21fa      	movs	r1, #250	; 0xfa
    d7b8:	0089      	lsls	r1, r1, #2
    d7ba:	4b06      	ldr	r3, [pc, #24]	; (d7d4 <AJ_InitTimer+0x28>)
    d7bc:	4798      	blx	r3
    d7be:	6060      	str	r0, [r4, #4]
    timer->milliseconds = (uint16_t)(now.milliseconds % 1000);
    d7c0:	1c28      	adds	r0, r5, #0
    d7c2:	21fa      	movs	r1, #250	; 0xfa
    d7c4:	0089      	lsls	r1, r1, #2
    d7c6:	4b04      	ldr	r3, [pc, #16]	; (d7d8 <AJ_InitTimer+0x2c>)
    d7c8:	4798      	blx	r3
    d7ca:	8021      	strh	r1, [r4, #0]
}
    d7cc:	bd38      	pop	{r3, r4, r5, pc}
    d7ce:	46c0      	nop			; (mov r8, r8)
    d7d0:	00014279 	.word	0x00014279
    d7d4:	00014e9d 	.word	0x00014e9d
    d7d8:	00014fa9 	.word	0x00014fa9

0000d7dc <AJ_Malloc>:

void* AJ_Malloc(size_t sz)
{
    d7dc:	b508      	push	{r3, lr}
    return malloc(sz);
    d7de:	4b01      	ldr	r3, [pc, #4]	; (d7e4 <AJ_Malloc+0x8>)
    d7e0:	4798      	blx	r3
}
    d7e2:	bd08      	pop	{r3, pc}
    d7e4:	000166dd 	.word	0x000166dd

0000d7e8 <AJ_Free>:
{
    return realloc(ptr, size);
}

void AJ_Free(void* mem)
{
    d7e8:	b508      	push	{r3, lr}
    if (mem) 
    d7ea:	2800      	cmp	r0, #0
    d7ec:	d001      	beq.n	d7f2 <AJ_Free+0xa>
	{
        free(mem);
    d7ee:	4b01      	ldr	r3, [pc, #4]	; (d7f4 <AJ_Free+0xc>)
    d7f0:	4798      	blx	r3
    }
}
    d7f2:	bd08      	pop	{r3, pc}
    d7f4:	000166f1 	.word	0x000166f1

0000d7f8 <A2H>:
    return &VERSION[0];
}

static uint8_t A2H(char hex, AJ_Status* status)
{
    if (hex >= '0' && hex <= '9') 
    d7f8:	1c02      	adds	r2, r0, #0
    d7fa:	3a30      	subs	r2, #48	; 0x30
    d7fc:	b2d2      	uxtb	r2, r2
    {
        return hex - '0';
    d7fe:	1e13      	subs	r3, r2, #0
    return &VERSION[0];
}

static uint8_t A2H(char hex, AJ_Status* status)
{
    if (hex >= '0' && hex <= '9') 
    d800:	2b09      	cmp	r3, #9
    d802:	d912      	bls.n	d82a <A2H+0x32>
    {
        return hex - '0';
    }
    hex |= 0x20;
    d804:	2320      	movs	r3, #32
    d806:	4318      	orrs	r0, r3
    if (hex >= 'a' && hex <= 'f') 
    d808:	1c03      	adds	r3, r0, #0
    d80a:	3b61      	subs	r3, #97	; 0x61
    d80c:	2b05      	cmp	r3, #5
    d80e:	d802      	bhi.n	d816 <A2H+0x1e>
    {
        return 10 + hex - 'a';
    d810:	3857      	subs	r0, #87	; 0x57
    d812:	b2c3      	uxtb	r3, r0
    d814:	e009      	b.n	d82a <A2H+0x32>
    }
    else if (hex >= 'A' && hex <= 'F') 
    d816:	1c03      	adds	r3, r0, #0
    d818:	3b41      	subs	r3, #65	; 0x41
    d81a:	2b05      	cmp	r3, #5
    d81c:	d802      	bhi.n	d824 <A2H+0x2c>
    {
        return 10 + hex - 'A';
    d81e:	3837      	subs	r0, #55	; 0x37
    d820:	b2c3      	uxtb	r3, r0
    d822:	e002      	b.n	d82a <A2H+0x32>
    }
	else 
    {
        *status = AJ_ERR_INVALID;
    d824:	2303      	movs	r3, #3
    d826:	700b      	strb	r3, [r1, #0]
        return 0;
    d828:	2300      	movs	r3, #0
    }
}
    d82a:	1c18      	adds	r0, r3, #0
    d82c:	4770      	bx	lr
    d82e:	46c0      	nop			; (mov r8, r8)

0000d830 <AJ_GetVersion>:
#define AJ_VERSION_STRING(a, b, c, d, e) AJ_TO_STRING(a) "." AJ_TO_STRING(b) "." AJ_TO_STRING(c) AJ_TO_STRING(d) " Tag " AJ_TO_STRING(e) "\0"
const char* AJ_GetVersion()
{
    static const char VERSION[] = AJ_VERSION_STRING(AJ_RELEASE_YEAR_STR, AJ_RELEASE_MONTH_STR, AJ_FEATURE_VERSION_STR, AJ_BUGFIX_VERSION_STR, AJ_RELEASE_TAG);
    return &VERSION[0];
}
    d830:	4800      	ldr	r0, [pc, #0]	; (d834 <AJ_GetVersion+0x4>)
    d832:	4770      	bx	lr
    d834:	0001f760 	.word	0x0001f760

0000d838 <AJ_StringFindFirstOf>:
        return 0;
    }
}

int32_t AJ_StringFindFirstOf(const char* str, char* chars)
{
    d838:	b530      	push	{r4, r5, lr}
    if (str)
    d83a:	2800      	cmp	r0, #0
    d83c:	d012      	beq.n	d864 <AJ_StringFindFirstOf+0x2c>
    d83e:	1c05      	adds	r5, r0, #0
	{
        const char* p = str;
        do {
            const char* c = chars;
    d840:	1c0b      	adds	r3, r1, #0
            while (*c) 
    d842:	e005      	b.n	d850 <AJ_StringFindFirstOf+0x18>
			{
                if (*p == *c++) 
    d844:	3301      	adds	r3, #1
    d846:	782c      	ldrb	r4, [r5, #0]
    d848:	4294      	cmp	r4, r2
    d84a:	d101      	bne.n	d850 <AJ_StringFindFirstOf+0x18>
				{
                    return (int32_t)(p - str);
    d84c:	1a28      	subs	r0, r5, r0
    d84e:	e00b      	b.n	d868 <AJ_StringFindFirstOf+0x30>
    if (str)
	{
        const char* p = str;
        do {
            const char* c = chars;
            while (*c) 
    d850:	781a      	ldrb	r2, [r3, #0]
    d852:	2a00      	cmp	r2, #0
    d854:	d1f6      	bne.n	d844 <AJ_StringFindFirstOf+0xc>
                if (*p == *c++) 
				{
                    return (int32_t)(p - str);
                }
            }
        } while (*(++p));
    d856:	3501      	adds	r5, #1
    d858:	782b      	ldrb	r3, [r5, #0]
    d85a:	2b00      	cmp	r3, #0
    d85c:	d1f0      	bne.n	d840 <AJ_StringFindFirstOf+0x8>
    }
    return -1;
    d85e:	2001      	movs	r0, #1
    d860:	4240      	negs	r0, r0
    d862:	e001      	b.n	d868 <AJ_StringFindFirstOf+0x30>
    d864:	2001      	movs	r0, #1
    d866:	4240      	negs	r0, r0
}
    d868:	bd30      	pop	{r4, r5, pc}
    d86a:	46c0      	nop			; (mov r8, r8)

0000d86c <AJ_RawToHex>:

AJ_Status AJ_RawToHex(const uint8_t* raw, size_t rawLen, char* hex, size_t hexLen, uint8_t lower)
{
    d86c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d86e:	ac05      	add	r4, sp, #20
    d870:	7824      	ldrb	r4, [r4, #0]
    static const char nibble_upper[] = "0123456789ABCDEF";
    static const char nibble_lower[] = "0123456789abcdef";
    const char* nibble = lower ? nibble_lower : nibble_upper;
    d872:	2c00      	cmp	r4, #0
    d874:	d101      	bne.n	d87a <AJ_RawToHex+0xe>
    d876:	4d10      	ldr	r5, [pc, #64]	; (d8b8 <AJ_RawToHex+0x4c>)
    d878:	e000      	b.n	d87c <AJ_RawToHex+0x10>
    d87a:	4d10      	ldr	r5, [pc, #64]	; (d8bc <AJ_RawToHex+0x50>)
    char* h = hex + 2 * rawLen;
    d87c:	004c      	lsls	r4, r1, #1
    const uint8_t* a = raw + rawLen;

    if ((2 * rawLen + 1) > hexLen) 
    d87e:	1c67      	adds	r7, r4, #1
    {
        return AJ_ERR_RESOURCES;
    d880:	260b      	movs	r6, #11
    static const char nibble_lower[] = "0123456789abcdef";
    const char* nibble = lower ? nibble_lower : nibble_upper;
    char* h = hex + 2 * rawLen;
    const uint8_t* a = raw + rawLen;

    if ((2 * rawLen + 1) > hexLen) 
    d882:	429f      	cmp	r7, r3
    d884:	d815      	bhi.n	d8b2 <AJ_RawToHex+0x46>
AJ_Status AJ_RawToHex(const uint8_t* raw, size_t rawLen, char* hex, size_t hexLen, uint8_t lower)
{
    static const char nibble_upper[] = "0123456789ABCDEF";
    static const char nibble_lower[] = "0123456789abcdef";
    const char* nibble = lower ? nibble_lower : nibble_upper;
    char* h = hex + 2 * rawLen;
    d886:	1912      	adds	r2, r2, r4

    if ((2 * rawLen + 1) > hexLen) 
    {
        return AJ_ERR_RESOURCES;
    }
    h[0] = '\0';
    d888:	2300      	movs	r3, #0
    d88a:	7013      	strb	r3, [r2, #0]
    /*
     * Running backwards encode each byte in inStr as a pair of ascii hex digits.
     * Going backwards allows the raw and hex buffers to be the same buffer.
     */
    while (rawLen--) 
    d88c:	2900      	cmp	r1, #0
    d88e:	d00f      	beq.n	d8b0 <AJ_RawToHex+0x44>
{
    static const char nibble_upper[] = "0123456789ABCDEF";
    static const char nibble_lower[] = "0123456789abcdef";
    const char* nibble = lower ? nibble_lower : nibble_upper;
    char* h = hex + 2 * rawLen;
    const uint8_t* a = raw + rawLen;
    d890:	1840      	adds	r0, r0, r1
    d892:	1a41      	subs	r1, r0, r1
    while (rawLen--) 
    {
        uint8_t n = *(--a);
        h -= 2;
        h[0] = nibble[n >> 4];
        h[1] = nibble[n & 0xF];
    d894:	3604      	adds	r6, #4
     * Running backwards encode each byte in inStr as a pair of ascii hex digits.
     * Going backwards allows the raw and hex buffers to be the same buffer.
     */
    while (rawLen--) 
    {
        uint8_t n = *(--a);
    d896:	3801      	subs	r0, #1
    d898:	7803      	ldrb	r3, [r0, #0]
        h -= 2;
    d89a:	3a02      	subs	r2, #2
        h[0] = nibble[n >> 4];
    d89c:	091c      	lsrs	r4, r3, #4
    d89e:	5d2c      	ldrb	r4, [r5, r4]
    d8a0:	7014      	strb	r4, [r2, #0]
        h[1] = nibble[n & 0xF];
    d8a2:	4033      	ands	r3, r6
    d8a4:	5ceb      	ldrb	r3, [r5, r3]
    d8a6:	7053      	strb	r3, [r2, #1]
    h[0] = '\0';
    /*
     * Running backwards encode each byte in inStr as a pair of ascii hex digits.
     * Going backwards allows the raw and hex buffers to be the same buffer.
     */
    while (rawLen--) 
    d8a8:	4288      	cmp	r0, r1
    d8aa:	d1f4      	bne.n	d896 <AJ_RawToHex+0x2a>
        uint8_t n = *(--a);
        h -= 2;
        h[0] = nibble[n >> 4];
        h[1] = nibble[n & 0xF];
    }
    return AJ_OK;
    d8ac:	2600      	movs	r6, #0
    d8ae:	e000      	b.n	d8b2 <AJ_RawToHex+0x46>
    d8b0:	2600      	movs	r6, #0
}
    d8b2:	1c30      	adds	r0, r6, #0
    d8b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d8b6:	46c0      	nop			; (mov r8, r8)
    d8b8:	0001f73c 	.word	0x0001f73c
    d8bc:	0001f728 	.word	0x0001f728

0000d8c0 <AJ_HexToRaw>:

AJ_Status AJ_HexToRaw(const char* hex, size_t hexLen, uint8_t* raw, size_t rawLen)
{
    d8c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d8c2:	4657      	mov	r7, sl
    d8c4:	464e      	mov	r6, r9
    d8c6:	b4c0      	push	{r6, r7}
    d8c8:	b085      	sub	sp, #20
    d8ca:	9001      	str	r0, [sp, #4]
    d8cc:	1c0c      	adds	r4, r1, #0
    d8ce:	1c16      	adds	r6, r2, #0
    d8d0:	1c1d      	adds	r5, r3, #0
    AJ_Status status = AJ_OK;
    d8d2:	2200      	movs	r2, #0
    d8d4:	ab02      	add	r3, sp, #8
    d8d6:	71da      	strb	r2, [r3, #7]
    char* p = (char*)raw;
    size_t sz = hexLen ? hexLen : strlen(hex);
    d8d8:	2900      	cmp	r1, #0
    d8da:	d102      	bne.n	d8e2 <AJ_HexToRaw+0x22>
    d8dc:	4b16      	ldr	r3, [pc, #88]	; (d938 <AJ_HexToRaw+0x78>)
    d8de:	4798      	blx	r3
    d8e0:	1c04      	adds	r4, r0, #0
    size_t i;

    // Length of encoded hex must be an even number
    if (sz & 1)
    {
        return AJ_ERR_UNEXPECTED;
    d8e2:	2002      	movs	r0, #2
    char* p = (char*)raw;
    size_t sz = hexLen ? hexLen : strlen(hex);
    size_t i;

    // Length of encoded hex must be an even number
    if (sz & 1)
    d8e4:	07e3      	lsls	r3, r4, #31
    d8e6:	d421      	bmi.n	d92c <AJ_HexToRaw+0x6c>
    {
        return AJ_ERR_UNEXPECTED;
    }
    if (rawLen < (sz / 2)) 
    d8e8:	0863      	lsrs	r3, r4, #1
    {
        return AJ_ERR_RESOURCES;
    d8ea:	3009      	adds	r0, #9
    // Length of encoded hex must be an even number
    if (sz & 1)
    {
        return AJ_ERR_UNEXPECTED;
    }
    if (rawLen < (sz / 2)) 
    d8ec:	42ab      	cmp	r3, r5
    d8ee:	d81d      	bhi.n	d92c <AJ_HexToRaw+0x6c>
    {
        return AJ_ERR_RESOURCES;
    }
    for (i = 0; ((i < sz) && (status == AJ_OK)); i += 2, hex += 2) 
    d8f0:	2c00      	cmp	r4, #0
    d8f2:	d019      	beq.n	d928 <AJ_HexToRaw+0x68>
    d8f4:	1c37      	adds	r7, r6, #0
    d8f6:	9d01      	ldr	r5, [sp, #4]
    {
        *p++ = (A2H(hex[0], &status) << 4) | A2H(hex[1], &status);
    d8f8:	ab02      	add	r3, sp, #8
    d8fa:	1dde      	adds	r6, r3, #7
    d8fc:	4b0f      	ldr	r3, [pc, #60]	; (d93c <AJ_HexToRaw+0x7c>)
    d8fe:	4699      	mov	r9, r3
    d900:	7828      	ldrb	r0, [r5, #0]
    d902:	1c31      	adds	r1, r6, #0
    d904:	47c8      	blx	r9
    d906:	4682      	mov	sl, r0
    d908:	7868      	ldrb	r0, [r5, #1]
    d90a:	1c31      	adds	r1, r6, #0
    d90c:	47c8      	blx	r9
    d90e:	4653      	mov	r3, sl
    d910:	011b      	lsls	r3, r3, #4
    d912:	4318      	orrs	r0, r3
    d914:	7038      	strb	r0, [r7, #0]
    }
    if (rawLen < (sz / 2)) 
    {
        return AJ_ERR_RESOURCES;
    }
    for (i = 0; ((i < sz) && (status == AJ_OK)); i += 2, hex += 2) 
    d916:	3502      	adds	r5, #2
    d918:	9b01      	ldr	r3, [sp, #4]
    d91a:	1aeb      	subs	r3, r5, r3
    d91c:	429c      	cmp	r4, r3
    d91e:	d903      	bls.n	d928 <AJ_HexToRaw+0x68>
    d920:	3701      	adds	r7, #1
    d922:	7833      	ldrb	r3, [r6, #0]
    d924:	2b00      	cmp	r3, #0
    d926:	d0eb      	beq.n	d900 <AJ_HexToRaw+0x40>
    {
        *p++ = (A2H(hex[0], &status) << 4) | A2H(hex[1], &status);
    }
    return status;
    d928:	ab02      	add	r3, sp, #8
    d92a:	79d8      	ldrb	r0, [r3, #7]
}
    d92c:	b005      	add	sp, #20
    d92e:	bc0c      	pop	{r2, r3}
    d930:	4691      	mov	r9, r2
    d932:	469a      	mov	sl, r3
    d934:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d936:	46c0      	nop			; (mov r8, r8)
    d938:	0001715b 	.word	0x0001715b
    d93c:	0000d7f9 	.word	0x0000d7f9

0000d940 <AJ_IntToString>:

    return AJ_OK;
}

AJ_Status AJ_IntToString(int32_t val, char* buf, size_t buflen)
{
    d940:	b538      	push	{r3, r4, r5, lr}
    d942:	1c03      	adds	r3, r0, #0
    d944:	1c14      	adds	r4, r2, #0
	AJ_Status status = AJ_OK;
	int c = snprintf(buf, buflen, "%d", val);
    d946:	1c08      	adds	r0, r1, #0
    d948:	1c11      	adds	r1, r2, #0
    d94a:	4a05      	ldr	r2, [pc, #20]	; (d960 <AJ_IntToString+0x20>)
    d94c:	4d05      	ldr	r5, [pc, #20]	; (d964 <AJ_IntToString+0x24>)
    d94e:	47a8      	blx	r5
	if (c <= 0 || c > buflen) 
	{
		status = AJ_ERR_RESOURCES;
    d950:	230b      	movs	r3, #11

AJ_Status AJ_IntToString(int32_t val, char* buf, size_t buflen)
{
	AJ_Status status = AJ_OK;
	int c = snprintf(buf, buflen, "%d", val);
	if (c <= 0 || c > buflen) 
    d952:	2800      	cmp	r0, #0
    d954:	dd02      	ble.n	d95c <AJ_IntToString+0x1c>
    d956:	4284      	cmp	r4, r0
    d958:	d300      	bcc.n	d95c <AJ_IntToString+0x1c>
    return AJ_OK;
}

AJ_Status AJ_IntToString(int32_t val, char* buf, size_t buflen)
{
	AJ_Status status = AJ_OK;
    d95a:	2300      	movs	r3, #0
	if (c <= 0 || c > buflen) 
	{
		status = AJ_ERR_RESOURCES;
	}
	return status;
}
    d95c:	1c18      	adds	r0, r3, #0
    d95e:	bd38      	pop	{r3, r4, r5, pc}
    d960:	0001f750 	.word	0x0001f750
    d964:	000170b5 	.word	0x000170b5

0000d968 <AJ_InetToString>:

AJ_Status AJ_InetToString(uint32_t addr, char* buf, size_t buflen)
{
    d968:	b530      	push	{r4, r5, lr}
    d96a:	b085      	sub	sp, #20
    d96c:	1c14      	adds	r4, r2, #0
	AJ_Status status = AJ_OK;
	int c = snprintf((char*)buf, buflen, "%u.%u.%u.%u", (addr & 0xFF000000) >> 24, (addr & 0x00FF0000) >> 16, (addr & 0x0000FF00) >> 8, (addr & 0x000000FF));
    d96e:	0e03      	lsrs	r3, r0, #24
    d970:	0202      	lsls	r2, r0, #8
    d972:	0e12      	lsrs	r2, r2, #24
    d974:	9200      	str	r2, [sp, #0]
    d976:	0402      	lsls	r2, r0, #16
    d978:	0e12      	lsrs	r2, r2, #24
    d97a:	9201      	str	r2, [sp, #4]
    d97c:	22ff      	movs	r2, #255	; 0xff
    d97e:	4010      	ands	r0, r2
    d980:	9002      	str	r0, [sp, #8]
    d982:	1c08      	adds	r0, r1, #0
    d984:	1c21      	adds	r1, r4, #0
    d986:	4a06      	ldr	r2, [pc, #24]	; (d9a0 <AJ_InetToString+0x38>)
    d988:	4d06      	ldr	r5, [pc, #24]	; (d9a4 <AJ_InetToString+0x3c>)
    d98a:	47a8      	blx	r5
	if (c <= 0 || c > buflen) 
	{
		status = AJ_ERR_RESOURCES;
    d98c:	230b      	movs	r3, #11

AJ_Status AJ_InetToString(uint32_t addr, char* buf, size_t buflen)
{
	AJ_Status status = AJ_OK;
	int c = snprintf((char*)buf, buflen, "%u.%u.%u.%u", (addr & 0xFF000000) >> 24, (addr & 0x00FF0000) >> 16, (addr & 0x0000FF00) >> 8, (addr & 0x000000FF));
	if (c <= 0 || c > buflen) 
    d98e:	2800      	cmp	r0, #0
    d990:	dd02      	ble.n	d998 <AJ_InetToString+0x30>
    d992:	4284      	cmp	r4, r0
    d994:	d300      	bcc.n	d998 <AJ_InetToString+0x30>
	return status;
}

AJ_Status AJ_InetToString(uint32_t addr, char* buf, size_t buflen)
{
	AJ_Status status = AJ_OK;
    d996:	2300      	movs	r3, #0
	if (c <= 0 || c > buflen) 
	{
		status = AJ_ERR_RESOURCES;
	}
	return status;
    d998:	1c18      	adds	r0, r3, #0
    d99a:	b005      	add	sp, #20
    d99c:	bd30      	pop	{r4, r5, pc}
    d99e:	46c0      	nop			; (mov r8, r8)
    d9a0:	0001f754 	.word	0x0001f754
    d9a4:	000170b5 	.word	0x000170b5

0000d9a8 <AJCFG_PropSetHandler>:
}

AJ_Status AJCFG_PropSetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    return AJ_ERR_UNEXPECTED;
}
    d9a8:	2002      	movs	r0, #2
    d9aa:	4770      	bx	lr

0000d9ac <AJCFG_PropGetHandler>:

    return status;
}

AJ_Status AJCFG_PropGetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    d9ac:	b508      	push	{r3, lr}
	{
        return AJ_MarshalArgs(replyMsg, "q", AJSVC_ConfigVersion);
    }
	else
    {
        return AJ_ERR_UNEXPECTED;
    d9ae:	2302      	movs	r3, #2
    return status;
}

AJ_Status AJCFG_PropGetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    if (propId == CONFIG_VERSION_PROP) 
    d9b0:	4a04      	ldr	r2, [pc, #16]	; (d9c4 <AJCFG_PropGetHandler+0x18>)
    d9b2:	4291      	cmp	r1, r2
    d9b4:	d104      	bne.n	d9c0 <AJCFG_PropGetHandler+0x14>
	{
        return AJ_MarshalArgs(replyMsg, "q", AJSVC_ConfigVersion);
    d9b6:	4904      	ldr	r1, [pc, #16]	; (d9c8 <AJCFG_PropGetHandler+0x1c>)
    d9b8:	2201      	movs	r2, #1
    d9ba:	4b04      	ldr	r3, [pc, #16]	; (d9cc <AJCFG_PropGetHandler+0x20>)
    d9bc:	4798      	blx	r3
    d9be:	1c03      	adds	r3, r0, #0
    }
	else
    {
        return AJ_ERR_UNEXPECTED;
    }
}
    d9c0:	1c18      	adds	r0, r3, #0
    d9c2:	bd08      	pop	{r3, pc}
    d9c4:	03000100 	.word	0x03000100
    d9c8:	0001eda8 	.word	0x0001eda8
    d9cc:	0000bc85 	.word	0x0000bc85

0000d9d0 <AJCFG_Start>:
static AJCFG_Restart AppRestart = NULL;
static AJCFG_SetPasscode AppSetPasscode = NULL;
static AJCFG_IsValueValid AppIsValueValid = NULL;

AJ_Status AJCFG_Start(AJCFG_FactoryReset factoryReset, AJCFG_Restart restart, AJCFG_SetPasscode setPasscode, AJCFG_IsValueValid isValueValid)
{
    d9d0:	b510      	push	{r4, lr}
    AJ_Status status = AJ_OK;

    AppFactoryReset = factoryReset;
    d9d2:	4c09      	ldr	r4, [pc, #36]	; (d9f8 <AJCFG_Start+0x28>)
    d9d4:	6020      	str	r0, [r4, #0]
    AppRestart = restart;
    d9d6:	4809      	ldr	r0, [pc, #36]	; (d9fc <AJCFG_Start+0x2c>)
    d9d8:	6001      	str	r1, [r0, #0]
    AppSetPasscode = setPasscode;
    d9da:	4909      	ldr	r1, [pc, #36]	; (da00 <AJCFG_Start+0x30>)
    d9dc:	600a      	str	r2, [r1, #0]
    AppIsValueValid = isValueValid;
    d9de:	4a09      	ldr	r2, [pc, #36]	; (da04 <AJCFG_Start+0x34>)
    d9e0:	6013      	str	r3, [r2, #0]
#define CONFIG_SET_PASSCODE                                     AJ_ENCODE_MESSAGE_ID(AJCFG_OBJECT_LIST_INDEX, CONFIG_OBJECT_INDEX, 1, 6)

static AJ_Status RegisterObjectList()
{
    AJCFG_ObjectList[CONFIG_OBJECT_INDEX].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    AJCFG_ObjectList[CONFIG_OBJECT_INDEX].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    d9e2:	4809      	ldr	r0, [pc, #36]	; (da08 <AJCFG_Start+0x38>)
#define CONFIG_RESET_CONFIGURATIONS                             AJ_ENCODE_MESSAGE_ID(AJCFG_OBJECT_LIST_INDEX, CONFIG_OBJECT_INDEX, 1, 5)
#define CONFIG_SET_PASSCODE                                     AJ_ENCODE_MESSAGE_ID(AJCFG_OBJECT_LIST_INDEX, CONFIG_OBJECT_INDEX, 1, 6)

static AJ_Status RegisterObjectList()
{
    AJCFG_ObjectList[CONFIG_OBJECT_INDEX].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    d9e4:	7a03      	ldrb	r3, [r0, #8]
    d9e6:	2206      	movs	r2, #6
    d9e8:	4393      	bics	r3, r2
    AJCFG_ObjectList[CONFIG_OBJECT_INDEX].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    d9ea:	2208      	movs	r2, #8
    d9ec:	4313      	orrs	r3, r2
    d9ee:	7203      	strb	r3, [r0, #8]

    return AJ_RegisterObjectList(AJCFG_ObjectList, AJCFG_OBJECT_LIST_INDEX);
    d9f0:	2103      	movs	r1, #3
    d9f2:	4b06      	ldr	r3, [pc, #24]	; (da0c <AJCFG_Start+0x3c>)
    d9f4:	4798      	blx	r3
    AppSetPasscode = setPasscode;
    AppIsValueValid = isValueValid;
    status = RegisterObjectList();

    return status;
}
    d9f6:	bd10      	pop	{r4, pc}
    d9f8:	20001270 	.word	0x20001270
    d9fc:	2000126c 	.word	0x2000126c
    da00:	20001274 	.word	0x20001274
    da04:	20001268 	.word	0x20001268
    da08:	2000015c 	.word	0x2000015c
    da0c:	000088ed 	.word	0x000088ed

0000da10 <AJCFG_FactoryResetHandler>:
{
    return AJ_ERR_UNEXPECTED;
}

AJ_Status AJCFG_FactoryResetHandler(AJ_Message* msg)
{
    da10:	b508      	push	{r3, lr}
    AJ_Status status = AJ_OK;

    if (AppFactoryReset) 
    da12:	4b04      	ldr	r3, [pc, #16]	; (da24 <AJCFG_FactoryResetHandler+0x14>)
    da14:	681b      	ldr	r3, [r3, #0]
    da16:	2b00      	cmp	r3, #0
    da18:	d001      	beq.n	da1e <AJCFG_FactoryResetHandler+0xe>
	{
        status = (AppFactoryReset)();
    da1a:	4798      	blx	r3
    da1c:	e000      	b.n	da20 <AJCFG_FactoryResetHandler+0x10>
    return AJ_ERR_UNEXPECTED;
}

AJ_Status AJCFG_FactoryResetHandler(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    da1e:	2000      	movs	r0, #0
	{
        status = (AppFactoryReset)();
    }

    return status;
}
    da20:	bd08      	pop	{r3, pc}
    da22:	46c0      	nop			; (mov r8, r8)
    da24:	20001270 	.word	0x20001270

0000da28 <AJCFG_RestartHandler>:

AJ_Status AJCFG_RestartHandler(AJ_Message* msg)
{
    da28:	b508      	push	{r3, lr}
    AJ_Status status = AJ_OK;

    if (AppRestart) 
    da2a:	4b04      	ldr	r3, [pc, #16]	; (da3c <AJCFG_RestartHandler+0x14>)
    da2c:	681b      	ldr	r3, [r3, #0]
    da2e:	2b00      	cmp	r3, #0
    da30:	d001      	beq.n	da36 <AJCFG_RestartHandler+0xe>
	{
        status = (AppRestart)();
    da32:	4798      	blx	r3
    da34:	e000      	b.n	da38 <AJCFG_RestartHandler+0x10>
    return status;
}

AJ_Status AJCFG_RestartHandler(AJ_Message* msg)
{
    AJ_Status status = AJ_OK;
    da36:	2000      	movs	r0, #0
	{
        status = (AppRestart)();
    }

    return status;
}
    da38:	bd08      	pop	{r3, pc}
    da3a:	46c0      	nop			; (mov r8, r8)
    da3c:	2000126c 	.word	0x2000126c

0000da40 <AJCFG_GetConfigurationsHandler>:

AJ_Status AJCFG_GetConfigurationsHandler(AJ_Message* msg)
{
    da40:	b570      	push	{r4, r5, r6, lr}
    da42:	b092      	sub	sp, #72	; 0x48
    da44:	1c05      	adds	r5, r0, #0
    AJ_Status status = AJ_OK;
    AJ_Message reply;
    char* language;
    int8_t langIndex = AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
    da46:	22ff      	movs	r2, #255	; 0xff
    da48:	466b      	mov	r3, sp
    da4a:	70da      	strb	r2, [r3, #3]
    AJSVC_PropertyStoreCategoryFilter filter;

    printf("Handling GetConfigurations request\n");
    da4c:	4823      	ldr	r0, [pc, #140]	; (dadc <AJCFG_GetConfigurationsHandler+0x9c>)
    da4e:	4b24      	ldr	r3, [pc, #144]	; (dae0 <AJCFG_GetConfigurationsHandler+0xa0>)
    da50:	4798      	blx	r3

    memset(&filter, 0, sizeof(AJSVC_PropertyStoreCategoryFilter));
    filter.bit1Config = TRUE;
    da52:	2302      	movs	r3, #2
    da54:	466a      	mov	r2, sp
    da56:	7013      	strb	r3, [r2, #0]
    status = AJ_UnmarshalArgs(msg, "s", &language);
    da58:	1c28      	adds	r0, r5, #0
    da5a:	4922      	ldr	r1, [pc, #136]	; (dae4 <AJCFG_GetConfigurationsHandler+0xa4>)
    da5c:	aa01      	add	r2, sp, #4
    da5e:	4b22      	ldr	r3, [pc, #136]	; (dae8 <AJCFG_GetConfigurationsHandler+0xa8>)
    da60:	4798      	blx	r3
    da62:	1c04      	adds	r4, r0, #0
	printf("AJCFG_GetConfigurationsHandler(): AJ_UnmarshalArgs status = %s\n",AJ_StatusText(status) );
    da64:	4b21      	ldr	r3, [pc, #132]	; (daec <AJCFG_GetConfigurationsHandler+0xac>)
    da66:	4798      	blx	r3
    da68:	1c01      	adds	r1, r0, #0
    da6a:	4821      	ldr	r0, [pc, #132]	; (daf0 <AJCFG_GetConfigurationsHandler+0xb0>)
    da6c:	4b21      	ldr	r3, [pc, #132]	; (daf4 <AJCFG_GetConfigurationsHandler+0xb4>)
    da6e:	4798      	blx	r3
    if (status != AJ_OK)
	{
        return status;
    da70:	1e20      	subs	r0, r4, #0

    memset(&filter, 0, sizeof(AJSVC_PropertyStoreCategoryFilter));
    filter.bit1Config = TRUE;
    status = AJ_UnmarshalArgs(msg, "s", &language);
	printf("AJCFG_GetConfigurationsHandler(): AJ_UnmarshalArgs status = %s\n",AJ_StatusText(status) );
    if (status != AJ_OK)
    da72:	d130      	bne.n	dad6 <AJCFG_GetConfigurationsHandler+0x96>
	{
        return status;
    }
    if (AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex)) 
    da74:	1c28      	adds	r0, r5, #0
    da76:	a902      	add	r1, sp, #8
    da78:	9a01      	ldr	r2, [sp, #4]
    da7a:	466b      	mov	r3, sp
    da7c:	3303      	adds	r3, #3
    da7e:	4c1e      	ldr	r4, [pc, #120]	; (daf8 <AJCFG_GetConfigurationsHandler+0xb8>)
    da80:	47a0      	blx	r4
    da82:	2800      	cmp	r0, #0
    da84:	d01c      	beq.n	dac0 <AJCFG_GetConfigurationsHandler+0x80>
	{
        status = AJ_MarshalReplyMsg(msg, &reply);
    da86:	1c28      	adds	r0, r5, #0
    da88:	a902      	add	r1, sp, #8
    da8a:	4b1c      	ldr	r3, [pc, #112]	; (dafc <AJCFG_GetConfigurationsHandler+0xbc>)
    da8c:	4798      	blx	r3
    da8e:	1c04      	adds	r4, r0, #0
		printf("AJCFG_GetConfigurationsHandler(): AJ_MarshalReplyMsg status = %s\n",AJ_StatusText(status) );
    da90:	4b16      	ldr	r3, [pc, #88]	; (daec <AJCFG_GetConfigurationsHandler+0xac>)
    da92:	4798      	blx	r3
    da94:	1c01      	adds	r1, r0, #0
    da96:	481a      	ldr	r0, [pc, #104]	; (db00 <AJCFG_GetConfigurationsHandler+0xc0>)
    da98:	4b16      	ldr	r3, [pc, #88]	; (daf4 <AJCFG_GetConfigurationsHandler+0xb4>)
    da9a:	4798      	blx	r3
        if (status != AJ_OK) {
            return status;
    da9c:	1e20      	subs	r0, r4, #0
    }
    if (AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex)) 
	{
        status = AJ_MarshalReplyMsg(msg, &reply);
		printf("AJCFG_GetConfigurationsHandler(): AJ_MarshalReplyMsg status = %s\n",AJ_StatusText(status) );
        if (status != AJ_OK) {
    da9e:	d11a      	bne.n	dad6 <AJCFG_GetConfigurationsHandler+0x96>
            return status;
        }
        status = AJSVC_PropertyStore_ReadAll(&reply, filter, langIndex);
    daa0:	466b      	mov	r3, sp
    daa2:	7819      	ldrb	r1, [r3, #0]
    daa4:	2203      	movs	r2, #3
    daa6:	569a      	ldrsb	r2, [r3, r2]
    daa8:	a802      	add	r0, sp, #8
    daaa:	4b16      	ldr	r3, [pc, #88]	; (db04 <AJCFG_GetConfigurationsHandler+0xc4>)
    daac:	4798      	blx	r3
    daae:	1c04      	adds	r4, r0, #0
		printf("AJCFG_GetConfigurationsHandler(): AJSVC_PropertyStore_ReadAll status = %s\n",AJ_StatusText(status) );
    dab0:	4b0e      	ldr	r3, [pc, #56]	; (daec <AJCFG_GetConfigurationsHandler+0xac>)
    dab2:	4798      	blx	r3
    dab4:	1c01      	adds	r1, r0, #0
    dab6:	4814      	ldr	r0, [pc, #80]	; (db08 <AJCFG_GetConfigurationsHandler+0xc8>)
    dab8:	4b0e      	ldr	r3, [pc, #56]	; (daf4 <AJCFG_GetConfigurationsHandler+0xb4>)
    daba:	4798      	blx	r3

        if (status != AJ_OK) 
		{
            return status;
    dabc:	1e20      	subs	r0, r4, #0
            return status;
        }
        status = AJSVC_PropertyStore_ReadAll(&reply, filter, langIndex);
		printf("AJCFG_GetConfigurationsHandler(): AJSVC_PropertyStore_ReadAll status = %s\n",AJ_StatusText(status) );

        if (status != AJ_OK) 
    dabe:	d10a      	bne.n	dad6 <AJCFG_GetConfigurationsHandler+0x96>
		{
            return status;
        }
    }
    status = AJ_DeliverMsg(&reply);
    dac0:	a802      	add	r0, sp, #8
    dac2:	4b12      	ldr	r3, [pc, #72]	; (db0c <AJCFG_GetConfigurationsHandler+0xcc>)
    dac4:	4798      	blx	r3
    dac6:	1c04      	adds	r4, r0, #0
	printf("AJCFG_GetConfigurationsHandler(): AJ_DeliverMsg status = %s\n",AJ_StatusText(status) );
    dac8:	4b08      	ldr	r3, [pc, #32]	; (daec <AJCFG_GetConfigurationsHandler+0xac>)
    daca:	4798      	blx	r3
    dacc:	1c01      	adds	r1, r0, #0
    dace:	4810      	ldr	r0, [pc, #64]	; (db10 <AJCFG_GetConfigurationsHandler+0xd0>)
    dad0:	4b08      	ldr	r3, [pc, #32]	; (daf4 <AJCFG_GetConfigurationsHandler+0xb4>)
    dad2:	4798      	blx	r3
    if (status != AJ_OK) 
	{
        return status;
    dad4:	1c20      	adds	r0, r4, #0
    }

    return status;
}
    dad6:	b012      	add	sp, #72	; 0x48
    dad8:	bd70      	pop	{r4, r5, r6, pc}
    dada:	46c0      	nop			; (mov r8, r8)
    dadc:	0001f77c 	.word	0x0001f77c
    dae0:	00016f5d 	.word	0x00016f5d
    dae4:	0001f054 	.word	0x0001f054
    dae8:	0000b5f5 	.word	0x0000b5f5
    daec:	000063c5 	.word	0x000063c5
    daf0:	0001f7a0 	.word	0x0001f7a0
    daf4:	00016e3d 	.word	0x00016e3d
    daf8:	0000ebc5 	.word	0x0000ebc5
    dafc:	0000bd45 	.word	0x0000bd45
    db00:	0001f7e0 	.word	0x0001f7e0
    db04:	00000ff9 	.word	0x00000ff9
    db08:	0001f824 	.word	0x0001f824
    db0c:	0000a539 	.word	0x0000a539
    db10:	0001f870 	.word	0x0001f870

0000db14 <AJCFG_UpdateConfigurationsHandler>:
    }
    return FALSE;
}

AJ_Status AJCFG_UpdateConfigurationsHandler(AJ_Message* msg)
{
    db14:	b5f0      	push	{r4, r5, r6, r7, lr}
    db16:	4657      	mov	r7, sl
    db18:	464e      	mov	r6, r9
    db1a:	4645      	mov	r5, r8
    db1c:	b4e0      	push	{r5, r6, r7}
    db1e:	b09e      	sub	sp, #120	; 0x78
    db20:	1c06      	adds	r6, r0, #0
    AJ_Message reply;
    char* key;
    char* sig;
    char* value;
    char* language;
    int8_t langIndex = AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
    db22:	22ff      	movs	r2, #255	; 0xff
    db24:	466b      	mov	r3, sp
    db26:	71da      	strb	r2, [r3, #7]
    uint8_t numOfUpdatedItems = 0;
    uint8_t errorReply = FALSE;

   // AJ_InfoPrintf(("Handling UpdateConfigurations request\n"));

    status = AJ_UnmarshalArgs(msg, "s", &language);
    db28:	4977      	ldr	r1, [pc, #476]	; (dd08 <AJCFG_UpdateConfigurationsHandler+0x1f4>)
    db2a:	aa02      	add	r2, sp, #8
    db2c:	4b77      	ldr	r3, [pc, #476]	; (dd0c <AJCFG_UpdateConfigurationsHandler+0x1f8>)
    db2e:	4798      	blx	r3
    db30:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    db32:	d000      	beq.n	db36 <AJCFG_UpdateConfigurationsHandler+0x22>
    db34:	e0e0      	b.n	dcf8 <AJCFG_UpdateConfigurationsHandler+0x1e4>
	{
        goto Exit;
    }
  //  AJ_InfoPrintf(("Lang=%s\n", language));
    errorReply = !AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex);
    db36:	1c30      	adds	r0, r6, #0
    db38:	a906      	add	r1, sp, #24
    db3a:	9a02      	ldr	r2, [sp, #8]
    db3c:	466b      	mov	r3, sp
    db3e:	3307      	adds	r3, #7
    db40:	4c73      	ldr	r4, [pc, #460]	; (dd10 <AJCFG_UpdateConfigurationsHandler+0x1fc>)
    db42:	47a0      	blx	r4
    db44:	4245      	negs	r5, r0
    db46:	4145      	adcs	r5, r0
    db48:	b2ed      	uxtb	r5, r5
    char* key;
    char* sig;
    char* value;
    char* language;
    int8_t langIndex = AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
    uint8_t numOfUpdatedItems = 0;
    db4a:	2300      	movs	r3, #0
    db4c:	4698      	mov	r8, r3
	{
        goto Exit;
    }
  //  AJ_InfoPrintf(("Lang=%s\n", language));
    errorReply = !AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex);
    if (!errorReply)
    db4e:	2d00      	cmp	r5, #0
    db50:	d000      	beq.n	db54 <AJCFG_UpdateConfigurationsHandler+0x40>
    db52:	e0b8      	b.n	dcc6 <AJCFG_UpdateConfigurationsHandler+0x1b2>
	 {
        status = AJ_UnmarshalContainer(msg, &array, AJ_ARG_ARRAY);
    db54:	1c30      	adds	r0, r6, #0
    db56:	a91a      	add	r1, sp, #104	; 0x68
    db58:	2261      	movs	r2, #97	; 0x61
    db5a:	4b6e      	ldr	r3, [pc, #440]	; (dd14 <AJCFG_UpdateConfigurationsHandler+0x200>)
    db5c:	4798      	blx	r3
    db5e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    db60:	d000      	beq.n	db64 <AJCFG_UpdateConfigurationsHandler+0x50>
    db62:	e0c9      	b.n	dcf8 <AJCFG_UpdateConfigurationsHandler+0x1e4>
		{
            goto Exit;
        }
        while (1)
		 {
            status = AJ_UnmarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    db64:	4b6b      	ldr	r3, [pc, #428]	; (dd14 <AJCFG_UpdateConfigurationsHandler+0x200>)
    db66:	4699      	mov	r9, r3
            if (status != AJ_OK)
			 {
                break;
            }
            status = AJ_UnmarshalArgs(msg, "s", &key);
    db68:	4b68      	ldr	r3, [pc, #416]	; (dd0c <AJCFG_UpdateConfigurationsHandler+0x1f8>)
    db6a:	469a      	mov	sl, r3
		{
            goto Exit;
        }
        while (1)
		 {
            status = AJ_UnmarshalContainer(msg, &dict, AJ_ARG_DICT_ENTRY);
    db6c:	1c30      	adds	r0, r6, #0
    db6e:	a916      	add	r1, sp, #88	; 0x58
    db70:	227b      	movs	r2, #123	; 0x7b
    db72:	47c8      	blx	r9
    db74:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK)
    db76:	d000      	beq.n	db7a <AJCFG_UpdateConfigurationsHandler+0x66>
    db78:	e0b8      	b.n	dcec <AJCFG_UpdateConfigurationsHandler+0x1d8>
			 {
                break;
            }
            status = AJ_UnmarshalArgs(msg, "s", &key);
    db7a:	1c30      	adds	r0, r6, #0
    db7c:	4962      	ldr	r1, [pc, #392]	; (dd08 <AJCFG_UpdateConfigurationsHandler+0x1f4>)
    db7e:	aa05      	add	r2, sp, #20
    db80:	47d0      	blx	sl
    db82:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK)
    db84:	d000      	beq.n	db88 <AJCFG_UpdateConfigurationsHandler+0x74>
    db86:	e0b1      	b.n	dcec <AJCFG_UpdateConfigurationsHandler+0x1d8>
			 {
                break;
            }
            status = AJ_UnmarshalVariant(msg, (const char**)&sig);
    db88:	1c30      	adds	r0, r6, #0
    db8a:	a904      	add	r1, sp, #16
    db8c:	4b62      	ldr	r3, [pc, #392]	; (dd18 <AJCFG_UpdateConfigurationsHandler+0x204>)
    db8e:	4798      	blx	r3
    db90:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    db92:	d000      	beq.n	db96 <AJCFG_UpdateConfigurationsHandler+0x82>
    db94:	e0aa      	b.n	dcec <AJCFG_UpdateConfigurationsHandler+0x1d8>
			{
                break;
            }
            status = AJ_UnmarshalArgs(msg, sig, &value);
    db96:	1c30      	adds	r0, r6, #0
    db98:	9904      	ldr	r1, [sp, #16]
    db9a:	aa03      	add	r2, sp, #12
    db9c:	4b5b      	ldr	r3, [pc, #364]	; (dd0c <AJCFG_UpdateConfigurationsHandler+0x1f8>)
    db9e:	4798      	blx	r3
    dba0:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    dba2:	d000      	beq.n	dba6 <AJCFG_UpdateConfigurationsHandler+0x92>
    dba4:	e0a2      	b.n	dcec <AJCFG_UpdateConfigurationsHandler+0x1d8>
			{
                break;
            }
         //   AJ_InfoPrintf(("key=%s value=%s\n", key, value));
            if (IsValueValid(msg, &reply, key, value)) 
    dba6:	9c05      	ldr	r4, [sp, #20]
    dba8:	9f03      	ldr	r7, [sp, #12]
    return status;
}

static uint8_t IsValueValid(AJ_Message* msg, AJ_Message* reply, const char* key, const char* value)
{
    if (strcmp(AJSVC_PropertyStore_GetFieldName(AJSVC_PROPERTY_STORE_DEFAULT_LANGUAGE), key) == 0)
    dbaa:	2003      	movs	r0, #3
    dbac:	4b5b      	ldr	r3, [pc, #364]	; (dd1c <AJCFG_UpdateConfigurationsHandler+0x208>)
    dbae:	4798      	blx	r3
    dbb0:	1c21      	adds	r1, r4, #0
    dbb2:	4b5b      	ldr	r3, [pc, #364]	; (dd20 <AJCFG_UpdateConfigurationsHandler+0x20c>)
    dbb4:	4798      	blx	r3
    dbb6:	2800      	cmp	r0, #0
    dbb8:	d112      	bne.n	dbe0 <AJCFG_UpdateConfigurationsHandler+0xcc>
	 { // Check that if language was updated that it is supported
        if (strlen(value) > 0) 
    dbba:	783b      	ldrb	r3, [r7, #0]
    dbbc:	2b00      	cmp	r3, #0
    dbbe:	d009      	beq.n	dbd4 <AJCFG_UpdateConfigurationsHandler+0xc0>
		{                                                   // that it is not empty
            return AJSVC_IsLanguageSupported(msg, reply, value, NULL);
    dbc0:	1c30      	adds	r0, r6, #0
    dbc2:	a906      	add	r1, sp, #24
    dbc4:	1c3a      	adds	r2, r7, #0
    dbc6:	2300      	movs	r3, #0
    dbc8:	4c51      	ldr	r4, [pc, #324]	; (dd10 <AJCFG_UpdateConfigurationsHandler+0x1fc>)
    dbca:	47a0      	blx	r4
            if (status != AJ_OK) 
			{
                break;
            }
         //   AJ_InfoPrintf(("key=%s value=%s\n", key, value));
            if (IsValueValid(msg, &reply, key, value)) 
    dbcc:	2800      	cmp	r0, #0
    dbce:	d141      	bne.n	dc54 <AJCFG_UpdateConfigurationsHandler+0x140>
                    }
                }
            } 
			else
			 {
                errorReply = TRUE;
    dbd0:	2501      	movs	r5, #1
    dbd2:	e062      	b.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
		{                                                   // that it is not empty
            return AJSVC_IsLanguageSupported(msg, reply, value, NULL);
        }
		 else 
		 {
            AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_LANGUAGE_NOT_SUPPORTED);
    dbd4:	1c30      	adds	r0, r6, #0
    dbd6:	a906      	add	r1, sp, #24
    dbd8:	4a52      	ldr	r2, [pc, #328]	; (dd24 <AJCFG_UpdateConfigurationsHandler+0x210>)
    dbda:	4b53      	ldr	r3, [pc, #332]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dbdc:	4798      	blx	r3
    dbde:	e083      	b.n	dce8 <AJCFG_UpdateConfigurationsHandler+0x1d4>
        }
    } 
	else if (strcmp(AJSVC_PropertyStore_GetFieldName(AJSVC_PROPERTY_STORE_DEVICE_NAME), key) == 0)
    dbe0:	2002      	movs	r0, #2
    dbe2:	4b4e      	ldr	r3, [pc, #312]	; (dd1c <AJCFG_UpdateConfigurationsHandler+0x208>)
    dbe4:	4798      	blx	r3
    dbe6:	1c21      	adds	r1, r4, #0
    dbe8:	4b4d      	ldr	r3, [pc, #308]	; (dd20 <AJCFG_UpdateConfigurationsHandler+0x20c>)
    dbea:	4798      	blx	r3
    dbec:	2800      	cmp	r0, #0
    dbee:	d117      	bne.n	dc20 <AJCFG_UpdateConfigurationsHandler+0x10c>
	 { // Check that if device name was updated
        if (strlen(value) <= AJSVC_PropertyStore_GetMaxValueLength(AJSVC_PROPERTY_STORE_DEVICE_NAME)) {        // that it does not exceed maximum length
    dbf0:	1c38      	adds	r0, r7, #0
    dbf2:	4b4e      	ldr	r3, [pc, #312]	; (dd2c <AJCFG_UpdateConfigurationsHandler+0x218>)
    dbf4:	4798      	blx	r3
    dbf6:	1c04      	adds	r4, r0, #0
    dbf8:	2002      	movs	r0, #2
    dbfa:	4b4d      	ldr	r3, [pc, #308]	; (dd30 <AJCFG_UpdateConfigurationsHandler+0x21c>)
    dbfc:	4798      	blx	r3
    dbfe:	4284      	cmp	r4, r0
    dc00:	d808      	bhi.n	dc14 <AJCFG_UpdateConfigurationsHandler+0x100>
            if (strlen(value) > 0)
    dc02:	783b      	ldrb	r3, [r7, #0]
    dc04:	2b00      	cmp	r3, #0
    dc06:	d125      	bne.n	dc54 <AJCFG_UpdateConfigurationsHandler+0x140>
			 {                                               // that it is not empty
                return TRUE;
            } 
			else 
			{
                AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_INVALID_VALUE);
    dc08:	1c30      	adds	r0, r6, #0
    dc0a:	a906      	add	r1, sp, #24
    dc0c:	4a49      	ldr	r2, [pc, #292]	; (dd34 <AJCFG_UpdateConfigurationsHandler+0x220>)
    dc0e:	4b46      	ldr	r3, [pc, #280]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc10:	4798      	blx	r3
    dc12:	e069      	b.n	dce8 <AJCFG_UpdateConfigurationsHandler+0x1d4>
            }
        } 
		else 
		{
            AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_MAX_SIZE_EXCEEDED);
    dc14:	1c30      	adds	r0, r6, #0
    dc16:	a906      	add	r1, sp, #24
    dc18:	4a47      	ldr	r2, [pc, #284]	; (dd38 <AJCFG_UpdateConfigurationsHandler+0x224>)
    dc1a:	4b43      	ldr	r3, [pc, #268]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc1c:	4798      	blx	r3
    dc1e:	e063      	b.n	dce8 <AJCFG_UpdateConfigurationsHandler+0x1d4>
        }
    } 
	else if (AJSVC_PropertyStore_GetFieldIndex(key) == AJSVC_PROPERTY_STORE_ERROR_FIELD_INDEX)
    dc20:	1c20      	adds	r0, r4, #0
    dc22:	4b46      	ldr	r3, [pc, #280]	; (dd3c <AJCFG_UpdateConfigurationsHandler+0x228>)
    dc24:	4798      	blx	r3
    dc26:	1c43      	adds	r3, r0, #1
    dc28:	d105      	bne.n	dc36 <AJCFG_UpdateConfigurationsHandler+0x122>
	 { // Check that the key exists
        AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_INVALID_VALUE);
    dc2a:	1c30      	adds	r0, r6, #0
    dc2c:	a906      	add	r1, sp, #24
    dc2e:	4a41      	ldr	r2, [pc, #260]	; (dd34 <AJCFG_UpdateConfigurationsHandler+0x220>)
    dc30:	4b3d      	ldr	r3, [pc, #244]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc32:	4798      	blx	r3
    dc34:	e058      	b.n	dce8 <AJCFG_UpdateConfigurationsHandler+0x1d4>
    }
	 else 
	 {
        if (AppIsValueValid == NULL || (AppIsValueValid)(key, value))
    dc36:	4b42      	ldr	r3, [pc, #264]	; (dd40 <AJCFG_UpdateConfigurationsHandler+0x22c>)
    dc38:	681b      	ldr	r3, [r3, #0]
    dc3a:	2b00      	cmp	r3, #0
    dc3c:	d00a      	beq.n	dc54 <AJCFG_UpdateConfigurationsHandler+0x140>
    dc3e:	1c20      	adds	r0, r4, #0
    dc40:	1c39      	adds	r1, r7, #0
    dc42:	4798      	blx	r3
    dc44:	2800      	cmp	r0, #0
    dc46:	d105      	bne.n	dc54 <AJCFG_UpdateConfigurationsHandler+0x140>
		 {
            return TRUE;
        }
        AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_INVALID_VALUE);
    dc48:	1c30      	adds	r0, r6, #0
    dc4a:	a906      	add	r1, sp, #24
    dc4c:	4a39      	ldr	r2, [pc, #228]	; (dd34 <AJCFG_UpdateConfigurationsHandler+0x220>)
    dc4e:	4b36      	ldr	r3, [pc, #216]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc50:	4798      	blx	r3
    dc52:	e049      	b.n	dce8 <AJCFG_UpdateConfigurationsHandler+0x1d4>
                break;
            }
         //   AJ_InfoPrintf(("key=%s value=%s\n", key, value));
            if (IsValueValid(msg, &reply, key, value)) 
			{
                status = AJSVC_PropertyStore_Update(key, langIndex, value);
    dc54:	466b      	mov	r3, sp
    dc56:	2107      	movs	r1, #7
    dc58:	5659      	ldrsb	r1, [r3, r1]
    dc5a:	9805      	ldr	r0, [sp, #20]
    dc5c:	9a03      	ldr	r2, [sp, #12]
    dc5e:	4b39      	ldr	r3, [pc, #228]	; (dd44 <AJCFG_UpdateConfigurationsHandler+0x230>)
    dc60:	4798      	blx	r3
                if (status == AJ_OK) 
    dc62:	2800      	cmp	r0, #0
    dc64:	d104      	bne.n	dc70 <AJCFG_UpdateConfigurationsHandler+0x15c>
				{
                    numOfUpdatedItems++;
    dc66:	4643      	mov	r3, r8
    dc68:	3301      	adds	r3, #1
    dc6a:	b2db      	uxtb	r3, r3
    dc6c:	4698      	mov	r8, r3
    dc6e:	e014      	b.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
                } 
				else if (status == AJ_ERR_INVALID)
    dc70:	2803      	cmp	r0, #3
    dc72:	d108      	bne.n	dc86 <AJCFG_UpdateConfigurationsHandler+0x172>
				 {
                    if (!errorReply)
    dc74:	2d00      	cmp	r5, #0
    dc76:	d110      	bne.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
					 {
                        AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_INVALID_VALUE);
    dc78:	1c30      	adds	r0, r6, #0
    dc7a:	a906      	add	r1, sp, #24
    dc7c:	4a2d      	ldr	r2, [pc, #180]	; (dd34 <AJCFG_UpdateConfigurationsHandler+0x220>)
    dc7e:	4b2a      	ldr	r3, [pc, #168]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc80:	4798      	blx	r3
                        errorReply = TRUE;
    dc82:	3501      	adds	r5, #1
    dc84:	e009      	b.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
                    }
                }
				 else if (status == AJ_ERR_FAILURE) 
    dc86:	2813      	cmp	r0, #19
    dc88:	d107      	bne.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
				 {
                    if (!errorReply)
    dc8a:	2d00      	cmp	r5, #0
    dc8c:	d105      	bne.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
					 {
                        AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_UPDATE_NOT_ALLOWED);
    dc8e:	1c30      	adds	r0, r6, #0
    dc90:	a906      	add	r1, sp, #24
    dc92:	4a2d      	ldr	r2, [pc, #180]	; (dd48 <AJCFG_UpdateConfigurationsHandler+0x234>)
    dc94:	4b24      	ldr	r3, [pc, #144]	; (dd28 <AJCFG_UpdateConfigurationsHandler+0x214>)
    dc96:	4798      	blx	r3
                        errorReply = TRUE;
    dc98:	3501      	adds	r5, #1
            } 
			else
			 {
                errorReply = TRUE;
            }
            status = AJ_UnmarshalCloseContainer(msg, &dict);
    dc9a:	1c30      	adds	r0, r6, #0
    dc9c:	a916      	add	r1, sp, #88	; 0x58
    dc9e:	4b2b      	ldr	r3, [pc, #172]	; (dd4c <AJCFG_UpdateConfigurationsHandler+0x238>)
    dca0:	4798      	blx	r3
    dca2:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    dca4:	d100      	bne.n	dca8 <AJCFG_UpdateConfigurationsHandler+0x194>
    dca6:	e761      	b.n	db6c <AJCFG_UpdateConfigurationsHandler+0x58>
    dca8:	e020      	b.n	dcec <AJCFG_UpdateConfigurationsHandler+0x1d8>
        }
        if (status != AJ_OK && status != AJ_ERR_NO_MORE) 
		{
            goto Exit;
        }
        status = AJ_UnmarshalCloseContainer(msg, &array);
    dcaa:	1c30      	adds	r0, r6, #0
    dcac:	a91a      	add	r1, sp, #104	; 0x68
    dcae:	4b27      	ldr	r3, [pc, #156]	; (dd4c <AJCFG_UpdateConfigurationsHandler+0x238>)
    dcb0:	4798      	blx	r3
    dcb2:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    dcb4:	d10b      	bne.n	dcce <AJCFG_UpdateConfigurationsHandler+0x1ba>
		{
            goto Exit;
        }
    }
    if (!errorReply) 
    dcb6:	2d00      	cmp	r5, #0
    dcb8:	d105      	bne.n	dcc6 <AJCFG_UpdateConfigurationsHandler+0x1b2>
	{
        status = AJ_MarshalReplyMsg(msg, &reply);
    dcba:	1c30      	adds	r0, r6, #0
    dcbc:	a906      	add	r1, sp, #24
    dcbe:	4b24      	ldr	r3, [pc, #144]	; (dd50 <AJCFG_UpdateConfigurationsHandler+0x23c>)
    dcc0:	4798      	blx	r3
    dcc2:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    dcc4:	d115      	bne.n	dcf2 <AJCFG_UpdateConfigurationsHandler+0x1de>
		{
            goto Exit;
        }
    }
    status = AJ_DeliverMsg(&reply);
    dcc6:	a806      	add	r0, sp, #24
    dcc8:	4b22      	ldr	r3, [pc, #136]	; (dd54 <AJCFG_UpdateConfigurationsHandler+0x240>)
    dcca:	4798      	blx	r3
    dccc:	1c04      	adds	r4, r0, #0
        goto Exit;
    }

Exit:

    if (numOfUpdatedItems)
    dcce:	4643      	mov	r3, r8
    dcd0:	2b00      	cmp	r3, #0
    dcd2:	d011      	beq.n	dcf8 <AJCFG_UpdateConfigurationsHandler+0x1e4>
	 {
        if (errorReply) 
    dcd4:	2d00      	cmp	r5, #0
    dcd6:	d002      	beq.n	dcde <AJCFG_UpdateConfigurationsHandler+0x1ca>
		{
            AJSVC_PropertyStore_LoadAll(); // Discard partial successful updates
    dcd8:	4b1f      	ldr	r3, [pc, #124]	; (dd58 <AJCFG_UpdateConfigurationsHandler+0x244>)
    dcda:	4798      	blx	r3
    dcdc:	e00c      	b.n	dcf8 <AJCFG_UpdateConfigurationsHandler+0x1e4>
        }
		 else
		  {
            AJSVC_PropertyStore_SaveAll();
    dcde:	4b1f      	ldr	r3, [pc, #124]	; (dd5c <AJCFG_UpdateConfigurationsHandler+0x248>)
    dce0:	4798      	blx	r3
            AJ_AboutSetShouldAnnounce();
    dce2:	4b1f      	ldr	r3, [pc, #124]	; (dd60 <AJCFG_UpdateConfigurationsHandler+0x24c>)
    dce4:	4798      	blx	r3
    dce6:	e007      	b.n	dcf8 <AJCFG_UpdateConfigurationsHandler+0x1e4>
                    }
                }
            } 
			else
			 {
                errorReply = TRUE;
    dce8:	2501      	movs	r5, #1
    dcea:	e7d6      	b.n	dc9a <AJCFG_UpdateConfigurationsHandler+0x186>
            if (status != AJ_OK) 
			{
                break;
            }
        }
        if (status != AJ_OK && status != AJ_ERR_NO_MORE) 
    dcec:	2c0c      	cmp	r4, #12
    dcee:	d1ee      	bne.n	dcce <AJCFG_UpdateConfigurationsHandler+0x1ba>
    dcf0:	e7db      	b.n	dcaa <AJCFG_UpdateConfigurationsHandler+0x196>
        goto Exit;
    }

Exit:

    if (numOfUpdatedItems)
    dcf2:	4643      	mov	r3, r8
    dcf4:	2b00      	cmp	r3, #0
    dcf6:	d1f2      	bne.n	dcde <AJCFG_UpdateConfigurationsHandler+0x1ca>
            AJ_AboutSetShouldAnnounce();
        }
    }

    return status;
}
    dcf8:	1c20      	adds	r0, r4, #0
    dcfa:	b01e      	add	sp, #120	; 0x78
    dcfc:	bc1c      	pop	{r2, r3, r4}
    dcfe:	4690      	mov	r8, r2
    dd00:	4699      	mov	r9, r3
    dd02:	46a2      	mov	sl, r4
    dd04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dd06:	46c0      	nop			; (mov r8, r8)
    dd08:	0001f054 	.word	0x0001f054
    dd0c:	0000b5f5 	.word	0x0000b5f5
    dd10:	0000ebc5 	.word	0x0000ebc5
    dd14:	0000a951 	.word	0x0000a951
    dd18:	0000b319 	.word	0x0000b319
    dd1c:	00000d79 	.word	0x00000d79
    dd20:	00017137 	.word	0x00017137
    dd24:	0001eadc 	.word	0x0001eadc
    dd28:	0000be55 	.word	0x0000be55
    dd2c:	0001715b 	.word	0x0001715b
    dd30:	00000d59 	.word	0x00000d59
    dd34:	0001ebd0 	.word	0x0001ebd0
    dd38:	0001e730 	.word	0x0001e730
    dd3c:	00000d95 	.word	0x00000d95
    dd40:	20001268 	.word	0x20001268
    dd44:	000013cd 	.word	0x000013cd
    dd48:	0001eb4c 	.word	0x0001eb4c
    dd4c:	0000a9d9 	.word	0x0000a9d9
    dd50:	0000bd45 	.word	0x0000bd45
    dd54:	0000a539 	.word	0x0000a539
    dd58:	00000fbd 	.word	0x00000fbd
    dd5c:	00000fe9 	.word	0x00000fe9
    dd60:	00001965 	.word	0x00001965

0000dd64 <AJCFG_ResetConfigurationsHandler>:

AJ_Status AJCFG_ResetConfigurationsHandler(AJ_Message* msg)
{
    dd64:	b5f0      	push	{r4, r5, r6, r7, lr}
    dd66:	464f      	mov	r7, r9
    dd68:	4646      	mov	r6, r8
    dd6a:	b4c0      	push	{r6, r7}
    dd6c:	b099      	sub	sp, #100	; 0x64
    dd6e:	1c05      	adds	r5, r0, #0
    AJ_Status status = AJ_OK;
    AJ_Arg array;
    AJ_Message reply;
    char* key;
    char* language;
    int8_t langIndex = AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
    dd70:	22ff      	movs	r2, #255	; 0xff
    dd72:	466b      	mov	r3, sp
    dd74:	71da      	strb	r2, [r3, #7]
    uint8_t numOfDeletedItems = 0;
    uint8_t errorReply = FALSE;

 //   AJ_InfoPrintf(("Handling ResetConfigurations request\n"));

    status = AJ_UnmarshalArgs(msg, "s", &language);
    dd76:	493b      	ldr	r1, [pc, #236]	; (de64 <AJCFG_ResetConfigurationsHandler+0x100>)
    dd78:	aa02      	add	r2, sp, #8
    dd7a:	4b3b      	ldr	r3, [pc, #236]	; (de68 <AJCFG_ResetConfigurationsHandler+0x104>)
    dd7c:	4798      	blx	r3
    dd7e:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    dd80:	d16a      	bne.n	de58 <AJCFG_ResetConfigurationsHandler+0xf4>
	{
        goto Exit;
    }
   // AJ_InfoPrintf(("Lang=%s\n", language));
    errorReply = !AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex);
    dd82:	1c28      	adds	r0, r5, #0
    dd84:	a904      	add	r1, sp, #16
    dd86:	9a02      	ldr	r2, [sp, #8]
    dd88:	466b      	mov	r3, sp
    dd8a:	3307      	adds	r3, #7
    dd8c:	4c37      	ldr	r4, [pc, #220]	; (de6c <AJCFG_ResetConfigurationsHandler+0x108>)
    dd8e:	47a0      	blx	r4
    dd90:	4246      	negs	r6, r0
    dd92:	4146      	adcs	r6, r0
    dd94:	b2f6      	uxtb	r6, r6
    AJ_Arg array;
    AJ_Message reply;
    char* key;
    char* language;
    int8_t langIndex = AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX;
    uint8_t numOfDeletedItems = 0;
    dd96:	2700      	movs	r7, #0
	{
        goto Exit;
    }
   // AJ_InfoPrintf(("Lang=%s\n", language));
    errorReply = !AJSVC_IsLanguageSupported(msg, &reply, language, &langIndex);
    if (!errorReply) 
    dd98:	2e00      	cmp	r6, #0
    dd9a:	d147      	bne.n	de2c <AJCFG_ResetConfigurationsHandler+0xc8>
	{
        status = AJ_UnmarshalContainer(msg, &array, AJ_ARG_ARRAY);
    dd9c:	1c28      	adds	r0, r5, #0
    dd9e:	a914      	add	r1, sp, #80	; 0x50
    dda0:	2261      	movs	r2, #97	; 0x61
    dda2:	4b33      	ldr	r3, [pc, #204]	; (de70 <AJCFG_ResetConfigurationsHandler+0x10c>)
    dda4:	4798      	blx	r3
    dda6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    dda8:	d156      	bne.n	de58 <AJCFG_ResetConfigurationsHandler+0xf4>
    ddaa:	46b1      	mov	r9, r6
		 {
            goto Exit;
        }
        while (1) {
            status = AJ_UnmarshalArgs(msg, "s", &key);
    ddac:	4b2e      	ldr	r3, [pc, #184]	; (de68 <AJCFG_ResetConfigurationsHandler+0x104>)
    ddae:	4698      	mov	r8, r3
            if (status != AJ_OK) 
			{
                break;
            }
         //   AJ_InfoPrintf(("Key=%s\n", key));
            status = AJSVC_PropertyStore_Reset(key, langIndex);
    ddb0:	4e30      	ldr	r6, [pc, #192]	; (de74 <AJCFG_ResetConfigurationsHandler+0x110>)
        if (status != AJ_OK)
		 {
            goto Exit;
        }
        while (1) {
            status = AJ_UnmarshalArgs(msg, "s", &key);
    ddb2:	1c28      	adds	r0, r5, #0
    ddb4:	492b      	ldr	r1, [pc, #172]	; (de64 <AJCFG_ResetConfigurationsHandler+0x100>)
    ddb6:	aa03      	add	r2, sp, #12
    ddb8:	47c0      	blx	r8
    ddba:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    ddbc:	d123      	bne.n	de06 <AJCFG_ResetConfigurationsHandler+0xa2>
			{
                break;
            }
         //   AJ_InfoPrintf(("Key=%s\n", key));
            status = AJSVC_PropertyStore_Reset(key, langIndex);
    ddbe:	466b      	mov	r3, sp
    ddc0:	2107      	movs	r1, #7
    ddc2:	5659      	ldrsb	r1, [r3, r1]
    ddc4:	9803      	ldr	r0, [sp, #12]
    ddc6:	47b0      	blx	r6
            if (status == AJ_OK) 
    ddc8:	2800      	cmp	r0, #0
    ddca:	d102      	bne.n	ddd2 <AJCFG_ResetConfigurationsHandler+0x6e>
			{
                numOfDeletedItems++;
    ddcc:	3701      	adds	r7, #1
    ddce:	b2ff      	uxtb	r7, r7
    ddd0:	e7ef      	b.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
            }
			 else if (status == AJ_ERR_INVALID)
    ddd2:	2803      	cmp	r0, #3
    ddd4:	d10a      	bne.n	ddec <AJCFG_ResetConfigurationsHandler+0x88>
			  {
                if (!errorReply) 
    ddd6:	464b      	mov	r3, r9
    ddd8:	2b00      	cmp	r3, #0
    ddda:	d1ea      	bne.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
				{
                    AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_INVALID_VALUE);
    dddc:	1c28      	adds	r0, r5, #0
    ddde:	a904      	add	r1, sp, #16
    dde0:	4a25      	ldr	r2, [pc, #148]	; (de78 <AJCFG_ResetConfigurationsHandler+0x114>)
    dde2:	4b26      	ldr	r3, [pc, #152]	; (de7c <AJCFG_ResetConfigurationsHandler+0x118>)
    dde4:	4798      	blx	r3
                    errorReply = TRUE;
    dde6:	2301      	movs	r3, #1
    dde8:	4699      	mov	r9, r3
    ddea:	e7e2      	b.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
                }
            }
			 else if (status == AJ_ERR_FAILURE) 
    ddec:	2813      	cmp	r0, #19
    ddee:	d1e0      	bne.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
			 {
                if (!errorReply) 
    ddf0:	464b      	mov	r3, r9
    ddf2:	2b00      	cmp	r3, #0
    ddf4:	d1dd      	bne.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
				{
                    AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_UPDATE_NOT_ALLOWED);
    ddf6:	1c28      	adds	r0, r5, #0
    ddf8:	a904      	add	r1, sp, #16
    ddfa:	4a21      	ldr	r2, [pc, #132]	; (de80 <AJCFG_ResetConfigurationsHandler+0x11c>)
    ddfc:	4b1f      	ldr	r3, [pc, #124]	; (de7c <AJCFG_ResetConfigurationsHandler+0x118>)
    ddfe:	4798      	blx	r3
                    errorReply = TRUE;
    de00:	2301      	movs	r3, #1
    de02:	4699      	mov	r9, r3
    de04:	e7d5      	b.n	ddb2 <AJCFG_ResetConfigurationsHandler+0x4e>
    de06:	464e      	mov	r6, r9
                }
            }
        }
        if (status != AJ_OK && status != AJ_ERR_NO_MORE) 
    de08:	280c      	cmp	r0, #12
    de0a:	d114      	bne.n	de36 <AJCFG_ResetConfigurationsHandler+0xd2>
		{
            goto Exit;
        }
        status = AJ_UnmarshalCloseContainer(msg, &array);
    de0c:	1c28      	adds	r0, r5, #0
    de0e:	a914      	add	r1, sp, #80	; 0x50
    de10:	4b1c      	ldr	r3, [pc, #112]	; (de84 <AJCFG_ResetConfigurationsHandler+0x120>)
    de12:	4798      	blx	r3
    de14:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    de16:	d110      	bne.n	de3a <AJCFG_ResetConfigurationsHandler+0xd6>
		 {
            goto Exit;
        }
    }
    if (!errorReply) 
    de18:	2e00      	cmp	r6, #0
    de1a:	d106      	bne.n	de2a <AJCFG_ResetConfigurationsHandler+0xc6>
	{
        status = AJ_MarshalReplyMsg(msg, &reply);
    de1c:	1c28      	adds	r0, r5, #0
    de1e:	a904      	add	r1, sp, #16
    de20:	4b19      	ldr	r3, [pc, #100]	; (de88 <AJCFG_ResetConfigurationsHandler+0x124>)
    de22:	4798      	blx	r3
    de24:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    de26:	d115      	bne.n	de54 <AJCFG_ResetConfigurationsHandler+0xf0>
    de28:	e000      	b.n	de2c <AJCFG_ResetConfigurationsHandler+0xc8>
    de2a:	464e      	mov	r6, r9
		 {
            goto Exit;
        }
    }
    status = AJ_DeliverMsg(&reply);
    de2c:	a804      	add	r0, sp, #16
    de2e:	4b17      	ldr	r3, [pc, #92]	; (de8c <AJCFG_ResetConfigurationsHandler+0x128>)
    de30:	4798      	blx	r3
    de32:	1c04      	adds	r4, r0, #0
    de34:	e002      	b.n	de3c <AJCFG_ResetConfigurationsHandler+0xd8>
    de36:	464e      	mov	r6, r9
    de38:	e000      	b.n	de3c <AJCFG_ResetConfigurationsHandler+0xd8>
    de3a:	464e      	mov	r6, r9
        goto Exit;
    }

Exit:

    if (numOfDeletedItems) 
    de3c:	2f00      	cmp	r7, #0
    de3e:	d00b      	beq.n	de58 <AJCFG_ResetConfigurationsHandler+0xf4>
	{
        if (errorReply)
    de40:	2e00      	cmp	r6, #0
    de42:	d002      	beq.n	de4a <AJCFG_ResetConfigurationsHandler+0xe6>
		 {
            AJSVC_PropertyStore_LoadAll(); // Discard partial successful deletions
    de44:	4b12      	ldr	r3, [pc, #72]	; (de90 <AJCFG_ResetConfigurationsHandler+0x12c>)
    de46:	4798      	blx	r3
    de48:	e006      	b.n	de58 <AJCFG_ResetConfigurationsHandler+0xf4>
        } 
		else
		 {
            AJSVC_PropertyStore_SaveAll();
    de4a:	4b12      	ldr	r3, [pc, #72]	; (de94 <AJCFG_ResetConfigurationsHandler+0x130>)
    de4c:	4798      	blx	r3
            AJ_AboutSetShouldAnnounce();
    de4e:	4b12      	ldr	r3, [pc, #72]	; (de98 <AJCFG_ResetConfigurationsHandler+0x134>)
    de50:	4798      	blx	r3
    de52:	e001      	b.n	de58 <AJCFG_ResetConfigurationsHandler+0xf4>
        goto Exit;
    }

Exit:

    if (numOfDeletedItems) 
    de54:	2f00      	cmp	r7, #0
    de56:	d1f8      	bne.n	de4a <AJCFG_ResetConfigurationsHandler+0xe6>
            AJ_AboutSetShouldAnnounce();
        }
    }

    return status;
}
    de58:	1c20      	adds	r0, r4, #0
    de5a:	b019      	add	sp, #100	; 0x64
    de5c:	bc0c      	pop	{r2, r3}
    de5e:	4690      	mov	r8, r2
    de60:	4699      	mov	r9, r3
    de62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    de64:	0001f054 	.word	0x0001f054
    de68:	0000b5f5 	.word	0x0000b5f5
    de6c:	0000ebc5 	.word	0x0000ebc5
    de70:	0000a951 	.word	0x0000a951
    de74:	000013fd 	.word	0x000013fd
    de78:	0001ebd0 	.word	0x0001ebd0
    de7c:	0000be55 	.word	0x0000be55
    de80:	0001eb4c 	.word	0x0001eb4c
    de84:	0000a9d9 	.word	0x0000a9d9
    de88:	0000bd45 	.word	0x0000bd45
    de8c:	0000a539 	.word	0x0000a539
    de90:	00000fbd 	.word	0x00000fbd
    de94:	00000fe9 	.word	0x00000fe9
    de98:	00001965 	.word	0x00001965

0000de9c <AJCFG_SetPasscodeHandler>:

AJ_Status AJCFG_SetPasscodeHandler(AJ_Message* msg)
{
    de9c:	b530      	push	{r4, r5, lr}
    de9e:	b097      	sub	sp, #92	; 0x5c
    dea0:	1c04      	adds	r4, r0, #0
    uint8_t forceRoutingNodeDisconnect = FALSE;
    uint8_t errorReply = FALSE;

   // AJ_InfoPrintf(("Handling SetPasscode request\n"));

    status = AJ_UnmarshalArgs(msg, "s", &daemonRealm);
    dea2:	4923      	ldr	r1, [pc, #140]	; (df30 <AJCFG_SetPasscodeHandler+0x94>)
    dea4:	aa15      	add	r2, sp, #84	; 0x54
    dea6:	4b23      	ldr	r3, [pc, #140]	; (df34 <AJCFG_SetPasscodeHandler+0x98>)
    dea8:	4798      	blx	r3
    deaa:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    deac:	d13d      	bne.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
	{
        return status;
    }
  //  AJ_InfoPrintf(("Realm=%s\n", daemonRealm));
    status = AJ_UnmarshalArg(msg, &newPasscode);
    deae:	1c20      	adds	r0, r4, #0
    deb0:	a911      	add	r1, sp, #68	; 0x44
    deb2:	4b21      	ldr	r3, [pc, #132]	; (df38 <AJCFG_SetPasscodeHandler+0x9c>)
    deb4:	4798      	blx	r3
    deb6:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK)
    deb8:	d137      	bne.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
	 {
        return status;
    }
  //  AJ_InfoPrintf(("Passcode=%d bytes long\n", newPasscode.len));
    if (newPasscode.len > 0) 
    deba:	ab11      	add	r3, sp, #68	; 0x44
    debc:	885a      	ldrh	r2, [r3, #2]
    debe:	2a00      	cmp	r2, #0
    dec0:	d013      	beq.n	deea <AJCFG_SetPasscodeHandler+0x4e>
	{ // Check passcode is not empty
        if (AppSetPasscode)
    dec2:	4b1e      	ldr	r3, [pc, #120]	; (df3c <AJCFG_SetPasscodeHandler+0xa0>)
    dec4:	681b      	ldr	r3, [r3, #0]
    dec6:	2b00      	cmp	r3, #0
    dec8:	d017      	beq.n	defa <AJCFG_SetPasscodeHandler+0x5e>
		 {
            status = (AppSetPasscode)(daemonRealm, (const uint8_t*)newPasscode.val.v_string, (uint8_t)newPasscode.len);
    deca:	b2d2      	uxtb	r2, r2
    decc:	9815      	ldr	r0, [sp, #84]	; 0x54
    dece:	9912      	ldr	r1, [sp, #72]	; 0x48
    ded0:	4798      	blx	r3
            if (status == AJ_ERR_RESOURCES)
    ded2:	280b      	cmp	r0, #11
    ded4:	d121      	bne.n	df1a <AJCFG_SetPasscodeHandler+0x7e>
			 { // Check passcode is too long to persist
                status = AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_MAX_SIZE_EXCEEDED);
    ded6:	1c20      	adds	r0, r4, #0
    ded8:	a901      	add	r1, sp, #4
    deda:	4a19      	ldr	r2, [pc, #100]	; (df40 <AJCFG_SetPasscodeHandler+0xa4>)
    dedc:	4b19      	ldr	r3, [pc, #100]	; (df44 <AJCFG_SetPasscodeHandler+0xa8>)
    dede:	4798      	blx	r3
    dee0:	1c03      	adds	r3, r0, #0
				 {
                    return status;
                }
                errorReply = TRUE;
            }
            forceRoutingNodeDisconnect = (status == AJ_ERR_READ);
    dee2:	2500      	movs	r5, #0
		 {
            status = (AppSetPasscode)(daemonRealm, (const uint8_t*)newPasscode.val.v_string, (uint8_t)newPasscode.len);
            if (status == AJ_ERR_RESOURCES)
			 { // Check passcode is too long to persist
                status = AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_MAX_SIZE_EXCEEDED);
                if (status != AJ_OK)
    dee4:	2b00      	cmp	r3, #0
    dee6:	d00f      	beq.n	df08 <AJCFG_SetPasscodeHandler+0x6c>
    dee8:	e01f      	b.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
        }
    } 
	else 
	{
     //   AJ_ErrPrintf(("Error - newPasscode cannot be empty!\n"));
        status = AJ_MarshalErrorMsg(msg, &reply, AJSVC_ERROR_INVALID_VALUE);
    deea:	1c20      	adds	r0, r4, #0
    deec:	a901      	add	r1, sp, #4
    deee:	4a16      	ldr	r2, [pc, #88]	; (df48 <AJCFG_SetPasscodeHandler+0xac>)
    def0:	4b14      	ldr	r3, [pc, #80]	; (df44 <AJCFG_SetPasscodeHandler+0xa8>)
    def2:	4798      	blx	r3
    def4:	1e03      	subs	r3, r0, #0
        if (status != AJ_OK)
    def6:	d015      	beq.n	df24 <AJCFG_SetPasscodeHandler+0x88>
    def8:	e017      	b.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
{
    AJ_Status status = AJ_OK;
    char* daemonRealm;
    AJ_Arg newPasscode;
    AJ_Message reply;
    uint8_t forceRoutingNodeDisconnect = FALSE;
    defa:	2500      	movs	r5, #0
        }
        errorReply = TRUE;
    }
    if (!errorReply)
	 {
        status = AJ_MarshalReplyMsg(msg, &reply);
    defc:	1c20      	adds	r0, r4, #0
    defe:	a901      	add	r1, sp, #4
    df00:	4b12      	ldr	r3, [pc, #72]	; (df4c <AJCFG_SetPasscodeHandler+0xb0>)
    df02:	4798      	blx	r3
    df04:	1e03      	subs	r3, r0, #0
        if (status != AJ_OK) 
    df06:	d110      	bne.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
		{
            return status;
        }
    }
    status = AJ_DeliverMsg(&reply);
    df08:	a801      	add	r0, sp, #4
    df0a:	4b11      	ldr	r3, [pc, #68]	; (df50 <AJCFG_SetPasscodeHandler+0xb4>)
    df0c:	4798      	blx	r3
    df0e:	1c03      	adds	r3, r0, #0

    if (forceRoutingNodeDisconnect)
	 {
        return AJ_ERR_READ;
    df10:	2005      	movs	r0, #5
            return status;
        }
    }
    status = AJ_DeliverMsg(&reply);

    if (forceRoutingNodeDisconnect)
    df12:	2d00      	cmp	r5, #0
    df14:	d109      	bne.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
        if (status != AJ_OK) 
		{
            return status;
        }
    }
    status = AJ_DeliverMsg(&reply);
    df16:	1c18      	adds	r0, r3, #0
    df18:	e007      	b.n	df2a <AJCFG_SetPasscodeHandler+0x8e>
				 {
                    return status;
                }
                errorReply = TRUE;
            }
            forceRoutingNodeDisconnect = (status == AJ_ERR_READ);
    df1a:	1f45      	subs	r5, r0, #5
    df1c:	4268      	negs	r0, r5
    df1e:	4145      	adcs	r5, r0
    df20:	b2ed      	uxtb	r5, r5
    df22:	e7eb      	b.n	defc <AJCFG_SetPasscodeHandler+0x60>
        if (status != AJ_OK) 
		{
            return status;
        }
    }
    status = AJ_DeliverMsg(&reply);
    df24:	a801      	add	r0, sp, #4
    df26:	4b0a      	ldr	r3, [pc, #40]	; (df50 <AJCFG_SetPasscodeHandler+0xb4>)
    df28:	4798      	blx	r3
    if (forceRoutingNodeDisconnect)
	 {
        return AJ_ERR_READ;
    }
    return status;
}
    df2a:	b017      	add	sp, #92	; 0x5c
    df2c:	bd30      	pop	{r4, r5, pc}
    df2e:	46c0      	nop			; (mov r8, r8)
    df30:	0001f054 	.word	0x0001f054
    df34:	0000b5f5 	.word	0x0000b5f5
    df38:	0000a855 	.word	0x0000a855
    df3c:	20001274 	.word	0x20001274
    df40:	0001e730 	.word	0x0001e730
    df44:	0000be55 	.word	0x0000be55
    df48:	0001ebd0 	.word	0x0001ebd0
    df4c:	0000bd45 	.word	0x0000bd45
    df50:	0000a539 	.word	0x0000a539

0000df54 <AJCFG_MessageProcessor>:
{
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    df54:	b538      	push	{r3, r4, r5, lr}
    df56:	1c0c      	adds	r4, r1, #0
    df58:	1c15      	adds	r5, r2, #0
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;

    switch (msg->msgId)
    df5a:	680b      	ldr	r3, [r1, #0]
    df5c:	4a29      	ldr	r2, [pc, #164]	; (e004 <AJCFG_MessageProcessor+0xb0>)
    df5e:	4293      	cmp	r3, r2
    df60:	d02c      	beq.n	dfbc <AJCFG_MessageProcessor+0x68>
    df62:	d80a      	bhi.n	df7a <AJCFG_MessageProcessor+0x26>
    df64:	4a28      	ldr	r2, [pc, #160]	; (e008 <AJCFG_MessageProcessor+0xb4>)
    df66:	4293      	cmp	r3, r2
    df68:	d01a      	beq.n	dfa0 <AJCFG_MessageProcessor+0x4c>
    df6a:	4a28      	ldr	r2, [pc, #160]	; (e00c <AJCFG_MessageProcessor+0xb8>)
    df6c:	4293      	cmp	r3, r2
    df6e:	d01f      	beq.n	dfb0 <AJCFG_MessageProcessor+0x5c>
    df70:	3a02      	subs	r2, #2
    df72:	3aff      	subs	r2, #255	; 0xff
    df74:	4293      	cmp	r3, r2
    df76:	d142      	bne.n	dffe <AJCFG_MessageProcessor+0xaa>
    df78:	e00a      	b.n	df90 <AJCFG_MessageProcessor+0x3c>
    df7a:	4a25      	ldr	r2, [pc, #148]	; (e010 <AJCFG_MessageProcessor+0xbc>)
    df7c:	4293      	cmp	r3, r2
    df7e:	d032      	beq.n	dfe6 <AJCFG_MessageProcessor+0x92>
    df80:	d322      	bcc.n	dfc8 <AJCFG_MessageProcessor+0x74>
    df82:	4a24      	ldr	r2, [pc, #144]	; (e014 <AJCFG_MessageProcessor+0xc0>)
    df84:	4293      	cmp	r3, r2
    df86:	d028      	beq.n	dfda <AJCFG_MessageProcessor+0x86>
    df88:	4a23      	ldr	r2, [pc, #140]	; (e018 <AJCFG_MessageProcessor+0xc4>)
    df8a:	4293      	cmp	r3, r2
    df8c:	d031      	beq.n	dff2 <AJCFG_MessageProcessor+0x9e>
    df8e:	e036      	b.n	dffe <AJCFG_MessageProcessor+0xaa>
	 {

    case CONFIG_GET_PROP:
        *msgStatus = AJ_BusPropGet(msg, AJCFG_PropGetHandler, NULL);
    df90:	1c08      	adds	r0, r1, #0
    df92:	4922      	ldr	r1, [pc, #136]	; (e01c <AJCFG_MessageProcessor+0xc8>)
    df94:	2200      	movs	r2, #0
    df96:	4b22      	ldr	r3, [pc, #136]	; (e020 <AJCFG_MessageProcessor+0xcc>)
    df98:	4798      	blx	r3
    df9a:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    df9c:	2000      	movs	r0, #0
    switch (msg->msgId)
	 {

    case CONFIG_GET_PROP:
        *msgStatus = AJ_BusPropGet(msg, AJCFG_PropGetHandler, NULL);
        break;
    df9e:	e02f      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_SET_PROP:
        *msgStatus = AJ_BusPropSet(msg, AJCFG_PropSetHandler, NULL);
    dfa0:	1c08      	adds	r0, r1, #0
    dfa2:	4920      	ldr	r1, [pc, #128]	; (e024 <AJCFG_MessageProcessor+0xd0>)
    dfa4:	2200      	movs	r2, #0
    dfa6:	4b20      	ldr	r3, [pc, #128]	; (e028 <AJCFG_MessageProcessor+0xd4>)
    dfa8:	4798      	blx	r3
    dfaa:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfac:	2000      	movs	r0, #0
        *msgStatus = AJ_BusPropGet(msg, AJCFG_PropGetHandler, NULL);
        break;

    case CONFIG_SET_PROP:
        *msgStatus = AJ_BusPropSet(msg, AJCFG_PropSetHandler, NULL);
        break;
    dfae:	e027      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_FACTORY_RESET:
        *msgStatus = AJCFG_FactoryResetHandler(msg);
    dfb0:	1c08      	adds	r0, r1, #0
    dfb2:	4b1e      	ldr	r3, [pc, #120]	; (e02c <AJCFG_MessageProcessor+0xd8>)
    dfb4:	4798      	blx	r3
    dfb6:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfb8:	2000      	movs	r0, #0
        *msgStatus = AJ_BusPropSet(msg, AJCFG_PropSetHandler, NULL);
        break;

    case CONFIG_FACTORY_RESET:
        *msgStatus = AJCFG_FactoryResetHandler(msg);
        break;
    dfba:	e021      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_RESTART:
        *msgStatus = AJCFG_RestartHandler(msg);
    dfbc:	1c08      	adds	r0, r1, #0
    dfbe:	4b1c      	ldr	r3, [pc, #112]	; (e030 <AJCFG_MessageProcessor+0xdc>)
    dfc0:	4798      	blx	r3
    dfc2:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfc4:	2000      	movs	r0, #0
        *msgStatus = AJCFG_FactoryResetHandler(msg);
        break;

    case CONFIG_RESTART:
        *msgStatus = AJCFG_RestartHandler(msg);
        break;
    dfc6:	e01b      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_GET_CONFIG_CONFIGURATIONS:
	    printf("************CONFIG_GET_CONFIG_CONFIGURATIONS*********\n");
    dfc8:	481a      	ldr	r0, [pc, #104]	; (e034 <AJCFG_MessageProcessor+0xe0>)
    dfca:	4b1b      	ldr	r3, [pc, #108]	; (e038 <AJCFG_MessageProcessor+0xe4>)
    dfcc:	4798      	blx	r3
        *msgStatus = AJCFG_GetConfigurationsHandler(msg);
    dfce:	1c20      	adds	r0, r4, #0
    dfd0:	4b1a      	ldr	r3, [pc, #104]	; (e03c <AJCFG_MessageProcessor+0xe8>)
    dfd2:	4798      	blx	r3
    dfd4:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfd6:	2000      	movs	r0, #0
        break;

    case CONFIG_GET_CONFIG_CONFIGURATIONS:
	    printf("************CONFIG_GET_CONFIG_CONFIGURATIONS*********\n");
        *msgStatus = AJCFG_GetConfigurationsHandler(msg);
        break;
    dfd8:	e012      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_RESET_CONFIGURATIONS:
        *msgStatus = AJCFG_ResetConfigurationsHandler(msg);
    dfda:	1c08      	adds	r0, r1, #0
    dfdc:	4b18      	ldr	r3, [pc, #96]	; (e040 <AJCFG_MessageProcessor+0xec>)
    dfde:	4798      	blx	r3
    dfe0:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfe2:	2000      	movs	r0, #0
        *msgStatus = AJCFG_GetConfigurationsHandler(msg);
        break;

    case CONFIG_RESET_CONFIGURATIONS:
        *msgStatus = AJCFG_ResetConfigurationsHandler(msg);
        break;
    dfe4:	e00c      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_UPDATE_CONFIGURATIONS:
        *msgStatus = AJCFG_UpdateConfigurationsHandler(msg);
    dfe6:	1c08      	adds	r0, r1, #0
    dfe8:	4b16      	ldr	r3, [pc, #88]	; (e044 <AJCFG_MessageProcessor+0xf0>)
    dfea:	4798      	blx	r3
    dfec:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dfee:	2000      	movs	r0, #0
        *msgStatus = AJCFG_ResetConfigurationsHandler(msg);
        break;

    case CONFIG_UPDATE_CONFIGURATIONS:
        *msgStatus = AJCFG_UpdateConfigurationsHandler(msg);
        break;
    dff0:	e006      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    case CONFIG_SET_PASSCODE:
        *msgStatus = AJCFG_SetPasscodeHandler(msg);
    dff2:	1c08      	adds	r0, r1, #0
    dff4:	4b14      	ldr	r3, [pc, #80]	; (e048 <AJCFG_MessageProcessor+0xf4>)
    dff6:	4798      	blx	r3
    dff8:	7028      	strb	r0, [r5, #0]
    return AJ_OK;
}

AJSVC_ServiceStatus AJCFG_MessageProcessor(AJ_BusAttachment* bus, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    dffa:	2000      	movs	r0, #0
        *msgStatus = AJCFG_UpdateConfigurationsHandler(msg);
        break;

    case CONFIG_SET_PASSCODE:
        *msgStatus = AJCFG_SetPasscodeHandler(msg);
        break;
    dffc:	e000      	b.n	e000 <AJCFG_MessageProcessor+0xac>

    default:
        serviceStatus = AJSVC_SERVICE_STATUS_NOT_HANDLED;
    dffe:	2001      	movs	r0, #1
        break;
    }

    return serviceStatus;
}
    e000:	bd38      	pop	{r3, r4, r5, pc}
    e002:	46c0      	nop			; (mov r8, r8)
    e004:	03000102 	.word	0x03000102
    e008:	03000001 	.word	0x03000001
    e00c:	03000101 	.word	0x03000101
    e010:	03000104 	.word	0x03000104
    e014:	03000105 	.word	0x03000105
    e018:	03000106 	.word	0x03000106
    e01c:	0000d9ad 	.word	0x0000d9ad
    e020:	000030d1 	.word	0x000030d1
    e024:	0000d9a9 	.word	0x0000d9a9
    e028:	00003105 	.word	0x00003105
    e02c:	0000da11 	.word	0x0000da11
    e030:	0000da29 	.word	0x0000da29
    e034:	0001f8b0 	.word	0x0001f8b0
    e038:	00016f5d 	.word	0x00016f5d
    e03c:	0000da41 	.word	0x0000da41
    e040:	0000dd65 	.word	0x0000dd65
    e044:	0000db15 	.word	0x0000db15
    e048:	0000de9d 	.word	0x0000de9d

0000e04c <AJCFG_DisconnectHandler>:

AJ_Status AJCFG_DisconnectHandler(AJ_BusAttachment* busAttachment)
{
    return AJ_OK;
}
    e04c:	2000      	movs	r0, #0
    e04e:	4770      	bx	lr

0000e050 <AJNS_SendDismissSignal>:
    AJNS_NotificationDismisserInterface,
    NULL
};

AJ_Status AJNS_SendDismissSignal(AJ_BusAttachment* busAttachment, int32_t msgId, const char* appId)
{
    e050:	b5f0      	push	{r4, r5, r6, r7, lr}
    e052:	b097      	sub	sp, #92	; 0x5c
    e054:	9005      	str	r0, [sp, #20]
    e056:	1c0e      	adds	r6, r1, #0
    e058:	1e15      	subs	r5, r2, #0
    AJ_Status status;
    AJ_Message msg;

   // AJ_InfoPrintf(("In SendDismiss\n"));

    if (appId == 0) 
    e05a:	d10c      	bne.n	e076 <AJNS_SendDismissSignal+0x26>
	{
        AJ_ErrPrintf(("AppId can not be NULL\n"));
    e05c:	2001      	movs	r0, #1
    e05e:	492e      	ldr	r1, [pc, #184]	; (e118 <AJNS_SendDismissSignal+0xc8>)
    e060:	226c      	movs	r2, #108	; 0x6c
    e062:	4b2e      	ldr	r3, [pc, #184]	; (e11c <AJNS_SendDismissSignal+0xcc>)
    e064:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e066:	2312      	movs	r3, #18

   // AJ_InfoPrintf(("In SendDismiss\n"));

    if (appId == 0) 
	{
        AJ_ErrPrintf(("AppId can not be NULL\n"));
    e068:	2800      	cmp	r0, #0
    e06a:	d051      	beq.n	e110 <AJNS_SendDismissSignal+0xc0>
    e06c:	482c      	ldr	r0, [pc, #176]	; (e120 <AJNS_SendDismissSignal+0xd0>)
    e06e:	4b2d      	ldr	r3, [pc, #180]	; (e124 <AJNS_SendDismissSignal+0xd4>)
    e070:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e072:	2312      	movs	r3, #18
    e074:	e04c      	b.n	e110 <AJNS_SendDismissSignal+0xc0>

    // TODO: Remove setting of temporary Dismisser ObjectPath when AJTCL adds the "DON'T COLLAPSE" flag
#ifdef _WIN32
    AJNS_NotificationDismisserObjectPath[_snprintf(AJNS_NotificationDismisserObjectPath, NOTIFICATION_DISMISSER_OBJECT_PATH_LENGTH, "%s/%s/%d", AJNS_NotificationDismisserObjectPath, appId, msgId)] = '\0';
#else
    AJNS_NotificationDismisserObjectPath[snprintf(AJNS_NotificationDismisserObjectPath, NOTIFICATION_DISMISSER_OBJECT_PATH_LENGTH, "%s/%s/%d", AJNS_NotificationDismisserObjectPath, appId, msgId)] = '\0';
    e076:	4c2c      	ldr	r4, [pc, #176]	; (e128 <AJNS_SendDismissSignal+0xd8>)
    e078:	9200      	str	r2, [sp, #0]
    e07a:	9101      	str	r1, [sp, #4]
    e07c:	1c20      	adds	r0, r4, #0
    e07e:	2143      	movs	r1, #67	; 0x43
    e080:	4a2a      	ldr	r2, [pc, #168]	; (e12c <AJNS_SendDismissSignal+0xdc>)
    e082:	1c23      	adds	r3, r4, #0
    e084:	4f2a      	ldr	r7, [pc, #168]	; (e130 <AJNS_SendDismissSignal+0xe0>)
    e086:	47b8      	blx	r7
    e088:	2300      	movs	r3, #0
    e08a:	5423      	strb	r3, [r4, r0]
#endif

    status = AJ_MarshalSignal(busAttachment, &msg, NOTIFICATION_DISMISSER_DISMISS_EMITTER, NULL, 0, AJ_FLAG_SESSIONLESS, AJNS_NOTIFICATION_TTL_MAX); // TODO: Add the "DON'T COLLAPSE" flag
    e08c:	9300      	str	r3, [sp, #0]
    e08e:	3310      	adds	r3, #16
    e090:	9301      	str	r3, [sp, #4]
    e092:	4b28      	ldr	r3, [pc, #160]	; (e134 <AJNS_SendDismissSignal+0xe4>)
    e094:	9302      	str	r3, [sp, #8]
    e096:	9805      	ldr	r0, [sp, #20]
    e098:	a906      	add	r1, sp, #24
    e09a:	4a27      	ldr	r2, [pc, #156]	; (e138 <AJNS_SendDismissSignal+0xe8>)
    e09c:	2300      	movs	r3, #0
    e09e:	4c27      	ldr	r4, [pc, #156]	; (e13c <AJNS_SendDismissSignal+0xec>)
    e0a0:	47a0      	blx	r4
    e0a2:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e0a4:	d00c      	beq.n	e0c0 <AJNS_SendDismissSignal+0x70>
	{
        AJ_ErrPrintf(("Could not Marshal Signal\n"));
    e0a6:	2001      	movs	r0, #1
    e0a8:	491b      	ldr	r1, [pc, #108]	; (e118 <AJNS_SendDismissSignal+0xc8>)
    e0aa:	227a      	movs	r2, #122	; 0x7a
    e0ac:	4b1b      	ldr	r3, [pc, #108]	; (e11c <AJNS_SendDismissSignal+0xcc>)
    e0ae:	4798      	blx	r3
        return status;
    e0b0:	1c23      	adds	r3, r4, #0
#endif

    status = AJ_MarshalSignal(busAttachment, &msg, NOTIFICATION_DISMISSER_DISMISS_EMITTER, NULL, 0, AJ_FLAG_SESSIONLESS, AJNS_NOTIFICATION_TTL_MAX); // TODO: Add the "DON'T COLLAPSE" flag
    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Could not Marshal Signal\n"));
    e0b2:	2800      	cmp	r0, #0
    e0b4:	d02c      	beq.n	e110 <AJNS_SendDismissSignal+0xc0>
    e0b6:	4822      	ldr	r0, [pc, #136]	; (e140 <AJNS_SendDismissSignal+0xf0>)
    e0b8:	4b1a      	ldr	r3, [pc, #104]	; (e124 <AJNS_SendDismissSignal+0xd4>)
    e0ba:	4798      	blx	r3
        return status;
    e0bc:	1c23      	adds	r3, r4, #0
    e0be:	e027      	b.n	e110 <AJNS_SendDismissSignal+0xc0>
    }

    status = AJ_MarshalArgs(&msg, "i", msgId);
    e0c0:	a806      	add	r0, sp, #24
    e0c2:	4920      	ldr	r1, [pc, #128]	; (e144 <AJNS_SendDismissSignal+0xf4>)
    e0c4:	1c32      	adds	r2, r6, #0
    e0c6:	4b20      	ldr	r3, [pc, #128]	; (e148 <AJNS_SendDismissSignal+0xf8>)
    e0c8:	4798      	blx	r3
    e0ca:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e0cc:	d114      	bne.n	e0f8 <AJNS_SendDismissSignal+0xa8>
	{
        goto ErrorExit;
    }
    status = AJSVC_MarshalAppId(&msg, appId);
    e0ce:	a806      	add	r0, sp, #24
    e0d0:	1c29      	adds	r1, r5, #0
    e0d2:	4b1e      	ldr	r3, [pc, #120]	; (e14c <AJNS_SendDismissSignal+0xfc>)
    e0d4:	4798      	blx	r3
    e0d6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e0d8:	d10e      	bne.n	e0f8 <AJNS_SendDismissSignal+0xa8>
	{
        goto ErrorExit;
    }
    status = AJ_DeliverMsg(&msg);
    e0da:	a806      	add	r0, sp, #24
    e0dc:	4b1c      	ldr	r3, [pc, #112]	; (e150 <AJNS_SendDismissSignal+0x100>)
    e0de:	4798      	blx	r3
    e0e0:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK)
    e0e2:	d109      	bne.n	e0f8 <AJNS_SendDismissSignal+0xa8>
	 {
        goto ErrorExit;
    }
    status = AJ_CloseMsg(&msg);
    e0e4:	a806      	add	r0, sp, #24
    e0e6:	4b1b      	ldr	r3, [pc, #108]	; (e154 <AJNS_SendDismissSignal+0x104>)
    e0e8:	4798      	blx	r3
    e0ea:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK)
    e0ec:	d104      	bne.n	e0f8 <AJNS_SendDismissSignal+0xa8>
	 {
        goto ErrorExit;
    }

    // TODO: Remove resetting of temporary Dismisser ObjectPath when AJTCL adds the "DON'T COLLAPSE" flag
    AJNS_NotificationDismisserObjectPath[NOTIFICATION_DISMISSER_OBJECT_PATH_PREFIX_LENGTH] = '\0';
    e0ee:	2200      	movs	r2, #0
    e0f0:	4b0d      	ldr	r3, [pc, #52]	; (e128 <AJNS_SendDismissSignal+0xd8>)
    e0f2:	759a      	strb	r2, [r3, #22]
    return status;
    e0f4:	2300      	movs	r3, #0
    e0f6:	e00b      	b.n	e110 <AJNS_SendDismissSignal+0xc0>

ErrorExit:

    AJ_ErrPrintf(("Could not Deliver Message\n"));
    e0f8:	2001      	movs	r0, #1
    e0fa:	4907      	ldr	r1, [pc, #28]	; (e118 <AJNS_SendDismissSignal+0xc8>)
    e0fc:	2299      	movs	r2, #153	; 0x99
    e0fe:	4b07      	ldr	r3, [pc, #28]	; (e11c <AJNS_SendDismissSignal+0xcc>)
    e100:	4798      	blx	r3
    return status;
    e102:	1c23      	adds	r3, r4, #0
    AJNS_NotificationDismisserObjectPath[NOTIFICATION_DISMISSER_OBJECT_PATH_PREFIX_LENGTH] = '\0';
    return status;

ErrorExit:

    AJ_ErrPrintf(("Could not Deliver Message\n"));
    e104:	2800      	cmp	r0, #0
    e106:	d003      	beq.n	e110 <AJNS_SendDismissSignal+0xc0>
    e108:	4813      	ldr	r0, [pc, #76]	; (e158 <AJNS_SendDismissSignal+0x108>)
    e10a:	4b06      	ldr	r3, [pc, #24]	; (e124 <AJNS_SendDismissSignal+0xd4>)
    e10c:	4798      	blx	r3
    return status;
    e10e:	1c23      	adds	r3, r4, #0
}
    e110:	1c18      	adds	r0, r3, #0
    e112:	b017      	add	sp, #92	; 0x5c
    e114:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e116:	46c0      	nop			; (mov r8, r8)
    e118:	0001fa34 	.word	0x0001fa34
    e11c:	0000636d 	.word	0x0000636d
    e120:	0001fa68 	.word	0x0001fa68
    e124:	00016f5d 	.word	0x00016f5d
    e128:	2000017c 	.word	0x2000017c
    e12c:	0001fa80 	.word	0x0001fa80
    e130:	000170b5 	.word	0x000170b5
    e134:	0000a8c0 	.word	0x0000a8c0
    e138:	05000100 	.word	0x05000100
    e13c:	0000bcfd 	.word	0x0000bcfd
    e140:	0001fa8c 	.word	0x0001fa8c
    e144:	0001a4e0 	.word	0x0001a4e0
    e148:	0000bc85 	.word	0x0000bc85
    e14c:	0000ebfd 	.word	0x0000ebfd
    e150:	0000a539 	.word	0x0000a539
    e154:	0000a77d 	.word	0x0000a77d
    e158:	0001faa8 	.word	0x0001faa8

0000e15c <AJNS_Common_RegisterObjects>:
};

void AJNS_Common_RegisterObjects()
{
    AJNS_ObjectList[NOTIFICATION_DISMISSER_OBJECT_INDEX].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    AJNS_ObjectList[NOTIFICATION_DISMISSER_OBJECT_INDEX].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    e15c:	4903      	ldr	r1, [pc, #12]	; (e16c <AJNS_Common_RegisterObjects+0x10>)
    { NULL }
};

void AJNS_Common_RegisterObjects()
{
    AJNS_ObjectList[NOTIFICATION_DISMISSER_OBJECT_INDEX].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    e15e:	7a0b      	ldrb	r3, [r1, #8]
    e160:	2206      	movs	r2, #6
    e162:	4393      	bics	r3, r2
    AJNS_ObjectList[NOTIFICATION_DISMISSER_OBJECT_INDEX].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    e164:	2208      	movs	r2, #8
    e166:	4313      	orrs	r3, r2
    e168:	720b      	strb	r3, [r1, #8]
}
    e16a:	4770      	bx	lr
    e16c:	200001c0 	.word	0x200001c0

0000e170 <AJNS_Producer_PropSetHandler>:
}

AJ_Status AJNS_Producer_PropSetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    return AJ_ERR_DISALLOWED;
}
    e170:	2012      	movs	r0, #18
    e172:	4770      	bx	lr

0000e174 <AJNS_Producer_PropGetHandler>:

    return status;
}

AJ_Status AJNS_Producer_PropGetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    e174:	b508      	push	{r3, lr}
    AJ_Status status = AJ_ERR_UNEXPECTED;

    switch (propId) 
    e176:	4b12      	ldr	r3, [pc, #72]	; (e1c0 <AJNS_Producer_PropGetHandler+0x4c>)
    e178:	4299      	cmp	r1, r3
    e17a:	d00e      	beq.n	e19a <AJNS_Producer_PropGetHandler+0x26>
    e17c:	d806      	bhi.n	e18c <AJNS_Producer_PropGetHandler+0x18>
    e17e:	4b11      	ldr	r3, [pc, #68]	; (e1c4 <AJNS_Producer_PropGetHandler+0x50>)
    e180:	4299      	cmp	r1, r3
    e182:	d015      	beq.n	e1b0 <AJNS_Producer_PropGetHandler+0x3c>
    e184:	4b10      	ldr	r3, [pc, #64]	; (e1c8 <AJNS_Producer_PropGetHandler+0x54>)
    e186:	4299      	cmp	r1, r3
    e188:	d118      	bne.n	e1bc <AJNS_Producer_PropGetHandler+0x48>
    e18a:	e006      	b.n	e19a <AJNS_Producer_PropGetHandler+0x26>
    e18c:	4b0f      	ldr	r3, [pc, #60]	; (e1cc <AJNS_Producer_PropGetHandler+0x58>)
    e18e:	4299      	cmp	r1, r3
    e190:	d003      	beq.n	e19a <AJNS_Producer_PropGetHandler+0x26>
    e192:	4b0f      	ldr	r3, [pc, #60]	; (e1d0 <AJNS_Producer_PropGetHandler+0x5c>)
    e194:	4299      	cmp	r1, r3
    e196:	d006      	beq.n	e1a6 <AJNS_Producer_PropGetHandler+0x32>
    e198:	e010      	b.n	e1bc <AJNS_Producer_PropGetHandler+0x48>
	{
    case GET_EMERGENCY_NOTIFICATION_VERSION_PROPERTY:
    case GET_WARNING_NOTIFICATION_VERSION_PROPERTY:
    case GET_INFO_NOTIFICATION_VERSION_PROPERTY:
        status = AJ_MarshalArgs(replyMsg, "q", AJNS_NotificationVersion);
    e19a:	4b0e      	ldr	r3, [pc, #56]	; (e1d4 <AJNS_Producer_PropGetHandler+0x60>)
    e19c:	881a      	ldrh	r2, [r3, #0]
    e19e:	490e      	ldr	r1, [pc, #56]	; (e1d8 <AJNS_Producer_PropGetHandler+0x64>)
    e1a0:	4b0e      	ldr	r3, [pc, #56]	; (e1dc <AJNS_Producer_PropGetHandler+0x68>)
    e1a2:	4798      	blx	r3
        break;
    e1a4:	e00b      	b.n	e1be <AJNS_Producer_PropGetHandler+0x4a>

    case GET_NOTIFICATION_PRODUCER_VERSION_PROPERTY:
        status = AJ_MarshalArgs(replyMsg, "q", AJNS_NotificationProducerVersion);
    e1a6:	490c      	ldr	r1, [pc, #48]	; (e1d8 <AJNS_Producer_PropGetHandler+0x64>)
    e1a8:	2201      	movs	r2, #1
    e1aa:	4b0c      	ldr	r3, [pc, #48]	; (e1dc <AJNS_Producer_PropGetHandler+0x68>)
    e1ac:	4798      	blx	r3
        break;
    e1ae:	e006      	b.n	e1be <AJNS_Producer_PropGetHandler+0x4a>

    case GET_NOTIFICATION_DISMISSER_VERSION_PROPERTY:
        status = AJ_MarshalArgs(replyMsg, "q", AJNS_NotificationDismisserVersion);
    e1b0:	4b0b      	ldr	r3, [pc, #44]	; (e1e0 <AJNS_Producer_PropGetHandler+0x6c>)
    e1b2:	881a      	ldrh	r2, [r3, #0]
    e1b4:	4908      	ldr	r1, [pc, #32]	; (e1d8 <AJNS_Producer_PropGetHandler+0x64>)
    e1b6:	4b09      	ldr	r3, [pc, #36]	; (e1dc <AJNS_Producer_PropGetHandler+0x68>)
    e1b8:	4798      	blx	r3
        break;
    e1ba:	e000      	b.n	e1be <AJNS_Producer_PropGetHandler+0x4a>
    return status;
}

AJ_Status AJNS_Producer_PropGetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
    AJ_Status status = AJ_ERR_UNEXPECTED;
    e1bc:	2002      	movs	r0, #2
    case GET_NOTIFICATION_DISMISSER_VERSION_PROPERTY:
        status = AJ_MarshalArgs(replyMsg, "q", AJNS_NotificationDismisserVersion);
        break;
    }
    return status;
}
    e1be:	bd08      	pop	{r3, pc}
    e1c0:	05050101 	.word	0x05050101
    e1c4:	05000101 	.word	0x05000101
    e1c8:	05040101 	.word	0x05040101
    e1cc:	05060101 	.word	0x05060101
    e1d0:	05070101 	.word	0x05070101
    e1d4:	0001f9c0 	.word	0x0001f9c0
    e1d8:	0001eda8 	.word	0x0001eda8
    e1dc:	0000bc85 	.word	0x0000bc85
    e1e0:	0001fa00 	.word	0x0001fa00

0000e1e4 <AJNS_Producer_Start>:

    return AJ_RegisterObjectList(AJNS_ObjectList, AJNS_OBJECT_LIST_INDEX);
}

AJ_Status AJNS_Producer_Start()
{
    e1e4:	b538      	push	{r3, r4, r5, lr}

static AJ_Status RegisterObjectList()
{
    uint8_t i = NOTIFICATION_PRODUCER_OBJECTS_INDEX;

    AJNS_Common_RegisterObjects();
    e1e6:	4b0a      	ldr	r3, [pc, #40]	; (e210 <AJNS_Producer_Start+0x2c>)
    e1e8:	4798      	blx	r3
    e1ea:	2100      	movs	r1, #0
    e1ec:	4d09      	ldr	r5, [pc, #36]	; (e214 <AJNS_Producer_Start+0x30>)
    for (; i < NOTIFICATION_PRODUCER_OBJECTS_INDEX + NOTIFICATION_PRODUCER_OBJECTS_COUNT; i++) 
	{
        AJNS_ObjectList[i].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    e1ee:	2406      	movs	r4, #6
        AJNS_ObjectList[i].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    e1f0:	2008      	movs	r0, #8
    e1f2:	1c0a      	adds	r2, r1, #0
    e1f4:	3248      	adds	r2, #72	; 0x48
    e1f6:	1952      	adds	r2, r2, r5
    uint8_t i = NOTIFICATION_PRODUCER_OBJECTS_INDEX;

    AJNS_Common_RegisterObjects();
    for (; i < NOTIFICATION_PRODUCER_OBJECTS_INDEX + NOTIFICATION_PRODUCER_OBJECTS_COUNT; i++) 
	{
        AJNS_ObjectList[i].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
    e1f8:	7813      	ldrb	r3, [r2, #0]
    e1fa:	43a3      	bics	r3, r4
        AJNS_ObjectList[i].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    e1fc:	4303      	orrs	r3, r0
    e1fe:	7013      	strb	r3, [r2, #0]
    e200:	3110      	adds	r1, #16
static AJ_Status RegisterObjectList()
{
    uint8_t i = NOTIFICATION_PRODUCER_OBJECTS_INDEX;

    AJNS_Common_RegisterObjects();
    for (; i < NOTIFICATION_PRODUCER_OBJECTS_INDEX + NOTIFICATION_PRODUCER_OBJECTS_COUNT; i++) 
    e202:	2940      	cmp	r1, #64	; 0x40
    e204:	d1f5      	bne.n	e1f2 <AJNS_Producer_Start+0xe>
	{
        AJNS_ObjectList[i].flags &= ~(AJ_OBJ_FLAG_HIDDEN | AJ_OBJ_FLAG_DISABLED);
        AJNS_ObjectList[i].flags |= AJ_OBJ_FLAG_ANNOUNCED;
    }

    return AJ_RegisterObjectList(AJNS_ObjectList, AJNS_OBJECT_LIST_INDEX);
    e206:	4803      	ldr	r0, [pc, #12]	; (e214 <AJNS_Producer_Start+0x30>)
    e208:	393b      	subs	r1, #59	; 0x3b
    e20a:	4b03      	ldr	r3, [pc, #12]	; (e218 <AJNS_Producer_Start+0x34>)
    e20c:	4798      	blx	r3
    AJ_Status status;

    status = RegisterObjectList();

    return status;
}
    e20e:	bd38      	pop	{r3, r4, r5, pc}
    e210:	0000e15d 	.word	0x0000e15d
    e214:	200001c0 	.word	0x200001c0
    e218:	000088ed 	.word	0x000088ed

0000e21c <AJNS_Producer_SendNotification>:

/**
 * Send Notification - see notes in h file
 */
AJ_Status AJNS_Producer_SendNotification(AJ_BusAttachment* busAttachment, AJNS_NotificationContent* content, uint16_t messageType, uint32_t ttl, uint32_t* messageSerialNumber)
{
    e21c:	b5f0      	push	{r4, r5, r6, r7, lr}
    e21e:	465f      	mov	r7, fp
    e220:	4656      	mov	r6, sl
    e222:	464d      	mov	r5, r9
    e224:	4644      	mov	r4, r8
    e226:	b4f0      	push	{r4, r5, r6, r7}
    e228:	b0bd      	sub	sp, #244	; 0xf4
    e22a:	9005      	str	r0, [sp, #20]
    e22c:	9104      	str	r1, [sp, #16]
    e22e:	1c16      	adds	r6, r2, #0
    e230:	1c1d      	adds	r5, r3, #0
    AJNS_Notification notification;
    uint32_t serialNumber;

  //  AJ_InfoPrintf(("In SendNotification\n"));

    notification.version = AJNS_NotificationVersion;
    e232:	4bb8      	ldr	r3, [pc, #736]	; (e514 <AJNS_Producer_SendNotification+0x2f8>)
    e234:	881f      	ldrh	r7, [r3, #0]
    if (messageType >= AJNS_NUM_MESSAGE_TYPES)
    e236:	2a02      	cmp	r2, #2
    e238:	d90c      	bls.n	e254 <AJNS_Producer_SendNotification+0x38>
	{
        AJ_ErrPrintf(("Could not Send Notification - MessageType is not valid\n"));
    e23a:	2001      	movs	r0, #1
    e23c:	49b6      	ldr	r1, [pc, #728]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e23e:	4ab7      	ldr	r2, [pc, #732]	; (e51c <AJNS_Producer_SendNotification+0x300>)
    e240:	4bb7      	ldr	r3, [pc, #732]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e242:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e244:	2412      	movs	r4, #18
  //  AJ_InfoPrintf(("In SendNotification\n"));

    notification.version = AJNS_NotificationVersion;
    if (messageType >= AJNS_NUM_MESSAGE_TYPES)
	{
        AJ_ErrPrintf(("Could not Send Notification - MessageType is not valid\n"));
    e246:	2800      	cmp	r0, #0
    e248:	d100      	bne.n	e24c <AJNS_Producer_SendNotification+0x30>
    e24a:	e38b      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e24c:	48b5      	ldr	r0, [pc, #724]	; (e524 <AJNS_Producer_SendNotification+0x308>)
    e24e:	4bb6      	ldr	r3, [pc, #728]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e250:	4798      	blx	r3
    e252:	e387      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
        return AJ_ERR_DISALLOWED;
    }
    notification.messageType = messageType;

    if ((ttl < AJNS_NOTIFICATION_TTL_MIN) || (ttl > AJNS_NOTIFICATION_TTL_MAX)) 
    e254:	4bb5      	ldr	r3, [pc, #724]	; (e52c <AJNS_Producer_SendNotification+0x310>)
    e256:	881b      	ldrh	r3, [r3, #0]
    e258:	42ab      	cmp	r3, r5
    e25a:	d803      	bhi.n	e264 <AJNS_Producer_SendNotification+0x48>
    e25c:	4bb4      	ldr	r3, [pc, #720]	; (e530 <AJNS_Producer_SendNotification+0x314>)
    e25e:	881b      	ldrh	r3, [r3, #0]
    e260:	429d      	cmp	r5, r3
    e262:	d90d      	bls.n	e280 <AJNS_Producer_SendNotification+0x64>
	{      //ttl is mandatory and must be in range
        AJ_ErrPrintf(("TTL '%u' is not a valid TTL value\n", ttl));
    e264:	2001      	movs	r0, #1
    e266:	49ac      	ldr	r1, [pc, #688]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e268:	4ab2      	ldr	r2, [pc, #712]	; (e534 <AJNS_Producer_SendNotification+0x318>)
    e26a:	4bad      	ldr	r3, [pc, #692]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e26c:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e26e:	2412      	movs	r4, #18
    }
    notification.messageType = messageType;

    if ((ttl < AJNS_NOTIFICATION_TTL_MIN) || (ttl > AJNS_NOTIFICATION_TTL_MAX)) 
	{      //ttl is mandatory and must be in range
        AJ_ErrPrintf(("TTL '%u' is not a valid TTL value\n", ttl));
    e270:	2800      	cmp	r0, #0
    e272:	d100      	bne.n	e276 <AJNS_Producer_SendNotification+0x5a>
    e274:	e376      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e276:	48b0      	ldr	r0, [pc, #704]	; (e538 <AJNS_Producer_SendNotification+0x31c>)
    e278:	1c29      	adds	r1, r5, #0
    e27a:	4bb0      	ldr	r3, [pc, #704]	; (e53c <AJNS_Producer_SendNotification+0x320>)
    e27c:	4798      	blx	r3
    e27e:	e371      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
        return AJ_ERR_DISALLOWED;
    }

    notification.deviceId = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID);
    e280:	2000      	movs	r0, #0
    e282:	4caf      	ldr	r4, [pc, #700]	; (e540 <AJNS_Producer_SendNotification+0x324>)
    e284:	47a0      	blx	r4
    e286:	4681      	mov	r9, r0
    notification.deviceName = AJSVC_PropertyStore_GetValueForLang(AJSVC_PROPERTY_STORE_DEVICE_NAME, AJSVC_PropertyStore_GetLanguageIndex(""));
    e288:	48ae      	ldr	r0, [pc, #696]	; (e544 <AJNS_Producer_SendNotification+0x328>)
    e28a:	4baf      	ldr	r3, [pc, #700]	; (e548 <AJNS_Producer_SendNotification+0x32c>)
    e28c:	4798      	blx	r3
    e28e:	1c01      	adds	r1, r0, #0
    e290:	2002      	movs	r0, #2
    e292:	4bae      	ldr	r3, [pc, #696]	; (e54c <AJNS_Producer_SendNotification+0x330>)
    e294:	4798      	blx	r3
    e296:	4682      	mov	sl, r0
    notification.appId = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_ID);
    e298:	2001      	movs	r0, #1
    e29a:	47a0      	blx	r4
    e29c:	4680      	mov	r8, r0
    notification.appName = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_NAME);
    e29e:	2006      	movs	r0, #6
    e2a0:	47a0      	blx	r4
    e2a2:	9006      	str	r0, [sp, #24]

    if ((notification.deviceId == 0) || (notification.deviceName == 0) ||
    e2a4:	464b      	mov	r3, r9
    e2a6:	2b00      	cmp	r3, #0
    e2a8:	d007      	beq.n	e2ba <AJNS_Producer_SendNotification+0x9e>
    e2aa:	4653      	mov	r3, sl
    e2ac:	2b00      	cmp	r3, #0
    e2ae:	d004      	beq.n	e2ba <AJNS_Producer_SendNotification+0x9e>
    e2b0:	4643      	mov	r3, r8
    e2b2:	2b00      	cmp	r3, #0
    e2b4:	d001      	beq.n	e2ba <AJNS_Producer_SendNotification+0x9e>
        (notification.appId == 0) || (notification.appName == 0)) 
    e2b6:	2800      	cmp	r0, #0
    e2b8:	d10c      	bne.n	e2d4 <AJNS_Producer_SendNotification+0xb8>
	{
        AJ_ErrPrintf(("DeviceId/DeviceName/AppId/AppName can not be NULL\n"));
    e2ba:	2001      	movs	r0, #1
    e2bc:	4996      	ldr	r1, [pc, #600]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e2be:	4aa4      	ldr	r2, [pc, #656]	; (e550 <AJNS_Producer_SendNotification+0x334>)
    e2c0:	4b97      	ldr	r3, [pc, #604]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e2c2:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e2c4:	2412      	movs	r4, #18
    notification.appName = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_NAME);

    if ((notification.deviceId == 0) || (notification.deviceName == 0) ||
        (notification.appId == 0) || (notification.appName == 0)) 
	{
        AJ_ErrPrintf(("DeviceId/DeviceName/AppId/AppName can not be NULL\n"));
    e2c6:	2800      	cmp	r0, #0
    e2c8:	d100      	bne.n	e2cc <AJNS_Producer_SendNotification+0xb0>
    e2ca:	e34b      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e2cc:	48a1      	ldr	r0, [pc, #644]	; (e554 <AJNS_Producer_SendNotification+0x338>)
    e2ce:	4b96      	ldr	r3, [pc, #600]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e2d0:	4798      	blx	r3
    e2d2:	e347      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
        return AJ_ERR_DISALLOWED;
    }

    if ((strlen(notification.deviceId) == 0) || (strlen(notification.deviceName) == 0) ||
    e2d4:	464b      	mov	r3, r9
    e2d6:	781b      	ldrb	r3, [r3, #0]
    e2d8:	2b00      	cmp	r3, #0
    e2da:	d00b      	beq.n	e2f4 <AJNS_Producer_SendNotification+0xd8>
    e2dc:	4653      	mov	r3, sl
    e2de:	781b      	ldrb	r3, [r3, #0]
    e2e0:	2b00      	cmp	r3, #0
    e2e2:	d007      	beq.n	e2f4 <AJNS_Producer_SendNotification+0xd8>
    e2e4:	4643      	mov	r3, r8
    e2e6:	781b      	ldrb	r3, [r3, #0]
    e2e8:	2b00      	cmp	r3, #0
    e2ea:	d003      	beq.n	e2f4 <AJNS_Producer_SendNotification+0xd8>
        (strlen(notification.appId) == 0) || (strlen(notification.appName) == 0)) 
    e2ec:	9b06      	ldr	r3, [sp, #24]
    e2ee:	781b      	ldrb	r3, [r3, #0]
    e2f0:	2b00      	cmp	r3, #0
    e2f2:	d10c      	bne.n	e30e <AJNS_Producer_SendNotification+0xf2>
	{
        AJ_ErrPrintf(("DeviceId/DeviceName/AppId/AppName can not be empty\n"));
    e2f4:	2001      	movs	r0, #1
    e2f6:	4988      	ldr	r1, [pc, #544]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e2f8:	4a97      	ldr	r2, [pc, #604]	; (e558 <AJNS_Producer_SendNotification+0x33c>)
    e2fa:	4b89      	ldr	r3, [pc, #548]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e2fc:	4798      	blx	r3
        return AJ_ERR_DISALLOWED;
    e2fe:	2412      	movs	r4, #18
    }

    if ((strlen(notification.deviceId) == 0) || (strlen(notification.deviceName) == 0) ||
        (strlen(notification.appId) == 0) || (strlen(notification.appName) == 0)) 
	{
        AJ_ErrPrintf(("DeviceId/DeviceName/AppId/AppName can not be empty\n"));
    e300:	2800      	cmp	r0, #0
    e302:	d100      	bne.n	e306 <AJNS_Producer_SendNotification+0xea>
    e304:	e32e      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e306:	4895      	ldr	r0, [pc, #596]	; (e55c <AJNS_Producer_SendNotification+0x340>)
    e308:	4b87      	ldr	r3, [pc, #540]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e30a:	4798      	blx	r3
    e30c:	e32a      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
        return AJ_ERR_DISALLOWED;
    }

    if (notification.version > 1) 
    e30e:	2f01      	cmp	r7, #1
    e310:	d923      	bls.n	e35a <AJNS_Producer_SendNotification+0x13e>
	{
        notification.originalSenderName = AJ_GetUniqueName(busAttachment);
    e312:	9805      	ldr	r0, [sp, #20]
    e314:	4b92      	ldr	r3, [pc, #584]	; (e560 <AJNS_Producer_SendNotification+0x344>)
    e316:	4798      	blx	r3
    e318:	9007      	str	r0, [sp, #28]

        if (notification.originalSenderName == 0) 
    e31a:	2800      	cmp	r0, #0
    e31c:	d10c      	bne.n	e338 <AJNS_Producer_SendNotification+0x11c>
		{
            AJ_ErrPrintf(("OriginalSender can not be NULL\n"));
    e31e:	2001      	movs	r0, #1
    e320:	497d      	ldr	r1, [pc, #500]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e322:	4a90      	ldr	r2, [pc, #576]	; (e564 <AJNS_Producer_SendNotification+0x348>)
    e324:	4b7e      	ldr	r3, [pc, #504]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e326:	4798      	blx	r3
            return AJ_ERR_DISALLOWED;
    e328:	2412      	movs	r4, #18
	{
        notification.originalSenderName = AJ_GetUniqueName(busAttachment);

        if (notification.originalSenderName == 0) 
		{
            AJ_ErrPrintf(("OriginalSender can not be NULL\n"));
    e32a:	2800      	cmp	r0, #0
    e32c:	d100      	bne.n	e330 <AJNS_Producer_SendNotification+0x114>
    e32e:	e319      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e330:	488d      	ldr	r0, [pc, #564]	; (e568 <AJNS_Producer_SendNotification+0x34c>)
    e332:	4b7d      	ldr	r3, [pc, #500]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e334:	4798      	blx	r3
    e336:	e315      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
            return AJ_ERR_DISALLOWED;
        }

        if (strlen(notification.originalSenderName) == 0) 
    e338:	9b07      	ldr	r3, [sp, #28]
    e33a:	781b      	ldrb	r3, [r3, #0]
    e33c:	2b00      	cmp	r3, #0
    e33e:	d10e      	bne.n	e35e <AJNS_Producer_SendNotification+0x142>
		{
            AJ_ErrPrintf(("OriginalSender can not be empty\n"));
    e340:	2001      	movs	r0, #1
    e342:	4975      	ldr	r1, [pc, #468]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e344:	4a89      	ldr	r2, [pc, #548]	; (e56c <AJNS_Producer_SendNotification+0x350>)
    e346:	4b76      	ldr	r3, [pc, #472]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e348:	4798      	blx	r3
            return AJ_ERR_DISALLOWED;
    e34a:	2412      	movs	r4, #18
            return AJ_ERR_DISALLOWED;
        }

        if (strlen(notification.originalSenderName) == 0) 
		{
            AJ_ErrPrintf(("OriginalSender can not be empty\n"));
    e34c:	2800      	cmp	r0, #0
    e34e:	d100      	bne.n	e352 <AJNS_Producer_SendNotification+0x136>
    e350:	e308      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e352:	4887      	ldr	r0, [pc, #540]	; (e570 <AJNS_Producer_SendNotification+0x354>)
    e354:	4b74      	ldr	r3, [pc, #464]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e356:	4798      	blx	r3
    e358:	e304      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
            return AJ_ERR_DISALLOWED;
        }
    }
	else 
	{
        notification.originalSenderName = NULL;
    e35a:	2300      	movs	r3, #0
    e35c:	9307      	str	r3, [sp, #28]
    }

    if (!notificationId)
    e35e:	4b85      	ldr	r3, [pc, #532]	; (e574 <AJNS_Producer_SendNotification+0x358>)
    e360:	681b      	ldr	r3, [r3, #0]
    e362:	2b00      	cmp	r3, #0
    e364:	d103      	bne.n	e36e <AJNS_Producer_SendNotification+0x152>
	{
    //    AJ_InfoPrintf(("Generating random number for notification id\n"));
        AJ_RandBytes((uint8_t*)&notificationId, 4);
    e366:	4883      	ldr	r0, [pc, #524]	; (e574 <AJNS_Producer_SendNotification+0x358>)
    e368:	2104      	movs	r1, #4
    e36a:	4b83      	ldr	r3, [pc, #524]	; (e578 <AJNS_Producer_SendNotification+0x35c>)
    e36c:	4798      	blx	r3
    }

    notification.notificationId = notificationId;
    e36e:	4b81      	ldr	r3, [pc, #516]	; (e574 <AJNS_Producer_SendNotification+0x358>)
    e370:	681b      	ldr	r3, [r3, #0]
    e372:	469b      	mov	fp, r3
	{
    //    AJ_InfoPrintf(("Nothing to send\n"));
        return status;
    }

    status = AJ_MarshalSignal(busAttachment, msg, AJ_ENCODE_MESSAGE_ID(AJNS_OBJECT_LIST_INDEX, NOTIFICATION_OBJECT_INDEX + notification->messageType, 1, 0), NULL, 0, AJ_FLAG_SESSIONLESS, ttl);
    e374:	1d32      	adds	r2, r6, #4
    e376:	0413      	lsls	r3, r2, #16
    e378:	4a80      	ldr	r2, [pc, #512]	; (e57c <AJNS_Producer_SendNotification+0x360>)
    e37a:	431a      	orrs	r2, r3
    e37c:	2300      	movs	r3, #0
    e37e:	9300      	str	r3, [sp, #0]
    e380:	3310      	adds	r3, #16
    e382:	9301      	str	r3, [sp, #4]
    e384:	9502      	str	r5, [sp, #8]
    e386:	9805      	ldr	r0, [sp, #20]
    e388:	a92c      	add	r1, sp, #176	; 0xb0
    e38a:	2300      	movs	r3, #0
    e38c:	4c7c      	ldr	r4, [pc, #496]	; (e580 <AJNS_Producer_SendNotification+0x364>)
    e38e:	47a0      	blx	r4
    e390:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e392:	d00b      	beq.n	e3ac <AJNS_Producer_SendNotification+0x190>
	{
        AJ_ErrPrintf(("Could not Marshal Signal\n"));
    e394:	2001      	movs	r0, #1
    e396:	4960      	ldr	r1, [pc, #384]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e398:	22bb      	movs	r2, #187	; 0xbb
    e39a:	4b61      	ldr	r3, [pc, #388]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e39c:	4798      	blx	r3
    e39e:	2800      	cmp	r0, #0
    e3a0:	d100      	bne.n	e3a4 <AJNS_Producer_SendNotification+0x188>
    e3a2:	e2df      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e3a4:	4877      	ldr	r0, [pc, #476]	; (e584 <AJNS_Producer_SendNotification+0x368>)
    e3a6:	4b60      	ldr	r3, [pc, #384]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e3a8:	4798      	blx	r3
    e3aa:	e2db      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
        return status;
    }

    ///////////////////       Proto     /////////////////////
    status = AJ_MarshalArgs(msg, "q", notification->version);
    e3ac:	a82c      	add	r0, sp, #176	; 0xb0
    e3ae:	4976      	ldr	r1, [pc, #472]	; (e588 <AJNS_Producer_SendNotification+0x36c>)
    e3b0:	1c3a      	adds	r2, r7, #0
    e3b2:	4b76      	ldr	r3, [pc, #472]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e3b4:	4798      	blx	r3
    e3b6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e3b8:	d000      	beq.n	e3bc <AJNS_Producer_SendNotification+0x1a0>
    e3ba:	e2cc      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    MessgeId    /////////////////////
    status = AJ_MarshalArgs(msg, "i", notification->notificationId);
    e3bc:	a82c      	add	r0, sp, #176	; 0xb0
    e3be:	4974      	ldr	r1, [pc, #464]	; (e590 <AJNS_Producer_SendNotification+0x374>)
    e3c0:	465a      	mov	r2, fp
    e3c2:	4b72      	ldr	r3, [pc, #456]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e3c4:	4798      	blx	r3
    e3c6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e3c8:	d000      	beq.n	e3cc <AJNS_Producer_SendNotification+0x1b0>
    e3ca:	e2c4      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    MessageType   ////////////////////////////
    status = AJ_MarshalArgs(msg, "q", notification->messageType);
    e3cc:	a82c      	add	r0, sp, #176	; 0xb0
    e3ce:	496e      	ldr	r1, [pc, #440]	; (e588 <AJNS_Producer_SendNotification+0x36c>)
    e3d0:	1c32      	adds	r2, r6, #0
    e3d2:	4b6e      	ldr	r3, [pc, #440]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e3d4:	4798      	blx	r3
    e3d6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e3d8:	d000      	beq.n	e3dc <AJNS_Producer_SendNotification+0x1c0>
    e3da:	e2bc      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
        goto ErrorExit;

    }

    ///////////////////    DeviceId   ////////////////////////////
    status = AJ_MarshalArgs(msg, "s", notification->deviceId);
    e3dc:	a82c      	add	r0, sp, #176	; 0xb0
    e3de:	496d      	ldr	r1, [pc, #436]	; (e594 <AJNS_Producer_SendNotification+0x378>)
    e3e0:	464a      	mov	r2, r9
    e3e2:	4b6a      	ldr	r3, [pc, #424]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e3e4:	4798      	blx	r3
    e3e6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e3e8:	d000      	beq.n	e3ec <AJNS_Producer_SendNotification+0x1d0>
    e3ea:	e2b4      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    DeviceName   ////////////////////////////
    status = AJ_MarshalArgs(msg, "s", notification->deviceName);
    e3ec:	a82c      	add	r0, sp, #176	; 0xb0
    e3ee:	4969      	ldr	r1, [pc, #420]	; (e594 <AJNS_Producer_SendNotification+0x378>)
    e3f0:	4652      	mov	r2, sl
    e3f2:	4b66      	ldr	r3, [pc, #408]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e3f4:	4798      	blx	r3
    e3f6:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e3f8:	d000      	beq.n	e3fc <AJNS_Producer_SendNotification+0x1e0>
    e3fa:	e2ac      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    AppId   ////////////////////////////
    status = AJSVC_MarshalAppId(msg, notification->appId);
    e3fc:	a82c      	add	r0, sp, #176	; 0xb0
    e3fe:	4641      	mov	r1, r8
    e400:	4b65      	ldr	r3, [pc, #404]	; (e598 <AJNS_Producer_SendNotification+0x37c>)
    e402:	4798      	blx	r3
    e404:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e406:	d000      	beq.n	e40a <AJNS_Producer_SendNotification+0x1ee>
    e408:	e2a5      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    AppName   ////////////////////////////
    status = AJ_MarshalArgs(msg, "s", notification->appName);
    e40a:	a82c      	add	r0, sp, #176	; 0xb0
    e40c:	4961      	ldr	r1, [pc, #388]	; (e594 <AJNS_Producer_SendNotification+0x378>)
    e40e:	9a06      	ldr	r2, [sp, #24]
    e410:	4b5e      	ldr	r3, [pc, #376]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e412:	4798      	blx	r3
    e414:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e416:	d000      	beq.n	e41a <AJNS_Producer_SendNotification+0x1fe>
    e418:	e29d      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    Attributes   ////////////////////////////
    status = AJ_MarshalContainer(msg, &attrbtArray, AJ_ARG_ARRAY);
    e41a:	a82c      	add	r0, sp, #176	; 0xb0
    e41c:	a908      	add	r1, sp, #32
    e41e:	2261      	movs	r2, #97	; 0x61
    e420:	4b5e      	ldr	r3, [pc, #376]	; (e59c <AJNS_Producer_SendNotification+0x380>)
    e422:	4798      	blx	r3
    e424:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e426:	d000      	beq.n	e42a <AJNS_Producer_SendNotification+0x20e>
    e428:	e295      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    if (notification->content->richIconUrl != 0) 
    e42a:	9b04      	ldr	r3, [sp, #16]
    e42c:	699b      	ldr	r3, [r3, #24]
    e42e:	9305      	str	r3, [sp, #20]
    e430:	2b00      	cmp	r3, #0
    e432:	d026      	beq.n	e482 <AJNS_Producer_SendNotification+0x266>
	{
        status = AJ_MarshalContainer(msg, &dictArg, AJ_ARG_DICT_ENTRY);
    e434:	a82c      	add	r0, sp, #176	; 0xb0
    e436:	a918      	add	r1, sp, #96	; 0x60
    e438:	227b      	movs	r2, #123	; 0x7b
    e43a:	4b58      	ldr	r3, [pc, #352]	; (e59c <AJNS_Producer_SendNotification+0x380>)
    e43c:	4798      	blx	r3
    e43e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e440:	d000      	beq.n	e444 <AJNS_Producer_SendNotification+0x228>
    e442:	e288      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_RICH_CONTENT_ICON_URL_ATTRIBUTE_KEY);
    e444:	a82c      	add	r0, sp, #176	; 0xb0
    e446:	4952      	ldr	r1, [pc, #328]	; (e590 <AJNS_Producer_SendNotification+0x374>)
    e448:	2200      	movs	r2, #0
    e44a:	4b50      	ldr	r3, [pc, #320]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e44c:	4798      	blx	r3
    e44e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e450:	d000      	beq.n	e454 <AJNS_Producer_SendNotification+0x238>
    e452:	e280      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "s");
    e454:	a82c      	add	r0, sp, #176	; 0xb0
    e456:	494f      	ldr	r1, [pc, #316]	; (e594 <AJNS_Producer_SendNotification+0x378>)
    e458:	4b51      	ldr	r3, [pc, #324]	; (e5a0 <AJNS_Producer_SendNotification+0x384>)
    e45a:	4798      	blx	r3
    e45c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    e45e:	d000      	beq.n	e462 <AJNS_Producer_SendNotification+0x246>
    e460:	e279      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "s", notification->content->richIconUrl);
    e462:	a82c      	add	r0, sp, #176	; 0xb0
    e464:	494b      	ldr	r1, [pc, #300]	; (e594 <AJNS_Producer_SendNotification+0x378>)
    e466:	9b04      	ldr	r3, [sp, #16]
    e468:	699a      	ldr	r2, [r3, #24]
    e46a:	4b48      	ldr	r3, [pc, #288]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e46c:	4798      	blx	r3
    e46e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e470:	d000      	beq.n	e474 <AJNS_Producer_SendNotification+0x258>
    e472:	e270      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &dictArg);
    e474:	a82c      	add	r0, sp, #176	; 0xb0
    e476:	a918      	add	r1, sp, #96	; 0x60
    e478:	4b4a      	ldr	r3, [pc, #296]	; (e5a4 <AJNS_Producer_SendNotification+0x388>)
    e47a:	4798      	blx	r3
    e47c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e47e:	d000      	beq.n	e482 <AJNS_Producer_SendNotification+0x266>
    e480:	e269      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }
    if (notification->content->numAudioUrls > 0) 
    e482:	9b04      	ldr	r3, [sp, #16]
    e484:	7c1b      	ldrb	r3, [r3, #16]
    e486:	b25b      	sxtb	r3, r3
    e488:	2b00      	cmp	r3, #0
    e48a:	dc00      	bgt.n	e48e <AJNS_Producer_SendNotification+0x272>
    e48c:	e0c1      	b.n	e612 <AJNS_Producer_SendNotification+0x3f6>
	{
        status = AJ_MarshalContainer(msg, &richAudioArray, AJ_ARG_DICT_ENTRY);
    e48e:	a82c      	add	r0, sp, #176	; 0xb0
    e490:	a914      	add	r1, sp, #80	; 0x50
    e492:	227b      	movs	r2, #123	; 0x7b
    e494:	4b41      	ldr	r3, [pc, #260]	; (e59c <AJNS_Producer_SendNotification+0x380>)
    e496:	4798      	blx	r3
    e498:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e49a:	d000      	beq.n	e49e <AJNS_Producer_SendNotification+0x282>
    e49c:	e25b      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_RICH_CONTENT_AUDIO_URL_ATTRIBUTE_KEY);
    e49e:	a82c      	add	r0, sp, #176	; 0xb0
    e4a0:	493b      	ldr	r1, [pc, #236]	; (e590 <AJNS_Producer_SendNotification+0x374>)
    e4a2:	2201      	movs	r2, #1
    e4a4:	4b39      	ldr	r3, [pc, #228]	; (e58c <AJNS_Producer_SendNotification+0x370>)
    e4a6:	4798      	blx	r3
    e4a8:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e4aa:	d000      	beq.n	e4ae <AJNS_Producer_SendNotification+0x292>
    e4ac:	e253      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "a(ss)");
    e4ae:	a82c      	add	r0, sp, #176	; 0xb0
    e4b0:	493d      	ldr	r1, [pc, #244]	; (e5a8 <AJNS_Producer_SendNotification+0x38c>)
    e4b2:	4b3b      	ldr	r3, [pc, #236]	; (e5a0 <AJNS_Producer_SendNotification+0x384>)
    e4b4:	4798      	blx	r3
    e4b6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e4b8:	d000      	beq.n	e4bc <AJNS_Producer_SendNotification+0x2a0>
    e4ba:	e24c      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalContainer(msg, &richAudioAttrArray, AJ_ARG_ARRAY);
    e4bc:	a82c      	add	r0, sp, #176	; 0xb0
    e4be:	a928      	add	r1, sp, #160	; 0xa0
    e4c0:	2261      	movs	r2, #97	; 0x61
    e4c2:	4b36      	ldr	r3, [pc, #216]	; (e59c <AJNS_Producer_SendNotification+0x380>)
    e4c4:	4798      	blx	r3
    e4c6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e4c8:	d000      	beq.n	e4cc <AJNS_Producer_SendNotification+0x2b0>
    e4ca:	e244      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e4cc:	2500      	movs	r5, #0
    e4ce:	46b0      	mov	r8, r6
    e4d0:	9e04      	ldr	r6, [sp, #16]
    e4d2:	e089      	b.n	e5e8 <AJNS_Producer_SendNotification+0x3cc>
            goto ErrorExit;
        }

        for (indx = 0; indx < notification->content->numAudioUrls; indx++) 
		{
            if ((strlen(notification->content->richAudioUrls[indx].key) == 0) || (strlen(notification->content->richAudioUrls[indx].value) == 0)) 
    e4d4:	b26b      	sxtb	r3, r5
    e4d6:	00db      	lsls	r3, r3, #3
    e4d8:	4699      	mov	r9, r3
    e4da:	6973      	ldr	r3, [r6, #20]
    e4dc:	444b      	add	r3, r9
    e4de:	681a      	ldr	r2, [r3, #0]
    e4e0:	7812      	ldrb	r2, [r2, #0]
    e4e2:	2a00      	cmp	r2, #0
    e4e4:	d003      	beq.n	e4ee <AJNS_Producer_SendNotification+0x2d2>
    e4e6:	685b      	ldr	r3, [r3, #4]
    e4e8:	781b      	ldrb	r3, [r3, #0]
    e4ea:	2b00      	cmp	r3, #0
    e4ec:	d160      	bne.n	e5b0 <AJNS_Producer_SendNotification+0x394>
    e4ee:	4646      	mov	r6, r8
			{
                AJ_ErrPrintf(("Rich Audio Language/Url can not be empty\n"));
    e4f0:	2001      	movs	r0, #1
    e4f2:	4909      	ldr	r1, [pc, #36]	; (e518 <AJNS_Producer_SendNotification+0x2fc>)
    e4f4:	2230      	movs	r2, #48	; 0x30
    e4f6:	32ff      	adds	r2, #255	; 0xff
    e4f8:	4b09      	ldr	r3, [pc, #36]	; (e520 <AJNS_Producer_SendNotification+0x304>)
    e4fa:	4798      	blx	r3
    e4fc:	2800      	cmp	r0, #0
    e4fe:	d002      	beq.n	e506 <AJNS_Producer_SendNotification+0x2ea>
    e500:	482a      	ldr	r0, [pc, #168]	; (e5ac <AJNS_Producer_SendNotification+0x390>)
    e502:	4b09      	ldr	r3, [pc, #36]	; (e528 <AJNS_Producer_SendNotification+0x30c>)
    e504:	4798      	blx	r3
                AJ_MarshalCloseContainer(msg, &richAudioArray);
    e506:	a82c      	add	r0, sp, #176	; 0xb0
    e508:	a914      	add	r1, sp, #80	; 0x50
    e50a:	4b26      	ldr	r3, [pc, #152]	; (e5a4 <AJNS_Producer_SendNotification+0x388>)
    e50c:	4798      	blx	r3
                status = AJ_ERR_DISALLOWED;
    e50e:	2412      	movs	r4, #18
    e510:	e221      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e512:	46c0      	nop			; (mov r8, r8)
    e514:	0001f9c0 	.word	0x0001f9c0
    e518:	0001fba0 	.word	0x0001fba0
    e51c:	0000024b 	.word	0x0000024b
    e520:	0000636d 	.word	0x0000636d
    e524:	0001fbd4 	.word	0x0001fbd4
    e528:	00016f5d 	.word	0x00016f5d
    e52c:	0001fb38 	.word	0x0001fb38
    e530:	0001fb3a 	.word	0x0001fb3a
    e534:	00000252 	.word	0x00000252
    e538:	0001fc0c 	.word	0x0001fc0c
    e53c:	00016e3d 	.word	0x00016e3d
    e540:	00000e39 	.word	0x00000e39
    e544:	0001d368 	.word	0x0001d368
    e548:	00000e49 	.word	0x00000e49
    e54c:	00000dc1 	.word	0x00000dc1
    e550:	0000025e 	.word	0x0000025e
    e554:	0001fc30 	.word	0x0001fc30
    e558:	00000265 	.word	0x00000265
    e55c:	0001fc64 	.word	0x0001fc64
    e560:	000028e9 	.word	0x000028e9
    e564:	0000026f 	.word	0x0000026f
    e568:	0001fc98 	.word	0x0001fc98
    e56c:	00000275 	.word	0x00000275
    e570:	0001fcb8 	.word	0x0001fcb8
    e574:	20001278 	.word	0x20001278
    e578:	0000d6a9 	.word	0x0000d6a9
    e57c:	05000100 	.word	0x05000100
    e580:	0000bcfd 	.word	0x0000bcfd
    e584:	0001fa8c 	.word	0x0001fa8c
    e588:	0001eda8 	.word	0x0001eda8
    e58c:	0000bc85 	.word	0x0000bc85
    e590:	0001a4e0 	.word	0x0001a4e0
    e594:	0001f054 	.word	0x0001f054
    e598:	0000ebfd 	.word	0x0000ebfd
    e59c:	0000b8a1 	.word	0x0000b8a1
    e5a0:	0000b9fd 	.word	0x0000b9fd
    e5a4:	0000b8d1 	.word	0x0000b8d1
    e5a8:	0001fcd8 	.word	0x0001fcd8
    e5ac:	0001fce0 	.word	0x0001fce0
                goto ErrorExit;
            }
            status = AJ_MarshalContainer(msg, &audioStructArg, AJ_ARG_STRUCT);
    e5b0:	a82c      	add	r0, sp, #176	; 0xb0
    e5b2:	a924      	add	r1, sp, #144	; 0x90
    e5b4:	2228      	movs	r2, #40	; 0x28
    e5b6:	4bc4      	ldr	r3, [pc, #784]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e5b8:	4798      	blx	r3
    e5ba:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    e5bc:	d000      	beq.n	e5c0 <AJNS_Producer_SendNotification+0x3a4>
    e5be:	e1b9      	b.n	e934 <AJNS_Producer_SendNotification+0x718>
			{
                goto ErrorExit;
            }
            status = AJ_MarshalArgs(msg, "ss", notification->content->richAudioUrls[indx].key, notification->content->richAudioUrls[indx].value);
    e5c0:	6973      	ldr	r3, [r6, #20]
    e5c2:	444b      	add	r3, r9
    e5c4:	a82c      	add	r0, sp, #176	; 0xb0
    e5c6:	49c1      	ldr	r1, [pc, #772]	; (e8cc <AJNS_Producer_SendNotification+0x6b0>)
    e5c8:	681a      	ldr	r2, [r3, #0]
    e5ca:	685b      	ldr	r3, [r3, #4]
    e5cc:	4cc0      	ldr	r4, [pc, #768]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e5ce:	47a0      	blx	r4
    e5d0:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    e5d2:	d000      	beq.n	e5d6 <AJNS_Producer_SendNotification+0x3ba>
    e5d4:	e1b0      	b.n	e938 <AJNS_Producer_SendNotification+0x71c>
			{
                goto ErrorExit;
            }
            status = AJ_MarshalCloseContainer(msg, &audioStructArg);
    e5d6:	a82c      	add	r0, sp, #176	; 0xb0
    e5d8:	a924      	add	r1, sp, #144	; 0x90
    e5da:	4bbe      	ldr	r3, [pc, #760]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e5dc:	4798      	blx	r3
    e5de:	1e04      	subs	r4, r0, #0
            if (status != AJ_OK) 
    e5e0:	d000      	beq.n	e5e4 <AJNS_Producer_SendNotification+0x3c8>
    e5e2:	e1ab      	b.n	e93c <AJNS_Producer_SendNotification+0x720>
    e5e4:	3501      	adds	r5, #1
    e5e6:	b2ed      	uxtb	r5, r5
        if (status != AJ_OK) 
		{
            goto ErrorExit;
        }

        for (indx = 0; indx < notification->content->numAudioUrls; indx++) 
    e5e8:	2210      	movs	r2, #16
    e5ea:	56b2      	ldrsb	r2, [r6, r2]
    e5ec:	b26b      	sxtb	r3, r5
    e5ee:	429a      	cmp	r2, r3
    e5f0:	dd00      	ble.n	e5f4 <AJNS_Producer_SendNotification+0x3d8>
    e5f2:	e76f      	b.n	e4d4 <AJNS_Producer_SendNotification+0x2b8>
    e5f4:	4646      	mov	r6, r8
			{
                goto ErrorExit;
            }
        }

        status = AJ_MarshalCloseContainer(msg, &richAudioAttrArray);
    e5f6:	a82c      	add	r0, sp, #176	; 0xb0
    e5f8:	a928      	add	r1, sp, #160	; 0xa0
    e5fa:	4bb6      	ldr	r3, [pc, #728]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e5fc:	4798      	blx	r3
    e5fe:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e600:	d000      	beq.n	e604 <AJNS_Producer_SendNotification+0x3e8>
    e602:	e1a8      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }

        status = AJ_MarshalCloseContainer(msg, &richAudioArray);
    e604:	a82c      	add	r0, sp, #176	; 0xb0
    e606:	a914      	add	r1, sp, #80	; 0x50
    e608:	4bb2      	ldr	r3, [pc, #712]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e60a:	4798      	blx	r3
    e60c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    e60e:	d000      	beq.n	e612 <AJNS_Producer_SendNotification+0x3f6>
    e610:	e1a1      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }

    if (notification->content->richIconObjectPath != 0) 
    e612:	9b04      	ldr	r3, [sp, #16]
    e614:	69db      	ldr	r3, [r3, #28]
    e616:	9305      	str	r3, [sp, #20]
    e618:	2b00      	cmp	r3, #0
    e61a:	d026      	beq.n	e66a <AJNS_Producer_SendNotification+0x44e>
	{
        status = AJ_MarshalContainer(msg, &dictArg, AJ_ARG_DICT_ENTRY);
    e61c:	a82c      	add	r0, sp, #176	; 0xb0
    e61e:	a918      	add	r1, sp, #96	; 0x60
    e620:	227b      	movs	r2, #123	; 0x7b
    e622:	4ba9      	ldr	r3, [pc, #676]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e624:	4798      	blx	r3
    e626:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e628:	d000      	beq.n	e62c <AJNS_Producer_SendNotification+0x410>
    e62a:	e194      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_RICH_CONTENT_ICON_OBJECT_PATH_ATTRIBUTE_KEY);
    e62c:	a82c      	add	r0, sp, #176	; 0xb0
    e62e:	49aa      	ldr	r1, [pc, #680]	; (e8d8 <AJNS_Producer_SendNotification+0x6bc>)
    e630:	2202      	movs	r2, #2
    e632:	4ba7      	ldr	r3, [pc, #668]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e634:	4798      	blx	r3
    e636:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e638:	d000      	beq.n	e63c <AJNS_Producer_SendNotification+0x420>
    e63a:	e18c      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "s");
    e63c:	a82c      	add	r0, sp, #176	; 0xb0
    e63e:	49a7      	ldr	r1, [pc, #668]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e640:	4ba7      	ldr	r3, [pc, #668]	; (e8e0 <AJNS_Producer_SendNotification+0x6c4>)
    e642:	4798      	blx	r3
    e644:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e646:	d000      	beq.n	e64a <AJNS_Producer_SendNotification+0x42e>
    e648:	e185      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "s", notification->content->richIconObjectPath);
    e64a:	a82c      	add	r0, sp, #176	; 0xb0
    e64c:	49a3      	ldr	r1, [pc, #652]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e64e:	9b04      	ldr	r3, [sp, #16]
    e650:	69da      	ldr	r2, [r3, #28]
    e652:	4b9f      	ldr	r3, [pc, #636]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e654:	4798      	blx	r3
    e656:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e658:	d000      	beq.n	e65c <AJNS_Producer_SendNotification+0x440>
    e65a:	e17c      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &dictArg);
    e65c:	a82c      	add	r0, sp, #176	; 0xb0
    e65e:	a918      	add	r1, sp, #96	; 0x60
    e660:	4b9c      	ldr	r3, [pc, #624]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e662:	4798      	blx	r3
    e664:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e666:	d000      	beq.n	e66a <AJNS_Producer_SendNotification+0x44e>
    e668:	e175      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }

    if (notification->content->richAudioObjectPath != 0) 
    e66a:	9b04      	ldr	r3, [sp, #16]
    e66c:	6a1b      	ldr	r3, [r3, #32]
    e66e:	9305      	str	r3, [sp, #20]
    e670:	2b00      	cmp	r3, #0
    e672:	d026      	beq.n	e6c2 <AJNS_Producer_SendNotification+0x4a6>
	{
        status = AJ_MarshalContainer(msg, &dictArg, AJ_ARG_DICT_ENTRY);
    e674:	a82c      	add	r0, sp, #176	; 0xb0
    e676:	a918      	add	r1, sp, #96	; 0x60
    e678:	227b      	movs	r2, #123	; 0x7b
    e67a:	4b93      	ldr	r3, [pc, #588]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e67c:	4798      	blx	r3
    e67e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e680:	d000      	beq.n	e684 <AJNS_Producer_SendNotification+0x468>
    e682:	e168      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_RICH_CONTENT_AUDIO_OBJECT_PATH_ATTRIBUTE_KEY);
    e684:	a82c      	add	r0, sp, #176	; 0xb0
    e686:	4994      	ldr	r1, [pc, #592]	; (e8d8 <AJNS_Producer_SendNotification+0x6bc>)
    e688:	2203      	movs	r2, #3
    e68a:	4b91      	ldr	r3, [pc, #580]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e68c:	4798      	blx	r3
    e68e:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e690:	d000      	beq.n	e694 <AJNS_Producer_SendNotification+0x478>
    e692:	e160      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "s");
    e694:	a82c      	add	r0, sp, #176	; 0xb0
    e696:	4991      	ldr	r1, [pc, #580]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e698:	4b91      	ldr	r3, [pc, #580]	; (e8e0 <AJNS_Producer_SendNotification+0x6c4>)
    e69a:	4798      	blx	r3
    e69c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e69e:	d000      	beq.n	e6a2 <AJNS_Producer_SendNotification+0x486>
    e6a0:	e159      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "s", notification->content->richAudioObjectPath);
    e6a2:	a82c      	add	r0, sp, #176	; 0xb0
    e6a4:	498d      	ldr	r1, [pc, #564]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e6a6:	9b04      	ldr	r3, [sp, #16]
    e6a8:	6a1a      	ldr	r2, [r3, #32]
    e6aa:	4b89      	ldr	r3, [pc, #548]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e6ac:	4798      	blx	r3
    e6ae:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e6b0:	d000      	beq.n	e6b4 <AJNS_Producer_SendNotification+0x498>
    e6b2:	e150      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &dictArg);
    e6b4:	a82c      	add	r0, sp, #176	; 0xb0
    e6b6:	a918      	add	r1, sp, #96	; 0x60
    e6b8:	4b86      	ldr	r3, [pc, #536]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e6ba:	4798      	blx	r3
    e6bc:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e6be:	d000      	beq.n	e6c2 <AJNS_Producer_SendNotification+0x4a6>
    e6c0:	e149      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }

    if (notification->content->controlPanelServiceObjectPath != 0) 
    e6c2:	9b04      	ldr	r3, [sp, #16]
    e6c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    e6c6:	9305      	str	r3, [sp, #20]
    e6c8:	2b00      	cmp	r3, #0
    e6ca:	d026      	beq.n	e71a <AJNS_Producer_SendNotification+0x4fe>
	{
        status = AJ_MarshalContainer(msg, &dictArg, AJ_ARG_DICT_ENTRY);
    e6cc:	a82c      	add	r0, sp, #176	; 0xb0
    e6ce:	a918      	add	r1, sp, #96	; 0x60
    e6d0:	227b      	movs	r2, #123	; 0x7b
    e6d2:	4b7d      	ldr	r3, [pc, #500]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e6d4:	4798      	blx	r3
    e6d6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e6d8:	d000      	beq.n	e6dc <AJNS_Producer_SendNotification+0x4c0>
    e6da:	e13c      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_CONTROLPANELSERVICE_OBJECT_PATH_ATTRIBUTE_KEY);
    e6dc:	a82c      	add	r0, sp, #176	; 0xb0
    e6de:	497e      	ldr	r1, [pc, #504]	; (e8d8 <AJNS_Producer_SendNotification+0x6bc>)
    e6e0:	2204      	movs	r2, #4
    e6e2:	4b7b      	ldr	r3, [pc, #492]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e6e4:	4798      	blx	r3
    e6e6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e6e8:	d000      	beq.n	e6ec <AJNS_Producer_SendNotification+0x4d0>
    e6ea:	e134      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "s");
    e6ec:	a82c      	add	r0, sp, #176	; 0xb0
    e6ee:	497b      	ldr	r1, [pc, #492]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e6f0:	4b7b      	ldr	r3, [pc, #492]	; (e8e0 <AJNS_Producer_SendNotification+0x6c4>)
    e6f2:	4798      	blx	r3
    e6f4:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e6f6:	d000      	beq.n	e6fa <AJNS_Producer_SendNotification+0x4de>
    e6f8:	e12d      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "s", notification->content->controlPanelServiceObjectPath);
    e6fa:	a82c      	add	r0, sp, #176	; 0xb0
    e6fc:	4977      	ldr	r1, [pc, #476]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e6fe:	9b04      	ldr	r3, [sp, #16]
    e700:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    e702:	4b73      	ldr	r3, [pc, #460]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e704:	4798      	blx	r3
    e706:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e708:	d000      	beq.n	e70c <AJNS_Producer_SendNotification+0x4f0>
    e70a:	e124      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &dictArg);
    e70c:	a82c      	add	r0, sp, #176	; 0xb0
    e70e:	a918      	add	r1, sp, #96	; 0x60
    e710:	4b70      	ldr	r3, [pc, #448]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e712:	4798      	blx	r3
    e714:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e716:	d000      	beq.n	e71a <AJNS_Producer_SendNotification+0x4fe>
    e718:	e11d      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }

    if (notification->version > 1) 
    e71a:	2f01      	cmp	r7, #1
    e71c:	d925      	bls.n	e76a <AJNS_Producer_SendNotification+0x54e>
	{
        status = AJ_MarshalContainer(msg, &dictArg, AJ_ARG_DICT_ENTRY);
    e71e:	a82c      	add	r0, sp, #176	; 0xb0
    e720:	a918      	add	r1, sp, #96	; 0x60
    e722:	227b      	movs	r2, #123	; 0x7b
    e724:	4b68      	ldr	r3, [pc, #416]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e726:	4798      	blx	r3
    e728:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    e72a:	d000      	beq.n	e72e <AJNS_Producer_SendNotification+0x512>
    e72c:	e113      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "i", AJNS_ORIGINAL_SENDER_NAME_ATTRIBUTE_KEY);
    e72e:	a82c      	add	r0, sp, #176	; 0xb0
    e730:	4969      	ldr	r1, [pc, #420]	; (e8d8 <AJNS_Producer_SendNotification+0x6bc>)
    e732:	2205      	movs	r2, #5
    e734:	4b66      	ldr	r3, [pc, #408]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e736:	4798      	blx	r3
    e738:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e73a:	d000      	beq.n	e73e <AJNS_Producer_SendNotification+0x522>
    e73c:	e10b      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalVariant(msg, "s");
    e73e:	a82c      	add	r0, sp, #176	; 0xb0
    e740:	4966      	ldr	r1, [pc, #408]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e742:	4b67      	ldr	r3, [pc, #412]	; (e8e0 <AJNS_Producer_SendNotification+0x6c4>)
    e744:	4798      	blx	r3
    e746:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e748:	d000      	beq.n	e74c <AJNS_Producer_SendNotification+0x530>
    e74a:	e104      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "s", notification->originalSenderName);
    e74c:	a82c      	add	r0, sp, #176	; 0xb0
    e74e:	4963      	ldr	r1, [pc, #396]	; (e8dc <AJNS_Producer_SendNotification+0x6c0>)
    e750:	9a07      	ldr	r2, [sp, #28]
    e752:	4b5f      	ldr	r3, [pc, #380]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e754:	4798      	blx	r3
    e756:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e758:	d000      	beq.n	e75c <AJNS_Producer_SendNotification+0x540>
    e75a:	e0fc      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &dictArg);
    e75c:	a82c      	add	r0, sp, #176	; 0xb0
    e75e:	a918      	add	r1, sp, #96	; 0x60
    e760:	4b5c      	ldr	r3, [pc, #368]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e762:	4798      	blx	r3
    e764:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e766:	d000      	beq.n	e76a <AJNS_Producer_SendNotification+0x54e>
    e768:	e0f5      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
		{
            goto ErrorExit;
        }
    }

    status = AJ_MarshalCloseContainer(msg, &attrbtArray);
    e76a:	a82c      	add	r0, sp, #176	; 0xb0
    e76c:	a908      	add	r1, sp, #32
    e76e:	4b59      	ldr	r3, [pc, #356]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e770:	4798      	blx	r3
    e772:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e774:	d000      	beq.n	e778 <AJNS_Producer_SendNotification+0x55c>
    e776:	e0ee      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////    Custom Attributes   ///////////////////
    status = AJ_MarshalContainer(msg, &customAttributeArray, AJ_ARG_ARRAY);
    e778:	a82c      	add	r0, sp, #176	; 0xb0
    e77a:	a90c      	add	r1, sp, #48	; 0x30
    e77c:	2261      	movs	r2, #97	; 0x61
    e77e:	4b52      	ldr	r3, [pc, #328]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e780:	4798      	blx	r3
    e782:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e784:	d000      	beq.n	e788 <AJNS_Producer_SendNotification+0x56c>
    e786:	e0e6      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e788:	2500      	movs	r5, #0
        goto ErrorExit;
    }

    for (indx = 0; indx < notification->content->numCustomAttributes; indx++) 
	{
        status = AJ_MarshalContainer(msg, &customAttributeDictArg, AJ_ARG_DICT_ENTRY);
    e78a:	277b      	movs	r7, #123	; 0x7b
    e78c:	46b0      	mov	r8, r6
    e78e:	9e04      	ldr	r6, [sp, #16]
    e790:	e01e      	b.n	e7d0 <AJNS_Producer_SendNotification+0x5b4>
    e792:	a82c      	add	r0, sp, #176	; 0xb0
    e794:	a91c      	add	r1, sp, #112	; 0x70
    e796:	1c3a      	adds	r2, r7, #0
    e798:	4b4b      	ldr	r3, [pc, #300]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e79a:	4798      	blx	r3
    e79c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e79e:	d000      	beq.n	e7a2 <AJNS_Producer_SendNotification+0x586>
    e7a0:	e0ce      	b.n	e940 <AJNS_Producer_SendNotification+0x724>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "ss", notification->content->customAttributes[indx].key, notification->content->customAttributes[indx].value);
    e7a2:	b26b      	sxtb	r3, r5
    e7a4:	00db      	lsls	r3, r3, #3
    e7a6:	6872      	ldr	r2, [r6, #4]
    e7a8:	4694      	mov	ip, r2
    e7aa:	4463      	add	r3, ip
    e7ac:	a82c      	add	r0, sp, #176	; 0xb0
    e7ae:	4947      	ldr	r1, [pc, #284]	; (e8cc <AJNS_Producer_SendNotification+0x6b0>)
    e7b0:	681a      	ldr	r2, [r3, #0]
    e7b2:	685b      	ldr	r3, [r3, #4]
    e7b4:	4c46      	ldr	r4, [pc, #280]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e7b6:	47a0      	blx	r4
    e7b8:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e7ba:	d000      	beq.n	e7be <AJNS_Producer_SendNotification+0x5a2>
    e7bc:	e0c2      	b.n	e944 <AJNS_Producer_SendNotification+0x728>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &customAttributeDictArg);
    e7be:	a82c      	add	r0, sp, #176	; 0xb0
    e7c0:	a91c      	add	r1, sp, #112	; 0x70
    e7c2:	4b44      	ldr	r3, [pc, #272]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e7c4:	4798      	blx	r3
    e7c6:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK)
    e7c8:	d000      	beq.n	e7cc <AJNS_Producer_SendNotification+0x5b0>
    e7ca:	e0bd      	b.n	e948 <AJNS_Producer_SendNotification+0x72c>
    e7cc:	3501      	adds	r5, #1
    e7ce:	b2ed      	uxtb	r5, r5
    if (status != AJ_OK) 
	{
        goto ErrorExit;
    }

    for (indx = 0; indx < notification->content->numCustomAttributes; indx++) 
    e7d0:	2200      	movs	r2, #0
    e7d2:	56b2      	ldrsb	r2, [r6, r2]
    e7d4:	b26b      	sxtb	r3, r5
    e7d6:	429a      	cmp	r2, r3
    e7d8:	dcdb      	bgt.n	e792 <AJNS_Producer_SendNotification+0x576>
    e7da:	4646      	mov	r6, r8
		{
            goto ErrorExit;
        }
    }

    status = AJ_MarshalCloseContainer(msg, &customAttributeArray);
    e7dc:	a82c      	add	r0, sp, #176	; 0xb0
    e7de:	a90c      	add	r1, sp, #48	; 0x30
    e7e0:	4b3c      	ldr	r3, [pc, #240]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e7e2:	4798      	blx	r3
    e7e4:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e7e6:	d000      	beq.n	e7ea <AJNS_Producer_SendNotification+0x5ce>
    e7e8:	e0b5      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
	{
        goto ErrorExit;
    }

    ///////////////////   Notifications   ////////////////////////////
    status = AJ_MarshalContainer(msg, &notTextArray, AJ_ARG_ARRAY);
    e7ea:	a82c      	add	r0, sp, #176	; 0xb0
    e7ec:	a910      	add	r1, sp, #64	; 0x40
    e7ee:	2261      	movs	r2, #97	; 0x61
    e7f0:	4b35      	ldr	r3, [pc, #212]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e7f2:	4798      	blx	r3
    e7f4:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e7f6:	d000      	beq.n	e7fa <AJNS_Producer_SendNotification+0x5de>
    e7f8:	e0ad      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e7fa:	2500      	movs	r5, #0
    e7fc:	9f04      	ldr	r7, [sp, #16]
    e7fe:	1c2e      	adds	r6, r5, #0
    e800:	e038      	b.n	e874 <AJNS_Producer_SendNotification+0x658>
        goto ErrorExit;
    }

    for (indx = 0; indx < notification->content->numTexts; indx++) 
	{
        if ((strlen(notification->content->texts[indx].key) == 0) || (strlen(notification->content->texts[indx].value) == 0)) 
    e802:	b275      	sxtb	r5, r6
    e804:	00ed      	lsls	r5, r5, #3
    e806:	68fb      	ldr	r3, [r7, #12]
    e808:	195b      	adds	r3, r3, r5
    e80a:	681a      	ldr	r2, [r3, #0]
    e80c:	7812      	ldrb	r2, [r2, #0]
    e80e:	2a00      	cmp	r2, #0
    e810:	d003      	beq.n	e81a <AJNS_Producer_SendNotification+0x5fe>
    e812:	685b      	ldr	r3, [r3, #4]
    e814:	781b      	ldrb	r3, [r3, #0]
    e816:	2b00      	cmp	r3, #0
    e818:	d111      	bne.n	e83e <AJNS_Producer_SendNotification+0x622>
    e81a:	4646      	mov	r6, r8
		{
            AJ_ErrPrintf(("Language/Text can not be empty\n"));
    e81c:	2001      	movs	r0, #1
    e81e:	4931      	ldr	r1, [pc, #196]	; (e8e4 <AJNS_Producer_SendNotification+0x6c8>)
    e820:	22f8      	movs	r2, #248	; 0xf8
    e822:	32ff      	adds	r2, #255	; 0xff
    e824:	4b30      	ldr	r3, [pc, #192]	; (e8e8 <AJNS_Producer_SendNotification+0x6cc>)
    e826:	4798      	blx	r3
    e828:	2800      	cmp	r0, #0
    e82a:	d002      	beq.n	e832 <AJNS_Producer_SendNotification+0x616>
    e82c:	482f      	ldr	r0, [pc, #188]	; (e8ec <AJNS_Producer_SendNotification+0x6d0>)
    e82e:	4b30      	ldr	r3, [pc, #192]	; (e8f0 <AJNS_Producer_SendNotification+0x6d4>)
    e830:	4798      	blx	r3
            AJ_MarshalCloseContainer(msg, &notTextArray);
    e832:	a82c      	add	r0, sp, #176	; 0xb0
    e834:	a910      	add	r1, sp, #64	; 0x40
    e836:	4b27      	ldr	r3, [pc, #156]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e838:	4798      	blx	r3
            status = AJ_ERR_DISALLOWED;
    e83a:	2412      	movs	r4, #18
    e83c:	e08b      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
            goto ErrorExit;
        }
        status = AJ_MarshalContainer(msg, &structArg, AJ_ARG_STRUCT);
    e83e:	a82c      	add	r0, sp, #176	; 0xb0
    e840:	a920      	add	r1, sp, #128	; 0x80
    e842:	2228      	movs	r2, #40	; 0x28
    e844:	4b20      	ldr	r3, [pc, #128]	; (e8c8 <AJNS_Producer_SendNotification+0x6ac>)
    e846:	4798      	blx	r3
    e848:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e84a:	d000      	beq.n	e84e <AJNS_Producer_SendNotification+0x632>
    e84c:	e07e      	b.n	e94c <AJNS_Producer_SendNotification+0x730>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalArgs(msg, "ss", notification->content->texts[indx].key, notification->content->texts[indx].value);
    e84e:	68fb      	ldr	r3, [r7, #12]
    e850:	469c      	mov	ip, r3
    e852:	4465      	add	r5, ip
    e854:	a82c      	add	r0, sp, #176	; 0xb0
    e856:	491d      	ldr	r1, [pc, #116]	; (e8cc <AJNS_Producer_SendNotification+0x6b0>)
    e858:	682a      	ldr	r2, [r5, #0]
    e85a:	686b      	ldr	r3, [r5, #4]
    e85c:	4c1c      	ldr	r4, [pc, #112]	; (e8d0 <AJNS_Producer_SendNotification+0x6b4>)
    e85e:	47a0      	blx	r4
    e860:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e862:	d175      	bne.n	e950 <AJNS_Producer_SendNotification+0x734>
		{
            goto ErrorExit;
        }
        status = AJ_MarshalCloseContainer(msg, &structArg);
    e864:	a82c      	add	r0, sp, #176	; 0xb0
    e866:	a920      	add	r1, sp, #128	; 0x80
    e868:	4b1a      	ldr	r3, [pc, #104]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e86a:	4798      	blx	r3
    e86c:	1e04      	subs	r4, r0, #0
        if (status != AJ_OK) 
    e86e:	d171      	bne.n	e954 <AJNS_Producer_SendNotification+0x738>
    e870:	3601      	adds	r6, #1
    e872:	b2f6      	uxtb	r6, r6
    if (status != AJ_OK) 
	{
        goto ErrorExit;
    }

    for (indx = 0; indx < notification->content->numTexts; indx++) 
    e874:	2208      	movs	r2, #8
    e876:	56ba      	ldrsb	r2, [r7, r2]
    e878:	b273      	sxtb	r3, r6
    e87a:	429a      	cmp	r2, r3
    e87c:	dcc1      	bgt.n	e802 <AJNS_Producer_SendNotification+0x5e6>
    e87e:	4646      	mov	r6, r8
		{
            goto ErrorExit;
        }
    }

    status = AJ_MarshalCloseContainer(msg, &notTextArray);
    e880:	a82c      	add	r0, sp, #176	; 0xb0
    e882:	a910      	add	r1, sp, #64	; 0x40
    e884:	4b13      	ldr	r3, [pc, #76]	; (e8d4 <AJNS_Producer_SendNotification+0x6b8>)
    e886:	4798      	blx	r3
    e888:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e88a:	d164      	bne.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e88c:	e008      	b.n	e8a0 <AJNS_Producer_SendNotification+0x684>

    return AJ_OK;

ErrorExit:

    AJ_ErrPrintf(("MarshalNotification failed: '%s'\n", AJ_StatusText(status)));
    e88e:	1c20      	adds	r0, r4, #0
    e890:	4b18      	ldr	r3, [pc, #96]	; (e8f4 <AJNS_Producer_SendNotification+0x6d8>)
    e892:	4798      	blx	r3
    e894:	1c01      	adds	r1, r0, #0
    e896:	4818      	ldr	r0, [pc, #96]	; (e8f8 <AJNS_Producer_SendNotification+0x6dc>)
    e898:	4b18      	ldr	r3, [pc, #96]	; (e8fc <AJNS_Producer_SendNotification+0x6e0>)
    e89a:	4798      	blx	r3
    AJ_Message msg;
    uint32_t serialNum;

//    AJ_InfoPrintf(("In SendNotifySignal\n"));
    status = AJNS_Producer_MarshalNotificationMsg(busAttachment, &msg, notification, ttl);
    if (status != AJ_OK) 
    e89c:	2c00      	cmp	r4, #0
    e89e:	d161      	bne.n	e964 <AJNS_Producer_SendNotification+0x748>
	{
 //       AJ_InfoPrintf(("Could not Marshal Message\n"));
        return status;
    }
    serialNum = msg.hdr->serialNum;
    e8a0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    e8a2:	689c      	ldr	r4, [r3, #8]
    status = AJ_DeliverMsg(&msg);
    e8a4:	a82c      	add	r0, sp, #176	; 0xb0
    e8a6:	4b16      	ldr	r3, [pc, #88]	; (e900 <AJNS_Producer_SendNotification+0x6e4>)
    e8a8:	4798      	blx	r3
    e8aa:	1e05      	subs	r5, r0, #0
    if (status != AJ_OK) 
    e8ac:	d02e      	beq.n	e90c <AJNS_Producer_SendNotification+0x6f0>
	{
        AJ_ErrPrintf(("Could not Deliver Message\n"));
    e8ae:	2001      	movs	r0, #1
    e8b0:	490c      	ldr	r1, [pc, #48]	; (e8e4 <AJNS_Producer_SendNotification+0x6c8>)
    e8b2:	4a14      	ldr	r2, [pc, #80]	; (e904 <AJNS_Producer_SendNotification+0x6e8>)
    e8b4:	4b0c      	ldr	r3, [pc, #48]	; (e8e8 <AJNS_Producer_SendNotification+0x6cc>)
    e8b6:	4798      	blx	r3
        return status;
    e8b8:	1c2c      	adds	r4, r5, #0
    }
    serialNum = msg.hdr->serialNum;
    status = AJ_DeliverMsg(&msg);
    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Could not Deliver Message\n"));
    e8ba:	2800      	cmp	r0, #0
    e8bc:	d052      	beq.n	e964 <AJNS_Producer_SendNotification+0x748>
    e8be:	4812      	ldr	r0, [pc, #72]	; (e908 <AJNS_Producer_SendNotification+0x6ec>)
    e8c0:	4b0b      	ldr	r3, [pc, #44]	; (e8f0 <AJNS_Producer_SendNotification+0x6d4>)
    e8c2:	4798      	blx	r3
    e8c4:	e04e      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e8c6:	46c0      	nop			; (mov r8, r8)
    e8c8:	0000b8a1 	.word	0x0000b8a1
    e8cc:	00018490 	.word	0x00018490
    e8d0:	0000bc85 	.word	0x0000bc85
    e8d4:	0000b8d1 	.word	0x0000b8d1
    e8d8:	0001a4e0 	.word	0x0001a4e0
    e8dc:	0001f054 	.word	0x0001f054
    e8e0:	0000b9fd 	.word	0x0000b9fd
    e8e4:	0001fba0 	.word	0x0001fba0
    e8e8:	0000636d 	.word	0x0000636d
    e8ec:	0001fd0c 	.word	0x0001fd0c
    e8f0:	00016f5d 	.word	0x00016f5d
    e8f4:	000063c5 	.word	0x000063c5
    e8f8:	0001fd2c 	.word	0x0001fd2c
    e8fc:	00016e3d 	.word	0x00016e3d
    e900:	0000a539 	.word	0x0000a539
    e904:	0000022f 	.word	0x0000022f
    e908:	0001faa8 	.word	0x0001faa8
    if (messageSerialNumber != NULL)
	{
        *messageSerialNumber = serialNum;
    }

    AJ_CloseMsg(&msg);
    e90c:	a82c      	add	r0, sp, #176	; 0xb0
    e90e:	4b19      	ldr	r3, [pc, #100]	; (e974 <AJNS_Producer_SendNotification+0x758>)
    e910:	4798      	blx	r3

    status = AJNS_Producer_SendNotifySignal(busAttachment, &notification, ttl, &serialNumber);

    if (status == AJ_OK) 
	{
        lastSentNotifications[messageType].notificationId = notificationId++;
    e912:	4b19      	ldr	r3, [pc, #100]	; (e978 <AJNS_Producer_SendNotification+0x75c>)
    e914:	681a      	ldr	r2, [r3, #0]
    e916:	1c51      	adds	r1, r2, #1
    e918:	6019      	str	r1, [r3, #0]
    e91a:	4b18      	ldr	r3, [pc, #96]	; (e97c <AJNS_Producer_SendNotification+0x760>)
    e91c:	00f6      	lsls	r6, r6, #3
    e91e:	50f2      	str	r2, [r6, r3]
        lastSentNotifications[messageType].serialNum = serialNumber;
    e920:	199e      	adds	r6, r3, r6
    e922:	6074      	str	r4, [r6, #4]
        if (messageSerialNumber != NULL) 
    e924:	9b46      	ldr	r3, [sp, #280]	; 0x118
    e926:	2b00      	cmp	r3, #0
    e928:	d002      	beq.n	e930 <AJNS_Producer_SendNotification+0x714>
		{
            *messageSerialNumber = serialNumber;
    e92a:	601c      	str	r4, [r3, #0]
        }
    }

    return status;
    e92c:	2400      	movs	r4, #0
    e92e:	e019      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e930:	2400      	movs	r4, #0
    e932:	e017      	b.n	e964 <AJNS_Producer_SendNotification+0x748>
    e934:	4646      	mov	r6, r8
    e936:	e00e      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e938:	4646      	mov	r6, r8
    e93a:	e00c      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e93c:	4646      	mov	r6, r8
    e93e:	e00a      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e940:	4646      	mov	r6, r8
    e942:	e008      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e944:	4646      	mov	r6, r8
    e946:	e006      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e948:	4646      	mov	r6, r8
    e94a:	e004      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e94c:	4646      	mov	r6, r8
    e94e:	e002      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e950:	4646      	mov	r6, r8
    e952:	e000      	b.n	e956 <AJNS_Producer_SendNotification+0x73a>
    e954:	4646      	mov	r6, r8

    return AJ_OK;

ErrorExit:

    AJ_ErrPrintf(("MarshalNotification failed: '%s'\n", AJ_StatusText(status)));
    e956:	2001      	movs	r0, #1
    e958:	4909      	ldr	r1, [pc, #36]	; (e980 <AJNS_Producer_SendNotification+0x764>)
    e95a:	4a0a      	ldr	r2, [pc, #40]	; (e984 <AJNS_Producer_SendNotification+0x768>)
    e95c:	4b0a      	ldr	r3, [pc, #40]	; (e988 <AJNS_Producer_SendNotification+0x76c>)
    e95e:	4798      	blx	r3
    e960:	2800      	cmp	r0, #0
    e962:	d194      	bne.n	e88e <AJNS_Producer_SendNotification+0x672>
            *messageSerialNumber = serialNumber;
        }
    }

    return status;
}
    e964:	1c20      	adds	r0, r4, #0
    e966:	b03d      	add	sp, #244	; 0xf4
    e968:	bc3c      	pop	{r2, r3, r4, r5}
    e96a:	4690      	mov	r8, r2
    e96c:	4699      	mov	r9, r3
    e96e:	46a2      	mov	sl, r4
    e970:	46ab      	mov	fp, r5
    e972:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e974:	0000a77d 	.word	0x0000a77d
    e978:	20001278 	.word	0x20001278
    e97c:	2000127c 	.word	0x2000127c
    e980:	0001fba0 	.word	0x0001fba0
    e984:	00000217 	.word	0x00000217
    e988:	0000636d 	.word	0x0000636d

0000e98c <AJNS_Producer_DismissRequestHandler>:

    return status;
}

AJ_Status AJNS_Producer_DismissRequestHandler(AJ_BusAttachment* busAttachment, AJ_Message* msg)
{
    e98c:	b570      	push	{r4, r5, r6, lr}
    e98e:	b092      	sub	sp, #72	; 0x48
    e990:	1c06      	adds	r6, r0, #0
    e992:	1c0d      	adds	r5, r1, #0
    int32_t notificationId;
    const char* appId;
    AJ_Message reply;

   // AJ_InfoPrintf(("In DismissMsg\n"));
    status = AJ_UnmarshalArgs(msg, "i", &notificationId);
    e994:	1c08      	adds	r0, r1, #0
    e996:	493e      	ldr	r1, [pc, #248]	; (ea90 <AJNS_Producer_DismissRequestHandler+0x104>)
    e998:	aa11      	add	r2, sp, #68	; 0x44
    e99a:	4b3e      	ldr	r3, [pc, #248]	; (ea94 <AJNS_Producer_DismissRequestHandler+0x108>)
    e99c:	4798      	blx	r3
    e99e:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    e9a0:	d00d      	beq.n	e9be <AJNS_Producer_DismissRequestHandler+0x32>
	{
        AJ_ErrPrintf(("Could not unmarshal message\n"));
    e9a2:	2001      	movs	r0, #1
    e9a4:	493c      	ldr	r1, [pc, #240]	; (ea98 <AJNS_Producer_DismissRequestHandler+0x10c>)
    e9a6:	22c9      	movs	r2, #201	; 0xc9
    e9a8:	0092      	lsls	r2, r2, #2
    e9aa:	4b3c      	ldr	r3, [pc, #240]	; (ea9c <AJNS_Producer_DismissRequestHandler+0x110>)
    e9ac:	4798      	blx	r3
        return status;
    e9ae:	1c23      	adds	r3, r4, #0

   // AJ_InfoPrintf(("In DismissMsg\n"));
    status = AJ_UnmarshalArgs(msg, "i", &notificationId);
    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Could not unmarshal message\n"));
    e9b0:	2800      	cmp	r0, #0
    e9b2:	d06a      	beq.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    e9b4:	483a      	ldr	r0, [pc, #232]	; (eaa0 <AJNS_Producer_DismissRequestHandler+0x114>)
    e9b6:	4b3b      	ldr	r3, [pc, #236]	; (eaa4 <AJNS_Producer_DismissRequestHandler+0x118>)
    e9b8:	4798      	blx	r3
        return status;
    e9ba:	1c23      	adds	r3, r4, #0
    e9bc:	e065      	b.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    }

    status = AJ_MarshalReplyMsg(msg, &reply);
    e9be:	1c28      	adds	r0, r5, #0
    e9c0:	a901      	add	r1, sp, #4
    e9c2:	4b39      	ldr	r3, [pc, #228]	; (eaa8 <AJNS_Producer_DismissRequestHandler+0x11c>)
    e9c4:	4798      	blx	r3
    if (status != AJ_OK) 
	{
        return status;
    e9c6:	1e03      	subs	r3, r0, #0
        AJ_ErrPrintf(("Could not unmarshal message\n"));
        return status;
    }

    status = AJ_MarshalReplyMsg(msg, &reply);
    if (status != AJ_OK) 
    e9c8:	d15f      	bne.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
	{
        return status;
    }

    status = AJ_DeliverMsg(&reply);
    e9ca:	a801      	add	r0, sp, #4
    e9cc:	4b37      	ldr	r3, [pc, #220]	; (eaac <AJNS_Producer_DismissRequestHandler+0x120>)
    e9ce:	4798      	blx	r3
    if (status != AJ_OK)
	 {
        return status;
    e9d0:	1e03      	subs	r3, r0, #0
	{
        return status;
    }

    status = AJ_DeliverMsg(&reply);
    if (status != AJ_OK)
    e9d2:	d15a      	bne.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
	 {
        return status;
    }

    appId = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_ID);
    e9d4:	3001      	adds	r0, #1
    e9d6:	4b36      	ldr	r3, [pc, #216]	; (eab0 <AJNS_Producer_DismissRequestHandler+0x124>)
    e9d8:	4798      	blx	r3
    e9da:	1c02      	adds	r2, r0, #0
    status = AJNS_SendDismissSignal(busAttachment, notificationId, appId);
    e9dc:	1c30      	adds	r0, r6, #0
    e9de:	9911      	ldr	r1, [sp, #68]	; 0x44
    e9e0:	4b34      	ldr	r3, [pc, #208]	; (eab4 <AJNS_Producer_DismissRequestHandler+0x128>)
    e9e2:	4798      	blx	r3
    if (status != AJ_OK) 
	{
        return status;
    e9e4:	1e03      	subs	r3, r0, #0
        return status;
    }

    appId = AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_APP_ID);
    status = AJNS_SendDismissSignal(busAttachment, notificationId, appId);
    if (status != AJ_OK) 
    e9e6:	d150      	bne.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
	{
        return status;
    }

    status = AJNS_Producer_CancelNotificationById(busAttachment, notificationId);
    e9e8:	9b11      	ldr	r3, [sp, #68]	; 0x44
    AJ_Status status;
    uint16_t messageType = 0;

  //  AJ_InfoPrintf(("In CancelNotificationById\n"));

    if (notificationId == 0)
    e9ea:	2b00      	cmp	r3, #0
    e9ec:	d004      	beq.n	e9f8 <AJNS_Producer_DismissRequestHandler+0x6c>
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
        return AJ_OK;
    }
    for (; messageType < AJNS_NUM_MESSAGE_TYPES; messageType++) 
	{
        if (lastSentNotifications[messageType].notificationId == notificationId) 
    e9ee:	4a32      	ldr	r2, [pc, #200]	; (eab8 <AJNS_Producer_DismissRequestHandler+0x12c>)
    e9f0:	6812      	ldr	r2, [r2, #0]
    e9f2:	429a      	cmp	r2, r3
    e9f4:	d10e      	bne.n	ea14 <AJNS_Producer_DismissRequestHandler+0x88>
    e9f6:	e03d      	b.n	ea74 <AJNS_Producer_DismissRequestHandler+0xe8>

  //  AJ_InfoPrintf(("In CancelNotificationById\n"));

    if (notificationId == 0)
	{
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
    e9f8:	2001      	movs	r0, #1
    e9fa:	4927      	ldr	r1, [pc, #156]	; (ea98 <AJNS_Producer_DismissRequestHandler+0x10c>)
    e9fc:	22b4      	movs	r2, #180	; 0xb4
    e9fe:	0092      	lsls	r2, r2, #2
    ea00:	4b26      	ldr	r3, [pc, #152]	; (ea9c <AJNS_Producer_DismissRequestHandler+0x110>)
    ea02:	4798      	blx	r3
        return AJ_OK;
    ea04:	2300      	movs	r3, #0

  //  AJ_InfoPrintf(("In CancelNotificationById\n"));

    if (notificationId == 0)
	{
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
    ea06:	2800      	cmp	r0, #0
    ea08:	d03f      	beq.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    ea0a:	482c      	ldr	r0, [pc, #176]	; (eabc <AJNS_Producer_DismissRequestHandler+0x130>)
    ea0c:	4b25      	ldr	r3, [pc, #148]	; (eaa4 <AJNS_Producer_DismissRequestHandler+0x118>)
    ea0e:	4798      	blx	r3
        return AJ_OK;
    ea10:	2300      	movs	r3, #0
    ea12:	e03a      	b.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    }
    for (; messageType < AJNS_NUM_MESSAGE_TYPES; messageType++) 
	{
        if (lastSentNotifications[messageType].notificationId == notificationId) 
    ea14:	4a28      	ldr	r2, [pc, #160]	; (eab8 <AJNS_Producer_DismissRequestHandler+0x12c>)
    ea16:	6892      	ldr	r2, [r2, #8]
    ea18:	429a      	cmp	r2, r3
    ea1a:	d005      	beq.n	ea28 <AJNS_Producer_DismissRequestHandler+0x9c>
    ea1c:	4a26      	ldr	r2, [pc, #152]	; (eab8 <AJNS_Producer_DismissRequestHandler+0x12c>)
    ea1e:	6912      	ldr	r2, [r2, #16]
    if (notificationId == 0)
	{
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
        return AJ_OK;
    }
    for (; messageType < AJNS_NUM_MESSAGE_TYPES; messageType++) 
    ea20:	2402      	movs	r4, #2
	{
        if (lastSentNotifications[messageType].notificationId == notificationId) 
    ea22:	429a      	cmp	r2, r3
    ea24:	d027      	beq.n	ea76 <AJNS_Producer_DismissRequestHandler+0xea>
    ea26:	e001      	b.n	ea2c <AJNS_Producer_DismissRequestHandler+0xa0>
    if (notificationId == 0)
	{
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
        return AJ_OK;
    }
    for (; messageType < AJNS_NUM_MESSAGE_TYPES; messageType++) 
    ea28:	2401      	movs	r4, #1
    ea2a:	e024      	b.n	ea76 <AJNS_Producer_DismissRequestHandler+0xea>
            break;
        }
    }
    if (messageType >= AJNS_NUM_MESSAGE_TYPES) 
	{
        AJ_ErrPrintf(("Could not find matching Message serial number - no message to cancel\n"));
    ea2c:	2001      	movs	r0, #1
    ea2e:	491a      	ldr	r1, [pc, #104]	; (ea98 <AJNS_Producer_DismissRequestHandler+0x10c>)
    ea30:	22b7      	movs	r2, #183	; 0xb7
    ea32:	0092      	lsls	r2, r2, #2
    ea34:	4b19      	ldr	r3, [pc, #100]	; (ea9c <AJNS_Producer_DismissRequestHandler+0x110>)
    ea36:	4798      	blx	r3
        return AJ_OK;
    ea38:	2300      	movs	r3, #0
            break;
        }
    }
    if (messageType >= AJNS_NUM_MESSAGE_TYPES) 
	{
        AJ_ErrPrintf(("Could not find matching Message serial number - no message to cancel\n"));
    ea3a:	2800      	cmp	r0, #0
    ea3c:	d025      	beq.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    ea3e:	4820      	ldr	r0, [pc, #128]	; (eac0 <AJNS_Producer_DismissRequestHandler+0x134>)
    ea40:	4b18      	ldr	r3, [pc, #96]	; (eaa4 <AJNS_Producer_DismissRequestHandler+0x118>)
    ea42:	4798      	blx	r3
        return AJ_OK;
    ea44:	2300      	movs	r3, #0
    ea46:	e020      	b.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>

    status = AJ_BusCancelSessionless(busAttachment, lastSentNotifications[messageType].serialNum);

    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Failed to send cancelation\n"));
    ea48:	2001      	movs	r0, #1
    ea4a:	4913      	ldr	r1, [pc, #76]	; (ea98 <AJNS_Producer_DismissRequestHandler+0x10c>)
    ea4c:	22b9      	movs	r2, #185	; 0xb9
    ea4e:	0092      	lsls	r2, r2, #2
    ea50:	4b12      	ldr	r3, [pc, #72]	; (ea9c <AJNS_Producer_DismissRequestHandler+0x110>)
    ea52:	4798      	blx	r3
        return status;
    ea54:	1c2b      	adds	r3, r5, #0

    status = AJ_BusCancelSessionless(busAttachment, lastSentNotifications[messageType].serialNum);

    if (status != AJ_OK) 
	{
        AJ_ErrPrintf(("Failed to send cancelation\n"));
    ea56:	2800      	cmp	r0, #0
    ea58:	d017      	beq.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    ea5a:	481a      	ldr	r0, [pc, #104]	; (eac4 <AJNS_Producer_DismissRequestHandler+0x138>)
    ea5c:	4b11      	ldr	r3, [pc, #68]	; (eaa4 <AJNS_Producer_DismissRequestHandler+0x118>)
    ea5e:	4798      	blx	r3
        return status;
    ea60:	1c2b      	adds	r3, r5, #0
    ea62:	e012      	b.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
    }

   // AJ_InfoPrintf(("***************** Message with Notification id %d and serialNum %u deleted successfully *****************\n", lastSentNotifications[messageType].notificationId, lastSentNotifications[messageType].serialNum));

    lastSentNotifications[messageType].notificationId = 0;
    ea64:	4914      	ldr	r1, [pc, #80]	; (eab8 <AJNS_Producer_DismissRequestHandler+0x12c>)
    ea66:	00e3      	lsls	r3, r4, #3
    ea68:	2200      	movs	r2, #0
    ea6a:	505a      	str	r2, [r3, r1]
    lastSentNotifications[messageType].serialNum = 0;
    ea6c:	18cb      	adds	r3, r1, r3
    ea6e:	605a      	str	r2, [r3, #4]

    return status;
    ea70:	2300      	movs	r3, #0
    ea72:	e00a      	b.n	ea8a <AJNS_Producer_DismissRequestHandler+0xfe>
        AJ_ErrPrintf(("Could not cancel Message - no message to cancel\n"));
        return AJ_OK;
    }
    for (; messageType < AJNS_NUM_MESSAGE_TYPES; messageType++) 
	{
        if (lastSentNotifications[messageType].notificationId == notificationId) 
    ea74:	2400      	movs	r4, #0
	{
        AJ_ErrPrintf(("Could not find matching Message serial number - no message to cancel\n"));
        return AJ_OK;
    }

    status = AJ_BusCancelSessionless(busAttachment, lastSentNotifications[messageType].serialNum);
    ea76:	00e3      	lsls	r3, r4, #3
    ea78:	4a0f      	ldr	r2, [pc, #60]	; (eab8 <AJNS_Producer_DismissRequestHandler+0x12c>)
    ea7a:	18d3      	adds	r3, r2, r3
    ea7c:	6859      	ldr	r1, [r3, #4]
    ea7e:	1c30      	adds	r0, r6, #0
    ea80:	4b11      	ldr	r3, [pc, #68]	; (eac8 <AJNS_Producer_DismissRequestHandler+0x13c>)
    ea82:	4798      	blx	r3
    ea84:	1e05      	subs	r5, r0, #0

    if (status != AJ_OK) 
    ea86:	d0ed      	beq.n	ea64 <AJNS_Producer_DismissRequestHandler+0xd8>
    ea88:	e7de      	b.n	ea48 <AJNS_Producer_DismissRequestHandler+0xbc>
    }

 //   AJ_InfoPrintf(("***************** Message with Notification id %d dismissed successfully *****************\n", notificationId));

    return status;
}
    ea8a:	1c18      	adds	r0, r3, #0
    ea8c:	b012      	add	sp, #72	; 0x48
    ea8e:	bd70      	pop	{r4, r5, r6, pc}
    ea90:	0001a4e0 	.word	0x0001a4e0
    ea94:	0000b5f5 	.word	0x0000b5f5
    ea98:	0001fba0 	.word	0x0001fba0
    ea9c:	0000636d 	.word	0x0000636d
    eaa0:	0001fe6c 	.word	0x0001fe6c
    eaa4:	00016f5d 	.word	0x00016f5d
    eaa8:	0000bd45 	.word	0x0000bd45
    eaac:	0000a539 	.word	0x0000a539
    eab0:	00000e39 	.word	0x00000e39
    eab4:	0000e051 	.word	0x0000e051
    eab8:	2000127c 	.word	0x2000127c
    eabc:	0001fdd8 	.word	0x0001fdd8
    eac0:	0001fe08 	.word	0x0001fe08
    eac4:	0001fe50 	.word	0x0001fe50
    eac8:	000029e5 	.word	0x000029e5

0000eacc <AJNS_Producer_MessageProcessor>:
  //  AJ_InfoPrintf(("Producer: Accepted session on port %u from %s\n", port, joiner));
    return TRUE;
}

AJSVC_ServiceStatus AJNS_Producer_MessageProcessor(AJ_BusAttachment* busAttachment, AJ_Message* msg, AJ_Status* msgStatus)
{
    eacc:	b510      	push	{r4, lr}
    eace:	1c14      	adds	r4, r2, #0
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_NOT_HANDLED;

    switch (msg->msgId) 
    ead0:	680b      	ldr	r3, [r1, #0]
    ead2:	4a1c      	ldr	r2, [pc, #112]	; (eb44 <AJNS_Producer_MessageProcessor+0x78>)
    ead4:	4293      	cmp	r3, r2
    ead6:	d01e      	beq.n	eb16 <AJNS_Producer_MessageProcessor+0x4a>
    ead8:	d80e      	bhi.n	eaf8 <AJNS_Producer_MessageProcessor+0x2c>
    eada:	4a1b      	ldr	r2, [pc, #108]	; (eb48 <AJNS_Producer_MessageProcessor+0x7c>)
    eadc:	4293      	cmp	r3, r2
    eade:	d022      	beq.n	eb26 <AJNS_Producer_MessageProcessor+0x5a>
    eae0:	d803      	bhi.n	eaea <AJNS_Producer_MessageProcessor+0x1e>
    eae2:	4a1a      	ldr	r2, [pc, #104]	; (eb4c <AJNS_Producer_MessageProcessor+0x80>)
    eae4:	4293      	cmp	r3, r2
    eae6:	d016      	beq.n	eb16 <AJNS_Producer_MessageProcessor+0x4a>
    eae8:	e02a      	b.n	eb40 <AJNS_Producer_MessageProcessor+0x74>
    eaea:	4a19      	ldr	r2, [pc, #100]	; (eb50 <AJNS_Producer_MessageProcessor+0x84>)
    eaec:	4293      	cmp	r3, r2
    eaee:	d012      	beq.n	eb16 <AJNS_Producer_MessageProcessor+0x4a>
    eaf0:	4a18      	ldr	r2, [pc, #96]	; (eb54 <AJNS_Producer_MessageProcessor+0x88>)
    eaf2:	4293      	cmp	r3, r2
    eaf4:	d017      	beq.n	eb26 <AJNS_Producer_MessageProcessor+0x5a>
    eaf6:	e023      	b.n	eb40 <AJNS_Producer_MessageProcessor+0x74>
    eaf8:	4a17      	ldr	r2, [pc, #92]	; (eb58 <AJNS_Producer_MessageProcessor+0x8c>)
    eafa:	4293      	cmp	r3, r2
    eafc:	d00b      	beq.n	eb16 <AJNS_Producer_MessageProcessor+0x4a>
    eafe:	d803      	bhi.n	eb08 <AJNS_Producer_MessageProcessor+0x3c>
    eb00:	4a16      	ldr	r2, [pc, #88]	; (eb5c <AJNS_Producer_MessageProcessor+0x90>)
    eb02:	4293      	cmp	r3, r2
    eb04:	d00f      	beq.n	eb26 <AJNS_Producer_MessageProcessor+0x5a>
    eb06:	e01b      	b.n	eb40 <AJNS_Producer_MessageProcessor+0x74>
    eb08:	4a15      	ldr	r2, [pc, #84]	; (eb60 <AJNS_Producer_MessageProcessor+0x94>)
    eb0a:	4293      	cmp	r3, r2
    eb0c:	d00b      	beq.n	eb26 <AJNS_Producer_MessageProcessor+0x5a>
    eb0e:	4a15      	ldr	r2, [pc, #84]	; (eb64 <AJNS_Producer_MessageProcessor+0x98>)
    eb10:	4293      	cmp	r3, r2
    eb12:	d010      	beq.n	eb36 <AJNS_Producer_MessageProcessor+0x6a>
    eb14:	e014      	b.n	eb40 <AJNS_Producer_MessageProcessor+0x74>
	{
    case EMERGENCY_NOTIFICATION_GET_PROPERTY:
    case WARNING_NOTIFICATION_GET_PROPERTY:
    case INFO_NOTIFICATION_GET_PROPERTY:
    case NOTIFICATION_PRODUCER_GET_PROPERTY:
        *msgStatus = AJ_BusPropGet(msg, AJNS_Producer_PropGetHandler, NULL);
    eb16:	1c08      	adds	r0, r1, #0
    eb18:	4913      	ldr	r1, [pc, #76]	; (eb68 <AJNS_Producer_MessageProcessor+0x9c>)
    eb1a:	2200      	movs	r2, #0
    eb1c:	4b13      	ldr	r3, [pc, #76]	; (eb6c <AJNS_Producer_MessageProcessor+0xa0>)
    eb1e:	4798      	blx	r3
    eb20:	7020      	strb	r0, [r4, #0]
        serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    eb22:	2000      	movs	r0, #0
        break;
    eb24:	e00d      	b.n	eb42 <AJNS_Producer_MessageProcessor+0x76>

    case EMERGENCY_NOTIFICATION_SET_PROPERTY:
    case WARNING_NOTIFICATION_SET_PROPERTY:
    case INFO_NOTIFICATION_SET_PROPERTY:
    case NOTIFICATION_PRODUCER_SET_PROPERTY:
        *msgStatus = AJ_BusPropSet(msg, AJNS_Producer_PropSetHandler, NULL);
    eb26:	1c08      	adds	r0, r1, #0
    eb28:	4911      	ldr	r1, [pc, #68]	; (eb70 <AJNS_Producer_MessageProcessor+0xa4>)
    eb2a:	2200      	movs	r2, #0
    eb2c:	4b11      	ldr	r3, [pc, #68]	; (eb74 <AJNS_Producer_MessageProcessor+0xa8>)
    eb2e:	4798      	blx	r3
    eb30:	7020      	strb	r0, [r4, #0]
        serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    eb32:	2000      	movs	r0, #0
        break;
    eb34:	e005      	b.n	eb42 <AJNS_Producer_MessageProcessor+0x76>

    case NOTIFICATION_PRODUCER_DISMISS:
        *msgStatus = AJNS_Producer_DismissRequestHandler(busAttachment, msg);
    eb36:	4b10      	ldr	r3, [pc, #64]	; (eb78 <AJNS_Producer_MessageProcessor+0xac>)
    eb38:	4798      	blx	r3
    eb3a:	7020      	strb	r0, [r4, #0]
        serviceStatus = AJSVC_SERVICE_STATUS_HANDLED;
    eb3c:	2000      	movs	r0, #0
        break;
    eb3e:	e000      	b.n	eb42 <AJNS_Producer_MessageProcessor+0x76>
    return TRUE;
}

AJSVC_ServiceStatus AJNS_Producer_MessageProcessor(AJ_BusAttachment* busAttachment, AJ_Message* msg, AJ_Status* msgStatus)
{
    AJSVC_ServiceStatus serviceStatus = AJSVC_SERVICE_STATUS_NOT_HANDLED;
    eb40:	2001      	movs	r0, #1
    default:
        break;
    }

    return serviceStatus;
}
    eb42:	bd10      	pop	{r4, pc}
    eb44:	05060000 	.word	0x05060000
    eb48:	05040001 	.word	0x05040001
    eb4c:	05040000 	.word	0x05040000
    eb50:	05050000 	.word	0x05050000
    eb54:	05050001 	.word	0x05050001
    eb58:	05070000 	.word	0x05070000
    eb5c:	05060001 	.word	0x05060001
    eb60:	05070001 	.word	0x05070001
    eb64:	05070100 	.word	0x05070100
    eb68:	0000e175 	.word	0x0000e175
    eb6c:	000030d1 	.word	0x000030d1
    eb70:	0000e171 	.word	0x0000e171
    eb74:	00003105 	.word	0x00003105
    eb78:	0000e98d 	.word	0x0000e98d

0000eb7c <AJNS_Producer_DisconnectHandler>:

AJ_Status AJNS_Producer_DisconnectHandler(AJ_BusAttachment* busAttachment)
{
    eb7c:	b538      	push	{r3, r4, r5, lr}
    AJ_Status status = AJ_OK;
    status = AJ_BusUnbindSession(busAttachment, AJNS_NotificationProducerPort);
    eb7e:	4b0a      	ldr	r3, [pc, #40]	; (eba8 <AJNS_Producer_DisconnectHandler+0x2c>)
    eb80:	881d      	ldrh	r5, [r3, #0]
    eb82:	1c29      	adds	r1, r5, #0
    eb84:	4b09      	ldr	r3, [pc, #36]	; (ebac <AJNS_Producer_DisconnectHandler+0x30>)
    eb86:	4798      	blx	r3
    eb88:	1e04      	subs	r4, r0, #0
    if (status != AJ_OK) 
    eb8a:	d00a      	beq.n	eba2 <AJNS_Producer_DisconnectHandler+0x26>
	{
        AJ_ErrPrintf(("Failed to send unbind session port=%d\n", AJNS_NotificationProducerPort));
    eb8c:	2001      	movs	r0, #1
    eb8e:	4908      	ldr	r1, [pc, #32]	; (ebb0 <AJNS_Producer_DisconnectHandler+0x34>)
    eb90:	4a08      	ldr	r2, [pc, #32]	; (ebb4 <AJNS_Producer_DisconnectHandler+0x38>)
    eb92:	4b09      	ldr	r3, [pc, #36]	; (ebb8 <AJNS_Producer_DisconnectHandler+0x3c>)
    eb94:	4798      	blx	r3
    eb96:	2800      	cmp	r0, #0
    eb98:	d003      	beq.n	eba2 <AJNS_Producer_DisconnectHandler+0x26>
    eb9a:	4808      	ldr	r0, [pc, #32]	; (ebbc <AJNS_Producer_DisconnectHandler+0x40>)
    eb9c:	1c29      	adds	r1, r5, #0
    eb9e:	4b08      	ldr	r3, [pc, #32]	; (ebc0 <AJNS_Producer_DisconnectHandler+0x44>)
    eba0:	4798      	blx	r3
    }
    return status;
}
    eba2:	1c20      	adds	r0, r4, #0
    eba4:	bd38      	pop	{r3, r4, r5, pc}
    eba6:	46c0      	nop			; (mov r8, r8)
    eba8:	0001f9c2 	.word	0x0001f9c2
    ebac:	00002981 	.word	0x00002981
    ebb0:	0001fba0 	.word	0x0001fba0
    ebb4:	000003d3 	.word	0x000003d3
    ebb8:	0000636d 	.word	0x0000636d
    ebbc:	0001fed8 	.word	0x0001fed8
    ebc0:	00016e3d 	.word	0x00016e3d

0000ebc4 <AJSVC_IsLanguageSupported>:
#endif
uint8_t dbgAJSVC = ER_DEBUG_AJSVC || ER_DEBUG_AJSVCALL;
#endif

uint8_t AJSVC_IsLanguageSupported(AJ_Message* msg, AJ_Message* reply, const char* language, int8_t* langIndex)
{
    ebc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ebc6:	1c07      	adds	r7, r0, #0
    ebc8:	1c0e      	adds	r6, r1, #0
    ebca:	1c1c      	adds	r4, r3, #0
    uint8_t supported = TRUE;
    int8_t foundLangIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
    ebcc:	1c10      	adds	r0, r2, #0
    ebce:	4b08      	ldr	r3, [pc, #32]	; (ebf0 <AJSVC_IsLanguageSupported+0x2c>)
    ebd0:	4798      	blx	r3
    ebd2:	1c05      	adds	r5, r0, #0
uint8_t dbgAJSVC = ER_DEBUG_AJSVC || ER_DEBUG_AJSVCALL;
#endif

uint8_t AJSVC_IsLanguageSupported(AJ_Message* msg, AJ_Message* reply, const char* language, int8_t* langIndex)
{
    uint8_t supported = TRUE;
    ebd4:	2001      	movs	r0, #1
    int8_t foundLangIndex = AJSVC_PropertyStore_GetLanguageIndex(language);
    if (foundLangIndex == AJSVC_PROPERTY_STORE_ERROR_LANGUAGE_INDEX) 
    ebd6:	1c6b      	adds	r3, r5, #1
    ebd8:	d105      	bne.n	ebe6 <AJSVC_IsLanguageSupported+0x22>
	{
        AJ_MarshalErrorMsg(msg, reply, AJSVC_ERROR_LANGUAGE_NOT_SUPPORTED);
    ebda:	1c38      	adds	r0, r7, #0
    ebdc:	1c31      	adds	r1, r6, #0
    ebde:	4a05      	ldr	r2, [pc, #20]	; (ebf4 <AJSVC_IsLanguageSupported+0x30>)
    ebe0:	4b05      	ldr	r3, [pc, #20]	; (ebf8 <AJSVC_IsLanguageSupported+0x34>)
    ebe2:	4798      	blx	r3
        supported = FALSE;
    ebe4:	2000      	movs	r0, #0
    }
    if (langIndex != NULL) 
    ebe6:	2c00      	cmp	r4, #0
    ebe8:	d000      	beq.n	ebec <AJSVC_IsLanguageSupported+0x28>
	{
        *langIndex = foundLangIndex;
    ebea:	7025      	strb	r5, [r4, #0]
    }
    return supported;
}
    ebec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ebee:	46c0      	nop			; (mov r8, r8)
    ebf0:	00000e49 	.word	0x00000e49
    ebf4:	0001eadc 	.word	0x0001eadc
    ebf8:	0000be55 	.word	0x0000be55

0000ebfc <AJSVC_MarshalAppId>:

    return status;
}

AJ_Status AJSVC_MarshalAppId(AJ_Message* msg, const char* appId)
{
    ebfc:	b570      	push	{r4, r5, r6, lr}
    ebfe:	b084      	sub	sp, #16
    ec00:	1c05      	adds	r5, r0, #0
    ec02:	1c0e      	adds	r6, r1, #0
    AJ_Status status;
    uint8_t binAppId[UUID_LENGTH];
    uint32_t sz = strlen(appId);
    ec04:	1c08      	adds	r0, r1, #0
    ec06:	4b0b      	ldr	r3, [pc, #44]	; (ec34 <AJSVC_MarshalAppId+0x38>)
    ec08:	4798      	blx	r3
    ec0a:	1e04      	subs	r4, r0, #0
    ec0c:	2c20      	cmp	r4, #32
    ec0e:	d900      	bls.n	ec12 <AJSVC_MarshalAppId+0x16>
    ec10:	2420      	movs	r4, #32

    if (sz > UUID_LENGTH * 2) 
	{ // Crop application id that is too long
        sz = UUID_LENGTH * 2;
    }
    status = AJ_HexToRaw(appId, sz, binAppId, UUID_LENGTH);
    ec12:	1c30      	adds	r0, r6, #0
    ec14:	1c21      	adds	r1, r4, #0
    ec16:	466a      	mov	r2, sp
    ec18:	2310      	movs	r3, #16
    ec1a:	4e07      	ldr	r6, [pc, #28]	; (ec38 <AJSVC_MarshalAppId+0x3c>)
    ec1c:	47b0      	blx	r6
    ec1e:	1e03      	subs	r3, r0, #0
    if (status != AJ_OK) 
    ec20:	d105      	bne.n	ec2e <AJSVC_MarshalAppId+0x32>
	{
        return status;
    }
    status = AJ_MarshalArgs(msg, APP_ID_SIGNATURE, binAppId, sz / 2);
    ec22:	0863      	lsrs	r3, r4, #1
    ec24:	1c28      	adds	r0, r5, #0
    ec26:	4905      	ldr	r1, [pc, #20]	; (ec3c <AJSVC_MarshalAppId+0x40>)
    ec28:	466a      	mov	r2, sp
    ec2a:	4c05      	ldr	r4, [pc, #20]	; (ec40 <AJSVC_MarshalAppId+0x44>)
    ec2c:	47a0      	blx	r4

    return status;
}
    ec2e:	b004      	add	sp, #16
    ec30:	bd70      	pop	{r4, r5, r6, pc}
    ec32:	46c0      	nop			; (mov r8, r8)
    ec34:	0001715b 	.word	0x0001715b
    ec38:	0000d8c1 	.word	0x0000d8c1
    ec3c:	0001ecdc 	.word	0x0001ecdc
    ec40:	0000bc85 	.word	0x0000bc85

0000ec44 <AJSVC_RoutingNodeConnect>:

#include <aj_config.h>
#include <aj_link_timeout.h>

AJ_Status AJSVC_RoutingNodeConnect(AJ_BusAttachment* busAttachment, const char* routingNodeName, uint32_t connectTimeout, uint32_t connectPause, uint32_t busLinkTimeout, uint8_t* isConnected)
{
    ec44:	b5f0      	push	{r4, r5, r6, r7, lr}
    ec46:	b085      	sub	sp, #20
    ec48:	1c04      	adds	r4, r0, #0
    ec4a:	1c0e      	adds	r6, r1, #0
    ec4c:	9201      	str	r2, [sp, #4]
    ec4e:	9302      	str	r3, [sp, #8]
#endif
        AJ_InfoPrintf(("Attempting to connect to bus '%s'\n", routingNodeName));
        status = AJ_FindBusAndConnect(busAttachment, routingNodeName, connectTimeout);
        if (status != AJ_OK) 
		{
            AJ_ErrPrintf(("Failed attempt to connect to bus, sleeping for %d seconds\n", connectPause / 1000));
    ec50:	1c18      	adds	r0, r3, #0
    ec52:	21fa      	movs	r1, #250	; 0xfa
    ec54:	0089      	lsls	r1, r1, #2
    ec56:	4b22      	ldr	r3, [pc, #136]	; (ece0 <AJSVC_RoutingNodeConnect+0x9c>)
    ec58:	4798      	blx	r3
    ec5a:	9003      	str	r0, [sp, #12]
            }
            return status;
        }
#endif
        AJ_InfoPrintf(("Attempting to connect to bus '%s'\n", routingNodeName));
        status = AJ_FindBusAndConnect(busAttachment, routingNodeName, connectTimeout);
    ec5c:	4f21      	ldr	r7, [pc, #132]	; (ece4 <AJSVC_RoutingNodeConnect+0xa0>)
    ec5e:	1c20      	adds	r0, r4, #0
    ec60:	1c31      	adds	r1, r6, #0
    ec62:	9a01      	ldr	r2, [sp, #4]
    ec64:	47b8      	blx	r7
    ec66:	1e05      	subs	r5, r0, #0
        if (status != AJ_OK) 
    ec68:	d01c      	beq.n	eca4 <AJSVC_RoutingNodeConnect+0x60>
		{
            AJ_ErrPrintf(("Failed attempt to connect to bus, sleeping for %d seconds\n", connectPause / 1000));
    ec6a:	2001      	movs	r0, #1
    ec6c:	491e      	ldr	r1, [pc, #120]	; (ece8 <AJSVC_RoutingNodeConnect+0xa4>)
    ec6e:	2253      	movs	r2, #83	; 0x53
    ec70:	4b1e      	ldr	r3, [pc, #120]	; (ecec <AJSVC_RoutingNodeConnect+0xa8>)
    ec72:	4798      	blx	r3
    ec74:	2800      	cmp	r0, #0
    ec76:	d003      	beq.n	ec80 <AJSVC_RoutingNodeConnect+0x3c>
    ec78:	481d      	ldr	r0, [pc, #116]	; (ecf0 <AJSVC_RoutingNodeConnect+0xac>)
    ec7a:	9903      	ldr	r1, [sp, #12]
    ec7c:	4b1d      	ldr	r3, [pc, #116]	; (ecf4 <AJSVC_RoutingNodeConnect+0xb0>)
    ec7e:	4798      	blx	r3
			AJ_ErrPrintf(("!!!!Status= %s!!!!!\n", AJ_StatusText(status)));
    ec80:	2001      	movs	r0, #1
    ec82:	4919      	ldr	r1, [pc, #100]	; (ece8 <AJSVC_RoutingNodeConnect+0xa4>)
    ec84:	2254      	movs	r2, #84	; 0x54
    ec86:	4b19      	ldr	r3, [pc, #100]	; (ecec <AJSVC_RoutingNodeConnect+0xa8>)
    ec88:	4798      	blx	r3
    ec8a:	2800      	cmp	r0, #0
    ec8c:	d006      	beq.n	ec9c <AJSVC_RoutingNodeConnect+0x58>
    ec8e:	1c28      	adds	r0, r5, #0
    ec90:	4b19      	ldr	r3, [pc, #100]	; (ecf8 <AJSVC_RoutingNodeConnect+0xb4>)
    ec92:	4798      	blx	r3
    ec94:	1c01      	adds	r1, r0, #0
    ec96:	4819      	ldr	r0, [pc, #100]	; (ecfc <AJSVC_RoutingNodeConnect+0xb8>)
    ec98:	4b16      	ldr	r3, [pc, #88]	; (ecf4 <AJSVC_RoutingNodeConnect+0xb0>)
    ec9a:	4798      	blx	r3
            AJ_Sleep(connectPause);
    ec9c:	9802      	ldr	r0, [sp, #8]
    ec9e:	4b18      	ldr	r3, [pc, #96]	; (ed00 <AJSVC_RoutingNodeConnect+0xbc>)
    eca0:	4798      	blx	r3
				 {
                    AJ_ErrPrintf(("Failed to switch to Retry mode status=%s\n", AJ_StatusText(status)));
                }
            }
#endif
            continue;
    eca2:	e7dc      	b.n	ec5e <AJSVC_RoutingNodeConnect+0x1a>
        }
        busUniqueName = AJ_GetUniqueName(busAttachment);
    eca4:	1c20      	adds	r0, r4, #0
    eca6:	4b17      	ldr	r3, [pc, #92]	; (ed04 <AJSVC_RoutingNodeConnect+0xc0>)
    eca8:	4798      	blx	r3
        if (busUniqueName == NULL) 
    ecaa:	2800      	cmp	r0, #0
    ecac:	d10a      	bne.n	ecc4 <AJSVC_RoutingNodeConnect+0x80>
		{
            AJ_ErrPrintf(("Failed to GetUniqueName() from newly connected bus, retrying\n"));
    ecae:	3001      	adds	r0, #1
    ecb0:	490d      	ldr	r1, [pc, #52]	; (ece8 <AJSVC_RoutingNodeConnect+0xa4>)
    ecb2:	2265      	movs	r2, #101	; 0x65
    ecb4:	4b0d      	ldr	r3, [pc, #52]	; (ecec <AJSVC_RoutingNodeConnect+0xa8>)
    ecb6:	4798      	blx	r3
    ecb8:	2800      	cmp	r0, #0
    ecba:	d0d0      	beq.n	ec5e <AJSVC_RoutingNodeConnect+0x1a>
    ecbc:	4812      	ldr	r0, [pc, #72]	; (ed08 <AJSVC_RoutingNodeConnect+0xc4>)
    ecbe:	4b13      	ldr	r3, [pc, #76]	; (ed0c <AJSVC_RoutingNodeConnect+0xc8>)
    ecc0:	4798      	blx	r3
    ecc2:	e7cc      	b.n	ec5e <AJSVC_RoutingNodeConnect+0x1a>
        AJ_InfoPrintf(("Connected to Routing Node with BusUniqueName=%s\n", busUniqueName));
        break;
    }

    /* Configure timeout for the link to the Routing Node bus */
    AJ_SetBusLinkTimeout(busAttachment, busLinkTimeout);
    ecc4:	1c20      	adds	r0, r4, #0
    ecc6:	990a      	ldr	r1, [sp, #40]	; 0x28
    ecc8:	4b11      	ldr	r3, [pc, #68]	; (ed10 <AJSVC_RoutingNodeConnect+0xcc>)
    ecca:	4798      	blx	r3

    if (isConnected != NULL) 
    eccc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ecce:	2b00      	cmp	r3, #0
    ecd0:	d002      	beq.n	ecd8 <AJSVC_RoutingNodeConnect+0x94>
	{
        *isConnected = TRUE;
    ecd2:	2301      	movs	r3, #1
    ecd4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ecd6:	7013      	strb	r3, [r2, #0]
    }
    return status;
}
    ecd8:	2000      	movs	r0, #0
    ecda:	b005      	add	sp, #20
    ecdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ecde:	46c0      	nop			; (mov r8, r8)
    ece0:	00014e9d 	.word	0x00014e9d
    ece4:	0000404d 	.word	0x0000404d
    ece8:	0001ff7c 	.word	0x0001ff7c
    ecec:	0000636d 	.word	0x0000636d
    ecf0:	0001ffac 	.word	0x0001ffac
    ecf4:	00016e3d 	.word	0x00016e3d
    ecf8:	000063c5 	.word	0x000063c5
    ecfc:	0001ffe8 	.word	0x0001ffe8
    ed00:	0000d765 	.word	0x0000d765
    ed04:	000028e9 	.word	0x000028e9
    ed08:	00020000 	.word	0x00020000
    ed0c:	00016f5d 	.word	0x00016f5d
    ed10:	000099a5 	.word	0x000099a5

0000ed14 <AJSVC_DisconnectHandler>:
    }
    return serviceStatus;
}

AJ_Status AJSVC_DisconnectHandler(AJ_BusAttachment* busAttachment)
{
    ed14:	b510      	push	{r4, lr}
    ed16:	1c04      	adds	r4, r0, #0
    AJ_Status status = AJ_OK;

#ifdef CONFIG_SERVICE
    AJCFG_DisconnectHandler(busAttachment);
    ed18:	4b03      	ldr	r3, [pc, #12]	; (ed28 <AJSVC_DisconnectHandler+0x14>)
    ed1a:	4798      	blx	r3
#endif
#ifdef NOTIFICATION_SERVICE_CONSUMER
    AJNS_Consumer_DisconnectHandler(busAttachment);
#endif
#ifdef NOTIFICATION_SERVICE_PRODUCER
    AJNS_Producer_DisconnectHandler(busAttachment);
    ed1c:	1c20      	adds	r0, r4, #0
    ed1e:	4b03      	ldr	r3, [pc, #12]	; (ed2c <AJSVC_DisconnectHandler+0x18>)
    ed20:	4798      	blx	r3
#ifdef TIME_SERVICE_CLIENT
    AJTS_Client_DisconnectHandler(busAttachment);
#endif

    return status;
}
    ed22:	2000      	movs	r0, #0
    ed24:	bd10      	pop	{r4, pc}
    ed26:	46c0      	nop			; (mov r8, r8)
    ed28:	0000e04d 	.word	0x0000e04d
    ed2c:	0000eb7d 	.word	0x0000eb7d

0000ed30 <AJSVC_RoutingNodeDisconnect>:

AJ_Status AJSVC_RoutingNodeDisconnect(AJ_BusAttachment* busAttachment, uint8_t disconnectWiFi, uint32_t preDisconnectPause, uint32_t postDisconnectPause, uint8_t* isConnected)
{
    ed30:	b570      	push	{r4, r5, r6, lr}
    ed32:	1c06      	adds	r6, r0, #0
    ed34:	1c14      	adds	r4, r2, #0
    ed36:	1c1d      	adds	r5, r3, #0
    AJ_Status status = AJ_OK;

    AJ_ErrPrintf(("AllJoyn disconnect\n"));
    ed38:	2001      	movs	r0, #1
    ed3a:	490d      	ldr	r1, [pc, #52]	; (ed70 <AJSVC_RoutingNodeDisconnect+0x40>)
    ed3c:	22a2      	movs	r2, #162	; 0xa2
    ed3e:	32ff      	adds	r2, #255	; 0xff
    ed40:	4b0c      	ldr	r3, [pc, #48]	; (ed74 <AJSVC_RoutingNodeDisconnect+0x44>)
    ed42:	4798      	blx	r3
    ed44:	2800      	cmp	r0, #0
    ed46:	d002      	beq.n	ed4e <AJSVC_RoutingNodeDisconnect+0x1e>
    ed48:	480b      	ldr	r0, [pc, #44]	; (ed78 <AJSVC_RoutingNodeDisconnect+0x48>)
    ed4a:	4b0c      	ldr	r3, [pc, #48]	; (ed7c <AJSVC_RoutingNodeDisconnect+0x4c>)
    ed4c:	4798      	blx	r3
    AJ_Sleep(preDisconnectPause); // Sleep a little to let any pending requests to Routing Node to be sent
    ed4e:	1c20      	adds	r0, r4, #0
    ed50:	4c0b      	ldr	r4, [pc, #44]	; (ed80 <AJSVC_RoutingNodeDisconnect+0x50>)
    ed52:	47a0      	blx	r4
    AJ_Disconnect(busAttachment);
    ed54:	1c30      	adds	r0, r6, #0
    ed56:	4b0b      	ldr	r3, [pc, #44]	; (ed84 <AJSVC_RoutingNodeDisconnect+0x54>)
    ed58:	4798      	blx	r3
    if (disconnectWiFi) 
	{
        status = AJOBS_DisconnectWiFi();
    }
#endif
    AJ_Sleep(postDisconnectPause); // Sleep a little while before trying to reconnect
    ed5a:	1c28      	adds	r0, r5, #0
    ed5c:	47a0      	blx	r4

    if (isConnected != NULL) 
    ed5e:	9b04      	ldr	r3, [sp, #16]
    ed60:	2b00      	cmp	r3, #0
    ed62:	d002      	beq.n	ed6a <AJSVC_RoutingNodeDisconnect+0x3a>
	{
        *isConnected = FALSE;
    ed64:	2300      	movs	r3, #0
    ed66:	9a04      	ldr	r2, [sp, #16]
    ed68:	7013      	strb	r3, [r2, #0]
    }
    return status;
}
    ed6a:	2000      	movs	r0, #0
    ed6c:	bd70      	pop	{r4, r5, r6, pc}
    ed6e:	46c0      	nop			; (mov r8, r8)
    ed70:	0001ff7c 	.word	0x0001ff7c
    ed74:	0000636d 	.word	0x0000636d
    ed78:	00020120 	.word	0x00020120
    ed7c:	00016f5d 	.word	0x00016f5d
    ed80:	0000d765 	.word	0x0000d765
    ed84:	00003c39 	.word	0x00003c39

0000ed88 <SHA256_Init>:
static const char *sha2_hex_digits = "0123456789abcdef";


/*** SHA-256: *********************************************************/
void SHA256_Init(SHA256_CTX* context)
{
    ed88:	b510      	push	{r4, lr}
	if (context == (SHA256_CTX*)0) 
    ed8a:	2800      	cmp	r0, #0
    ed8c:	d00e      	beq.n	edac <SHA256_Init+0x24>
    ed8e:	1c04      	adds	r4, r0, #0
	{
		return;
	}
	MEMCPY_BCOPY(context->state, sha256_initial_hash_value, SHA256_DIGEST_LENGTH);
    ed90:	4907      	ldr	r1, [pc, #28]	; (edb0 <SHA256_Init+0x28>)
    ed92:	2220      	movs	r2, #32
    ed94:	4b07      	ldr	r3, [pc, #28]	; (edb4 <SHA256_Init+0x2c>)
    ed96:	4798      	blx	r3
	MEMSET_BZERO(context->buffer, SHA256_BLOCK_LENGTH);
    ed98:	1c20      	adds	r0, r4, #0
    ed9a:	3028      	adds	r0, #40	; 0x28
    ed9c:	2100      	movs	r1, #0
    ed9e:	2240      	movs	r2, #64	; 0x40
    eda0:	4b05      	ldr	r3, [pc, #20]	; (edb8 <SHA256_Init+0x30>)
    eda2:	4798      	blx	r3
	context->bitcount = 0;
    eda4:	2200      	movs	r2, #0
    eda6:	2300      	movs	r3, #0
    eda8:	6222      	str	r2, [r4, #32]
    edaa:	6263      	str	r3, [r4, #36]	; 0x24
}
    edac:	bd10      	pop	{r4, pc}
    edae:	46c0      	nop			; (mov r8, r8)
    edb0:	00020154 	.word	0x00020154
    edb4:	00016739 	.word	0x00016739
    edb8:	00016773 	.word	0x00016773

0000edbc <SHA256_Transform>:
}

#else /* SHA2_UNROLL_TRANSFORM */

void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) 
{
    edbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    edbe:	465f      	mov	r7, fp
    edc0:	4656      	mov	r6, sl
    edc2:	464d      	mov	r5, r9
    edc4:	4644      	mov	r4, r8
    edc6:	b4f0      	push	{r4, r5, r6, r7}
    edc8:	b089      	sub	sp, #36	; 0x24
    edca:	9007      	str	r0, [sp, #28]
    edcc:	1c0e      	adds	r6, r1, #0
	sha2_word32	a, b, c, d, e, f, g, h, s0, s1;
	sha2_word32	T1, T2, *W256;
	int		j;

	W256 = (sha2_word32*)context->buffer;
    edce:	1c03      	adds	r3, r0, #0
    edd0:	2128      	movs	r1, #40	; 0x28
    edd2:	468c      	mov	ip, r1
    edd4:	4463      	add	r3, ip
    edd6:	4699      	mov	r9, r3

	/* Initialize registers with the prev. intermediate value */
	a = context->state[0];
    edd8:	1c03      	adds	r3, r0, #0
    edda:	6802      	ldr	r2, [r0, #0]
    eddc:	4694      	mov	ip, r2
	b = context->state[1];
    edde:	6842      	ldr	r2, [r0, #4]
    ede0:	9200      	str	r2, [sp, #0]
	c = context->state[2];
    ede2:	6882      	ldr	r2, [r0, #8]
	d = context->state[3];
    ede4:	68c1      	ldr	r1, [r0, #12]
    ede6:	9102      	str	r1, [sp, #8]
	e = context->state[4];
    ede8:	6901      	ldr	r1, [r0, #16]
	f = context->state[5];
    edea:	6940      	ldr	r0, [r0, #20]
    edec:	9001      	str	r0, [sp, #4]
	g = context->state[6];
    edee:	6998      	ldr	r0, [r3, #24]
    edf0:	9004      	str	r0, [sp, #16]
	h = context->state[7];
    edf2:	69db      	ldr	r3, [r3, #28]
    edf4:	9303      	str	r3, [sp, #12]
    edf6:	2000      	movs	r0, #0
	do {
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Copy data while converting to host byte order */
		REVERSE32(*data++,W256[j]);
		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];
    edf8:	2306      	movs	r3, #6
    edfa:	469a      	mov	sl, r3
    edfc:	3313      	adds	r3, #19
    edfe:	4698      	mov	r8, r3
#else /* BYTE_ORDER == LITTLE_ENDIAN */
		/* Apply the SHA-256 compression function to update a..h with copy */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
		T2 = Sigma0_256(a) + Maj(a, b, c);
    ee00:	3b0c      	subs	r3, #12
    ee02:	469b      	mov	fp, r3
    ee04:	4667      	mov	r7, ip
    ee06:	1c0d      	adds	r5, r1, #0
    ee08:	464b      	mov	r3, r9
    ee0a:	9306      	str	r3, [sp, #24]
    ee0c:	46b4      	mov	ip, r6
    ee0e:	1c16      	adds	r6, r2, #0
    ee10:	e006      	b.n	ee20 <SHA256_Transform+0x64>
    ee12:	9b01      	ldr	r3, [sp, #4]
    ee14:	9304      	str	r3, [sp, #16]
    ee16:	9501      	str	r5, [sp, #4]
		h = g;
		g = f;
		f = e;
		e = d + T1;
    ee18:	1c15      	adds	r5, r2, #0
    ee1a:	9e00      	ldr	r6, [sp, #0]
    ee1c:	9700      	str	r7, [sp, #0]
		d = c;
		c = b;
		b = a;
		a = T1 + T2;
    ee1e:	1c0f      	adds	r7, r1, #0

	j = 0;
	do {
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Copy data while converting to host byte order */
		REVERSE32(*data++,W256[j]);
    ee20:	4663      	mov	r3, ip
    ee22:	5819      	ldr	r1, [r3, r0]
    ee24:	2310      	movs	r3, #16
    ee26:	41d9      	rors	r1, r3
    ee28:	4a7c      	ldr	r2, [pc, #496]	; (f01c <SHA256_Transform+0x260>)
    ee2a:	400a      	ands	r2, r1
    ee2c:	0213      	lsls	r3, r2, #8
    ee2e:	4a7c      	ldr	r2, [pc, #496]	; (f020 <SHA256_Transform+0x264>)
    ee30:	400a      	ands	r2, r1
    ee32:	0a12      	lsrs	r2, r2, #8
    ee34:	431a      	orrs	r2, r3
    ee36:	9b06      	ldr	r3, [sp, #24]
    ee38:	501a      	str	r2, [r3, r0]
		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];
    ee3a:	1c29      	adds	r1, r5, #0
    ee3c:	4653      	mov	r3, sl
    ee3e:	41d9      	rors	r1, r3
    ee40:	1c2b      	adds	r3, r5, #0
    ee42:	240b      	movs	r4, #11
    ee44:	41e3      	rors	r3, r4
    ee46:	404b      	eors	r3, r1
    ee48:	1c29      	adds	r1, r5, #0
    ee4a:	4644      	mov	r4, r8
    ee4c:	41e1      	rors	r1, r4
    ee4e:	404b      	eors	r3, r1
    ee50:	9901      	ldr	r1, [sp, #4]
    ee52:	4029      	ands	r1, r5
    ee54:	9c04      	ldr	r4, [sp, #16]
    ee56:	43ac      	bics	r4, r5
    ee58:	4061      	eors	r1, r4
    ee5a:	185b      	adds	r3, r3, r1
    ee5c:	4971      	ldr	r1, [pc, #452]	; (f024 <SHA256_Transform+0x268>)
    ee5e:	5841      	ldr	r1, [r0, r1]
    ee60:	4689      	mov	r9, r1
    ee62:	444b      	add	r3, r9
    ee64:	189b      	adds	r3, r3, r2
    ee66:	9a03      	ldr	r2, [sp, #12]
    ee68:	4691      	mov	r9, r2
    ee6a:	444b      	add	r3, r9
#else /* BYTE_ORDER == LITTLE_ENDIAN */
		/* Apply the SHA-256 compression function to update a..h with copy */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
		T2 = Sigma0_256(a) + Maj(a, b, c);
    ee6c:	9a00      	ldr	r2, [sp, #0]
    ee6e:	1c11      	adds	r1, r2, #0
    ee70:	4071      	eors	r1, r6
    ee72:	4039      	ands	r1, r7
    ee74:	4032      	ands	r2, r6
    ee76:	4051      	eors	r1, r2
    ee78:	2202      	movs	r2, #2
    ee7a:	1c3c      	adds	r4, r7, #0
    ee7c:	41d4      	rors	r4, r2
    ee7e:	46a1      	mov	r9, r4
    ee80:	1c3a      	adds	r2, r7, #0
    ee82:	465c      	mov	r4, fp
    ee84:	41e2      	rors	r2, r4
    ee86:	464c      	mov	r4, r9
    ee88:	4054      	eors	r4, r2
    ee8a:	46a1      	mov	r9, r4
    ee8c:	2216      	movs	r2, #22
    ee8e:	1c3c      	adds	r4, r7, #0
    ee90:	41d4      	rors	r4, r2
    ee92:	1c22      	adds	r2, r4, #0
    ee94:	464c      	mov	r4, r9
    ee96:	4062      	eors	r2, r4
    ee98:	1889      	adds	r1, r1, r2
		h = g;
		g = f;
		f = e;
		e = d + T1;
    ee9a:	9a02      	ldr	r2, [sp, #8]
    ee9c:	18d2      	adds	r2, r2, r3
		d = c;
		c = b;
		b = a;
		a = T1 + T2;
    ee9e:	18c9      	adds	r1, r1, r3
    eea0:	3004      	adds	r0, #4
    eea2:	9602      	str	r6, [sp, #8]
    eea4:	9c04      	ldr	r4, [sp, #16]
    eea6:	9403      	str	r4, [sp, #12]

		j++;
	} while (j < 16);
    eea8:	2840      	cmp	r0, #64	; 0x40
    eeaa:	d1b2      	bne.n	ee12 <SHA256_Transform+0x56>
    eeac:	46bc      	mov	ip, r7
    eeae:	9605      	str	r6, [sp, #20]
    eeb0:	9502      	str	r5, [sp, #8]
    eeb2:	1c17      	adds	r7, r2, #0
    eeb4:	9b06      	ldr	r3, [sp, #24]
    eeb6:	4699      	mov	r9, r3
    eeb8:	4b5a      	ldr	r3, [pc, #360]	; (f024 <SHA256_Transform+0x268>)
    eeba:	2240      	movs	r2, #64	; 0x40
    eebc:	4693      	mov	fp, r2
    eebe:	449b      	add	fp, r3
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
    eec0:	2310      	movs	r3, #16
    eec2:	4698      	mov	r8, r3
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W256[(j+1)&0x0f];
    eec4:	3b01      	subs	r3, #1
    eec6:	469a      	mov	sl, r3
    eec8:	4663      	mov	r3, ip
    eeca:	9303      	str	r3, [sp, #12]
    eecc:	4644      	mov	r4, r8
    eece:	e007      	b.n	eee0 <SHA256_Transform+0x124>
    eed0:	9a02      	ldr	r2, [sp, #8]
    eed2:	9201      	str	r2, [sp, #4]
    eed4:	9702      	str	r7, [sp, #8]
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
		T2 = Sigma0_256(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
    eed6:	1c07      	adds	r7, r0, #0
    eed8:	9a03      	ldr	r2, [sp, #12]
    eeda:	9200      	str	r2, [sp, #0]
    eedc:	9103      	str	r1, [sp, #12]
		d = c;
		c = b;
		b = a;
		a = T1 + T2;
    eede:	1c19      	adds	r1, r3, #0
		j++;
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W256[(j+1)&0x0f];
    eee0:	3401      	adds	r4, #1
    eee2:	4653      	mov	r3, sl
    eee4:	4023      	ands	r3, r4
    eee6:	009b      	lsls	r3, r3, #2
    eee8:	464a      	mov	r2, r9
    eeea:	589a      	ldr	r2, [r3, r2]
		s0 = sigma0_256(s0);
    eeec:	1c10      	adds	r0, r2, #0
    eeee:	2312      	movs	r3, #18
    eef0:	41d8      	rors	r0, r3
    eef2:	1c13      	adds	r3, r2, #0
    eef4:	2507      	movs	r5, #7
    eef6:	41eb      	rors	r3, r5
    eef8:	4058      	eors	r0, r3
    eefa:	4680      	mov	r8, r0
    eefc:	08d2      	lsrs	r2, r2, #3
    eefe:	1c23      	adds	r3, r4, #0
    ef00:	330d      	adds	r3, #13
		s1 = W256[(j+14)&0x0f];	
    ef02:	4650      	mov	r0, sl
    ef04:	4003      	ands	r3, r0
    ef06:	009b      	lsls	r3, r3, #2
    ef08:	4648      	mov	r0, r9
    ef0a:	581b      	ldr	r3, [r3, r0]
		s1 = sigma1_256(s1);
    ef0c:	1c1d      	adds	r5, r3, #0
    ef0e:	2013      	movs	r0, #19
    ef10:	41c5      	rors	r5, r0
    ef12:	1c18      	adds	r0, r3, #0
    ef14:	2611      	movs	r6, #17
    ef16:	41f0      	rors	r0, r6
    ef18:	4045      	eors	r5, r0
    ef1a:	9506      	str	r5, [sp, #24]
    ef1c:	0a9b      	lsrs	r3, r3, #10
    ef1e:	1e60      	subs	r0, r4, #1

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
    ef20:	4655      	mov	r5, sl
    ef22:	4028      	ands	r0, r5
    ef24:	0080      	lsls	r0, r0, #2
    ef26:	4448      	add	r0, r9
    ef28:	1c25      	adds	r5, r4, #0
    ef2a:	3508      	adds	r5, #8
    ef2c:	4656      	mov	r6, sl
    ef2e:	4035      	ands	r5, r6
    ef30:	00ad      	lsls	r5, r5, #2
    ef32:	464e      	mov	r6, r9
    ef34:	59ad      	ldr	r5, [r5, r6]
    ef36:	6806      	ldr	r6, [r0, #0]
    ef38:	46b4      	mov	ip, r6
    ef3a:	4465      	add	r5, ip
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W256[(j+1)&0x0f];
		s0 = sigma0_256(s0);
    ef3c:	4646      	mov	r6, r8
    ef3e:	4072      	eors	r2, r6
    ef40:	18aa      	adds	r2, r5, r2
		s1 = W256[(j+14)&0x0f];	
		s1 = sigma1_256(s1);
    ef42:	9d06      	ldr	r5, [sp, #24]
    ef44:	406b      	eors	r3, r5

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
    ef46:	18d3      	adds	r3, r2, r3
    ef48:	465a      	mov	r2, fp
    ef4a:	ca20      	ldmia	r2!, {r5}
    ef4c:	4693      	mov	fp, r2
    ef4e:	46ac      	mov	ip, r5
    ef50:	449c      	add	ip, r3
		s0 = sigma0_256(s0);
		s1 = W256[(j+14)&0x0f];	
		s1 = sigma1_256(s1);

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
    ef52:	1c3d      	adds	r5, r7, #0
    ef54:	2206      	movs	r2, #6
    ef56:	41d5      	rors	r5, r2
    ef58:	1c3a      	adds	r2, r7, #0
    ef5a:	260b      	movs	r6, #11
    ef5c:	41f2      	rors	r2, r6
    ef5e:	4055      	eors	r5, r2
    ef60:	1c3a      	adds	r2, r7, #0
    ef62:	360e      	adds	r6, #14
    ef64:	41f2      	rors	r2, r6
    ef66:	4055      	eors	r5, r2
    ef68:	4465      	add	r5, ip
    ef6a:	9a02      	ldr	r2, [sp, #8]
    ef6c:	403a      	ands	r2, r7
    ef6e:	9e01      	ldr	r6, [sp, #4]
    ef70:	43be      	bics	r6, r7
    ef72:	4072      	eors	r2, r6
    ef74:	18aa      	adds	r2, r5, r2
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
    ef76:	6003      	str	r3, [r0, #0]
		s0 = sigma0_256(s0);
		s1 = W256[(j+14)&0x0f];	
		s1 = sigma1_256(s1);

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
    ef78:	9b04      	ldr	r3, [sp, #16]
    ef7a:	469c      	mov	ip, r3
    ef7c:	4462      	add	r2, ip
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
		T2 = Sigma0_256(a) + Maj(a, b, c);
    ef7e:	9800      	ldr	r0, [sp, #0]
    ef80:	1c03      	adds	r3, r0, #0
    ef82:	9d03      	ldr	r5, [sp, #12]
    ef84:	406b      	eors	r3, r5
    ef86:	400b      	ands	r3, r1
    ef88:	4028      	ands	r0, r5
    ef8a:	4043      	eors	r3, r0
    ef8c:	200d      	movs	r0, #13
    ef8e:	1c0d      	adds	r5, r1, #0
    ef90:	41c5      	rors	r5, r0
    ef92:	380b      	subs	r0, #11
    ef94:	1c0e      	adds	r6, r1, #0
    ef96:	41c6      	rors	r6, r0
    ef98:	4075      	eors	r5, r6
    ef9a:	2016      	movs	r0, #22
    ef9c:	1c0e      	adds	r6, r1, #0
    ef9e:	41c6      	rors	r6, r0
    efa0:	1c30      	adds	r0, r6, #0
    efa2:	4068      	eors	r0, r5
    efa4:	181b      	adds	r3, r3, r0
		h = g;
		g = f;
		f = e;
		e = d + T1;
    efa6:	9d05      	ldr	r5, [sp, #20]
    efa8:	18a8      	adds	r0, r5, r2
		d = c;
		c = b;
		b = a;
		a = T1 + T2;
    efaa:	189b      	adds	r3, r3, r2
    efac:	9a00      	ldr	r2, [sp, #0]
    efae:	9205      	str	r2, [sp, #20]
    efb0:	9e01      	ldr	r6, [sp, #4]
    efb2:	9604      	str	r6, [sp, #16]

		j++;
	} while (j < 64);
    efb4:	2c40      	cmp	r4, #64	; 0x40
    efb6:	d18b      	bne.n	eed0 <SHA256_Transform+0x114>
    efb8:	9a03      	ldr	r2, [sp, #12]
    efba:	4694      	mov	ip, r2
    efbc:	1c06      	adds	r6, r0, #0

	/* Compute the current intermediate hash value */
	context->state[0] += a;
    efbe:	9a07      	ldr	r2, [sp, #28]
    efc0:	6810      	ldr	r0, [r2, #0]
    efc2:	4680      	mov	r8, r0
    efc4:	4443      	add	r3, r8
    efc6:	6013      	str	r3, [r2, #0]
	context->state[1] += b;
    efc8:	6853      	ldr	r3, [r2, #4]
    efca:	4698      	mov	r8, r3
    efcc:	4441      	add	r1, r8
    efce:	6051      	str	r1, [r2, #4]
	context->state[2] += c;
    efd0:	6893      	ldr	r3, [r2, #8]
    efd2:	4463      	add	r3, ip
    efd4:	6093      	str	r3, [r2, #8]
	context->state[3] += d;
    efd6:	68d3      	ldr	r3, [r2, #12]
    efd8:	9303      	str	r3, [sp, #12]
    efda:	9b00      	ldr	r3, [sp, #0]
    efdc:	9903      	ldr	r1, [sp, #12]
    efde:	468c      	mov	ip, r1
    efe0:	4463      	add	r3, ip
    efe2:	60d3      	str	r3, [r2, #12]
	context->state[4] += e;
    efe4:	6913      	ldr	r3, [r2, #16]
    efe6:	469c      	mov	ip, r3
    efe8:	4466      	add	r6, ip
    efea:	6116      	str	r6, [r2, #16]
	context->state[5] += f;
    efec:	6953      	ldr	r3, [r2, #20]
    efee:	19db      	adds	r3, r3, r7
    eff0:	6153      	str	r3, [r2, #20]
	context->state[6] += g;
    eff2:	6993      	ldr	r3, [r2, #24]
    eff4:	9300      	str	r3, [sp, #0]
    eff6:	9b02      	ldr	r3, [sp, #8]
    eff8:	9900      	ldr	r1, [sp, #0]
    effa:	468c      	mov	ip, r1
    effc:	4463      	add	r3, ip
    effe:	6193      	str	r3, [r2, #24]
	context->state[7] += h;
    f000:	69d3      	ldr	r3, [r2, #28]
    f002:	9300      	str	r3, [sp, #0]
    f004:	9b01      	ldr	r3, [sp, #4]
    f006:	9900      	ldr	r1, [sp, #0]
    f008:	468c      	mov	ip, r1
    f00a:	4463      	add	r3, ip
    f00c:	61d3      	str	r3, [r2, #28]

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = T2 = 0;
}
    f00e:	b009      	add	sp, #36	; 0x24
    f010:	bc3c      	pop	{r2, r3, r4, r5}
    f012:	4690      	mov	r8, r2
    f014:	4699      	mov	r9, r3
    f016:	46a2      	mov	sl, r4
    f018:	46ab      	mov	fp, r5
    f01a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f01c:	00ff00ff 	.word	0x00ff00ff
    f020:	ff00ff00 	.word	0xff00ff00
    f024:	00020268 	.word	0x00020268

0000f028 <SHA256_Update>:

#endif /* SHA2_UNROLL_TRANSFORM */

void SHA256_Update(SHA256_CTX* context, const sha2_byte *data, size_t len) 
{
    f028:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f02a:	465f      	mov	r7, fp
    f02c:	4656      	mov	r6, sl
    f02e:	464d      	mov	r5, r9
    f030:	4644      	mov	r4, r8
    f032:	b4f0      	push	{r4, r5, r6, r7}
    f034:	1c04      	adds	r4, r0, #0
    f036:	468b      	mov	fp, r1
    f038:	4691      	mov	r9, r2
	unsigned int	freespace, usedspace;

	if (len == 0) 
    f03a:	2a00      	cmp	r2, #0
    f03c:	d070      	beq.n	f120 <SHA256_Update+0xf8>
		/* Calling with no data is valid - we do nothing */
		return;
	}

	/* Sanity check: */
	assert(context != (SHA256_CTX*)0 && data != (sha2_byte*)0);
    f03e:	2800      	cmp	r0, #0
    f040:	d001      	beq.n	f046 <SHA256_Update+0x1e>
    f042:	2900      	cmp	r1, #0
    f044:	d106      	bne.n	f054 <SHA256_Update+0x2c>
    f046:	4839      	ldr	r0, [pc, #228]	; (f12c <SHA256_Update+0x104>)
    f048:	218e      	movs	r1, #142	; 0x8e
    f04a:	0089      	lsls	r1, r1, #2
    f04c:	4a38      	ldr	r2, [pc, #224]	; (f130 <SHA256_Update+0x108>)
    f04e:	4b39      	ldr	r3, [pc, #228]	; (f134 <SHA256_Update+0x10c>)
    f050:	4c39      	ldr	r4, [pc, #228]	; (f138 <SHA256_Update+0x110>)
    f052:	47a0      	blx	r4

	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
    f054:	6a03      	ldr	r3, [r0, #32]
    f056:	05d8      	lsls	r0, r3, #23
    f058:	0e80      	lsrs	r0, r0, #26
	if (usedspace > 0)
    f05a:	d05d      	beq.n	f118 <SHA256_Update+0xf0>
	{
		/* Calculate how much free space is available in the buffer */
		freespace = SHA256_BLOCK_LENGTH - usedspace;
    f05c:	2540      	movs	r5, #64	; 0x40
    f05e:	1a2d      	subs	r5, r5, r0

		if (len >= freespace) 
    f060:	42aa      	cmp	r2, r5
    f062:	d31a      	bcc.n	f09a <SHA256_Update+0x72>
		{
			/* Fill the buffer completely and process it */
			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
    f064:	3028      	adds	r0, #40	; 0x28
    f066:	1820      	adds	r0, r4, r0
    f068:	1c2a      	adds	r2, r5, #0
    f06a:	4b34      	ldr	r3, [pc, #208]	; (f13c <SHA256_Update+0x114>)
    f06c:	4798      	blx	r3
			context->bitcount += freespace << 3;
    f06e:	00ea      	lsls	r2, r5, #3
    f070:	2300      	movs	r3, #0
    f072:	6a20      	ldr	r0, [r4, #32]
    f074:	6a61      	ldr	r1, [r4, #36]	; 0x24
    f076:	1812      	adds	r2, r2, r0
    f078:	414b      	adcs	r3, r1
    f07a:	6222      	str	r2, [r4, #32]
    f07c:	6263      	str	r3, [r4, #36]	; 0x24
			len -= freespace;
    f07e:	464b      	mov	r3, r9
    f080:	1b5b      	subs	r3, r3, r5
    f082:	4699      	mov	r9, r3
			data += freespace;
    f084:	44ab      	add	fp, r5
			SHA256_Transform(context, (sha2_word32*)context->buffer);
    f086:	1c21      	adds	r1, r4, #0
    f088:	3128      	adds	r1, #40	; 0x28
    f08a:	1c20      	adds	r0, r4, #0
    f08c:	4b2c      	ldr	r3, [pc, #176]	; (f140 <SHA256_Update+0x118>)
    f08e:	4798      	blx	r3
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
    f090:	464b      	mov	r3, r9
		if (len >= freespace) 
		{
			/* Fill the buffer completely and process it */
			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
			context->bitcount += freespace << 3;
			len -= freespace;
    f092:	464d      	mov	r5, r9
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
    f094:	2b3f      	cmp	r3, #63	; 0x3f
    f096:	d92e      	bls.n	f0f6 <SHA256_Update+0xce>
    f098:	e00d      	b.n	f0b6 <SHA256_Update+0x8e>
			SHA256_Transform(context, (sha2_word32*)context->buffer);
		}
		else
		{
			/* The buffer is not yet full */
			MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
    f09a:	3028      	adds	r0, #40	; 0x28
    f09c:	1820      	adds	r0, r4, r0
    f09e:	4b27      	ldr	r3, [pc, #156]	; (f13c <SHA256_Update+0x114>)
    f0a0:	4798      	blx	r3
			context->bitcount += len << 3;
    f0a2:	4649      	mov	r1, r9
    f0a4:	00ca      	lsls	r2, r1, #3
    f0a6:	2300      	movs	r3, #0
    f0a8:	6a20      	ldr	r0, [r4, #32]
    f0aa:	6a61      	ldr	r1, [r4, #36]	; 0x24
    f0ac:	1812      	adds	r2, r2, r0
    f0ae:	414b      	adcs	r3, r1
    f0b0:	6222      	str	r2, [r4, #32]
    f0b2:	6263      	str	r3, [r4, #36]	; 0x24
			/* Clean up: */
			usedspace = freespace = 0;
			return;
    f0b4:	e034      	b.n	f120 <SHA256_Update+0xf8>
}

#endif /* SHA2_UNROLL_TRANSFORM */

void SHA256_Update(SHA256_CTX* context, const sha2_byte *data, size_t len) 
{
    f0b6:	46c8      	mov	r8, r9
    f0b8:	465d      	mov	r5, fp
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
	{
		/* Process as many complete blocks as we can */
		SHA256_Transform(context, (sha2_word32*)data);
    f0ba:	4b21      	ldr	r3, [pc, #132]	; (f140 <SHA256_Update+0x118>)
    f0bc:	469a      	mov	sl, r3
		context->bitcount += SHA256_BLOCK_LENGTH << 3;
    f0be:	2680      	movs	r6, #128	; 0x80
    f0c0:	00b6      	lsls	r6, r6, #2
    f0c2:	2700      	movs	r7, #0
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
	{
		/* Process as many complete blocks as we can */
		SHA256_Transform(context, (sha2_word32*)data);
    f0c4:	1c20      	adds	r0, r4, #0
    f0c6:	1c29      	adds	r1, r5, #0
    f0c8:	47d0      	blx	sl
		context->bitcount += SHA256_BLOCK_LENGTH << 3;
    f0ca:	6a22      	ldr	r2, [r4, #32]
    f0cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    f0ce:	1992      	adds	r2, r2, r6
    f0d0:	417b      	adcs	r3, r7
    f0d2:	6222      	str	r2, [r4, #32]
    f0d4:	6263      	str	r3, [r4, #36]	; 0x24
		len -= SHA256_BLOCK_LENGTH;
    f0d6:	2340      	movs	r3, #64	; 0x40
    f0d8:	425b      	negs	r3, r3
    f0da:	469c      	mov	ip, r3
    f0dc:	44e0      	add	r8, ip
		data += SHA256_BLOCK_LENGTH;
    f0de:	3540      	adds	r5, #64	; 0x40
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
    f0e0:	4643      	mov	r3, r8
    f0e2:	2b3f      	cmp	r3, #63	; 0x3f
    f0e4:	d8ee      	bhi.n	f0c4 <SHA256_Update+0x9c>
    f0e6:	253f      	movs	r5, #63	; 0x3f
    f0e8:	464b      	mov	r3, r9
    f0ea:	401d      	ands	r5, r3
    f0ec:	4463      	add	r3, ip
    f0ee:	099b      	lsrs	r3, r3, #6
    f0f0:	3301      	adds	r3, #1
    f0f2:	019b      	lsls	r3, r3, #6
    f0f4:	449b      	add	fp, r3
		SHA256_Transform(context, (sha2_word32*)data);
		context->bitcount += SHA256_BLOCK_LENGTH << 3;
		len -= SHA256_BLOCK_LENGTH;
		data += SHA256_BLOCK_LENGTH;
	}
	if (len > 0) 
    f0f6:	2d00      	cmp	r5, #0
    f0f8:	d012      	beq.n	f120 <SHA256_Update+0xf8>
	{
		/* There's left-overs, so save 'em */
		MEMCPY_BCOPY(context->buffer, data, len);
    f0fa:	1c20      	adds	r0, r4, #0
    f0fc:	3028      	adds	r0, #40	; 0x28
    f0fe:	4659      	mov	r1, fp
    f100:	1c2a      	adds	r2, r5, #0
    f102:	4b0e      	ldr	r3, [pc, #56]	; (f13c <SHA256_Update+0x114>)
    f104:	4798      	blx	r3
		context->bitcount += len << 3;
    f106:	00ea      	lsls	r2, r5, #3
    f108:	2300      	movs	r3, #0
    f10a:	6a20      	ldr	r0, [r4, #32]
    f10c:	6a61      	ldr	r1, [r4, #36]	; 0x24
    f10e:	1812      	adds	r2, r2, r0
    f110:	414b      	adcs	r3, r1
    f112:	6222      	str	r2, [r4, #32]
    f114:	6263      	str	r3, [r4, #36]	; 0x24
    f116:	e003      	b.n	f120 <SHA256_Update+0xf8>
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) 
    f118:	1e15      	subs	r5, r2, #0
    f11a:	2d3f      	cmp	r5, #63	; 0x3f
    f11c:	d9ed      	bls.n	f0fa <SHA256_Update+0xd2>
    f11e:	e7ca      	b.n	f0b6 <SHA256_Update+0x8e>
		MEMCPY_BCOPY(context->buffer, data, len);
		context->bitcount += len << 3;
	}
	/* Clean up: */
	usedspace = freespace = 0;
}
    f120:	bc3c      	pop	{r2, r3, r4, r5}
    f122:	4690      	mov	r8, r2
    f124:	4699      	mov	r9, r3
    f126:	46a2      	mov	sl, r4
    f128:	46ab      	mov	fp, r5
    f12a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f12c:	00020174 	.word	0x00020174
    f130:	00020134 	.word	0x00020134
    f134:	00020198 	.word	0x00020198
    f138:	00016629 	.word	0x00016629
    f13c:	00016739 	.word	0x00016739
    f140:	0000edbd 	.word	0x0000edbd

0000f144 <SHA256_Final>:

void SHA256_Final(sha2_byte digest[], SHA256_CTX* context) 
{
    f144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f146:	1c05      	adds	r5, r0, #0
    f148:	1e0c      	subs	r4, r1, #0
	sha2_word32	*d = (sha2_word32*)digest;
	unsigned int	usedspace;

	/* Sanity check: */
	assert(context != (SHA256_CTX*)0);
    f14a:	d105      	bne.n	f158 <SHA256_Final+0x14>
    f14c:	4837      	ldr	r0, [pc, #220]	; (f22c <SHA256_Final+0xe8>)
    f14e:	4938      	ldr	r1, [pc, #224]	; (f230 <SHA256_Final+0xec>)
    f150:	4a38      	ldr	r2, [pc, #224]	; (f234 <SHA256_Final+0xf0>)
    f152:	4b39      	ldr	r3, [pc, #228]	; (f238 <SHA256_Final+0xf4>)
    f154:	4c39      	ldr	r4, [pc, #228]	; (f23c <SHA256_Final+0xf8>)
    f156:	47a0      	blx	r4

	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != (sha2_byte*)0) 
    f158:	2800      	cmp	r0, #0
    f15a:	d061      	beq.n	f220 <SHA256_Final+0xdc>
	{
		usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
    f15c:	6a0f      	ldr	r7, [r1, #32]
    f15e:	6a4e      	ldr	r6, [r1, #36]	; 0x24
    f160:	05fa      	lsls	r2, r7, #23
    f162:	0e92      	lsrs	r2, r2, #26
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert FROM host byte order */
		REVERSE64(context->bitcount,context->bitcount);
    f164:	4b36      	ldr	r3, [pc, #216]	; (f240 <SHA256_Final+0xfc>)
    f166:	1c30      	adds	r0, r6, #0
    f168:	4018      	ands	r0, r3
    f16a:	403b      	ands	r3, r7
    f16c:	0a00      	lsrs	r0, r0, #8
    f16e:	0a19      	lsrs	r1, r3, #8
    f170:	4b34      	ldr	r3, [pc, #208]	; (f244 <SHA256_Final+0x100>)
    f172:	401e      	ands	r6, r3
    f174:	403b      	ands	r3, r7
    f176:	021b      	lsls	r3, r3, #8
    f178:	0236      	lsls	r6, r6, #8
    f17a:	4330      	orrs	r0, r6
    f17c:	430b      	orrs	r3, r1
    f17e:	0419      	lsls	r1, r3, #16
    f180:	0406      	lsls	r6, r0, #16
    f182:	0c00      	lsrs	r0, r0, #16
    f184:	0c1b      	lsrs	r3, r3, #16
    f186:	4330      	orrs	r0, r6
    f188:	6220      	str	r0, [r4, #32]
    f18a:	430b      	orrs	r3, r1
    f18c:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		if (usedspace > 0) 
    f18e:	2a00      	cmp	r2, #0
    f190:	d023      	beq.n	f1da <SHA256_Final+0x96>
		{
			/* Begin padding with a 1 bit: */
			context->buffer[usedspace++] = 0x80;
    f192:	1c50      	adds	r0, r2, #1
    f194:	18a3      	adds	r3, r4, r2
    f196:	3328      	adds	r3, #40	; 0x28
    f198:	2180      	movs	r1, #128	; 0x80
    f19a:	7019      	strb	r1, [r3, #0]

			if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) 
    f19c:	2838      	cmp	r0, #56	; 0x38
    f19e:	d807      	bhi.n	f1b0 <SHA256_Final+0x6c>
			{
				/* Set-up for the last transform: */
				MEMSET_BZERO(&context->buffer[usedspace], SHA256_SHORT_BLOCK_LENGTH - usedspace);
    f1a0:	2337      	movs	r3, #55	; 0x37
    f1a2:	1a9a      	subs	r2, r3, r2
    f1a4:	3028      	adds	r0, #40	; 0x28
    f1a6:	1820      	adds	r0, r4, r0
    f1a8:	2100      	movs	r1, #0
    f1aa:	4b27      	ldr	r3, [pc, #156]	; (f248 <SHA256_Final+0x104>)
    f1ac:	4798      	blx	r3
    f1ae:	e01d      	b.n	f1ec <SHA256_Final+0xa8>
			}
			else
			{
				if (usedspace < SHA256_BLOCK_LENGTH) 
    f1b0:	283f      	cmp	r0, #63	; 0x3f
    f1b2:	d806      	bhi.n	f1c2 <SHA256_Final+0x7e>
				{
					MEMSET_BZERO(&context->buffer[usedspace], SHA256_BLOCK_LENGTH - usedspace);
    f1b4:	233f      	movs	r3, #63	; 0x3f
    f1b6:	1a9a      	subs	r2, r3, r2
    f1b8:	3028      	adds	r0, #40	; 0x28
    f1ba:	1820      	adds	r0, r4, r0
    f1bc:	2100      	movs	r1, #0
    f1be:	4b22      	ldr	r3, [pc, #136]	; (f248 <SHA256_Final+0x104>)
    f1c0:	4798      	blx	r3
				}
				/* Do second-to-last transform: */
				SHA256_Transform(context, (sha2_word32*)context->buffer);
    f1c2:	1c26      	adds	r6, r4, #0
    f1c4:	3628      	adds	r6, #40	; 0x28
    f1c6:	1c20      	adds	r0, r4, #0
    f1c8:	1c31      	adds	r1, r6, #0
    f1ca:	4b20      	ldr	r3, [pc, #128]	; (f24c <SHA256_Final+0x108>)
    f1cc:	4798      	blx	r3

				/* And set-up for the last transform: */
				MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
    f1ce:	1c30      	adds	r0, r6, #0
    f1d0:	2100      	movs	r1, #0
    f1d2:	2238      	movs	r2, #56	; 0x38
    f1d4:	4b1c      	ldr	r3, [pc, #112]	; (f248 <SHA256_Final+0x104>)
    f1d6:	4798      	blx	r3
    f1d8:	e008      	b.n	f1ec <SHA256_Final+0xa8>
			}
		} 
		else
		 {
			/* Set-up for the last transform: */
			MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
    f1da:	1c20      	adds	r0, r4, #0
    f1dc:	3028      	adds	r0, #40	; 0x28
    f1de:	2100      	movs	r1, #0
    f1e0:	2238      	movs	r2, #56	; 0x38
    f1e2:	4b19      	ldr	r3, [pc, #100]	; (f248 <SHA256_Final+0x104>)
    f1e4:	4798      	blx	r3

			/* Begin padding with a 1 bit: */
			*context->buffer = 0x80;
    f1e6:	2280      	movs	r2, #128	; 0x80
    f1e8:	2328      	movs	r3, #40	; 0x28
    f1ea:	54e2      	strb	r2, [r4, r3]
		}
		/* Set the bit count: */
		*(sha2_word64*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
    f1ec:	6a22      	ldr	r2, [r4, #32]
    f1ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
    f1f0:	6622      	str	r2, [r4, #96]	; 0x60
    f1f2:	6663      	str	r3, [r4, #100]	; 0x64

		/* Final transform: */
		SHA256_Transform(context, (sha2_word32*)context->buffer);
    f1f4:	1c21      	adds	r1, r4, #0
    f1f6:	3128      	adds	r1, #40	; 0x28
    f1f8:	1c20      	adds	r0, r4, #0
    f1fa:	4b14      	ldr	r3, [pc, #80]	; (f24c <SHA256_Final+0x108>)
    f1fc:	4798      	blx	r3
    f1fe:	2100      	movs	r1, #0
		{
			/* Convert TO host byte order */
			int	j;
			for (j = 0; j < 8; j++)
			{
				REVERSE32(context->state[j],context->state[j]);
    f200:	2710      	movs	r7, #16
    f202:	4e10      	ldr	r6, [pc, #64]	; (f244 <SHA256_Final+0x100>)
    f204:	480e      	ldr	r0, [pc, #56]	; (f240 <SHA256_Final+0xfc>)
    f206:	5862      	ldr	r2, [r4, r1]
    f208:	41fa      	rors	r2, r7
    f20a:	1c13      	adds	r3, r2, #0
    f20c:	4033      	ands	r3, r6
    f20e:	021b      	lsls	r3, r3, #8
    f210:	4002      	ands	r2, r0
    f212:	0a12      	lsrs	r2, r2, #8
    f214:	4313      	orrs	r3, r2
    f216:	5063      	str	r3, [r4, r1]
				*d++ = context->state[j];
    f218:	506b      	str	r3, [r5, r1]
    f21a:	3104      	adds	r1, #4

#if BYTE_ORDER == LITTLE_ENDIAN
		{
			/* Convert TO host byte order */
			int	j;
			for (j = 0; j < 8; j++)
    f21c:	2920      	cmp	r1, #32
    f21e:	d1f2      	bne.n	f206 <SHA256_Final+0xc2>
		MEMCPY_BCOPY(d, context->state, SHA256_DIGEST_LENGTH);
#endif
	}

	/* Clean up state data: */
	MEMSET_BZERO(context, sizeof(SHA256_CTX));
    f220:	1c20      	adds	r0, r4, #0
    f222:	2100      	movs	r1, #0
    f224:	2268      	movs	r2, #104	; 0x68
    f226:	4b08      	ldr	r3, [pc, #32]	; (f248 <SHA256_Final+0x104>)
    f228:	4798      	blx	r3
	usedspace = 0;
}
    f22a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f22c:	00020174 	.word	0x00020174
    f230:	0000026b 	.word	0x0000026b
    f234:	00020144 	.word	0x00020144
    f238:	000201cc 	.word	0x000201cc
    f23c:	00016629 	.word	0x00016629
    f240:	ff00ff00 	.word	0xff00ff00
    f244:	00ff00ff 	.word	0x00ff00ff
    f248:	00016773 	.word	0x00016773
    f24c:	0000edbd 	.word	0x0000edbd

0000f250 <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    f250:	4a04      	ldr	r2, [pc, #16]	; (f264 <_extint_enable+0x14>)
    f252:	7811      	ldrb	r1, [r2, #0]
    f254:	2302      	movs	r3, #2
    f256:	430b      	orrs	r3, r1
    f258:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    f25a:	7853      	ldrb	r3, [r2, #1]
    f25c:	b25b      	sxtb	r3, r3
    f25e:	2b00      	cmp	r3, #0
    f260:	dbfb      	blt.n	f25a <_extint_enable+0xa>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    f262:	4770      	bx	lr
    f264:	40001800 	.word	0x40001800

0000f268 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    f268:	b500      	push	{lr}
    f26a:	b083      	sub	sp, #12
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    f26c:	4a12      	ldr	r2, [pc, #72]	; (f2b8 <_system_extint_init+0x50>)
    f26e:	6991      	ldr	r1, [r2, #24]
    f270:	2340      	movs	r3, #64	; 0x40
    f272:	430b      	orrs	r3, r1
    f274:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    f276:	a901      	add	r1, sp, #4
    f278:	2300      	movs	r3, #0
    f27a:	700b      	strb	r3, [r1, #0]

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    f27c:	2005      	movs	r0, #5
    f27e:	4b0f      	ldr	r3, [pc, #60]	; (f2bc <_system_extint_init+0x54>)
    f280:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    f282:	2005      	movs	r0, #5
    f284:	4b0e      	ldr	r3, [pc, #56]	; (f2c0 <_system_extint_init+0x58>)
    f286:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    f288:	4a0e      	ldr	r2, [pc, #56]	; (f2c4 <_system_extint_init+0x5c>)
    f28a:	7811      	ldrb	r1, [r2, #0]
    f28c:	2301      	movs	r3, #1
    f28e:	430b      	orrs	r3, r1
    f290:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    f292:	7853      	ldrb	r3, [r2, #1]
    f294:	b25b      	sxtb	r3, r3
    f296:	2b00      	cmp	r3, #0
    f298:	dbfb      	blt.n	f292 <_system_extint_init+0x2a>
    f29a:	4b0b      	ldr	r3, [pc, #44]	; (f2c8 <_system_extint_init+0x60>)
    f29c:	1c19      	adds	r1, r3, #0
    f29e:	3140      	adds	r1, #64	; 0x40

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    f2a0:	2200      	movs	r2, #0
    f2a2:	c304      	stmia	r3!, {r2}
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    f2a4:	428b      	cmp	r3, r1
    f2a6:	d1fc      	bne.n	f2a2 <_system_extint_init+0x3a>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    f2a8:	2210      	movs	r2, #16
    f2aa:	4b08      	ldr	r3, [pc, #32]	; (f2cc <_system_extint_init+0x64>)
    f2ac:	601a      	str	r2, [r3, #0]
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
    f2ae:	4b08      	ldr	r3, [pc, #32]	; (f2d0 <_system_extint_init+0x68>)
    f2b0:	4798      	blx	r3
}
    f2b2:	b003      	add	sp, #12
    f2b4:	bd00      	pop	{pc}
    f2b6:	46c0      	nop			; (mov r8, r8)
    f2b8:	40000400 	.word	0x40000400
    f2bc:	0001392d 	.word	0x0001392d
    f2c0:	000138a1 	.word	0x000138a1
    f2c4:	40001800 	.word	0x40001800
    f2c8:	20002acc 	.word	0x20002acc
    f2cc:	e000e100 	.word	0xe000e100
    f2d0:	0000f251 	.word	0x0000f251

0000f2d4 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    f2d4:	2300      	movs	r3, #0
    f2d6:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
    f2d8:	6043      	str	r3, [r0, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    f2da:	2201      	movs	r2, #1
    f2dc:	7202      	strb	r2, [r0, #8]
	config->wake_if_sleeping    = true;
    f2de:	7242      	strb	r2, [r0, #9]
	config->filter_input_signal = false;
    f2e0:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    f2e2:	3302      	adds	r3, #2
    f2e4:	72c3      	strb	r3, [r0, #11]
}
    f2e6:	4770      	bx	lr

0000f2e8 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    f2e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    f2ea:	b083      	sub	sp, #12
    f2ec:	1c05      	adds	r5, r0, #0
    f2ee:	1c0c      	adds	r4, r1, #0
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    f2f0:	a901      	add	r1, sp, #4
    f2f2:	2300      	movs	r3, #0
    f2f4:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    f2f6:	70cb      	strb	r3, [r1, #3]
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
    f2f8:	7923      	ldrb	r3, [r4, #4]
    f2fa:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    f2fc:	7a23      	ldrb	r3, [r4, #8]
    f2fe:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    f300:	7820      	ldrb	r0, [r4, #0]
    f302:	4b15      	ldr	r3, [pc, #84]	; (f358 <extint_chan_set_config+0x70>)
    f304:	4798      	blx	r3
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    f306:	2600      	movs	r6, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    f308:	2d1f      	cmp	r5, #31
    f30a:	d800      	bhi.n	f30e <extint_chan_set_config+0x26>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    f30c:	4e13      	ldr	r6, [pc, #76]	; (f35c <extint_chan_set_config+0x74>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
    f30e:	2207      	movs	r2, #7
    f310:	402a      	ands	r2, r5
    f312:	0092      	lsls	r2, r2, #2
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    f314:	7ae0      	ldrb	r0, [r4, #11]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    f316:	7aa3      	ldrb	r3, [r4, #10]
    f318:	2b00      	cmp	r3, #0
    f31a:	d001      	beq.n	f320 <extint_chan_set_config+0x38>
		new_config |= EIC_CONFIG_FILTEN0;
    f31c:	2308      	movs	r3, #8
    f31e:	4318      	orrs	r0, r3
    f320:	08eb      	lsrs	r3, r5, #3
    f322:	009b      	lsls	r3, r3, #2
    f324:	18f3      	adds	r3, r6, r3
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    f326:	6999      	ldr	r1, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
    f328:	4090      	lsls	r0, r2
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    f32a:	270f      	movs	r7, #15
    f32c:	4097      	lsls	r7, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    f32e:	43b9      	bics	r1, r7
    f330:	1c0a      	adds	r2, r1, #0
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    f332:	4302      	orrs	r2, r0
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    f334:	619a      	str	r2, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
    f336:	7a63      	ldrb	r3, [r4, #9]
    f338:	2b00      	cmp	r3, #0
    f33a:	d006      	beq.n	f34a <extint_chan_set_config+0x62>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
    f33c:	6973      	ldr	r3, [r6, #20]
    f33e:	2201      	movs	r2, #1
    f340:	40aa      	lsls	r2, r5
    f342:	1c15      	adds	r5, r2, #0
    f344:	431d      	orrs	r5, r3
    f346:	6175      	str	r5, [r6, #20]
    f348:	e004      	b.n	f354 <extint_chan_set_config+0x6c>
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
    f34a:	6973      	ldr	r3, [r6, #20]
    f34c:	2201      	movs	r2, #1
    f34e:	40aa      	lsls	r2, r5
    f350:	4393      	bics	r3, r2
    f352:	6173      	str	r3, [r6, #20]
	}
}
    f354:	b003      	add	sp, #12
    f356:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f358:	00013a25 	.word	0x00013a25
    f35c:	40001800 	.word	0x40001800

0000f360 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    f360:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    f362:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f364:	2440      	movs	r4, #64	; 0x40
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    f366:	4281      	cmp	r1, r0
    f368:	d30c      	bcc.n	f384 <_sercom_get_sync_baud_val+0x24>
    f36a:	2300      	movs	r3, #0
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
    f36c:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    f36e:	3301      	adds	r3, #1
    f370:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    f372:	4288      	cmp	r0, r1
    f374:	d9fa      	bls.n	f36c <_sercom_get_sync_baud_val+0xc>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
    f376:	3b01      	subs	r3, #1
    f378:	b29b      	uxth	r3, r3

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f37a:	2440      	movs	r4, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    f37c:	2bff      	cmp	r3, #255	; 0xff
    f37e:	d801      	bhi.n	f384 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
    f380:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
    f382:	2400      	movs	r4, #0
	}
}
    f384:	1c20      	adds	r0, r4, #0
    f386:	bd10      	pop	{r4, pc}

0000f388 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    f388:	b5f0      	push	{r4, r5, r6, r7, lr}
    f38a:	465f      	mov	r7, fp
    f38c:	4656      	mov	r6, sl
    f38e:	464d      	mov	r5, r9
    f390:	4644      	mov	r4, r8
    f392:	b4f0      	push	{r4, r5, r6, r7}
    f394:	b089      	sub	sp, #36	; 0x24
    f396:	1c1c      	adds	r4, r3, #0
    f398:	ab12      	add	r3, sp, #72	; 0x48
    f39a:	781b      	ldrb	r3, [r3, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    f39c:	1c06      	adds	r6, r0, #0
    f39e:	435e      	muls	r6, r3
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f3a0:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    f3a2:	428e      	cmp	r6, r1
    f3a4:	d900      	bls.n	f3a8 <_sercom_get_async_baud_val+0x20>
    f3a6:	e0c7      	b.n	f538 <_sercom_get_async_baud_val+0x1b0>
    f3a8:	1c25      	adds	r5, r4, #0
    f3aa:	9207      	str	r2, [sp, #28]
    f3ac:	1c0c      	adds	r4, r1, #0
    f3ae:	1c02      	adds	r2, r0, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    f3b0:	2d00      	cmp	r5, #0
    f3b2:	d151      	bne.n	f458 <_sercom_get_async_baud_val+0xd0>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    f3b4:	1c18      	adds	r0, r3, #0
    f3b6:	2100      	movs	r1, #0
    f3b8:	2300      	movs	r3, #0
    f3ba:	4d63      	ldr	r5, [pc, #396]	; (f548 <_sercom_get_async_baud_val+0x1c0>)
    f3bc:	47a8      	blx	r5
    f3be:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
    f3c0:	1c26      	adds	r6, r4, #0
    f3c2:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    f3c4:	2300      	movs	r3, #0
    f3c6:	2400      	movs	r4, #0
    f3c8:	9302      	str	r3, [sp, #8]
    f3ca:	9403      	str	r4, [sp, #12]
    f3cc:	2200      	movs	r2, #0
    f3ce:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    f3d0:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    f3d2:	2120      	movs	r1, #32
    f3d4:	468c      	mov	ip, r1
    f3d6:	391f      	subs	r1, #31
    f3d8:	9600      	str	r6, [sp, #0]
    f3da:	9701      	str	r7, [sp, #4]
    f3dc:	2420      	movs	r4, #32
    f3de:	4264      	negs	r4, r4
    f3e0:	1904      	adds	r4, r0, r4
    f3e2:	d403      	bmi.n	f3ec <_sercom_get_async_baud_val+0x64>
    f3e4:	1c0d      	adds	r5, r1, #0
    f3e6:	40a5      	lsls	r5, r4
    f3e8:	46a8      	mov	r8, r5
    f3ea:	e004      	b.n	f3f6 <_sercom_get_async_baud_val+0x6e>
    f3ec:	4664      	mov	r4, ip
    f3ee:	1a24      	subs	r4, r4, r0
    f3f0:	1c0d      	adds	r5, r1, #0
    f3f2:	40e5      	lsrs	r5, r4
    f3f4:	46a8      	mov	r8, r5
    f3f6:	1c0c      	adds	r4, r1, #0
    f3f8:	4084      	lsls	r4, r0
    f3fa:	46a1      	mov	r9, r4

		r = r << 1;
    f3fc:	1c14      	adds	r4, r2, #0
    f3fe:	1c1d      	adds	r5, r3, #0
    f400:	18a4      	adds	r4, r4, r2
    f402:	415d      	adcs	r5, r3
    f404:	1c22      	adds	r2, r4, #0
    f406:	1c2b      	adds	r3, r5, #0

		if (n & bit_shift) {
    f408:	465e      	mov	r6, fp
    f40a:	4647      	mov	r7, r8
    f40c:	423e      	tst	r6, r7
    f40e:	d003      	beq.n	f418 <_sercom_get_async_baud_val+0x90>
			r |= 0x01;
    f410:	1c0e      	adds	r6, r1, #0
    f412:	4326      	orrs	r6, r4
    f414:	1c32      	adds	r2, r6, #0
    f416:	1c2b      	adds	r3, r5, #0
		}

		if (r >= d) {
    f418:	9c01      	ldr	r4, [sp, #4]
    f41a:	429c      	cmp	r4, r3
    f41c:	d810      	bhi.n	f440 <_sercom_get_async_baud_val+0xb8>
    f41e:	d102      	bne.n	f426 <_sercom_get_async_baud_val+0x9e>
    f420:	9c00      	ldr	r4, [sp, #0]
    f422:	4294      	cmp	r4, r2
    f424:	d80c      	bhi.n	f440 <_sercom_get_async_baud_val+0xb8>
			r = r - d;
    f426:	9c00      	ldr	r4, [sp, #0]
    f428:	9d01      	ldr	r5, [sp, #4]
    f42a:	1b12      	subs	r2, r2, r4
    f42c:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    f42e:	464d      	mov	r5, r9
    f430:	9e02      	ldr	r6, [sp, #8]
    f432:	9f03      	ldr	r7, [sp, #12]
    f434:	4335      	orrs	r5, r6
    f436:	1c3c      	adds	r4, r7, #0
    f438:	4646      	mov	r6, r8
    f43a:	4334      	orrs	r4, r6
    f43c:	9502      	str	r5, [sp, #8]
    f43e:	9403      	str	r4, [sp, #12]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    f440:	3801      	subs	r0, #1
    f442:	d2cb      	bcs.n	f3dc <_sercom_get_async_baud_val+0x54>

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
    f444:	2200      	movs	r2, #0
    f446:	2301      	movs	r3, #1
    f448:	9802      	ldr	r0, [sp, #8]
    f44a:	9903      	ldr	r1, [sp, #12]
    f44c:	1a12      	subs	r2, r2, r0
    f44e:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
    f450:	0c11      	lsrs	r1, r2, #16
    f452:	041b      	lsls	r3, r3, #16
    f454:	4319      	orrs	r1, r3
    f456:	e06c      	b.n	f532 <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    f458:	2100      	movs	r1, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    f45a:	2d01      	cmp	r5, #1
    f45c:	d169      	bne.n	f532 <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    f45e:	0f61      	lsrs	r1, r4, #29
    f460:	1c0f      	adds	r7, r1, #0
    f462:	00e1      	lsls	r1, r4, #3
    f464:	4688      	mov	r8, r1
			temp2 = ((uint64_t)baudrate * sample_num);
    f466:	1c18      	adds	r0, r3, #0
    f468:	2100      	movs	r1, #0
    f46a:	2300      	movs	r3, #0
    f46c:	4c36      	ldr	r4, [pc, #216]	; (f548 <_sercom_get_async_baud_val+0x1c0>)
    f46e:	47a0      	blx	r4
    f470:	1c04      	adds	r4, r0, #0
    f472:	1c0d      	adds	r5, r1, #0
    f474:	2300      	movs	r3, #0
    f476:	469c      	mov	ip, r3
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
    f478:	3320      	adds	r3, #32
    f47a:	469b      	mov	fp, r3
    f47c:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
    f47e:	4663      	mov	r3, ip
    f480:	9305      	str	r3, [sp, #20]
    f482:	46b9      	mov	r9, r7
    f484:	466b      	mov	r3, sp
    f486:	7d1b      	ldrb	r3, [r3, #20]
    f488:	9306      	str	r3, [sp, #24]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    f48a:	2300      	movs	r3, #0
    f48c:	469c      	mov	ip, r3
    f48e:	2000      	movs	r0, #0
    f490:	2100      	movs	r1, #0
	for (i = 63; i >= 0; i--) {
    f492:	223f      	movs	r2, #63	; 0x3f
    f494:	9400      	str	r4, [sp, #0]
    f496:	9501      	str	r5, [sp, #4]
		bit_shift = (uint64_t)1 << i;
    f498:	2320      	movs	r3, #32
    f49a:	425b      	negs	r3, r3
    f49c:	18d3      	adds	r3, r2, r3
    f49e:	d403      	bmi.n	f4a8 <_sercom_get_async_baud_val+0x120>
    f4a0:	1c34      	adds	r4, r6, #0
    f4a2:	409c      	lsls	r4, r3
    f4a4:	1c23      	adds	r3, r4, #0
    f4a6:	e004      	b.n	f4b2 <_sercom_get_async_baud_val+0x12a>
    f4a8:	465b      	mov	r3, fp
    f4aa:	1a9b      	subs	r3, r3, r2
    f4ac:	1c34      	adds	r4, r6, #0
    f4ae:	40dc      	lsrs	r4, r3
    f4b0:	1c23      	adds	r3, r4, #0
    f4b2:	1c37      	adds	r7, r6, #0
    f4b4:	4097      	lsls	r7, r2

		r = r << 1;
    f4b6:	1c04      	adds	r4, r0, #0
    f4b8:	1c0d      	adds	r5, r1, #0
    f4ba:	1824      	adds	r4, r4, r0
    f4bc:	414d      	adcs	r5, r1
    f4be:	1c20      	adds	r0, r4, #0
    f4c0:	1c29      	adds	r1, r5, #0
    f4c2:	9002      	str	r0, [sp, #8]
    f4c4:	9103      	str	r1, [sp, #12]

		if (n & bit_shift) {
    f4c6:	4644      	mov	r4, r8
    f4c8:	403c      	ands	r4, r7
    f4ca:	46a2      	mov	sl, r4
    f4cc:	464c      	mov	r4, r9
    f4ce:	4023      	ands	r3, r4
    f4d0:	4654      	mov	r4, sl
    f4d2:	4323      	orrs	r3, r4
    f4d4:	d005      	beq.n	f4e2 <_sercom_get_async_baud_val+0x15a>
			r |= 0x01;
    f4d6:	9b02      	ldr	r3, [sp, #8]
    f4d8:	9c03      	ldr	r4, [sp, #12]
    f4da:	1c1d      	adds	r5, r3, #0
    f4dc:	4335      	orrs	r5, r6
    f4de:	1c28      	adds	r0, r5, #0
    f4e0:	1c21      	adds	r1, r4, #0
		}

		if (r >= d) {
    f4e2:	9b01      	ldr	r3, [sp, #4]
    f4e4:	428b      	cmp	r3, r1
    f4e6:	d80a      	bhi.n	f4fe <_sercom_get_async_baud_val+0x176>
    f4e8:	d102      	bne.n	f4f0 <_sercom_get_async_baud_val+0x168>
    f4ea:	9b00      	ldr	r3, [sp, #0]
    f4ec:	4283      	cmp	r3, r0
    f4ee:	d806      	bhi.n	f4fe <_sercom_get_async_baud_val+0x176>
			r = r - d;
    f4f0:	9b00      	ldr	r3, [sp, #0]
    f4f2:	9c01      	ldr	r4, [sp, #4]
    f4f4:	1ac0      	subs	r0, r0, r3
    f4f6:	41a1      	sbcs	r1, r4
			q |= bit_shift;
    f4f8:	4663      	mov	r3, ip
    f4fa:	433b      	orrs	r3, r7
    f4fc:	469c      	mov	ip, r3
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    f4fe:	3a01      	subs	r2, #1
    f500:	d2ca      	bcs.n	f498 <_sercom_get_async_baud_val+0x110>
    f502:	9c00      	ldr	r4, [sp, #0]
    f504:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
    f506:	4662      	mov	r2, ip
    f508:	9905      	ldr	r1, [sp, #20]
    f50a:	1a53      	subs	r3, r2, r1
			baud_int = baud_int / BAUD_FP_MAX;
    f50c:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    f50e:	4a0f      	ldr	r2, [pc, #60]	; (f54c <_sercom_get_async_baud_val+0x1c4>)
    f510:	4293      	cmp	r3, r2
    f512:	d908      	bls.n	f526 <_sercom_get_async_baud_val+0x19e>
    f514:	9a06      	ldr	r2, [sp, #24]
    f516:	3201      	adds	r2, #1
    f518:	b2d2      	uxtb	r2, r2
    f51a:	9206      	str	r2, [sp, #24]
    f51c:	1c0a      	adds	r2, r1, #0
    f51e:	3201      	adds	r2, #1
    f520:	9205      	str	r2, [sp, #20]
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    f522:	2a08      	cmp	r2, #8
    f524:	d1ae      	bne.n	f484 <_sercom_get_async_baud_val+0xfc>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f526:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
    f528:	9a06      	ldr	r2, [sp, #24]
    f52a:	2a08      	cmp	r2, #8
    f52c:	d004      	beq.n	f538 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    f52e:	0351      	lsls	r1, r2, #13
    f530:	4319      	orrs	r1, r3
	}

	*baudval = baud_calculated;
    f532:	9b07      	ldr	r3, [sp, #28]
    f534:	8019      	strh	r1, [r3, #0]
	return STATUS_OK;
    f536:	2500      	movs	r5, #0
}
    f538:	1c28      	adds	r0, r5, #0
    f53a:	b009      	add	sp, #36	; 0x24
    f53c:	bc3c      	pop	{r2, r3, r4, r5}
    f53e:	4690      	mov	r8, r2
    f540:	4699      	mov	r9, r3
    f542:	46a2      	mov	sl, r4
    f544:	46ab      	mov	fp, r5
    f546:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f548:	000151a1 	.word	0x000151a1
    f54c:	00001fff 	.word	0x00001fff

0000f550 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    f550:	b510      	push	{r4, lr}
    f552:	b082      	sub	sp, #8
    f554:	1c04      	adds	r4, r0, #0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    f556:	4b0e      	ldr	r3, [pc, #56]	; (f590 <sercom_set_gclk_generator+0x40>)
    f558:	781b      	ldrb	r3, [r3, #0]
    f55a:	2b00      	cmp	r3, #0
    f55c:	d001      	beq.n	f562 <sercom_set_gclk_generator+0x12>
    f55e:	2900      	cmp	r1, #0
    f560:	d00d      	beq.n	f57e <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    f562:	a901      	add	r1, sp, #4
    f564:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    f566:	2013      	movs	r0, #19
    f568:	4b0a      	ldr	r3, [pc, #40]	; (f594 <sercom_set_gclk_generator+0x44>)
    f56a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    f56c:	2013      	movs	r0, #19
    f56e:	4b0a      	ldr	r3, [pc, #40]	; (f598 <sercom_set_gclk_generator+0x48>)
    f570:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    f572:	4b07      	ldr	r3, [pc, #28]	; (f590 <sercom_set_gclk_generator+0x40>)
    f574:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    f576:	2201      	movs	r2, #1
    f578:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    f57a:	2000      	movs	r0, #0
    f57c:	e006      	b.n	f58c <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    f57e:	4b04      	ldr	r3, [pc, #16]	; (f590 <sercom_set_gclk_generator+0x40>)
    f580:	785b      	ldrb	r3, [r3, #1]
    f582:	4283      	cmp	r3, r0
    f584:	d001      	beq.n	f58a <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    f586:	201d      	movs	r0, #29
    f588:	e000      	b.n	f58c <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    f58a:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    f58c:	b002      	add	sp, #8
    f58e:	bd10      	pop	{r4, pc}
    f590:	20001294 	.word	0x20001294
    f594:	0001392d 	.word	0x0001392d
    f598:	000138a1 	.word	0x000138a1

0000f59c <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    f59c:	4b44      	ldr	r3, [pc, #272]	; (f6b0 <_sercom_get_default_pad+0x114>)
    f59e:	4298      	cmp	r0, r3
    f5a0:	d033      	beq.n	f60a <_sercom_get_default_pad+0x6e>
    f5a2:	d806      	bhi.n	f5b2 <_sercom_get_default_pad+0x16>
    f5a4:	4b43      	ldr	r3, [pc, #268]	; (f6b4 <_sercom_get_default_pad+0x118>)
    f5a6:	4298      	cmp	r0, r3
    f5a8:	d00d      	beq.n	f5c6 <_sercom_get_default_pad+0x2a>
    f5aa:	4b43      	ldr	r3, [pc, #268]	; (f6b8 <_sercom_get_default_pad+0x11c>)
    f5ac:	4298      	cmp	r0, r3
    f5ae:	d01b      	beq.n	f5e8 <_sercom_get_default_pad+0x4c>
    f5b0:	e06f      	b.n	f692 <_sercom_get_default_pad+0xf6>
    f5b2:	4b42      	ldr	r3, [pc, #264]	; (f6bc <_sercom_get_default_pad+0x120>)
    f5b4:	4298      	cmp	r0, r3
    f5b6:	d04a      	beq.n	f64e <_sercom_get_default_pad+0xb2>
    f5b8:	4b41      	ldr	r3, [pc, #260]	; (f6c0 <_sercom_get_default_pad+0x124>)
    f5ba:	4298      	cmp	r0, r3
    f5bc:	d058      	beq.n	f670 <_sercom_get_default_pad+0xd4>
    f5be:	4b41      	ldr	r3, [pc, #260]	; (f6c4 <_sercom_get_default_pad+0x128>)
    f5c0:	4298      	cmp	r0, r3
    f5c2:	d166      	bne.n	f692 <_sercom_get_default_pad+0xf6>
    f5c4:	e032      	b.n	f62c <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f5c6:	2901      	cmp	r1, #1
    f5c8:	d006      	beq.n	f5d8 <_sercom_get_default_pad+0x3c>
    f5ca:	2900      	cmp	r1, #0
    f5cc:	d063      	beq.n	f696 <_sercom_get_default_pad+0xfa>
    f5ce:	2902      	cmp	r1, #2
    f5d0:	d006      	beq.n	f5e0 <_sercom_get_default_pad+0x44>
    f5d2:	2903      	cmp	r1, #3
    f5d4:	d006      	beq.n	f5e4 <_sercom_get_default_pad+0x48>
    f5d6:	e001      	b.n	f5dc <_sercom_get_default_pad+0x40>
    f5d8:	483b      	ldr	r0, [pc, #236]	; (f6c8 <_sercom_get_default_pad+0x12c>)
    f5da:	e067      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f5dc:	2000      	movs	r0, #0
    f5de:	e065      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f5e0:	483a      	ldr	r0, [pc, #232]	; (f6cc <_sercom_get_default_pad+0x130>)
    f5e2:	e063      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f5e4:	483a      	ldr	r0, [pc, #232]	; (f6d0 <_sercom_get_default_pad+0x134>)
    f5e6:	e061      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f5e8:	2901      	cmp	r1, #1
    f5ea:	d006      	beq.n	f5fa <_sercom_get_default_pad+0x5e>
    f5ec:	2900      	cmp	r1, #0
    f5ee:	d054      	beq.n	f69a <_sercom_get_default_pad+0xfe>
    f5f0:	2902      	cmp	r1, #2
    f5f2:	d006      	beq.n	f602 <_sercom_get_default_pad+0x66>
    f5f4:	2903      	cmp	r1, #3
    f5f6:	d006      	beq.n	f606 <_sercom_get_default_pad+0x6a>
    f5f8:	e001      	b.n	f5fe <_sercom_get_default_pad+0x62>
    f5fa:	4836      	ldr	r0, [pc, #216]	; (f6d4 <_sercom_get_default_pad+0x138>)
    f5fc:	e056      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f5fe:	2000      	movs	r0, #0
    f600:	e054      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f602:	4835      	ldr	r0, [pc, #212]	; (f6d8 <_sercom_get_default_pad+0x13c>)
    f604:	e052      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f606:	4835      	ldr	r0, [pc, #212]	; (f6dc <_sercom_get_default_pad+0x140>)
    f608:	e050      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f60a:	2901      	cmp	r1, #1
    f60c:	d006      	beq.n	f61c <_sercom_get_default_pad+0x80>
    f60e:	2900      	cmp	r1, #0
    f610:	d045      	beq.n	f69e <_sercom_get_default_pad+0x102>
    f612:	2902      	cmp	r1, #2
    f614:	d006      	beq.n	f624 <_sercom_get_default_pad+0x88>
    f616:	2903      	cmp	r1, #3
    f618:	d006      	beq.n	f628 <_sercom_get_default_pad+0x8c>
    f61a:	e001      	b.n	f620 <_sercom_get_default_pad+0x84>
    f61c:	4830      	ldr	r0, [pc, #192]	; (f6e0 <_sercom_get_default_pad+0x144>)
    f61e:	e045      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f620:	2000      	movs	r0, #0
    f622:	e043      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f624:	482f      	ldr	r0, [pc, #188]	; (f6e4 <_sercom_get_default_pad+0x148>)
    f626:	e041      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f628:	482f      	ldr	r0, [pc, #188]	; (f6e8 <_sercom_get_default_pad+0x14c>)
    f62a:	e03f      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f62c:	2901      	cmp	r1, #1
    f62e:	d006      	beq.n	f63e <_sercom_get_default_pad+0xa2>
    f630:	2900      	cmp	r1, #0
    f632:	d036      	beq.n	f6a2 <_sercom_get_default_pad+0x106>
    f634:	2902      	cmp	r1, #2
    f636:	d006      	beq.n	f646 <_sercom_get_default_pad+0xaa>
    f638:	2903      	cmp	r1, #3
    f63a:	d006      	beq.n	f64a <_sercom_get_default_pad+0xae>
    f63c:	e001      	b.n	f642 <_sercom_get_default_pad+0xa6>
    f63e:	482b      	ldr	r0, [pc, #172]	; (f6ec <_sercom_get_default_pad+0x150>)
    f640:	e034      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f642:	2000      	movs	r0, #0
    f644:	e032      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f646:	482a      	ldr	r0, [pc, #168]	; (f6f0 <_sercom_get_default_pad+0x154>)
    f648:	e030      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f64a:	482a      	ldr	r0, [pc, #168]	; (f6f4 <_sercom_get_default_pad+0x158>)
    f64c:	e02e      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f64e:	2901      	cmp	r1, #1
    f650:	d006      	beq.n	f660 <_sercom_get_default_pad+0xc4>
    f652:	2900      	cmp	r1, #0
    f654:	d027      	beq.n	f6a6 <_sercom_get_default_pad+0x10a>
    f656:	2902      	cmp	r1, #2
    f658:	d006      	beq.n	f668 <_sercom_get_default_pad+0xcc>
    f65a:	2903      	cmp	r1, #3
    f65c:	d006      	beq.n	f66c <_sercom_get_default_pad+0xd0>
    f65e:	e001      	b.n	f664 <_sercom_get_default_pad+0xc8>
    f660:	4825      	ldr	r0, [pc, #148]	; (f6f8 <_sercom_get_default_pad+0x15c>)
    f662:	e023      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f664:	2000      	movs	r0, #0
    f666:	e021      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f668:	4824      	ldr	r0, [pc, #144]	; (f6fc <_sercom_get_default_pad+0x160>)
    f66a:	e01f      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f66c:	4824      	ldr	r0, [pc, #144]	; (f700 <_sercom_get_default_pad+0x164>)
    f66e:	e01d      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f670:	2901      	cmp	r1, #1
    f672:	d006      	beq.n	f682 <_sercom_get_default_pad+0xe6>
    f674:	2900      	cmp	r1, #0
    f676:	d018      	beq.n	f6aa <_sercom_get_default_pad+0x10e>
    f678:	2902      	cmp	r1, #2
    f67a:	d006      	beq.n	f68a <_sercom_get_default_pad+0xee>
    f67c:	2903      	cmp	r1, #3
    f67e:	d006      	beq.n	f68e <_sercom_get_default_pad+0xf2>
    f680:	e001      	b.n	f686 <_sercom_get_default_pad+0xea>
    f682:	4820      	ldr	r0, [pc, #128]	; (f704 <_sercom_get_default_pad+0x168>)
    f684:	e012      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f686:	2000      	movs	r0, #0
    f688:	e010      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f68a:	481f      	ldr	r0, [pc, #124]	; (f708 <_sercom_get_default_pad+0x16c>)
    f68c:	e00e      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f68e:	481f      	ldr	r0, [pc, #124]	; (f70c <_sercom_get_default_pad+0x170>)
    f690:	e00c      	b.n	f6ac <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    f692:	2000      	movs	r0, #0
    f694:	e00a      	b.n	f6ac <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f696:	481e      	ldr	r0, [pc, #120]	; (f710 <_sercom_get_default_pad+0x174>)
    f698:	e008      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f69a:	2003      	movs	r0, #3
    f69c:	e006      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f69e:	481d      	ldr	r0, [pc, #116]	; (f714 <_sercom_get_default_pad+0x178>)
    f6a0:	e004      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f6a2:	481d      	ldr	r0, [pc, #116]	; (f718 <_sercom_get_default_pad+0x17c>)
    f6a4:	e002      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f6a6:	481d      	ldr	r0, [pc, #116]	; (f71c <_sercom_get_default_pad+0x180>)
    f6a8:	e000      	b.n	f6ac <_sercom_get_default_pad+0x110>
    f6aa:	481d      	ldr	r0, [pc, #116]	; (f720 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
    f6ac:	4770      	bx	lr
    f6ae:	46c0      	nop			; (mov r8, r8)
    f6b0:	42001000 	.word	0x42001000
    f6b4:	42000800 	.word	0x42000800
    f6b8:	42000c00 	.word	0x42000c00
    f6bc:	42001800 	.word	0x42001800
    f6c0:	42001c00 	.word	0x42001c00
    f6c4:	42001400 	.word	0x42001400
    f6c8:	00050003 	.word	0x00050003
    f6cc:	00060003 	.word	0x00060003
    f6d0:	00070003 	.word	0x00070003
    f6d4:	00010003 	.word	0x00010003
    f6d8:	001e0003 	.word	0x001e0003
    f6dc:	001f0003 	.word	0x001f0003
    f6e0:	00090003 	.word	0x00090003
    f6e4:	000a0003 	.word	0x000a0003
    f6e8:	000b0003 	.word	0x000b0003
    f6ec:	00110003 	.word	0x00110003
    f6f0:	00120003 	.word	0x00120003
    f6f4:	00130003 	.word	0x00130003
    f6f8:	000d0003 	.word	0x000d0003
    f6fc:	000e0003 	.word	0x000e0003
    f700:	000f0003 	.word	0x000f0003
    f704:	00170003 	.word	0x00170003
    f708:	00180003 	.word	0x00180003
    f70c:	00190003 	.word	0x00190003
    f710:	00040003 	.word	0x00040003
    f714:	00080003 	.word	0x00080003
    f718:	00100003 	.word	0x00100003
    f71c:	000c0003 	.word	0x000c0003
    f720:	00160003 	.word	0x00160003

0000f724 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    f724:	b530      	push	{r4, r5, lr}
    f726:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    f728:	4b0c      	ldr	r3, [pc, #48]	; (f75c <_sercom_get_sercom_inst_index+0x38>)
    f72a:	466a      	mov	r2, sp
    f72c:	cb32      	ldmia	r3!, {r1, r4, r5}
    f72e:	c232      	stmia	r2!, {r1, r4, r5}
    f730:	cb32      	ldmia	r3!, {r1, r4, r5}
    f732:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    f734:	9b00      	ldr	r3, [sp, #0]
    f736:	4283      	cmp	r3, r0
    f738:	d006      	beq.n	f748 <_sercom_get_sercom_inst_index+0x24>
    f73a:	2301      	movs	r3, #1
    f73c:	009a      	lsls	r2, r3, #2
    f73e:	4669      	mov	r1, sp
    f740:	5852      	ldr	r2, [r2, r1]
    f742:	4282      	cmp	r2, r0
    f744:	d103      	bne.n	f74e <_sercom_get_sercom_inst_index+0x2a>
    f746:	e000      	b.n	f74a <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    f748:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    f74a:	b2d8      	uxtb	r0, r3
    f74c:	e003      	b.n	f756 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    f74e:	3301      	adds	r3, #1
    f750:	2b06      	cmp	r3, #6
    f752:	d1f3      	bne.n	f73c <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    f754:	2000      	movs	r0, #0
}
    f756:	b007      	add	sp, #28
    f758:	bd30      	pop	{r4, r5, pc}
    f75a:	46c0      	nop			; (mov r8, r8)
    f75c:	00020368 	.word	0x00020368

0000f760 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    f760:	b5f0      	push	{r4, r5, r6, r7, lr}
    f762:	4647      	mov	r7, r8
    f764:	b480      	push	{r7}
    f766:	1c0c      	adds	r4, r1, #0
    f768:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
    f76a:	2800      	cmp	r0, #0
    f76c:	d110      	bne.n	f790 <_read+0x30>
		return -1;
	}

	for (; len > 0; --len) {
    f76e:	2a00      	cmp	r2, #0
    f770:	dd0a      	ble.n	f788 <_read+0x28>
    f772:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
    f774:	4e09      	ldr	r6, [pc, #36]	; (f79c <_read+0x3c>)
    f776:	4d0a      	ldr	r5, [pc, #40]	; (f7a0 <_read+0x40>)
    f778:	6830      	ldr	r0, [r6, #0]
    f77a:	1c21      	adds	r1, r4, #0
    f77c:	682b      	ldr	r3, [r5, #0]
    f77e:	4798      	blx	r3
		ptr++;
    f780:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    f782:	42bc      	cmp	r4, r7
    f784:	d1f8      	bne.n	f778 <_read+0x18>
    f786:	e001      	b.n	f78c <_read+0x2c>
    f788:	2300      	movs	r3, #0
    f78a:	4698      	mov	r8, r3
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
    f78c:	4640      	mov	r0, r8
    f78e:	e001      	b.n	f794 <_read+0x34>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
    f790:	2001      	movs	r0, #1
    f792:	4240      	negs	r0, r0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
    f794:	bc04      	pop	{r2}
    f796:	4690      	mov	r8, r2
    f798:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f79a:	46c0      	nop			; (mov r8, r8)
    f79c:	20002b14 	.word	0x20002b14
    f7a0:	20002b0c 	.word	0x20002b0c

0000f7a4 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    f7a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    f7a6:	4647      	mov	r7, r8
    f7a8:	b480      	push	{r7}
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
    f7aa:	3801      	subs	r0, #1
    f7ac:	2802      	cmp	r0, #2
    f7ae:	d815      	bhi.n	f7dc <_write+0x38>
		return -1;
	}

	for (; len != 0; --len) {
    f7b0:	2a00      	cmp	r2, #0
    f7b2:	d010      	beq.n	f7d6 <_write+0x32>
    f7b4:	1c15      	adds	r5, r2, #0
    f7b6:	1c0e      	adds	r6, r1, #0
    f7b8:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
    f7ba:	4b0c      	ldr	r3, [pc, #48]	; (f7ec <_write+0x48>)
    f7bc:	4698      	mov	r8, r3
    f7be:	4f0c      	ldr	r7, [pc, #48]	; (f7f0 <_write+0x4c>)
    f7c0:	4643      	mov	r3, r8
    f7c2:	6818      	ldr	r0, [r3, #0]
    f7c4:	5d31      	ldrb	r1, [r6, r4]
    f7c6:	683b      	ldr	r3, [r7, #0]
    f7c8:	4798      	blx	r3
    f7ca:	2800      	cmp	r0, #0
    f7cc:	db09      	blt.n	f7e2 <_write+0x3e>
			return -1;
		}
		++nChars;
    f7ce:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    f7d0:	42a5      	cmp	r5, r4
    f7d2:	d1f5      	bne.n	f7c0 <_write+0x1c>
    f7d4:	e000      	b.n	f7d8 <_write+0x34>
    f7d6:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
    f7d8:	1c20      	adds	r0, r4, #0
    f7da:	e004      	b.n	f7e6 <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
    f7dc:	2001      	movs	r0, #1
    f7de:	4240      	negs	r0, r0
    f7e0:	e001      	b.n	f7e6 <_write+0x42>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
    f7e2:	2001      	movs	r0, #1
    f7e4:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
    f7e6:	bc04      	pop	{r2}
    f7e8:	4690      	mov	r8, r2
    f7ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f7ec:	20002b14 	.word	0x20002b14
    f7f0:	20002b10 	.word	0x20002b10

0000f7f4 <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    f7f4:	b570      	push	{r4, r5, r6, lr}
    f7f6:	b082      	sub	sp, #8
    f7f8:	1c05      	adds	r5, r0, #0
    f7fa:	1c0e      	adds	r6, r1, #0
	uint16_t temp = 0;
    f7fc:	2200      	movs	r2, #0
    f7fe:	466b      	mov	r3, sp
    f800:	80da      	strh	r2, [r3, #6]

	while(STATUS_OK != usart_read_wait(module, &temp));
    f802:	4c06      	ldr	r4, [pc, #24]	; (f81c <usart_serial_getchar+0x28>)
    f804:	1c28      	adds	r0, r5, #0
    f806:	466b      	mov	r3, sp
    f808:	1d99      	adds	r1, r3, #6
    f80a:	47a0      	blx	r4
    f80c:	2800      	cmp	r0, #0
    f80e:	d1f9      	bne.n	f804 <usart_serial_getchar+0x10>

	*c = temp;
    f810:	466b      	mov	r3, sp
    f812:	3306      	adds	r3, #6
    f814:	881b      	ldrh	r3, [r3, #0]
    f816:	7033      	strb	r3, [r6, #0]
}
    f818:	b002      	add	sp, #8
    f81a:	bd70      	pop	{r4, r5, r6, pc}
    f81c:	0000fca1 	.word	0x0000fca1

0000f820 <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    f820:	b570      	push	{r4, r5, r6, lr}
    f822:	1c05      	adds	r5, r0, #0
	while(STATUS_OK !=usart_write_wait(module, c));
    f824:	b28c      	uxth	r4, r1
    f826:	4e03      	ldr	r6, [pc, #12]	; (f834 <usart_serial_putchar+0x14>)
    f828:	1c28      	adds	r0, r5, #0
    f82a:	1c21      	adds	r1, r4, #0
    f82c:	47b0      	blx	r6
    f82e:	2800      	cmp	r0, #0
    f830:	d1fa      	bne.n	f828 <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    f832:	bd70      	pop	{r4, r5, r6, pc}
    f834:	0000fc75 	.word	0x0000fc75

0000f838 <init_MC>:
}



void init_MC(void)
{
    f838:	b5f0      	push	{r4, r5, r6, r7, lr}
    f83a:	b091      	sub	sp, #68	; 0x44
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    f83c:	2380      	movs	r3, #128	; 0x80
    f83e:	05db      	lsls	r3, r3, #23
    f840:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    f842:	2300      	movs	r3, #0
    f844:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    f846:	22ff      	movs	r2, #255	; 0xff
    f848:	4669      	mov	r1, sp
    f84a:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    f84c:	2200      	movs	r2, #0
    f84e:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    f850:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    f852:	2401      	movs	r4, #1
    f854:	2124      	movs	r1, #36	; 0x24
    f856:	4668      	mov	r0, sp
    f858:	5444      	strb	r4, [r0, r1]
	config->transmitter_enable = true;
    f85a:	3101      	adds	r1, #1
    f85c:	5444      	strb	r4, [r0, r1]
	config->clock_polarity_inverted = false;
    f85e:	3101      	adds	r1, #1
    f860:	5443      	strb	r3, [r0, r1]
	config->use_external_clock = false;
    f862:	3101      	adds	r1, #1
    f864:	5443      	strb	r3, [r0, r1]
	config->ext_clock_freq   = 0;
    f866:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    f868:	3105      	adds	r1, #5
    f86a:	5443      	strb	r3, [r0, r1]
	config->generator_source = GCLK_GENERATOR_0;
    f86c:	3101      	adds	r1, #1
    f86e:	5443      	strb	r3, [r0, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    f870:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    f872:	8203      	strh	r3, [r0, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    f874:	76c3      	strb	r3, [r0, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    f876:	7602      	strb	r2, [r0, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    f878:	7702      	strb	r2, [r0, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    f87a:	7642      	strb	r2, [r0, #25]
	config->receive_pulse_length                    = 19;
    f87c:	2313      	movs	r3, #19
    f87e:	7683      	strb	r3, [r0, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    f880:	7742      	strb	r2, [r0, #29]
static void configure_console(void)
{
	struct usart_config usart_conf;

	usart_get_config_defaults(&usart_conf);
	usart_conf.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    f882:	2380      	movs	r3, #128	; 0x80
    f884:	035b      	lsls	r3, r3, #13
    f886:	9303      	str	r3, [sp, #12]
	usart_conf.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    f888:	4b1c      	ldr	r3, [pc, #112]	; (f8fc <init_MC+0xc4>)
    f88a:	930c      	str	r3, [sp, #48]	; 0x30
	usart_conf.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    f88c:	4b1c      	ldr	r3, [pc, #112]	; (f900 <init_MC+0xc8>)
    f88e:	930d      	str	r3, [sp, #52]	; 0x34
	usart_conf.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    f890:	2301      	movs	r3, #1
    f892:	425b      	negs	r3, r3
    f894:	930e      	str	r3, [sp, #56]	; 0x38
	usart_conf.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    f896:	930f      	str	r3, [sp, #60]	; 0x3c
	usart_conf.baudrate    = 115200;
    f898:	23e1      	movs	r3, #225	; 0xe1
    f89a:	025b      	lsls	r3, r3, #9
    f89c:	9308      	str	r3, [sp, #32]
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    f89e:	4d19      	ldr	r5, [pc, #100]	; (f904 <init_MC+0xcc>)
    f8a0:	4b19      	ldr	r3, [pc, #100]	; (f908 <init_MC+0xd0>)
    f8a2:	601d      	str	r5, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    f8a4:	4a19      	ldr	r2, [pc, #100]	; (f90c <init_MC+0xd4>)
    f8a6:	4b1a      	ldr	r3, [pc, #104]	; (f910 <init_MC+0xd8>)
    f8a8:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    f8aa:	4a1a      	ldr	r2, [pc, #104]	; (f914 <init_MC+0xdc>)
    f8ac:	4b1a      	ldr	r3, [pc, #104]	; (f918 <init_MC+0xe0>)
    f8ae:	601a      	str	r2, [r3, #0]
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    f8b0:	1c28      	adds	r0, r5, #0
    f8b2:	491a      	ldr	r1, [pc, #104]	; (f91c <init_MC+0xe4>)
    f8b4:	466a      	mov	r2, sp
    f8b6:	4b1a      	ldr	r3, [pc, #104]	; (f920 <init_MC+0xe8>)
    f8b8:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    f8ba:	4f1a      	ldr	r7, [pc, #104]	; (f924 <init_MC+0xec>)
    f8bc:	683b      	ldr	r3, [r7, #0]
    f8be:	6898      	ldr	r0, [r3, #8]
    f8c0:	2100      	movs	r1, #0
    f8c2:	4e19      	ldr	r6, [pc, #100]	; (f928 <init_MC+0xf0>)
    f8c4:	47b0      	blx	r6
	setbuf(stdin, NULL);
    f8c6:	683b      	ldr	r3, [r7, #0]
    f8c8:	6858      	ldr	r0, [r3, #4]
    f8ca:	2100      	movs	r1, #0
    f8cc:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    f8ce:	682e      	ldr	r6, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    f8d0:	1c30      	adds	r0, r6, #0
    f8d2:	4b16      	ldr	r3, [pc, #88]	; (f92c <init_MC+0xf4>)
    f8d4:	4798      	blx	r3
    f8d6:	231f      	movs	r3, #31
    f8d8:	4018      	ands	r0, r3
    f8da:	4084      	lsls	r4, r0
    f8dc:	4b14      	ldr	r3, [pc, #80]	; (f930 <init_MC+0xf8>)
    f8de:	601c      	str	r4, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    f8e0:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    f8e2:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    f8e4:	2b00      	cmp	r3, #0
    f8e6:	d1fc      	bne.n	f8e2 <init_MC+0xaa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    f8e8:	6832      	ldr	r2, [r6, #0]
    f8ea:	3302      	adds	r3, #2
    f8ec:	4313      	orrs	r3, r2
    f8ee:	6033      	str	r3, [r6, #0]

void init_MC(void)
{
	// Initialize the UART console.
	configure_console();
	printf(STRING_HEADER);
    f8f0:	4810      	ldr	r0, [pc, #64]	; (f934 <init_MC+0xfc>)
    f8f2:	4b11      	ldr	r3, [pc, #68]	; (f938 <init_MC+0x100>)
    f8f4:	4798      	blx	r3
    f8f6:	b011      	add	sp, #68	; 0x44
    f8f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f8fa:	46c0      	nop			; (mov r8, r8)
    f8fc:	00160002 	.word	0x00160002
    f900:	00170002 	.word	0x00170002
    f904:	20001298 	.word	0x20001298
    f908:	20002b14 	.word	0x20002b14
    f90c:	0000f821 	.word	0x0000f821
    f910:	20002b10 	.word	0x20002b10
    f914:	0000f7f5 	.word	0x0000f7f5
    f918:	20002b0c 	.word	0x20002b0c
    f91c:	42001400 	.word	0x42001400
    f920:	0000f93d 	.word	0x0000f93d
    f924:	200002f4 	.word	0x200002f4
    f928:	00016f95 	.word	0x00016f95
    f92c:	000103f9 	.word	0x000103f9
    f930:	e000e100 	.word	0xe000e100
    f934:	00020380 	.word	0x00020380
    f938:	00016f5d 	.word	0x00016f5d

0000f93c <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    f93c:	b5f0      	push	{r4, r5, r6, r7, lr}
    f93e:	465f      	mov	r7, fp
    f940:	4656      	mov	r6, sl
    f942:	464d      	mov	r5, r9
    f944:	4644      	mov	r4, r8
    f946:	b4f0      	push	{r4, r5, r6, r7}
    f948:	b091      	sub	sp, #68	; 0x44
    f94a:	1c05      	adds	r5, r0, #0
    f94c:	1c0c      	adds	r4, r1, #0
    f94e:	1c16      	adds	r6, r2, #0
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    f950:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    f952:	1c08      	adds	r0, r1, #0
    f954:	4bb9      	ldr	r3, [pc, #740]	; (fc3c <usart_init+0x300>)
    f956:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    f958:	6822      	ldr	r2, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    f95a:	2305      	movs	r3, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    f95c:	07d2      	lsls	r2, r2, #31
    f95e:	d500      	bpl.n	f962 <usart_init+0x26>
    f960:	e163      	b.n	fc2a <usart_init+0x2ee>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    f962:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    f964:	3317      	adds	r3, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    f966:	0792      	lsls	r2, r2, #30
    f968:	d500      	bpl.n	f96c <usart_init+0x30>
    f96a:	e15e      	b.n	fc2a <usart_init+0x2ee>
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    f96c:	49b4      	ldr	r1, [pc, #720]	; (fc40 <usart_init+0x304>)
    f96e:	6a0a      	ldr	r2, [r1, #32]
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    f970:	1c87      	adds	r7, r0, #2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    f972:	3b1b      	subs	r3, #27
    f974:	40bb      	lsls	r3, r7
    f976:	4313      	orrs	r3, r2
    f978:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    f97a:	a90f      	add	r1, sp, #60	; 0x3c
    f97c:	272d      	movs	r7, #45	; 0x2d
    f97e:	5df3      	ldrb	r3, [r6, r7]
    f980:	700b      	strb	r3, [r1, #0]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    f982:	3014      	adds	r0, #20

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    f984:	b2c3      	uxtb	r3, r0
    f986:	9302      	str	r3, [sp, #8]
    f988:	1c18      	adds	r0, r3, #0
    f98a:	4bae      	ldr	r3, [pc, #696]	; (fc44 <usart_init+0x308>)
    f98c:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    f98e:	9802      	ldr	r0, [sp, #8]
    f990:	4bad      	ldr	r3, [pc, #692]	; (fc48 <usart_init+0x30c>)
    f992:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    f994:	5df0      	ldrb	r0, [r6, r7]
    f996:	2100      	movs	r1, #0
    f998:	4bac      	ldr	r3, [pc, #688]	; (fc4c <usart_init+0x310>)
    f99a:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    f99c:	7af3      	ldrb	r3, [r6, #11]
    f99e:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    f9a0:	2324      	movs	r3, #36	; 0x24
    f9a2:	5cf3      	ldrb	r3, [r6, r3]
    f9a4:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    f9a6:	2325      	movs	r3, #37	; 0x25
    f9a8:	5cf3      	ldrb	r3, [r6, r3]
    f9aa:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    f9ac:	7ef3      	ldrb	r3, [r6, #27]
    f9ae:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    f9b0:	7f33      	ldrb	r3, [r6, #28]
    f9b2:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    f9b4:	682b      	ldr	r3, [r5, #0]
    f9b6:	469a      	mov	sl, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    f9b8:	1c18      	adds	r0, r3, #0
    f9ba:	4ba0      	ldr	r3, [pc, #640]	; (fc3c <usart_init+0x300>)
    f9bc:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    f9be:	3014      	adds	r0, #20
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    f9c0:	2200      	movs	r2, #0
    f9c2:	230e      	movs	r3, #14
    f9c4:	a906      	add	r1, sp, #24
    f9c6:	468c      	mov	ip, r1
    f9c8:	4463      	add	r3, ip
    f9ca:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    f9cc:	8a33      	ldrh	r3, [r6, #16]
    f9ce:	4699      	mov	r9, r3
    f9d0:	2380      	movs	r3, #128	; 0x80
    f9d2:	01db      	lsls	r3, r3, #7
    f9d4:	4599      	cmp	r9, r3
    f9d6:	d019      	beq.n	fa0c <usart_init+0xd0>
    f9d8:	d804      	bhi.n	f9e4 <usart_init+0xa8>
    f9da:	2380      	movs	r3, #128	; 0x80
    f9dc:	019b      	lsls	r3, r3, #6
    f9de:	4599      	cmp	r9, r3
    f9e0:	d00a      	beq.n	f9f8 <usart_init+0xbc>
    f9e2:	e103      	b.n	fbec <usart_init+0x2b0>
    f9e4:	23c0      	movs	r3, #192	; 0xc0
    f9e6:	01db      	lsls	r3, r3, #7
    f9e8:	4599      	cmp	r9, r3
    f9ea:	d00a      	beq.n	fa02 <usart_init+0xc6>
    f9ec:	2380      	movs	r3, #128	; 0x80
    f9ee:	021b      	lsls	r3, r3, #8
    f9f0:	4599      	cmp	r9, r3
    f9f2:	d100      	bne.n	f9f6 <usart_init+0xba>
    f9f4:	e0ff      	b.n	fbf6 <usart_init+0x2ba>
    f9f6:	e0f9      	b.n	fbec <usart_init+0x2b0>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    f9f8:	2310      	movs	r3, #16
    f9fa:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    f9fc:	3b0f      	subs	r3, #15
    f9fe:	9307      	str	r3, [sp, #28]
    fa00:	e0fd      	b.n	fbfe <usart_init+0x2c2>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    fa02:	2308      	movs	r3, #8
    fa04:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    fa06:	3b07      	subs	r3, #7
    fa08:	9307      	str	r3, [sp, #28]
    fa0a:	e0f8      	b.n	fbfe <usart_init+0x2c2>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    fa0c:	6833      	ldr	r3, [r6, #0]
    fa0e:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
    fa10:	68f3      	ldr	r3, [r6, #12]
    fa12:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    fa14:	6973      	ldr	r3, [r6, #20]
    fa16:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    fa18:	7e33      	ldrb	r3, [r6, #24]
    fa1a:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    fa1c:	2326      	movs	r3, #38	; 0x26
    fa1e:	5cf3      	ldrb	r3, [r6, r3]
    fa20:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    fa22:	6872      	ldr	r2, [r6, #4]
    fa24:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    fa26:	2a00      	cmp	r2, #0
    fa28:	d015      	beq.n	fa56 <usart_init+0x11a>
    fa2a:	2380      	movs	r3, #128	; 0x80
    fa2c:	055b      	lsls	r3, r3, #21
    fa2e:	429a      	cmp	r2, r3
    fa30:	d136      	bne.n	faa0 <usart_init+0x164>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    fa32:	2327      	movs	r3, #39	; 0x27
    fa34:	5cf3      	ldrb	r3, [r6, r3]
    fa36:	2b00      	cmp	r3, #0
    fa38:	d136      	bne.n	faa8 <usart_init+0x16c>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    fa3a:	6a33      	ldr	r3, [r6, #32]
    fa3c:	4698      	mov	r8, r3
    fa3e:	b2c0      	uxtb	r0, r0
    fa40:	4b83      	ldr	r3, [pc, #524]	; (fc50 <usart_init+0x314>)
    fa42:	4798      	blx	r3
    fa44:	1c01      	adds	r1, r0, #0
    fa46:	4640      	mov	r0, r8
    fa48:	220e      	movs	r2, #14
    fa4a:	ab06      	add	r3, sp, #24
    fa4c:	469c      	mov	ip, r3
    fa4e:	4462      	add	r2, ip
    fa50:	4b80      	ldr	r3, [pc, #512]	; (fc54 <usart_init+0x318>)
    fa52:	4798      	blx	r3
    fa54:	e025      	b.n	faa2 <usart_init+0x166>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    fa56:	2308      	movs	r3, #8
    fa58:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    fa5a:	2300      	movs	r3, #0
    fa5c:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    fa5e:	2327      	movs	r3, #39	; 0x27
    fa60:	5cf3      	ldrb	r3, [r6, r3]
    fa62:	2b00      	cmp	r3, #0
    fa64:	d00b      	beq.n	fa7e <usart_init+0x142>
				status_code =
    fa66:	4643      	mov	r3, r8
    fa68:	9300      	str	r3, [sp, #0]
    fa6a:	6a30      	ldr	r0, [r6, #32]
    fa6c:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    fa6e:	220e      	movs	r2, #14
    fa70:	ab06      	add	r3, sp, #24
    fa72:	469c      	mov	ip, r3
    fa74:	4462      	add	r2, ip
    fa76:	9b07      	ldr	r3, [sp, #28]
    fa78:	4f77      	ldr	r7, [pc, #476]	; (fc58 <usart_init+0x31c>)
    fa7a:	47b8      	blx	r7
    fa7c:	e011      	b.n	faa2 <usart_init+0x166>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    fa7e:	6a33      	ldr	r3, [r6, #32]
    fa80:	1c1f      	adds	r7, r3, #0
    fa82:	b2c0      	uxtb	r0, r0
    fa84:	4b72      	ldr	r3, [pc, #456]	; (fc50 <usart_init+0x314>)
    fa86:	4798      	blx	r3
    fa88:	1c01      	adds	r1, r0, #0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    fa8a:	4643      	mov	r3, r8
    fa8c:	9300      	str	r3, [sp, #0]
    fa8e:	1c38      	adds	r0, r7, #0
    fa90:	220e      	movs	r2, #14
    fa92:	ab06      	add	r3, sp, #24
    fa94:	469c      	mov	ip, r3
    fa96:	4462      	add	r2, ip
    fa98:	9b07      	ldr	r3, [sp, #28]
    fa9a:	4f6f      	ldr	r7, [pc, #444]	; (fc58 <usart_init+0x31c>)
    fa9c:	47b8      	blx	r7
    fa9e:	e000      	b.n	faa2 <usart_init+0x166>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    faa0:	2000      	movs	r0, #0
    faa2:	1e03      	subs	r3, r0, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    faa4:	d000      	beq.n	faa8 <usart_init+0x16c>
    faa6:	e0c0      	b.n	fc2a <usart_init+0x2ee>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    faa8:	7e73      	ldrb	r3, [r6, #25]
    faaa:	2b00      	cmp	r3, #0
    faac:	d002      	beq.n	fab4 <usart_init+0x178>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    faae:	7eb3      	ldrb	r3, [r6, #26]
    fab0:	4652      	mov	r2, sl
    fab2:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    fab4:	682a      	ldr	r2, [r5, #0]
    fab6:	9f06      	ldr	r7, [sp, #24]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fab8:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    faba:	2b00      	cmp	r3, #0
    fabc:	d1fc      	bne.n	fab8 <usart_init+0x17c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    fabe:	330e      	adds	r3, #14
    fac0:	aa06      	add	r2, sp, #24
    fac2:	4694      	mov	ip, r2
    fac4:	4463      	add	r3, ip
    fac6:	881b      	ldrh	r3, [r3, #0]
    fac8:	4652      	mov	r2, sl
    faca:	8193      	strh	r3, [r2, #12]
    facc:	9b02      	ldr	r3, [sp, #8]
    face:	465a      	mov	r2, fp
    fad0:	4313      	orrs	r3, r2
    fad2:	9a03      	ldr	r2, [sp, #12]
    fad4:	4313      	orrs	r3, r2
    fad6:	433b      	orrs	r3, r7
    fad8:	464a      	mov	r2, r9
    fada:	4313      	orrs	r3, r2
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    fadc:	9a04      	ldr	r2, [sp, #16]
    fade:	0212      	lsls	r2, r2, #8
    fae0:	4313      	orrs	r3, r2
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    fae2:	9a05      	ldr	r2, [sp, #20]
    fae4:	0757      	lsls	r7, r2, #29

	/*Set baud val */
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;
    fae6:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    fae8:	2327      	movs	r3, #39	; 0x27
    faea:	5cf3      	ldrb	r3, [r6, r3]
    faec:	2b00      	cmp	r3, #0
    faee:	d101      	bne.n	faf4 <usart_init+0x1b8>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    faf0:	3304      	adds	r3, #4
    faf2:	431f      	orrs	r7, r3
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    faf4:	7f33      	ldrb	r3, [r6, #28]
    faf6:	0259      	lsls	r1, r3, #9
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    faf8:	7e72      	ldrb	r2, [r6, #25]
    fafa:	0293      	lsls	r3, r2, #10
    fafc:	430b      	orrs	r3, r1
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    fafe:	7f72      	ldrb	r2, [r6, #29]
    fb00:	0212      	lsls	r2, r2, #8
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    fb02:	4313      	orrs	r3, r2
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    fb04:	2224      	movs	r2, #36	; 0x24
    fb06:	5cb2      	ldrb	r2, [r6, r2]
    fb08:	0452      	lsls	r2, r2, #17
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    fb0a:	4313      	orrs	r3, r2
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    fb0c:	2225      	movs	r2, #37	; 0x25
    fb0e:	5cb2      	ldrb	r2, [r6, r2]
    fb10:	0412      	lsls	r2, r2, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    fb12:	4313      	orrs	r3, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
    fb14:	7af1      	ldrb	r1, [r6, #11]
    fb16:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    fb18:	8933      	ldrh	r3, [r6, #8]
    fb1a:	2bff      	cmp	r3, #255	; 0xff
    fb1c:	d004      	beq.n	fb28 <usart_init+0x1ec>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    fb1e:	2280      	movs	r2, #128	; 0x80
    fb20:	0452      	lsls	r2, r2, #17
    fb22:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    fb24:	4319      	orrs	r1, r3
    fb26:	e005      	b.n	fb34 <usart_init+0x1f8>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    fb28:	7ef3      	ldrb	r3, [r6, #27]
    fb2a:	2b00      	cmp	r3, #0
    fb2c:	d002      	beq.n	fb34 <usart_init+0x1f8>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    fb2e:	2380      	movs	r3, #128	; 0x80
    fb30:	04db      	lsls	r3, r3, #19
    fb32:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    fb34:	232c      	movs	r3, #44	; 0x2c
    fb36:	5cf3      	ldrb	r3, [r6, r3]
    fb38:	2b00      	cmp	r3, #0
    fb3a:	d103      	bne.n	fb44 <usart_init+0x208>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    fb3c:	4b47      	ldr	r3, [pc, #284]	; (fc5c <usart_init+0x320>)
    fb3e:	789b      	ldrb	r3, [r3, #2]
    fb40:	079b      	lsls	r3, r3, #30
    fb42:	d501      	bpl.n	fb48 <usart_init+0x20c>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    fb44:	2380      	movs	r3, #128	; 0x80
    fb46:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    fb48:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fb4a:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    fb4c:	2b00      	cmp	r3, #0
    fb4e:	d1fc      	bne.n	fb4a <usart_init+0x20e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    fb50:	4653      	mov	r3, sl
    fb52:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    fb54:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fb56:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    fb58:	2b00      	cmp	r3, #0
    fb5a:	d1fc      	bne.n	fb56 <usart_init+0x21a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    fb5c:	4653      	mov	r3, sl
    fb5e:	601f      	str	r7, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    fb60:	ab0e      	add	r3, sp, #56	; 0x38
    fb62:	2280      	movs	r2, #128	; 0x80
    fb64:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    fb66:	2200      	movs	r2, #0
    fb68:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    fb6a:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    fb6c:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    fb6e:	6b33      	ldr	r3, [r6, #48]	; 0x30
    fb70:	930a      	str	r3, [sp, #40]	; 0x28
    fb72:	6b73      	ldr	r3, [r6, #52]	; 0x34
    fb74:	930b      	str	r3, [sp, #44]	; 0x2c
    fb76:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    fb78:	930c      	str	r3, [sp, #48]	; 0x30
    fb7a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    fb7c:	9302      	str	r3, [sp, #8]
    fb7e:	930d      	str	r3, [sp, #52]	; 0x34
    fb80:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    fb82:	ae0e      	add	r6, sp, #56	; 0x38
    fb84:	b2f9      	uxtb	r1, r7
    fb86:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    fb88:	aa0a      	add	r2, sp, #40	; 0x28
    fb8a:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    fb8c:	2800      	cmp	r0, #0
    fb8e:	d102      	bne.n	fb96 <usart_init+0x25a>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    fb90:	1c20      	adds	r0, r4, #0
    fb92:	4b33      	ldr	r3, [pc, #204]	; (fc60 <usart_init+0x324>)
    fb94:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    fb96:	1c43      	adds	r3, r0, #1
    fb98:	d005      	beq.n	fba6 <usart_init+0x26a>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    fb9a:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    fb9c:	0c00      	lsrs	r0, r0, #16
    fb9e:	b2c0      	uxtb	r0, r0
    fba0:	1c31      	adds	r1, r6, #0
    fba2:	4b30      	ldr	r3, [pc, #192]	; (fc64 <usart_init+0x328>)
    fba4:	4798      	blx	r3
    fba6:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    fba8:	2f04      	cmp	r7, #4
    fbaa:	d1eb      	bne.n	fb84 <usart_init+0x248>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    fbac:	2300      	movs	r3, #0
    fbae:	60eb      	str	r3, [r5, #12]
    fbb0:	612b      	str	r3, [r5, #16]
    fbb2:	616b      	str	r3, [r5, #20]
    fbb4:	61ab      	str	r3, [r5, #24]
    fbb6:	61eb      	str	r3, [r5, #28]
    fbb8:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
    fbba:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    fbbc:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    fbbe:	2200      	movs	r2, #0
    fbc0:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    fbc2:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    fbc4:	3330      	adds	r3, #48	; 0x30
    fbc6:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    fbc8:	3301      	adds	r3, #1
    fbca:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    fbcc:	3301      	adds	r3, #1
    fbce:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    fbd0:	3301      	adds	r3, #1
    fbd2:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    fbd4:	6828      	ldr	r0, [r5, #0]
    fbd6:	4b19      	ldr	r3, [pc, #100]	; (fc3c <usart_init+0x300>)
    fbd8:	4798      	blx	r3
    fbda:	1c04      	adds	r4, r0, #0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    fbdc:	4922      	ldr	r1, [pc, #136]	; (fc68 <usart_init+0x32c>)
    fbde:	4b23      	ldr	r3, [pc, #140]	; (fc6c <usart_init+0x330>)
    fbe0:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    fbe2:	00a4      	lsls	r4, r4, #2
    fbe4:	4b22      	ldr	r3, [pc, #136]	; (fc70 <usart_init+0x334>)
    fbe6:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    fbe8:	2300      	movs	r3, #0
    fbea:	e01e      	b.n	fc2a <usart_init+0x2ee>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    fbec:	2310      	movs	r3, #16
    fbee:	4698      	mov	r8, r3
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    fbf0:	2300      	movs	r3, #0
    fbf2:	9307      	str	r3, [sp, #28]
    fbf4:	e003      	b.n	fbfe <usart_init+0x2c2>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    fbf6:	2303      	movs	r3, #3
    fbf8:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    fbfa:	2300      	movs	r3, #0
    fbfc:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    fbfe:	6833      	ldr	r3, [r6, #0]
    fc00:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
    fc02:	68f3      	ldr	r3, [r6, #12]
    fc04:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    fc06:	6973      	ldr	r3, [r6, #20]
    fc08:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    fc0a:	7e33      	ldrb	r3, [r6, #24]
    fc0c:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    fc0e:	2326      	movs	r3, #38	; 0x26
    fc10:	5cf3      	ldrb	r3, [r6, r3]
    fc12:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    fc14:	6872      	ldr	r2, [r6, #4]
    fc16:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    fc18:	2a00      	cmp	r2, #0
    fc1a:	d100      	bne.n	fc1e <usart_init+0x2e2>
    fc1c:	e71f      	b.n	fa5e <usart_init+0x122>
    fc1e:	2380      	movs	r3, #128	; 0x80
    fc20:	055b      	lsls	r3, r3, #21
    fc22:	429a      	cmp	r2, r3
    fc24:	d100      	bne.n	fc28 <usart_init+0x2ec>
    fc26:	e704      	b.n	fa32 <usart_init+0xf6>
    fc28:	e73e      	b.n	faa8 <usart_init+0x16c>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    fc2a:	1c18      	adds	r0, r3, #0
    fc2c:	b011      	add	sp, #68	; 0x44
    fc2e:	bc3c      	pop	{r2, r3, r4, r5}
    fc30:	4690      	mov	r8, r2
    fc32:	4699      	mov	r9, r3
    fc34:	46a2      	mov	sl, r4
    fc36:	46ab      	mov	fp, r5
    fc38:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fc3a:	46c0      	nop			; (mov r8, r8)
    fc3c:	0000f725 	.word	0x0000f725
    fc40:	40000400 	.word	0x40000400
    fc44:	0001392d 	.word	0x0001392d
    fc48:	000138a1 	.word	0x000138a1
    fc4c:	0000f551 	.word	0x0000f551
    fc50:	00013949 	.word	0x00013949
    fc54:	0000f361 	.word	0x0000f361
    fc58:	0000f389 	.word	0x0000f389
    fc5c:	41002000 	.word	0x41002000
    fc60:	0000f59d 	.word	0x0000f59d
    fc64:	00013a25 	.word	0x00013a25
    fc68:	0000fd19 	.word	0x0000fd19
    fc6c:	000103bd 	.word	0x000103bd
    fc70:	20002b1c 	.word	0x20002b1c

0000fc74 <usart_write_wait>:
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_wait(
		struct usart_module *const module,
		const uint16_t tx_data)
{
    fc74:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    fc76:	6803      	ldr	r3, [r0, #0]

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    fc78:	79c4      	ldrb	r4, [r0, #7]
		return STATUS_ERR_DENIED;
    fc7a:	221c      	movs	r2, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    fc7c:	2c00      	cmp	r4, #0
    fc7e:	d00d      	beq.n	fc9c <usart_write_wait+0x28>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    fc80:	8dc0      	ldrh	r0, [r0, #46]	; 0x2e
    fc82:	b280      	uxth	r0, r0
		return STATUS_BUSY;
    fc84:	3a17      	subs	r2, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    fc86:	2800      	cmp	r0, #0
    fc88:	d108      	bne.n	fc9c <usart_write_wait+0x28>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fc8a:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    fc8c:	2a00      	cmp	r2, #0
    fc8e:	d1fc      	bne.n	fc8a <usart_write_wait+0x16>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
    fc90:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    fc92:	2102      	movs	r1, #2
    fc94:	7e1a      	ldrb	r2, [r3, #24]
    fc96:	420a      	tst	r2, r1
    fc98:	d0fc      	beq.n	fc94 <usart_write_wait+0x20>
		/* Wait until data is sent */
	}

	return STATUS_OK;
    fc9a:	2200      	movs	r2, #0
}
    fc9c:	1c10      	adds	r0, r2, #0
    fc9e:	bd10      	pop	{r4, pc}

0000fca0 <usart_read_wait>:
 * \retval STATUS_ERR_DENIED        If the receiver is not enabled
 */
enum status_code usart_read_wait(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
    fca0:	b510      	push	{r4, lr}

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    fca2:	6804      	ldr	r4, [r0, #0]

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    fca4:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
    fca6:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    fca8:	2a00      	cmp	r2, #0
    fcaa:	d033      	beq.n	fd14 <usart_read_wait+0x74>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    fcac:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    fcae:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    fcb0:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    fcb2:	2a00      	cmp	r2, #0
    fcb4:	d12e      	bne.n	fd14 <usart_read_wait+0x74>
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
    fcb6:	7e22      	ldrb	r2, [r4, #24]
    fcb8:	0752      	lsls	r2, r2, #29
    fcba:	d52b      	bpl.n	fd14 <usart_read_wait+0x74>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fcbc:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    fcbe:	2b00      	cmp	r3, #0
    fcc0:	d1fc      	bne.n	fcbc <usart_read_wait+0x1c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    fcc2:	8b63      	ldrh	r3, [r4, #26]
    fcc4:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
    fcc6:	069a      	lsls	r2, r3, #26
    fcc8:	d021      	beq.n	fd0e <usart_read_wait+0x6e>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
    fcca:	079a      	lsls	r2, r3, #30
    fccc:	d503      	bpl.n	fcd6 <usart_read_wait+0x36>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    fcce:	2302      	movs	r3, #2
    fcd0:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_FORMAT;
    fcd2:	3318      	adds	r3, #24
    fcd4:	e01e      	b.n	fd14 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    fcd6:	075a      	lsls	r2, r3, #29
    fcd8:	d503      	bpl.n	fce2 <usart_read_wait+0x42>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    fcda:	2304      	movs	r3, #4
    fcdc:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_OVERFLOW;
    fcde:	331a      	adds	r3, #26
    fce0:	e018      	b.n	fd14 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
    fce2:	07da      	lsls	r2, r3, #31
    fce4:	d503      	bpl.n	fcee <usart_read_wait+0x4e>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    fce6:	2301      	movs	r3, #1
    fce8:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_DATA;
    fcea:	3312      	adds	r3, #18
    fcec:	e012      	b.n	fd14 <usart_read_wait+0x74>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
    fcee:	06da      	lsls	r2, r3, #27
    fcf0:	d505      	bpl.n	fcfe <usart_read_wait+0x5e>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    fcf2:	8b62      	ldrh	r2, [r4, #26]
    fcf4:	2310      	movs	r3, #16
    fcf6:	4313      	orrs	r3, r2
    fcf8:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PROTOCOL;
    fcfa:	2342      	movs	r3, #66	; 0x42
    fcfc:	e00a      	b.n	fd14 <usart_read_wait+0x74>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
    fcfe:	069b      	lsls	r3, r3, #26
    fd00:	d505      	bpl.n	fd0e <usart_read_wait+0x6e>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    fd02:	8b62      	ldrh	r2, [r4, #26]
    fd04:	2320      	movs	r3, #32
    fd06:	4313      	orrs	r3, r2
    fd08:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PACKET_COLLISION;
    fd0a:	2341      	movs	r3, #65	; 0x41
    fd0c:	e002      	b.n	fd14 <usart_read_wait+0x74>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
    fd0e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    fd10:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
    fd12:	2300      	movs	r3, #0
}
    fd14:	1c18      	adds	r0, r3, #0
    fd16:	bd10      	pop	{r4, pc}

0000fd18 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    fd18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    fd1a:	0080      	lsls	r0, r0, #2
    fd1c:	4b65      	ldr	r3, [pc, #404]	; (feb4 <_usart_interrupt_handler+0x19c>)
    fd1e:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    fd20:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    fd22:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    fd24:	2b00      	cmp	r3, #0
    fd26:	d1fc      	bne.n	fd22 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    fd28:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    fd2a:	7da6      	ldrb	r6, [r4, #22]
    fd2c:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
			module->callback_enable_mask;
    fd2e:	2331      	movs	r3, #49	; 0x31
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
    fd30:	5ceb      	ldrb	r3, [r5, r3]
    fd32:	2230      	movs	r2, #48	; 0x30
    fd34:	5caf      	ldrb	r7, [r5, r2]
    fd36:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    fd38:	07f3      	lsls	r3, r6, #31
    fd3a:	d522      	bpl.n	fd82 <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    fd3c:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    fd3e:	b29b      	uxth	r3, r3
    fd40:	2b00      	cmp	r3, #0
    fd42:	d01c      	beq.n	fd7e <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    fd44:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    fd46:	7813      	ldrb	r3, [r2, #0]
    fd48:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    fd4a:	1c51      	adds	r1, r2, #1
    fd4c:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    fd4e:	7969      	ldrb	r1, [r5, #5]
    fd50:	2901      	cmp	r1, #1
    fd52:	d001      	beq.n	fd58 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    fd54:	b29b      	uxth	r3, r3
    fd56:	e004      	b.n	fd62 <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    fd58:	7851      	ldrb	r1, [r2, #1]
    fd5a:	0209      	lsls	r1, r1, #8
    fd5c:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    fd5e:	3202      	adds	r2, #2
    fd60:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    fd62:	05db      	lsls	r3, r3, #23
    fd64:	0ddb      	lsrs	r3, r3, #23
    fd66:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    fd68:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    fd6a:	3b01      	subs	r3, #1
    fd6c:	b29b      	uxth	r3, r3
    fd6e:	85eb      	strh	r3, [r5, #46]	; 0x2e
    fd70:	2b00      	cmp	r3, #0
    fd72:	d106      	bne.n	fd82 <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    fd74:	3301      	adds	r3, #1
    fd76:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    fd78:	3301      	adds	r3, #1
    fd7a:	75a3      	strb	r3, [r4, #22]
    fd7c:	e001      	b.n	fd82 <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    fd7e:	2301      	movs	r3, #1
    fd80:	7523      	strb	r3, [r4, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    fd82:	07b3      	lsls	r3, r6, #30
    fd84:	d509      	bpl.n	fd9a <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    fd86:	2302      	movs	r3, #2
    fd88:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    fd8a:	2200      	movs	r2, #0
    fd8c:	3331      	adds	r3, #49	; 0x31
    fd8e:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    fd90:	07fb      	lsls	r3, r7, #31
    fd92:	d502      	bpl.n	fd9a <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    fd94:	1c28      	adds	r0, r5, #0
    fd96:	68eb      	ldr	r3, [r5, #12]
    fd98:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    fd9a:	0773      	lsls	r3, r6, #29
    fd9c:	d56a      	bpl.n	fe74 <_usart_interrupt_handler+0x15c>

		if (module->remaining_rx_buffer_length) {
    fd9e:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    fda0:	b29b      	uxth	r3, r3
    fda2:	2b00      	cmp	r3, #0
    fda4:	d064      	beq.n	fe70 <_usart_interrupt_handler+0x158>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    fda6:	8b63      	ldrh	r3, [r4, #26]
    fda8:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    fdaa:	071a      	lsls	r2, r3, #28
    fdac:	d402      	bmi.n	fdb4 <_usart_interrupt_handler+0x9c>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    fdae:	223f      	movs	r2, #63	; 0x3f
    fdb0:	4013      	ands	r3, r2
    fdb2:	e001      	b.n	fdb8 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
    fdb4:	2237      	movs	r2, #55	; 0x37
    fdb6:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    fdb8:	2b00      	cmp	r3, #0
    fdba:	d037      	beq.n	fe2c <_usart_interrupt_handler+0x114>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    fdbc:	079a      	lsls	r2, r3, #30
    fdbe:	d507      	bpl.n	fdd0 <_usart_interrupt_handler+0xb8>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    fdc0:	221a      	movs	r2, #26
    fdc2:	2332      	movs	r3, #50	; 0x32
    fdc4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
    fdc6:	8b62      	ldrh	r2, [r4, #26]
    fdc8:	3b30      	subs	r3, #48	; 0x30
    fdca:	4313      	orrs	r3, r2
    fdcc:	8363      	strh	r3, [r4, #26]
    fdce:	e027      	b.n	fe20 <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    fdd0:	075a      	lsls	r2, r3, #29
    fdd2:	d507      	bpl.n	fde4 <_usart_interrupt_handler+0xcc>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    fdd4:	221e      	movs	r2, #30
    fdd6:	2332      	movs	r3, #50	; 0x32
    fdd8:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
    fdda:	8b62      	ldrh	r2, [r4, #26]
    fddc:	3b2e      	subs	r3, #46	; 0x2e
    fdde:	4313      	orrs	r3, r2
    fde0:	8363      	strh	r3, [r4, #26]
    fde2:	e01d      	b.n	fe20 <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    fde4:	07da      	lsls	r2, r3, #31
    fde6:	d507      	bpl.n	fdf8 <_usart_interrupt_handler+0xe0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    fde8:	2213      	movs	r2, #19
    fdea:	2332      	movs	r3, #50	; 0x32
    fdec:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
    fdee:	8b62      	ldrh	r2, [r4, #26]
    fdf0:	3b31      	subs	r3, #49	; 0x31
    fdf2:	4313      	orrs	r3, r2
    fdf4:	8363      	strh	r3, [r4, #26]
    fdf6:	e013      	b.n	fe20 <_usart_interrupt_handler+0x108>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    fdf8:	06da      	lsls	r2, r3, #27
    fdfa:	d507      	bpl.n	fe0c <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    fdfc:	2242      	movs	r2, #66	; 0x42
    fdfe:	2332      	movs	r3, #50	; 0x32
    fe00:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    fe02:	8b62      	ldrh	r2, [r4, #26]
    fe04:	3b22      	subs	r3, #34	; 0x22
    fe06:	4313      	orrs	r3, r2
    fe08:	8363      	strh	r3, [r4, #26]
    fe0a:	e009      	b.n	fe20 <_usart_interrupt_handler+0x108>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    fe0c:	2220      	movs	r2, #32
    fe0e:	421a      	tst	r2, r3
    fe10:	d006      	beq.n	fe20 <_usart_interrupt_handler+0x108>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    fe12:	3221      	adds	r2, #33	; 0x21
    fe14:	2332      	movs	r3, #50	; 0x32
    fe16:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    fe18:	8b62      	ldrh	r2, [r4, #26]
    fe1a:	3b12      	subs	r3, #18
    fe1c:	4313      	orrs	r3, r2
    fe1e:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    fe20:	077b      	lsls	r3, r7, #29
    fe22:	d527      	bpl.n	fe74 <_usart_interrupt_handler+0x15c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    fe24:	1c28      	adds	r0, r5, #0
    fe26:	696b      	ldr	r3, [r5, #20]
    fe28:	4798      	blx	r3
    fe2a:	e023      	b.n	fe74 <_usart_interrupt_handler+0x15c>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    fe2c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    fe2e:	05db      	lsls	r3, r3, #23
    fe30:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    fe32:	b2da      	uxtb	r2, r3
    fe34:	6a69      	ldr	r1, [r5, #36]	; 0x24
    fe36:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    fe38:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    fe3a:	1c51      	adds	r1, r2, #1
    fe3c:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    fe3e:	7969      	ldrb	r1, [r5, #5]
    fe40:	2901      	cmp	r1, #1
    fe42:	d104      	bne.n	fe4e <_usart_interrupt_handler+0x136>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    fe44:	0a1b      	lsrs	r3, r3, #8
    fe46:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    fe48:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    fe4a:	3301      	adds	r3, #1
    fe4c:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    fe4e:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    fe50:	3b01      	subs	r3, #1
    fe52:	b29b      	uxth	r3, r3
    fe54:	85ab      	strh	r3, [r5, #44]	; 0x2c
    fe56:	2b00      	cmp	r3, #0
    fe58:	d10c      	bne.n	fe74 <_usart_interrupt_handler+0x15c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    fe5a:	3304      	adds	r3, #4
    fe5c:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    fe5e:	2200      	movs	r2, #0
    fe60:	332e      	adds	r3, #46	; 0x2e
    fe62:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    fe64:	07bb      	lsls	r3, r7, #30
    fe66:	d505      	bpl.n	fe74 <_usart_interrupt_handler+0x15c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    fe68:	1c28      	adds	r0, r5, #0
    fe6a:	692b      	ldr	r3, [r5, #16]
    fe6c:	4798      	blx	r3
    fe6e:	e001      	b.n	fe74 <_usart_interrupt_handler+0x15c>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    fe70:	2304      	movs	r3, #4
    fe72:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    fe74:	06f3      	lsls	r3, r6, #27
    fe76:	d507      	bpl.n	fe88 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    fe78:	2310      	movs	r3, #16
    fe7a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    fe7c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    fe7e:	06fb      	lsls	r3, r7, #27
    fe80:	d502      	bpl.n	fe88 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    fe82:	1c28      	adds	r0, r5, #0
    fe84:	69eb      	ldr	r3, [r5, #28]
    fe86:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    fe88:	06b3      	lsls	r3, r6, #26
    fe8a:	d507      	bpl.n	fe9c <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    fe8c:	2320      	movs	r3, #32
    fe8e:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    fe90:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    fe92:	073b      	lsls	r3, r7, #28
    fe94:	d502      	bpl.n	fe9c <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    fe96:	1c28      	adds	r0, r5, #0
    fe98:	69ab      	ldr	r3, [r5, #24]
    fe9a:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    fe9c:	0733      	lsls	r3, r6, #28
    fe9e:	d507      	bpl.n	feb0 <_usart_interrupt_handler+0x198>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    fea0:	2308      	movs	r3, #8
    fea2:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    fea4:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    fea6:	06bb      	lsls	r3, r7, #26
    fea8:	d502      	bpl.n	feb0 <_usart_interrupt_handler+0x198>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    feaa:	6a2b      	ldr	r3, [r5, #32]
    feac:	1c28      	adds	r0, r5, #0
    feae:	4798      	blx	r3
		}
	}
#endif
}
    feb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    feb2:	46c0      	nop			; (mov r8, r8)
    feb4:	20002b1c 	.word	0x20002b1c

0000feb8 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    feb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    feba:	b08b      	sub	sp, #44	; 0x2c
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    febc:	6001      	str	r1, [r0, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    febe:	680c      	ldr	r4, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    fec0:	231c      	movs	r3, #28
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    fec2:	07a4      	lsls	r4, r4, #30
    fec4:	d500      	bpl.n	fec8 <spi_init+0x10>
    fec6:	e0e2      	b.n	1008e <spi_init+0x1d6>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    fec8:	680c      	ldr	r4, [r1, #0]
		return STATUS_BUSY;
    feca:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    fecc:	07e4      	lsls	r4, r4, #31
    fece:	d500      	bpl.n	fed2 <spi_init+0x1a>
    fed0:	e0dd      	b.n	1008e <spi_init+0x1d6>
    fed2:	1c16      	adds	r6, r2, #0
    fed4:	1c0c      	adds	r4, r1, #0
    fed6:	1c05      	adds	r5, r0, #0
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    fed8:	1c08      	adds	r0, r1, #0
    feda:	4b6e      	ldr	r3, [pc, #440]	; (10094 <spi_init+0x1dc>)
    fedc:	4798      	blx	r3
    fede:	496e      	ldr	r1, [pc, #440]	; (10098 <spi_init+0x1e0>)
    fee0:	6a0a      	ldr	r2, [r1, #32]
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    fee2:	1c87      	adds	r7, r0, #2
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    fee4:	2301      	movs	r3, #1
    fee6:	40bb      	lsls	r3, r7
    fee8:	4313      	orrs	r3, r2
    feea:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    feec:	a909      	add	r1, sp, #36	; 0x24
    feee:	2724      	movs	r7, #36	; 0x24
    fef0:	5df3      	ldrb	r3, [r6, r7]
    fef2:	700b      	strb	r3, [r1, #0]
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    fef4:	3014      	adds	r0, #20

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    fef6:	b2c3      	uxtb	r3, r0
    fef8:	9301      	str	r3, [sp, #4]
    fefa:	1c18      	adds	r0, r3, #0
    fefc:	4b67      	ldr	r3, [pc, #412]	; (1009c <spi_init+0x1e4>)
    fefe:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    ff00:	9801      	ldr	r0, [sp, #4]
    ff02:	4b67      	ldr	r3, [pc, #412]	; (100a0 <spi_init+0x1e8>)
    ff04:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    ff06:	5df0      	ldrb	r0, [r6, r7]
    ff08:	2100      	movs	r1, #0
    ff0a:	4b66      	ldr	r3, [pc, #408]	; (100a4 <spi_init+0x1ec>)
    ff0c:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    ff0e:	7833      	ldrb	r3, [r6, #0]
    ff10:	2b01      	cmp	r3, #1
    ff12:	d103      	bne.n	ff1c <spi_init+0x64>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    ff14:	6822      	ldr	r2, [r4, #0]
    ff16:	330b      	adds	r3, #11
    ff18:	4313      	orrs	r3, r2
    ff1a:	6023      	str	r3, [r4, #0]
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    ff1c:	7833      	ldrb	r3, [r6, #0]
    ff1e:	2b00      	cmp	r3, #0
    ff20:	d000      	beq.n	ff24 <spi_init+0x6c>
    ff22:	e0ae      	b.n	10082 <spi_init+0x1ca>
		/* Set the SERCOM in SPI slave mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
    ff24:	6822      	ldr	r2, [r4, #0]
    ff26:	3308      	adds	r3, #8
    ff28:	4313      	orrs	r3, r2
    ff2a:	6023      	str	r3, [r4, #0]
    ff2c:	e0a9      	b.n	10082 <spi_init+0x1ca>
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    ff2e:	c304      	stmia	r3!, {r2}
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    ff30:	428b      	cmp	r3, r1
    ff32:	d1fc      	bne.n	ff2e <spi_init+0x76>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    ff34:	2300      	movs	r3, #0
    ff36:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    ff38:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    ff3a:	2400      	movs	r4, #0
    ff3c:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    ff3e:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    ff40:	3336      	adds	r3, #54	; 0x36
    ff42:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    ff44:	3301      	adds	r3, #1
    ff46:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    ff48:	3301      	adds	r3, #1
    ff4a:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    ff4c:	3b35      	subs	r3, #53	; 0x35
    ff4e:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    ff50:	712c      	strb	r4, [r5, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    ff52:	6828      	ldr	r0, [r5, #0]
    ff54:	4b4f      	ldr	r3, [pc, #316]	; (10094 <spi_init+0x1dc>)
    ff56:	4798      	blx	r3
    ff58:	1c07      	adds	r7, r0, #0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    ff5a:	4953      	ldr	r1, [pc, #332]	; (100a8 <spi_init+0x1f0>)
    ff5c:	4b53      	ldr	r3, [pc, #332]	; (100ac <spi_init+0x1f4>)
    ff5e:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    ff60:	00bf      	lsls	r7, r7, #2
    ff62:	4b53      	ldr	r3, [pc, #332]	; (100b0 <spi_init+0x1f8>)
    ff64:	50fd      	str	r5, [r7, r3]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    ff66:	682f      	ldr	r7, [r5, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    ff68:	ab04      	add	r3, sp, #16
    ff6a:	2280      	movs	r2, #128	; 0x80
    ff6c:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    ff6e:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    ff70:	3a7f      	subs	r2, #127	; 0x7f
    ff72:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    ff74:	70dc      	strb	r4, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    ff76:	7833      	ldrb	r3, [r6, #0]
    ff78:	2b00      	cmp	r3, #0
    ff7a:	d102      	bne.n	ff82 <spi_init+0xca>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    ff7c:	2200      	movs	r2, #0
    ff7e:	ab04      	add	r3, sp, #16
    ff80:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    ff82:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    ff84:	9305      	str	r3, [sp, #20]
    ff86:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    ff88:	9306      	str	r3, [sp, #24]
    ff8a:	6b33      	ldr	r3, [r6, #48]	; 0x30
    ff8c:	9307      	str	r3, [sp, #28]
    ff8e:	6b73      	ldr	r3, [r6, #52]	; 0x34
    ff90:	9308      	str	r3, [sp, #32]
    ff92:	2400      	movs	r4, #0
    ff94:	b2e1      	uxtb	r1, r4
    ff96:	00a3      	lsls	r3, r4, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    ff98:	aa05      	add	r2, sp, #20
    ff9a:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    ff9c:	2800      	cmp	r0, #0
    ff9e:	d102      	bne.n	ffa6 <spi_init+0xee>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    ffa0:	1c38      	adds	r0, r7, #0
    ffa2:	4b44      	ldr	r3, [pc, #272]	; (100b4 <spi_init+0x1fc>)
    ffa4:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    ffa6:	1c43      	adds	r3, r0, #1
    ffa8:	d006      	beq.n	ffb8 <spi_init+0x100>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    ffaa:	ab02      	add	r3, sp, #8
    ffac:	7218      	strb	r0, [r3, #8]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    ffae:	0c00      	lsrs	r0, r0, #16
    ffb0:	b2c0      	uxtb	r0, r0
    ffb2:	a904      	add	r1, sp, #16
    ffb4:	4b40      	ldr	r3, [pc, #256]	; (100b8 <spi_init+0x200>)
    ffb6:	4798      	blx	r3
    ffb8:	3401      	adds	r4, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    ffba:	2c04      	cmp	r4, #4
    ffbc:	d1ea      	bne.n	ff94 <spi_init+0xdc>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    ffbe:	7833      	ldrb	r3, [r6, #0]
    ffc0:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    ffc2:	7c33      	ldrb	r3, [r6, #16]
    ffc4:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    ffc6:	7cb3      	ldrb	r3, [r6, #18]
    ffc8:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    ffca:	7d33      	ldrb	r3, [r6, #20]
    ffcc:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    ffce:	2200      	movs	r2, #0
    ffd0:	ab02      	add	r3, sp, #8
    ffd2:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    ffd4:	7833      	ldrb	r3, [r6, #0]
    ffd6:	2b01      	cmp	r3, #1
    ffd8:	d113      	bne.n	10002 <spi_init+0x14a>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ffda:	6828      	ldr	r0, [r5, #0]
    ffdc:	4b2d      	ldr	r3, [pc, #180]	; (10094 <spi_init+0x1dc>)
    ffde:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    ffe0:	3014      	adds	r0, #20
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    ffe2:	b2c0      	uxtb	r0, r0
    ffe4:	4b35      	ldr	r3, [pc, #212]	; (100bc <spi_init+0x204>)
    ffe6:	4798      	blx	r3
    ffe8:	1c01      	adds	r1, r0, #0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    ffea:	69b0      	ldr	r0, [r6, #24]
    ffec:	ab02      	add	r3, sp, #8
    ffee:	1d9a      	adds	r2, r3, #6
    fff0:	4b33      	ldr	r3, [pc, #204]	; (100c0 <spi_init+0x208>)
    fff2:	4798      	blx	r3
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    fff4:	2317      	movs	r3, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    fff6:	2800      	cmp	r0, #0
    fff8:	d149      	bne.n	1008e <spi_init+0x1d6>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    fffa:	ab02      	add	r3, sp, #8
    fffc:	3306      	adds	r3, #6
    fffe:	781b      	ldrb	r3, [r3, #0]
   10000:	733b      	strb	r3, [r7, #12]
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
   10002:	7833      	ldrb	r3, [r6, #0]
   10004:	2b00      	cmp	r3, #0
   10006:	d10f      	bne.n	10028 <spi_init+0x170>
		/* Set frame format */
		ctrla = config->mode_specific.slave.frame_format;
   10008:	69b0      	ldr	r0, [r6, #24]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;
   1000a:	8bb3      	ldrh	r3, [r6, #28]

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
   1000c:	6a79      	ldr	r1, [r7, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);
   1000e:	7ff2      	ldrb	r2, [r6, #31]
   10010:	0412      	lsls	r2, r2, #16
		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
   10012:	7fb4      	ldrb	r4, [r6, #30]
   10014:	4322      	orrs	r2, r4

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
   10016:	430a      	orrs	r2, r1
   10018:	627a      	str	r2, [r7, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
   1001a:	2220      	movs	r2, #32
   1001c:	5cb2      	ldrb	r2, [r6, r2]
   1001e:	2a00      	cmp	r2, #0
   10020:	d004      	beq.n	1002c <spi_init+0x174>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
   10022:	2140      	movs	r1, #64	; 0x40
   10024:	430b      	orrs	r3, r1
   10026:	e001      	b.n	1002c <spi_init+0x174>
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
   10028:	2300      	movs	r3, #0
#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
   1002a:	2000      	movs	r0, #0
   1002c:	68b2      	ldr	r2, [r6, #8]
   1002e:	6871      	ldr	r1, [r6, #4]
   10030:	430a      	orrs	r2, r1
   10032:	68f1      	ldr	r1, [r6, #12]
   10034:	430a      	orrs	r2, r1

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
   10036:	4302      	orrs	r2, r0

	/* Set SPI character size */
	ctrlb |= config->character_size;
   10038:	7c31      	ldrb	r1, [r6, #16]
   1003a:	430b      	orrs	r3, r1

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
   1003c:	7c71      	ldrb	r1, [r6, #17]
   1003e:	2900      	cmp	r1, #0
   10040:	d103      	bne.n	1004a <spi_init+0x192>
   10042:	4920      	ldr	r1, [pc, #128]	; (100c4 <spi_init+0x20c>)
   10044:	7889      	ldrb	r1, [r1, #2]
   10046:	0789      	lsls	r1, r1, #30
   10048:	d501      	bpl.n	1004e <spi_init+0x196>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
   1004a:	2180      	movs	r1, #128	; 0x80
   1004c:	430a      	orrs	r2, r1
	}

	if (config->receiver_enable) {
   1004e:	7cb1      	ldrb	r1, [r6, #18]
   10050:	2900      	cmp	r1, #0
   10052:	d002      	beq.n	1005a <spi_init+0x1a2>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
   10054:	2180      	movs	r1, #128	; 0x80
   10056:	0289      	lsls	r1, r1, #10
   10058:	430b      	orrs	r3, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
   1005a:	7cf1      	ldrb	r1, [r6, #19]
   1005c:	2900      	cmp	r1, #0
   1005e:	d002      	beq.n	10066 <spi_init+0x1ae>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
   10060:	2180      	movs	r1, #128	; 0x80
   10062:	0089      	lsls	r1, r1, #2
   10064:	430b      	orrs	r3, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
   10066:	7d31      	ldrb	r1, [r6, #20]
   10068:	2900      	cmp	r1, #0
   1006a:	d002      	beq.n	10072 <spi_init+0x1ba>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
   1006c:	2180      	movs	r1, #128	; 0x80
   1006e:	0189      	lsls	r1, r1, #6
   10070:	430b      	orrs	r3, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
   10072:	6839      	ldr	r1, [r7, #0]
   10074:	430a      	orrs	r2, r1
   10076:	603a      	str	r2, [r7, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
   10078:	687a      	ldr	r2, [r7, #4]
   1007a:	4313      	orrs	r3, r2
   1007c:	607b      	str	r3, [r7, #4]

	return STATUS_OK;
   1007e:	2300      	movs	r3, #0
   10080:	e005      	b.n	1008e <spi_init+0x1d6>
   10082:	1c2b      	adds	r3, r5, #0
   10084:	330c      	adds	r3, #12
   10086:	1c29      	adds	r1, r5, #0
   10088:	3128      	adds	r1, #40	; 0x28
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
   1008a:	2200      	movs	r2, #0
   1008c:	e74f      	b.n	ff2e <spi_init+0x76>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
   1008e:	1c18      	adds	r0, r3, #0
   10090:	b00b      	add	sp, #44	; 0x2c
   10092:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10094:	0000f725 	.word	0x0000f725
   10098:	40000400 	.word	0x40000400
   1009c:	0001392d 	.word	0x0001392d
   100a0:	000138a1 	.word	0x000138a1
   100a4:	0000f551 	.word	0x0000f551
   100a8:	000101bd 	.word	0x000101bd
   100ac:	000103bd 	.word	0x000103bd
   100b0:	20002b1c 	.word	0x20002b1c
   100b4:	0000f59d 	.word	0x0000f59d
   100b8:	00013a25 	.word	0x00013a25
   100bc:	00013949 	.word	0x00013949
   100c0:	0000f361 	.word	0x0000f361
   100c4:	41002000 	.word	0x41002000

000100c8 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
   100c8:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
   100ca:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
   100cc:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
   100ce:	2c01      	cmp	r4, #1
   100d0:	d170      	bne.n	101b4 <spi_select_slave+0xec>
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
   100d2:	7a04      	ldrb	r4, [r0, #8]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
   100d4:	2300      	movs	r3, #0
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
   100d6:	2c00      	cmp	r4, #0
   100d8:	d16c      	bne.n	101b4 <spi_select_slave+0xec>
#  endif
	{
		if (select) {
   100da:	2a00      	cmp	r2, #0
   100dc:	d05a      	beq.n	10194 <spi_select_slave+0xcc>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
   100de:	784b      	ldrb	r3, [r1, #1]
   100e0:	2b00      	cmp	r3, #0
   100e2:	d046      	beq.n	10172 <spi_select_slave+0xaa>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   100e4:	6803      	ldr	r3, [r0, #0]
   100e6:	7e1b      	ldrb	r3, [r3, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
   100e8:	07db      	lsls	r3, r3, #31
   100ea:	d410      	bmi.n	1010e <spi_select_slave+0x46>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
   100ec:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   100ee:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   100f0:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   100f2:	2900      	cmp	r1, #0
   100f4:	d104      	bne.n	10100 <spi_select_slave+0x38>
		return &(ports[port_index]->Group[group_index]);
   100f6:	095a      	lsrs	r2, r3, #5
   100f8:	01d2      	lsls	r2, r2, #7
   100fa:	492f      	ldr	r1, [pc, #188]	; (101b8 <spi_select_slave+0xf0>)
   100fc:	468c      	mov	ip, r1
   100fe:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   10100:	211f      	movs	r1, #31
   10102:	400b      	ands	r3, r1
   10104:	391e      	subs	r1, #30
   10106:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
   10108:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
   1010a:	2305      	movs	r3, #5
   1010c:	e052      	b.n	101b4 <spi_select_slave+0xec>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
   1010e:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10110:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   10112:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10114:	2c00      	cmp	r4, #0
   10116:	d104      	bne.n	10122 <spi_select_slave+0x5a>
		return &(ports[port_index]->Group[group_index]);
   10118:	095a      	lsrs	r2, r3, #5
   1011a:	01d2      	lsls	r2, r2, #7
   1011c:	4c26      	ldr	r4, [pc, #152]	; (101b8 <spi_select_slave+0xf0>)
   1011e:	46a4      	mov	ip, r4
   10120:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   10122:	241f      	movs	r4, #31
   10124:	4023      	ands	r3, r4
   10126:	3c1e      	subs	r4, #30
   10128:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   1012a:	6154      	str	r4, [r2, #20]

				/* Write address to slave */
				spi_write(module, slave->address);
   1012c:	788a      	ldrb	r2, [r1, #2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1012e:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   10130:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
   10132:	07c9      	lsls	r1, r1, #31
   10134:	d500      	bpl.n	10138 <spi_select_slave+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
   10136:	629a      	str	r2, [r3, #40]	; 0x28

				if (!(module->receiver_enabled)) {
   10138:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
   1013a:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
   1013c:	2a00      	cmp	r2, #0
   1013e:	d139      	bne.n	101b4 <spi_select_slave+0xec>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   10140:	6802      	ldr	r2, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   10142:	2104      	movs	r1, #4
   10144:	7e13      	ldrb	r3, [r2, #24]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
   10146:	420b      	tst	r3, r1
   10148:	d0fc      	beq.n	10144 <spi_select_slave+0x7c>
   1014a:	7e11      	ldrb	r1, [r2, #24]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
   1014c:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
   1014e:	0749      	lsls	r1, r1, #29
   10150:	d530      	bpl.n	101b4 <spi_select_slave+0xec>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   10152:	8b53      	ldrh	r3, [r2, #26]
   10154:	075b      	lsls	r3, r3, #29
   10156:	d503      	bpl.n	10160 <spi_select_slave+0x98>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   10158:	8b51      	ldrh	r1, [r2, #26]
   1015a:	2304      	movs	r3, #4
   1015c:	430b      	orrs	r3, r1
   1015e:	8353      	strh	r3, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   10160:	7983      	ldrb	r3, [r0, #6]
   10162:	2b01      	cmp	r3, #1
   10164:	d102      	bne.n	1016c <spi_select_slave+0xa4>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   10166:	6a93      	ldr	r3, [r2, #40]	; 0x28
   10168:	2300      	movs	r3, #0
   1016a:	e023      	b.n	101b4 <spi_select_slave+0xec>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
   1016c:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1016e:	2300      	movs	r3, #0
   10170:	e020      	b.n	101b4 <spi_select_slave+0xec>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
   10172:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10174:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   10176:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10178:	2900      	cmp	r1, #0
   1017a:	d104      	bne.n	10186 <spi_select_slave+0xbe>
		return &(ports[port_index]->Group[group_index]);
   1017c:	095a      	lsrs	r2, r3, #5
   1017e:	01d2      	lsls	r2, r2, #7
   10180:	490d      	ldr	r1, [pc, #52]	; (101b8 <spi_select_slave+0xf0>)
   10182:	468c      	mov	ip, r1
   10184:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   10186:	211f      	movs	r1, #31
   10188:	400b      	ands	r3, r1
   1018a:	391e      	subs	r1, #30
   1018c:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   1018e:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
   10190:	2300      	movs	r3, #0
   10192:	e00f      	b.n	101b4 <spi_select_slave+0xec>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
   10194:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10196:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   10198:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   1019a:	2900      	cmp	r1, #0
   1019c:	d104      	bne.n	101a8 <spi_select_slave+0xe0>
		return &(ports[port_index]->Group[group_index]);
   1019e:	095a      	lsrs	r2, r3, #5
   101a0:	01d2      	lsls	r2, r2, #7
   101a2:	4905      	ldr	r1, [pc, #20]	; (101b8 <spi_select_slave+0xf0>)
   101a4:	468c      	mov	ip, r1
   101a6:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   101a8:	211f      	movs	r1, #31
   101aa:	400b      	ands	r3, r1
   101ac:	391e      	subs	r1, #30
   101ae:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
   101b0:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
   101b2:	2300      	movs	r3, #0
}
   101b4:	1c18      	adds	r0, r3, #0
   101b6:	bd10      	pop	{r4, pc}
   101b8:	41004400 	.word	0x41004400

000101bc <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
   101bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
   101be:	0080      	lsls	r0, r0, #2
   101c0:	4b7b      	ldr	r3, [pc, #492]	; (103b0 <_spi_interrupt_handler+0x1f4>)
   101c2:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   101c4:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
   101c6:	2336      	movs	r3, #54	; 0x36

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
   101c8:	5ce3      	ldrb	r3, [r4, r3]
   101ca:	2237      	movs	r2, #55	; 0x37
   101cc:	5ca7      	ldrb	r7, [r4, r2]
   101ce:	401f      	ands	r7, r3
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
   101d0:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
   101d2:	7db5      	ldrb	r5, [r6, #22]
   101d4:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
   101d6:	07eb      	lsls	r3, r5, #31
   101d8:	d543      	bpl.n	10262 <_spi_interrupt_handler+0xa6>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   101da:	7963      	ldrb	r3, [r4, #5]
   101dc:	2b01      	cmp	r3, #1
   101de:	d116      	bne.n	1020e <_spi_interrupt_handler+0x52>
			(module->dir == SPI_DIRECTION_READ)) {
   101e0:	7a63      	ldrb	r3, [r4, #9]
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   101e2:	2b00      	cmp	r3, #0
   101e4:	d10f      	bne.n	10206 <_spi_interrupt_handler+0x4a>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
   101e6:	4b73      	ldr	r3, [pc, #460]	; (103b4 <_spi_interrupt_handler+0x1f8>)
   101e8:	881b      	ldrh	r3, [r3, #0]
   101ea:	62b3      	str	r3, [r6, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
   101ec:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   101ee:	3b01      	subs	r3, #1
   101f0:	b29b      	uxth	r3, r3
   101f2:	8663      	strh	r3, [r4, #50]	; 0x32
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
   101f4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   101f6:	b29b      	uxth	r3, r3
   101f8:	2b00      	cmp	r3, #0
   101fa:	d101      	bne.n	10200 <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   101fc:	3301      	adds	r3, #1
   101fe:	7533      	strb	r3, [r6, #20]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
   10200:	7963      	ldrb	r3, [r4, #5]
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			}
		}
#  endif

		if (0
   10202:	2b01      	cmp	r3, #1
   10204:	d103      	bne.n	1020e <_spi_interrupt_handler+0x52>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
   10206:	7a63      	ldrb	r3, [r4, #9]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
   10208:	2b00      	cmp	r3, #0
   1020a:	d105      	bne.n	10218 <_spi_interrupt_handler+0x5c>
   1020c:	e029      	b.n	10262 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
   1020e:	2b00      	cmp	r3, #0
   10210:	d127      	bne.n	10262 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
   10212:	7a63      	ldrb	r3, [r4, #9]
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
   10214:	2b00      	cmp	r3, #0
   10216:	d024      	beq.n	10262 <_spi_interrupt_handler+0xa6>
 */
static void _spi_write(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   10218:	6820      	ldr	r0, [r4, #0]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1021a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   1021c:	780b      	ldrb	r3, [r1, #0]
   1021e:	b2da      	uxtb	r2, r3
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
   10220:	1c4b      	adds	r3, r1, #1
   10222:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   10224:	79a3      	ldrb	r3, [r4, #6]
   10226:	2b01      	cmp	r3, #1
   10228:	d001      	beq.n	1022e <_spi_interrupt_handler+0x72>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1022a:	b293      	uxth	r3, r2
   1022c:	e004      	b.n	10238 <_spi_interrupt_handler+0x7c>
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
   1022e:	784b      	ldrb	r3, [r1, #1]
   10230:	021b      	lsls	r3, r3, #8
   10232:	4313      	orrs	r3, r2
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
   10234:	3102      	adds	r1, #2
   10236:	62e1      	str	r1, [r4, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
   10238:	05db      	lsls	r3, r3, #23
   1023a:	0ddb      	lsrs	r3, r3, #23
   1023c:	6283      	str	r3, [r0, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
   1023e:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   10240:	3b01      	subs	r3, #1
   10242:	b29b      	uxth	r3, r3
   10244:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
   10246:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   10248:	b29b      	uxth	r3, r3
   1024a:	2b00      	cmp	r3, #0
   1024c:	d109      	bne.n	10262 <_spi_interrupt_handler+0xa6>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   1024e:	3301      	adds	r3, #1
   10250:	7533      	strb	r3, [r6, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
   10252:	7a63      	ldrb	r3, [r4, #9]
   10254:	2b01      	cmp	r3, #1
   10256:	d104      	bne.n	10262 <_spi_interrupt_handler+0xa6>
   10258:	79e3      	ldrb	r3, [r4, #7]
   1025a:	2b00      	cmp	r3, #0
   1025c:	d101      	bne.n	10262 <_spi_interrupt_handler+0xa6>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
   1025e:	3302      	adds	r3, #2
   10260:	75b3      	strb	r3, [r6, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
   10262:	076b      	lsls	r3, r5, #29
   10264:	d561      	bpl.n	1032a <_spi_interrupt_handler+0x16e>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   10266:	8b73      	ldrh	r3, [r6, #26]
   10268:	075b      	lsls	r3, r3, #29
   1026a:	d514      	bpl.n	10296 <_spi_interrupt_handler+0xda>
			if (module->dir != SPI_DIRECTION_WRITE) {
   1026c:	7a63      	ldrb	r3, [r4, #9]
   1026e:	2b01      	cmp	r3, #1
   10270:	d00b      	beq.n	1028a <_spi_interrupt_handler+0xce>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
   10272:	221e      	movs	r2, #30
   10274:	2338      	movs	r3, #56	; 0x38
   10276:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
   10278:	3b35      	subs	r3, #53	; 0x35
   1027a:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
   1027c:	3302      	adds	r3, #2
   1027e:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
   10280:	073b      	lsls	r3, r7, #28
   10282:	d502      	bpl.n	1028a <_spi_interrupt_handler+0xce>
					(module->callback[SPI_CALLBACK_ERROR])(module);
   10284:	1c20      	adds	r0, r4, #0
   10286:	69a3      	ldr	r3, [r4, #24]
   10288:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
   1028a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   1028c:	8b72      	ldrh	r2, [r6, #26]
   1028e:	2304      	movs	r3, #4
   10290:	4313      	orrs	r3, r2
   10292:	8373      	strh	r3, [r6, #26]
   10294:	e049      	b.n	1032a <_spi_interrupt_handler+0x16e>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
   10296:	7a63      	ldrb	r3, [r4, #9]
   10298:	2b01      	cmp	r3, #1
   1029a:	d116      	bne.n	102ca <_spi_interrupt_handler+0x10e>
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   1029c:	6823      	ldr	r3, [r4, #0]
	uint16_t flush = 0;

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
   1029e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
   102a0:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   102a2:	3b01      	subs	r3, #1
   102a4:	b29b      	uxth	r3, r3
   102a6:	8663      	strh	r3, [r4, #50]	; 0x32
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
				if (module->remaining_dummy_buffer_length == 0) {
   102a8:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   102aa:	b29b      	uxth	r3, r3
   102ac:	2b00      	cmp	r3, #0
   102ae:	d13c      	bne.n	1032a <_spi_interrupt_handler+0x16e>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   102b0:	3304      	adds	r3, #4
   102b2:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
   102b4:	2200      	movs	r2, #0
   102b6:	3334      	adds	r3, #52	; 0x34
   102b8:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
   102ba:	3b35      	subs	r3, #53	; 0x35
   102bc:	7263      	strb	r3, [r4, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
   102be:	07fb      	lsls	r3, r7, #31
   102c0:	d533      	bpl.n	1032a <_spi_interrupt_handler+0x16e>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
   102c2:	1c20      	adds	r0, r4, #0
   102c4:	68e3      	ldr	r3, [r4, #12]
   102c6:	4798      	blx	r3
   102c8:	e02f      	b.n	1032a <_spi_interrupt_handler+0x16e>
 */
static void _spi_read(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
   102ca:	6823      	ldr	r3, [r4, #0]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
   102cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   102ce:	05db      	lsls	r3, r3, #23
   102d0:	0ddb      	lsrs	r3, r3, #23

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
   102d2:	b2da      	uxtb	r2, r3
   102d4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   102d6:	700a      	strb	r2, [r1, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
   102d8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   102da:	1c51      	adds	r1, r2, #1
   102dc:	62a1      	str	r1, [r4, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   102de:	79a1      	ldrb	r1, [r4, #6]
   102e0:	2901      	cmp	r1, #1
   102e2:	d104      	bne.n	102ee <_spi_interrupt_handler+0x132>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
   102e4:	0a1b      	lsrs	r3, r3, #8
   102e6:	7053      	strb	r3, [r2, #1]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
   102e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   102ea:	3301      	adds	r3, #1
   102ec:	62a3      	str	r3, [r4, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
   102ee:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   102f0:	3b01      	subs	r3, #1
   102f2:	b29b      	uxth	r3, r3
   102f4:	8623      	strh	r3, [r4, #48]	; 0x30
			} else {
				/* Read data register */
				_spi_read(module);

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
   102f6:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   102f8:	b29b      	uxth	r3, r3
   102fa:	2b00      	cmp	r3, #0
   102fc:	d115      	bne.n	1032a <_spi_interrupt_handler+0x16e>
					module->status = STATUS_OK;
   102fe:	2200      	movs	r2, #0
   10300:	3338      	adds	r3, #56	; 0x38
   10302:	54e2      	strb	r2, [r4, r3]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   10304:	3b34      	subs	r3, #52	; 0x34
   10306:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
   10308:	7a63      	ldrb	r3, [r4, #9]
   1030a:	2b02      	cmp	r3, #2
   1030c:	d105      	bne.n	1031a <_spi_interrupt_handler+0x15e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
   1030e:	077b      	lsls	r3, r7, #29
   10310:	d50b      	bpl.n	1032a <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
   10312:	1c20      	adds	r0, r4, #0
   10314:	6963      	ldr	r3, [r4, #20]
   10316:	4798      	blx	r3
   10318:	e007      	b.n	1032a <_spi_interrupt_handler+0x16e>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
   1031a:	7a63      	ldrb	r3, [r4, #9]
   1031c:	2b00      	cmp	r3, #0
   1031e:	d104      	bne.n	1032a <_spi_interrupt_handler+0x16e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
   10320:	07bb      	lsls	r3, r7, #30
   10322:	d502      	bpl.n	1032a <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
   10324:	1c20      	adds	r0, r4, #0
   10326:	6923      	ldr	r3, [r4, #16]
   10328:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
   1032a:	07ab      	lsls	r3, r5, #30
   1032c:	d528      	bpl.n	10380 <_spi_interrupt_handler+0x1c4>
#  if CONF_SPI_SLAVE_ENABLE == true
		if (module->mode == SPI_MODE_SLAVE) {
   1032e:	7963      	ldrb	r3, [r4, #5]
   10330:	2b00      	cmp	r3, #0
   10332:	d110      	bne.n	10356 <_spi_interrupt_handler+0x19a>
			/* Transaction ended by master */

			/* Disable interrupts */
			spi_hw->INTENCLR.reg =
   10334:	3307      	adds	r3, #7
   10336:	7533      	strb	r3, [r6, #20]
					SPI_INTERRUPT_FLAG_TX_COMPLETE |
					SPI_INTERRUPT_FLAG_RX_COMPLETE |
					SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			/* Clear interrupt flag */
			spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
   10338:	3b05      	subs	r3, #5
   1033a:	7633      	strb	r3, [r6, #24]


			/* Reset all status information */
			module->dir = SPI_DIRECTION_IDLE;
   1033c:	3301      	adds	r3, #1
   1033e:	7263      	strb	r3, [r4, #9]
			module->remaining_tx_buffer_length = 0;
   10340:	2300      	movs	r3, #0
   10342:	86a3      	strh	r3, [r4, #52]	; 0x34
			module->remaining_rx_buffer_length = 0;
   10344:	8623      	strh	r3, [r4, #48]	; 0x30
			module->status = STATUS_OK;
   10346:	3338      	adds	r3, #56	; 0x38
   10348:	2200      	movs	r2, #0
   1034a:	54e2      	strb	r2, [r4, r3]

			if (callback_mask &
   1034c:	06fb      	lsls	r3, r7, #27
   1034e:	d502      	bpl.n	10356 <_spi_interrupt_handler+0x19a>
					(1 << SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE)) {
			(module->callback[SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE])
   10350:	1c20      	adds	r0, r4, #0
   10352:	69e3      	ldr	r3, [r4, #28]
   10354:	4798      	blx	r3
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   10356:	7963      	ldrb	r3, [r4, #5]
   10358:	2b01      	cmp	r3, #1
   1035a:	d111      	bne.n	10380 <_spi_interrupt_handler+0x1c4>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   1035c:	7a63      	ldrb	r3, [r4, #9]
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   1035e:	2b01      	cmp	r3, #1
   10360:	d11b      	bne.n	1039a <_spi_interrupt_handler+0x1de>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   10362:	79e3      	ldrb	r3, [r4, #7]
   10364:	2b00      	cmp	r3, #0
   10366:	d118      	bne.n	1039a <_spi_interrupt_handler+0x1de>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
   10368:	3302      	adds	r3, #2
   1036a:	7533      	strb	r3, [r6, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
   1036c:	3301      	adds	r3, #1
   1036e:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
   10370:	2200      	movs	r2, #0
   10372:	3335      	adds	r3, #53	; 0x35
   10374:	54e2      	strb	r2, [r4, r3]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
   10376:	07fb      	lsls	r3, r7, #31
   10378:	d502      	bpl.n	10380 <_spi_interrupt_handler+0x1c4>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
   1037a:	1c20      	adds	r0, r4, #0
   1037c:	68e3      	ldr	r3, [r4, #12]
   1037e:	4798      	blx	r3
	}

#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
#  if CONF_SPI_SLAVE_ENABLE == true
		/* When a high to low transition is detected on the _SS pin in slave mode */
		if (interrupt_status & SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW) {
   10380:	072b      	lsls	r3, r5, #28
   10382:	d50a      	bpl.n	1039a <_spi_interrupt_handler+0x1de>
			if (module->mode == SPI_MODE_SLAVE) {
   10384:	7963      	ldrb	r3, [r4, #5]
   10386:	2b00      	cmp	r3, #0
   10388:	d107      	bne.n	1039a <_spi_interrupt_handler+0x1de>
				/* Disable interrupts */
				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
   1038a:	3308      	adds	r3, #8
   1038c:	7533      	strb	r3, [r6, #20]
				/* Clear interrupt flag */
				spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
   1038e:	7633      	strb	r3, [r6, #24]

				if (callback_mask & (1 << SPI_CALLBACK_SLAVE_SELECT_LOW)) {
   10390:	06bb      	lsls	r3, r7, #26
   10392:	d502      	bpl.n	1039a <_spi_interrupt_handler+0x1de>
					(module->callback[SPI_CALLBACK_SLAVE_SELECT_LOW])(module);
   10394:	1c20      	adds	r0, r4, #0
   10396:	6a23      	ldr	r3, [r4, #32]
   10398:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
   1039a:	09ed      	lsrs	r5, r5, #7
   1039c:	d007      	beq.n	103ae <_spi_interrupt_handler+0x1f2>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   1039e:	2380      	movs	r3, #128	; 0x80
   103a0:	7533      	strb	r3, [r6, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   103a2:	7633      	strb	r3, [r6, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
   103a4:	067b      	lsls	r3, r7, #25
   103a6:	d502      	bpl.n	103ae <_spi_interrupt_handler+0x1f2>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
   103a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   103aa:	1c20      	adds	r0, r4, #0
   103ac:	4798      	blx	r3
		}
	}
#  endif
}
   103ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   103b0:	20002b1c 	.word	0x20002b1c
   103b4:	20002b18 	.word	0x20002b18

000103b8 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
   103b8:	4770      	bx	lr
   103ba:	46c0      	nop			; (mov r8, r8)

000103bc <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
   103bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
   103be:	4b0a      	ldr	r3, [pc, #40]	; (103e8 <_sercom_set_handler+0x2c>)
   103c0:	781b      	ldrb	r3, [r3, #0]
   103c2:	2b00      	cmp	r3, #0
   103c4:	d10c      	bne.n	103e0 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
   103c6:	4f09      	ldr	r7, [pc, #36]	; (103ec <_sercom_set_handler+0x30>)
   103c8:	4e09      	ldr	r6, [pc, #36]	; (103f0 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
   103ca:	4d0a      	ldr	r5, [pc, #40]	; (103f4 <_sercom_set_handler+0x38>)
   103cc:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
   103ce:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
   103d0:	195a      	adds	r2, r3, r5
   103d2:	6014      	str	r4, [r2, #0]
   103d4:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   103d6:	2b18      	cmp	r3, #24
   103d8:	d1f9      	bne.n	103ce <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
   103da:	2201      	movs	r2, #1
   103dc:	4b02      	ldr	r3, [pc, #8]	; (103e8 <_sercom_set_handler+0x2c>)
   103de:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
   103e0:	0080      	lsls	r0, r0, #2
   103e2:	4b02      	ldr	r3, [pc, #8]	; (103ec <_sercom_set_handler+0x30>)
   103e4:	50c1      	str	r1, [r0, r3]
}
   103e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   103e8:	200012cc 	.word	0x200012cc
   103ec:	200012d0 	.word	0x200012d0
   103f0:	000103b9 	.word	0x000103b9
   103f4:	20002b1c 	.word	0x20002b1c

000103f8 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
   103f8:	b510      	push	{r4, lr}
   103fa:	b082      	sub	sp, #8
   103fc:	1c04      	adds	r4, r0, #0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
   103fe:	4668      	mov	r0, sp
   10400:	4905      	ldr	r1, [pc, #20]	; (10418 <_sercom_get_interrupt_vector+0x20>)
   10402:	2206      	movs	r2, #6
   10404:	4b05      	ldr	r3, [pc, #20]	; (1041c <_sercom_get_interrupt_vector+0x24>)
   10406:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
   10408:	1c20      	adds	r0, r4, #0
   1040a:	4b05      	ldr	r3, [pc, #20]	; (10420 <_sercom_get_interrupt_vector+0x28>)
   1040c:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
   1040e:	466b      	mov	r3, sp
   10410:	5618      	ldrsb	r0, [r3, r0]
}
   10412:	b002      	add	sp, #8
   10414:	bd10      	pop	{r4, pc}
   10416:	46c0      	nop			; (mov r8, r8)
   10418:	000203e4 	.word	0x000203e4
   1041c:	00016739 	.word	0x00016739
   10420:	0000f725 	.word	0x0000f725

00010424 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
   10424:	b508      	push	{r3, lr}
   10426:	4b02      	ldr	r3, [pc, #8]	; (10430 <SERCOM0_Handler+0xc>)
   10428:	681b      	ldr	r3, [r3, #0]
   1042a:	2000      	movs	r0, #0
   1042c:	4798      	blx	r3
   1042e:	bd08      	pop	{r3, pc}
   10430:	200012d0 	.word	0x200012d0

00010434 <SERCOM1_Handler>:
   10434:	b508      	push	{r3, lr}
   10436:	4b02      	ldr	r3, [pc, #8]	; (10440 <SERCOM1_Handler+0xc>)
   10438:	685b      	ldr	r3, [r3, #4]
   1043a:	2001      	movs	r0, #1
   1043c:	4798      	blx	r3
   1043e:	bd08      	pop	{r3, pc}
   10440:	200012d0 	.word	0x200012d0

00010444 <SERCOM2_Handler>:
   10444:	b508      	push	{r3, lr}
   10446:	4b02      	ldr	r3, [pc, #8]	; (10450 <SERCOM2_Handler+0xc>)
   10448:	689b      	ldr	r3, [r3, #8]
   1044a:	2002      	movs	r0, #2
   1044c:	4798      	blx	r3
   1044e:	bd08      	pop	{r3, pc}
   10450:	200012d0 	.word	0x200012d0

00010454 <SERCOM3_Handler>:
   10454:	b508      	push	{r3, lr}
   10456:	4b02      	ldr	r3, [pc, #8]	; (10460 <SERCOM3_Handler+0xc>)
   10458:	68db      	ldr	r3, [r3, #12]
   1045a:	2003      	movs	r0, #3
   1045c:	4798      	blx	r3
   1045e:	bd08      	pop	{r3, pc}
   10460:	200012d0 	.word	0x200012d0

00010464 <SERCOM4_Handler>:
   10464:	b508      	push	{r3, lr}
   10466:	4b02      	ldr	r3, [pc, #8]	; (10470 <SERCOM4_Handler+0xc>)
   10468:	691b      	ldr	r3, [r3, #16]
   1046a:	2004      	movs	r0, #4
   1046c:	4798      	blx	r3
   1046e:	bd08      	pop	{r3, pc}
   10470:	200012d0 	.word	0x200012d0

00010474 <SERCOM5_Handler>:
   10474:	b508      	push	{r3, lr}
   10476:	4b02      	ldr	r3, [pc, #8]	; (10480 <SERCOM5_Handler+0xc>)
   10478:	695b      	ldr	r3, [r3, #20]
   1047a:	2005      	movs	r0, #5
   1047c:	4798      	blx	r3
   1047e:	bd08      	pop	{r3, pc}
   10480:	200012d0 	.word	0x200012d0

00010484 <extint_register_callback>:
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   10484:	2317      	movs	r3, #23
	const enum extint_callback_type type)
{
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
   10486:	2a00      	cmp	r2, #0
   10488:	d10d      	bne.n	104a6 <extint_register_callback+0x22>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	if (_extint_dev.callbacks[channel] == NULL) {
   1048a:	008b      	lsls	r3, r1, #2
   1048c:	4a07      	ldr	r2, [pc, #28]	; (104ac <extint_register_callback+0x28>)
   1048e:	589b      	ldr	r3, [r3, r2]
   10490:	2b00      	cmp	r3, #0
   10492:	d103      	bne.n	1049c <extint_register_callback+0x18>
		_extint_dev.callbacks[channel] = callback;
   10494:	0089      	lsls	r1, r1, #2
   10496:	5088      	str	r0, [r1, r2]
		return STATUS_OK;
   10498:	2300      	movs	r3, #0
   1049a:	e004      	b.n	104a6 <extint_register_callback+0x22>
	} else if (_extint_dev.callbacks[channel] == callback) {
   1049c:	4283      	cmp	r3, r0
   1049e:	d001      	beq.n	104a4 <extint_register_callback+0x20>
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
   104a0:	231d      	movs	r3, #29
   104a2:	e000      	b.n	104a6 <extint_register_callback+0x22>

	if (_extint_dev.callbacks[channel] == NULL) {
		_extint_dev.callbacks[channel] = callback;
		return STATUS_OK;
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
   104a4:	2300      	movs	r3, #0
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
   104a6:	1c18      	adds	r0, r3, #0
   104a8:	4770      	bx	lr
   104aa:	46c0      	nop			; (mov r8, r8)
   104ac:	20002acc 	.word	0x20002acc

000104b0 <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   104b0:	2317      	movs	r3, #23
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
   104b2:	2900      	cmp	r1, #0
   104b4:	d107      	bne.n	104c6 <extint_chan_enable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
   104b6:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
   104b8:	281f      	cmp	r0, #31
   104ba:	d800      	bhi.n	104be <extint_chan_enable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
   104bc:	4a03      	ldr	r2, [pc, #12]	; (104cc <extint_chan_enable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENSET.reg = (1UL << channel);
   104be:	2301      	movs	r3, #1
   104c0:	4083      	lsls	r3, r0
   104c2:	60d3      	str	r3, [r2, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   104c4:	2300      	movs	r3, #0
}
   104c6:	1c18      	adds	r0, r3, #0
   104c8:	4770      	bx	lr
   104ca:	46c0      	nop			; (mov r8, r8)
   104cc:	40001800 	.word	0x40001800

000104d0 <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   104d0:	2317      	movs	r3, #23
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
   104d2:	2900      	cmp	r1, #0
   104d4:	d107      	bne.n	104e6 <extint_chan_disable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
   104d6:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
   104d8:	281f      	cmp	r0, #31
   104da:	d800      	bhi.n	104de <extint_chan_disable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
   104dc:	4a03      	ldr	r2, [pc, #12]	; (104ec <extint_chan_disable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENCLR.reg = (1UL << channel);
   104de:	2301      	movs	r3, #1
   104e0:	4083      	lsls	r3, r0
   104e2:	6093      	str	r3, [r2, #8]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   104e4:	2300      	movs	r3, #0
}
   104e6:	1c18      	adds	r0, r3, #0
   104e8:	4770      	bx	lr
   104ea:	46c0      	nop			; (mov r8, r8)
   104ec:	40001800 	.word	0x40001800

000104f0 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
   104f0:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   104f2:	2200      	movs	r2, #0
   104f4:	4b15      	ldr	r3, [pc, #84]	; (1054c <EIC_Handler+0x5c>)
   104f6:	701a      	strb	r2, [r3, #0]
   104f8:	2300      	movs	r3, #0
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
   104fa:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
   104fc:	4e14      	ldr	r6, [pc, #80]	; (10550 <EIC_Handler+0x60>)

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   104fe:	4c13      	ldr	r4, [pc, #76]	; (1054c <EIC_Handler+0x5c>)
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
   10500:	2b1f      	cmp	r3, #31
   10502:	d919      	bls.n	10538 <EIC_Handler+0x48>
   10504:	e00f      	b.n	10526 <EIC_Handler+0x36>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
   10506:	2100      	movs	r1, #0
   10508:	e000      	b.n	1050c <EIC_Handler+0x1c>

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
   1050a:	4912      	ldr	r1, [pc, #72]	; (10554 <EIC_Handler+0x64>)
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
   1050c:	610a      	str	r2, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
   1050e:	009b      	lsls	r3, r3, #2
   10510:	599b      	ldr	r3, [r3, r6]
   10512:	2b00      	cmp	r3, #0
   10514:	d000      	beq.n	10518 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
   10516:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   10518:	7823      	ldrb	r3, [r4, #0]
   1051a:	3301      	adds	r3, #1
   1051c:	b2db      	uxtb	r3, r3
   1051e:	7023      	strb	r3, [r4, #0]
   10520:	2b0f      	cmp	r3, #15
   10522:	d9ed      	bls.n	10500 <EIC_Handler+0x10>
   10524:	e011      	b.n	1054a <EIC_Handler+0x5a>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
   10526:	1c29      	adds	r1, r5, #0
   10528:	4019      	ands	r1, r3
   1052a:	2201      	movs	r2, #1
   1052c:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
   1052e:	2100      	movs	r1, #0
   10530:	6909      	ldr	r1, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
   10532:	4211      	tst	r1, r2
   10534:	d1e7      	bne.n	10506 <EIC_Handler+0x16>
   10536:	e7ef      	b.n	10518 <EIC_Handler+0x28>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
   10538:	1c29      	adds	r1, r5, #0
   1053a:	4019      	ands	r1, r3
   1053c:	2201      	movs	r2, #1
   1053e:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
   10540:	4904      	ldr	r1, [pc, #16]	; (10554 <EIC_Handler+0x64>)
   10542:	6909      	ldr	r1, [r1, #16]
   10544:	4211      	tst	r1, r2
   10546:	d1e0      	bne.n	1050a <EIC_Handler+0x1a>
   10548:	e7e6      	b.n	10518 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
   1054a:	bd70      	pop	{r4, r5, r6, pc}
   1054c:	20002b34 	.word	0x20002b34
   10550:	20002acc 	.word	0x20002acc
   10554:	40001800 	.word	0x40001800

00010558 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
   10558:	b510      	push	{r4, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
   1055a:	2000      	movs	r0, #0
   1055c:	4b08      	ldr	r3, [pc, #32]	; (10580 <delay_init+0x28>)
   1055e:	4798      	blx	r3
	cycles_per_ms /= 1000;
   10560:	4c08      	ldr	r4, [pc, #32]	; (10584 <delay_init+0x2c>)
   10562:	21fa      	movs	r1, #250	; 0xfa
   10564:	0089      	lsls	r1, r1, #2
   10566:	47a0      	blx	r4
   10568:	4b07      	ldr	r3, [pc, #28]	; (10588 <delay_init+0x30>)
   1056a:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
   1056c:	21fa      	movs	r1, #250	; 0xfa
   1056e:	0089      	lsls	r1, r1, #2
   10570:	47a0      	blx	r4
   10572:	4b06      	ldr	r3, [pc, #24]	; (1058c <delay_init+0x34>)
   10574:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
   10576:	2205      	movs	r2, #5
   10578:	4b05      	ldr	r3, [pc, #20]	; (10590 <delay_init+0x38>)
   1057a:	601a      	str	r2, [r3, #0]
}
   1057c:	bd10      	pop	{r4, pc}
   1057e:	46c0      	nop			; (mov r8, r8)
   10580:	00013815 	.word	0x00013815
   10584:	00014e9d 	.word	0x00014e9d
   10588:	20000264 	.word	0x20000264
   1058c:	20000260 	.word	0x20000260
   10590:	e000e010 	.word	0xe000e010

00010594 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
   10594:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
   10596:	4b08      	ldr	r3, [pc, #32]	; (105b8 <delay_cycles_ms+0x24>)
   10598:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
   1059a:	4a08      	ldr	r2, [pc, #32]	; (105bc <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
   1059c:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
   1059e:	2180      	movs	r1, #128	; 0x80
   105a0:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
   105a2:	e006      	b.n	105b2 <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
   105a4:	2c00      	cmp	r4, #0
   105a6:	d004      	beq.n	105b2 <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
   105a8:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
   105aa:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
   105ac:	6813      	ldr	r3, [r2, #0]
   105ae:	420b      	tst	r3, r1
   105b0:	d0fc      	beq.n	105ac <delay_cycles_ms+0x18>
   105b2:	3801      	subs	r0, #1
   105b4:	d2f6      	bcs.n	105a4 <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
   105b6:	bd30      	pop	{r4, r5, pc}
   105b8:	20000264 	.word	0x20000264
   105bc:	e000e010 	.word	0xe000e010

000105c0 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
   105c0:	b508      	push	{r3, lr}
	if (gpfIsr) {
   105c2:	4b03      	ldr	r3, [pc, #12]	; (105d0 <chip_isr+0x10>)
   105c4:	681b      	ldr	r3, [r3, #0]
   105c6:	2b00      	cmp	r3, #0
   105c8:	d000      	beq.n	105cc <chip_isr+0xc>
		gpfIsr();
   105ca:	4798      	blx	r3
	}
}
   105cc:	bd08      	pop	{r3, pc}
   105ce:	46c0      	nop			; (mov r8, r8)
   105d0:	200012e8 	.word	0x200012e8

000105d4 <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
   105d4:	b538      	push	{r3, r4, r5, lr}
	while (u32TimeMsec--) {
   105d6:	2800      	cmp	r0, #0
   105d8:	d006      	beq.n	105e8 <nm_bsp_sleep+0x14>
   105da:	1c04      	adds	r4, r0, #0
		delay_ms(1);
   105dc:	4d03      	ldr	r5, [pc, #12]	; (105ec <nm_bsp_sleep+0x18>)
   105de:	2001      	movs	r0, #1
   105e0:	47a8      	blx	r5
   105e2:	3c01      	subs	r4, #1
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
   105e4:	2c00      	cmp	r4, #0
   105e6:	d1fa      	bne.n	105de <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
   105e8:	bd38      	pop	{r3, r4, r5, pc}
   105ea:	46c0      	nop			; (mov r8, r8)
   105ec:	00010595 	.word	0x00010595

000105f0 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
   105f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	} else {
		port_base->OUTCLR.reg = pin_mask;
   105f2:	4c07      	ldr	r4, [pc, #28]	; (10610 <nm_bsp_reset+0x20>)
   105f4:	2720      	movs	r7, #32
   105f6:	6167      	str	r7, [r4, #20]
   105f8:	2640      	movs	r6, #64	; 0x40
   105fa:	6166      	str	r6, [r4, #20]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
	nm_bsp_sleep(100);
   105fc:	2064      	movs	r0, #100	; 0x64
   105fe:	4d05      	ldr	r5, [pc, #20]	; (10614 <nm_bsp_reset+0x24>)
   10600:	47a8      	blx	r5
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
   10602:	61a7      	str	r7, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
	nm_bsp_sleep(10);
   10604:	200a      	movs	r0, #10
   10606:	47a8      	blx	r5
   10608:	61a6      	str	r6, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
	nm_bsp_sleep(10);
   1060a:	200a      	movs	r0, #10
   1060c:	47a8      	blx	r5
}
   1060e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10610:	41004480 	.word	0x41004480
   10614:	000105d5 	.word	0x000105d5

00010618 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
   10618:	b570      	push	{r4, r5, r6, lr}
   1061a:	b082      	sub	sp, #8
	gpfIsr = NULL;
   1061c:	2300      	movs	r3, #0
   1061e:	4a13      	ldr	r2, [pc, #76]	; (1066c <nm_bsp_init+0x54>)
   10620:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
   10622:	ac01      	add	r4, sp, #4
   10624:	2501      	movs	r5, #1
   10626:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
   10628:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   1062a:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
   1062c:	2026      	movs	r0, #38	; 0x26
   1062e:	1c21      	adds	r1, r4, #0
   10630:	4e0f      	ldr	r6, [pc, #60]	; (10670 <nm_bsp_init+0x58>)
   10632:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
   10634:	2025      	movs	r0, #37	; 0x25
   10636:	1c21      	adds	r1, r4, #0
   10638:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
   1063a:	2027      	movs	r0, #39	; 0x27
   1063c:	1c21      	adds	r1, r4, #0
   1063e:	47b0      	blx	r6

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
   10640:	4b0c      	ldr	r3, [pc, #48]	; (10674 <nm_bsp_init+0x5c>)
   10642:	681b      	ldr	r3, [r3, #0]
   10644:	421d      	tst	r5, r3
   10646:	d003      	beq.n	10650 <nm_bsp_init+0x38>
   10648:	4b0a      	ldr	r3, [pc, #40]	; (10674 <nm_bsp_init+0x5c>)
   1064a:	681b      	ldr	r3, [r3, #0]
   1064c:	079b      	lsls	r3, r3, #30
   1064e:	d401      	bmi.n	10654 <nm_bsp_init+0x3c>
	    delay_init();
   10650:	4b09      	ldr	r3, [pc, #36]	; (10678 <nm_bsp_init+0x60>)
   10652:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
   10654:	4b09      	ldr	r3, [pc, #36]	; (1067c <nm_bsp_init+0x64>)
   10656:	4798      	blx	r3
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
   10658:	2201      	movs	r2, #1
   1065a:	4b09      	ldr	r3, [pc, #36]	; (10680 <nm_bsp_init+0x68>)
   1065c:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   1065e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   10662:	b662      	cpsie	i

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
   10664:	2000      	movs	r0, #0
   10666:	b002      	add	sp, #8
   10668:	bd70      	pop	{r4, r5, r6, pc}
   1066a:	46c0      	nop			; (mov r8, r8)
   1066c:	200012e8 	.word	0x200012e8
   10670:	000131a9 	.word	0x000131a9
   10674:	e000e010 	.word	0xe000e010
   10678:	00010559 	.word	0x00010559
   1067c:	000105f1 	.word	0x000105f1
   10680:	20000270 	.word	0x20000270

00010684 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
   10684:	b510      	push	{r4, lr}
   10686:	b084      	sub	sp, #16
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
   10688:	4b0e      	ldr	r3, [pc, #56]	; (106c4 <nm_bsp_register_isr+0x40>)
   1068a:	6018      	str	r0, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
   1068c:	ac01      	add	r4, sp, #4
   1068e:	1c20      	adds	r0, r4, #0
   10690:	4b0d      	ldr	r3, [pc, #52]	; (106c8 <nm_bsp_register_isr+0x44>)
   10692:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
   10694:	2324      	movs	r3, #36	; 0x24
   10696:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
   10698:	2300      	movs	r3, #0
   1069a:	6063      	str	r3, [r4, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
   1069c:	3301      	adds	r3, #1
   1069e:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
   106a0:	3301      	adds	r3, #1
   106a2:	72e3      	strb	r3, [r4, #11]

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
   106a4:	2004      	movs	r0, #4
   106a6:	1c21      	adds	r1, r4, #0
   106a8:	4b08      	ldr	r3, [pc, #32]	; (106cc <nm_bsp_register_isr+0x48>)
   106aa:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
   106ac:	4808      	ldr	r0, [pc, #32]	; (106d0 <nm_bsp_register_isr+0x4c>)
   106ae:	2104      	movs	r1, #4
   106b0:	2200      	movs	r2, #0
   106b2:	4b08      	ldr	r3, [pc, #32]	; (106d4 <nm_bsp_register_isr+0x50>)
   106b4:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
   106b6:	2004      	movs	r0, #4
   106b8:	2100      	movs	r1, #0
   106ba:	4b07      	ldr	r3, [pc, #28]	; (106d8 <nm_bsp_register_isr+0x54>)
   106bc:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
   106be:	b004      	add	sp, #16
   106c0:	bd10      	pop	{r4, pc}
   106c2:	46c0      	nop			; (mov r8, r8)
   106c4:	200012e8 	.word	0x200012e8
   106c8:	0000f2d5 	.word	0x0000f2d5
   106cc:	0000f2e9 	.word	0x0000f2e9
   106d0:	000105c1 	.word	0x000105c1
   106d4:	00010485 	.word	0x00010485
   106d8:	000104b1 	.word	0x000104b1

000106dc <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
   106dc:	b508      	push	{r3, lr}
	if (u8Enable) {
   106de:	2800      	cmp	r0, #0
   106e0:	d004      	beq.n	106ec <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
   106e2:	2004      	movs	r0, #4
   106e4:	2100      	movs	r1, #0
   106e6:	4b04      	ldr	r3, [pc, #16]	; (106f8 <nm_bsp_interrupt_ctrl+0x1c>)
   106e8:	4798      	blx	r3
   106ea:	e003      	b.n	106f4 <nm_bsp_interrupt_ctrl+0x18>
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
   106ec:	2004      	movs	r0, #4
   106ee:	2100      	movs	r1, #0
   106f0:	4b02      	ldr	r3, [pc, #8]	; (106fc <nm_bsp_interrupt_ctrl+0x20>)
   106f2:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
   106f4:	bd08      	pop	{r3, pc}
   106f6:	46c0      	nop			; (mov r8, r8)
   106f8:	000104b1 	.word	0x000104b1
   106fc:	000104d1 	.word	0x000104d1

00010700 <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
   10700:	b530      	push	{r4, r5, lr}
   10702:	b091      	sub	sp, #68	; 0x44
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
   10704:	4c2f      	ldr	r4, [pc, #188]	; (107c4 <nm_bus_init+0xc4>)
   10706:	2305      	movs	r3, #5
   10708:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
   1070a:	2300      	movs	r3, #0
   1070c:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
   1070e:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
   10710:	a901      	add	r1, sp, #4
   10712:	2201      	movs	r2, #1
   10714:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
   10716:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
   10718:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
   1071a:	2005      	movs	r0, #5
   1071c:	4b2a      	ldr	r3, [pc, #168]	; (107c8 <nm_bus_init+0xc8>)
   1071e:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
   10720:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10722:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   10724:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   10726:	2900      	cmp	r1, #0
   10728:	d104      	bne.n	10734 <nm_bus_init+0x34>
		return &(ports[port_index]->Group[group_index]);
   1072a:	095a      	lsrs	r2, r3, #5
   1072c:	01d2      	lsls	r2, r2, #7
   1072e:	4927      	ldr	r1, [pc, #156]	; (107cc <nm_bus_init+0xcc>)
   10730:	468c      	mov	ip, r1
   10732:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   10734:	211f      	movs	r1, #31
   10736:	400b      	ands	r3, r1
   10738:	391e      	subs	r1, #30
   1073a:	1c08      	adds	r0, r1, #0
   1073c:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
   1073e:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
   10740:	aa02      	add	r2, sp, #8
   10742:	7011      	strb	r1, [r2, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
   10744:	2300      	movs	r3, #0
   10746:	6053      	str	r3, [r2, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
   10748:	6093      	str	r3, [r2, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
   1074a:	7413      	strb	r3, [r2, #16]
	config->run_in_standby   = false;
   1074c:	7453      	strb	r3, [r2, #17]
	config->receiver_enable  = true;
   1074e:	7491      	strb	r1, [r2, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
   10750:	74d1      	strb	r1, [r2, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
   10752:	7513      	strb	r3, [r2, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
   10754:	3123      	adds	r1, #35	; 0x23
   10756:	5453      	strb	r3, [r2, r1]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   10758:	9309      	str	r3, [sp, #36]	; 0x24
   1075a:	930a      	str	r3, [sp, #40]	; 0x28
	slave_config.ss_pin = CONF_WINC_SPI_CS_PIN;
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
   1075c:	2380      	movs	r3, #128	; 0x80
   1075e:	025b      	lsls	r3, r3, #9
   10760:	60d3      	str	r3, [r2, #12]
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
   10762:	4b1b      	ldr	r3, [pc, #108]	; (107d0 <nm_bus_init+0xd0>)
   10764:	6293      	str	r3, [r2, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
   10766:	2301      	movs	r3, #1
   10768:	425b      	negs	r3, r3
   1076a:	62d3      	str	r3, [r2, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
   1076c:	4b19      	ldr	r3, [pc, #100]	; (107d4 <nm_bus_init+0xd4>)
   1076e:	6313      	str	r3, [r2, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
   10770:	4b19      	ldr	r3, [pc, #100]	; (107d8 <nm_bus_init+0xd8>)
   10772:	6353      	str	r3, [r2, #52]	; 0x34
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
   10774:	4b19      	ldr	r3, [pc, #100]	; (107dc <nm_bus_init+0xdc>)
   10776:	6193      	str	r3, [r2, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   10778:	4819      	ldr	r0, [pc, #100]	; (107e0 <nm_bus_init+0xe0>)
   1077a:	491a      	ldr	r1, [pc, #104]	; (107e4 <nm_bus_init+0xe4>)
   1077c:	4b1a      	ldr	r3, [pc, #104]	; (107e8 <nm_bus_init+0xe8>)
   1077e:	4798      	blx	r3
   10780:	2800      	cmp	r0, #0
   10782:	d11a      	bne.n	107ba <nm_bus_init+0xba>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   10784:	4d16      	ldr	r5, [pc, #88]	; (107e0 <nm_bus_init+0xe0>)
   10786:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   10788:	1c20      	adds	r0, r4, #0
   1078a:	4b18      	ldr	r3, [pc, #96]	; (107ec <nm_bus_init+0xec>)
   1078c:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1078e:	231f      	movs	r3, #31
   10790:	4018      	ands	r0, r3
   10792:	3b1e      	subs	r3, #30
   10794:	4083      	lsls	r3, r0
   10796:	1c18      	adds	r0, r3, #0
   10798:	4b15      	ldr	r3, [pc, #84]	; (107f0 <nm_bus_init+0xf0>)
   1079a:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1079c:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
   1079e:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
   107a0:	2b00      	cmp	r3, #0
   107a2:	d1fc      	bne.n	1079e <nm_bus_init+0x9e>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   107a4:	6822      	ldr	r2, [r4, #0]
   107a6:	3302      	adds	r3, #2
   107a8:	4313      	orrs	r3, r2
   107aa:	6023      	str	r3, [r4, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
   107ac:	4b11      	ldr	r3, [pc, #68]	; (107f4 <nm_bus_init+0xf4>)
   107ae:	4798      	blx	r3
	nm_bsp_sleep(1);
   107b0:	2001      	movs	r0, #1
   107b2:	4b11      	ldr	r3, [pc, #68]	; (107f8 <nm_bus_init+0xf8>)
   107b4:	4798      	blx	r3
#endif
	return result;
   107b6:	2000      	movs	r0, #0
   107b8:	e000      	b.n	107bc <nm_bus_init+0xbc>
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
		return M2M_ERR_BUS_FAIL;
   107ba:	20fa      	movs	r0, #250	; 0xfa
   107bc:	b240      	sxtb	r0, r0

	nm_bsp_reset();
	nm_bsp_sleep(1);
#endif
	return result;
}
   107be:	b011      	add	sp, #68	; 0x44
   107c0:	bd30      	pop	{r4, r5, pc}
   107c2:	46c0      	nop			; (mov r8, r8)
   107c4:	20002b38 	.word	0x20002b38
   107c8:	000131a9 	.word	0x000131a9
   107cc:	41004400 	.word	0x41004400
   107d0:	00040003 	.word	0x00040003
   107d4:	00060003 	.word	0x00060003
   107d8:	00070003 	.word	0x00070003
   107dc:	00b71b00 	.word	0x00b71b00
   107e0:	20002b3c 	.word	0x20002b3c
   107e4:	42000800 	.word	0x42000800
   107e8:	0000feb9 	.word	0x0000feb9
   107ec:	000103f9 	.word	0x000103f9
   107f0:	e000e100 	.word	0xe000e100
   107f4:	000105f1 	.word	0x000105f1
   107f8:	000105d5 	.word	0x000105d5

000107fc <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
   107fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   107fe:	465f      	mov	r7, fp
   10800:	4656      	mov	r6, sl
   10802:	464d      	mov	r5, r9
   10804:	4644      	mov	r4, r8
   10806:	b4f0      	push	{r4, r5, r6, r7}
   10808:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
   1080a:	2803      	cmp	r0, #3
   1080c:	d169      	bne.n	108e2 <nm_bus_ioctl+0xe6>
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
   1080e:	680e      	ldr	r6, [r1, #0]
   10810:	684d      	ldr	r5, [r1, #4]
   10812:	890c      	ldrh	r4, [r1, #8]
struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
   10814:	2200      	movs	r2, #0
   10816:	ab02      	add	r3, sp, #8
   10818:	71da      	strb	r2, [r3, #7]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
   1081a:	2e00      	cmp	r6, #0
   1081c:	d008      	beq.n	10830 <nm_bus_ioctl+0x34>
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	else if(!pu8Miso) {
   1081e:	2d00      	cmp	r5, #0
   10820:	d15d      	bne.n	108de <nm_bus_ioctl+0xe2>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
   10822:	2301      	movs	r3, #1
   10824:	4699      	mov	r9, r3
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
   10826:	2300      	movs	r3, #0
   10828:	9301      	str	r3, [sp, #4]
	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	else if(!pu8Miso) {
		pu8Miso = &u8Dummy;
   1082a:	ab02      	add	r3, sp, #8
   1082c:	1ddd      	adds	r5, r3, #7
   1082e:	e005      	b.n	1083c <nm_bus_ioctl+0x40>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
   10830:	2300      	movs	r3, #0
   10832:	4699      	mov	r9, r3
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
   10834:	3301      	adds	r3, #1
   10836:	9301      	str	r3, [sp, #4]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
   10838:	ab02      	add	r3, sp, #8
   1083a:	1dde      	adds	r6, r3, #7
	}
	else {
		return M2M_ERR_BUS_FAIL;
	}

	spi_select_slave(&master, &slave_inst, true);
   1083c:	4833      	ldr	r0, [pc, #204]	; (1090c <nm_bus_ioctl+0x110>)
   1083e:	4934      	ldr	r1, [pc, #208]	; (10910 <nm_bus_ioctl+0x114>)
   10840:	2201      	movs	r2, #1
   10842:	4b34      	ldr	r3, [pc, #208]	; (10914 <nm_bus_ioctl+0x118>)
   10844:	4798      	blx	r3

	while (u16Sz) {
   10846:	2c00      	cmp	r4, #0
   10848:	d03c      	beq.n	108c4 <nm_bus_ioctl+0xc8>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1084a:	4b30      	ldr	r3, [pc, #192]	; (1090c <nm_bus_ioctl+0x110>)
   1084c:	469b      	mov	fp, r3

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1084e:	2701      	movs	r7, #1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   10850:	2204      	movs	r2, #4
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   10852:	469a      	mov	sl, r3

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   10854:	2304      	movs	r3, #4
   10856:	4698      	mov	r8, r3
			;
		*pu8Miso = rxd_data;

		u16Sz--;
		if (!u8SkipMiso)
			pu8Miso++;
   10858:	4649      	mov	r1, r9
   1085a:	424b      	negs	r3, r1
   1085c:	4159      	adcs	r1, r3
   1085e:	4689      	mov	r9, r1
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
		txd_data = *pu8Mosi;
   10860:	7830      	ldrb	r0, [r6, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   10862:	465b      	mov	r3, fp
   10864:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   10866:	7e19      	ldrb	r1, [r3, #24]
		while (!spi_is_ready_to_write(&master))
   10868:	4239      	tst	r1, r7
   1086a:	d0fc      	beq.n	10866 <nm_bus_ioctl+0x6a>
   1086c:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
   1086e:	4239      	tst	r1, r7
   10870:	d0fc      	beq.n	1086c <nm_bus_ioctl+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
   10872:	6298      	str	r0, [r3, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   10874:	7e19      	ldrb	r1, [r3, #24]
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
   10876:	4211      	tst	r1, r2
   10878:	d0fc      	beq.n	10874 <nm_bus_ioctl+0x78>
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1087a:	4651      	mov	r1, sl
   1087c:	7989      	ldrb	r1, [r1, #6]
   1087e:	468c      	mov	ip, r1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   10880:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
   10882:	4211      	tst	r1, r2
   10884:	d0fc      	beq.n	10880 <nm_bus_ioctl+0x84>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   10886:	8b59      	ldrh	r1, [r3, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
   10888:	2000      	movs	r0, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1088a:	4211      	tst	r1, r2
   1088c:	d005      	beq.n	1089a <nm_bus_ioctl+0x9e>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
   1088e:	8b59      	ldrh	r1, [r3, #26]
   10890:	4640      	mov	r0, r8
   10892:	4301      	orrs	r1, r0
   10894:	b289      	uxth	r1, r1
   10896:	8359      	strh	r1, [r3, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
   10898:	201e      	movs	r0, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1089a:	4661      	mov	r1, ip
   1089c:	2901      	cmp	r1, #1
   1089e:	d103      	bne.n	108a8 <nm_bus_ioctl+0xac>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   108a0:	6a99      	ldr	r1, [r3, #40]	; 0x28
   108a2:	05c9      	lsls	r1, r1, #23
   108a4:	0dc9      	lsrs	r1, r1, #23
   108a6:	e001      	b.n	108ac <nm_bus_ioctl+0xb0>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
   108a8:	6a99      	ldr	r1, [r3, #40]	; 0x28
   108aa:	b2c9      	uxtb	r1, r1
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
   108ac:	2800      	cmp	r0, #0
   108ae:	d1e7      	bne.n	10880 <nm_bus_ioctl+0x84>
			;
		*pu8Miso = rxd_data;
   108b0:	7029      	strb	r1, [r5, #0]

		u16Sz--;
   108b2:	3c01      	subs	r4, #1
   108b4:	b2a4      	uxth	r4, r4
		if (!u8SkipMiso)
			pu8Miso++;
   108b6:	444d      	add	r5, r9
		if (!u8SkipMosi)
			pu8Mosi++;
   108b8:	9b01      	ldr	r3, [sp, #4]
   108ba:	4259      	negs	r1, r3
   108bc:	414b      	adcs	r3, r1
   108be:	18f6      	adds	r6, r6, r3
		return M2M_ERR_BUS_FAIL;
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
   108c0:	2c00      	cmp	r4, #0
   108c2:	d1cd      	bne.n	10860 <nm_bus_ioctl+0x64>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   108c4:	4b11      	ldr	r3, [pc, #68]	; (1090c <nm_bus_ioctl+0x110>)
   108c6:	6819      	ldr	r1, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
   108c8:	2202      	movs	r2, #2
   108ca:	7e0b      	ldrb	r3, [r1, #24]
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
   108cc:	4213      	tst	r3, r2
   108ce:	d0fc      	beq.n	108ca <nm_bus_ioctl+0xce>
		;

	spi_select_slave(&master, &slave_inst, false);
   108d0:	480e      	ldr	r0, [pc, #56]	; (1090c <nm_bus_ioctl+0x110>)
   108d2:	490f      	ldr	r1, [pc, #60]	; (10910 <nm_bus_ioctl+0x114>)
   108d4:	2200      	movs	r2, #0
   108d6:	4b0f      	ldr	r3, [pc, #60]	; (10914 <nm_bus_ioctl+0x118>)
   108d8:	4798      	blx	r3

	return M2M_SUCCESS;
   108da:	2000      	movs	r0, #0
   108dc:	e00e      	b.n	108fc <nm_bus_ioctl+0x100>
	else if(!pu8Miso) {
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
	}
	else {
		return M2M_ERR_BUS_FAIL;
   108de:	20fa      	movs	r0, #250	; 0xfa
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
   108e0:	e00c      	b.n	108fc <nm_bus_ioctl+0x100>
#endif
		default:
			s8Ret = -1;
			M2M_ERR("invalide ioclt cmd\n");
   108e2:	480d      	ldr	r0, [pc, #52]	; (10918 <nm_bus_ioctl+0x11c>)
   108e4:	490d      	ldr	r1, [pc, #52]	; (1091c <nm_bus_ioctl+0x120>)
   108e6:	2286      	movs	r2, #134	; 0x86
   108e8:	0052      	lsls	r2, r2, #1
   108ea:	4b0d      	ldr	r3, [pc, #52]	; (10920 <nm_bus_ioctl+0x124>)
   108ec:	4798      	blx	r3
   108ee:	480d      	ldr	r0, [pc, #52]	; (10924 <nm_bus_ioctl+0x128>)
   108f0:	4b0d      	ldr	r3, [pc, #52]	; (10928 <nm_bus_ioctl+0x12c>)
   108f2:	4798      	blx	r3
   108f4:	200d      	movs	r0, #13
   108f6:	4b0d      	ldr	r3, [pc, #52]	; (1092c <nm_bus_ioctl+0x130>)
   108f8:	4798      	blx	r3
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
#endif
		default:
			s8Ret = -1;
   108fa:	20ff      	movs	r0, #255	; 0xff
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
   108fc:	b240      	sxtb	r0, r0
}
   108fe:	b005      	add	sp, #20
   10900:	bc3c      	pop	{r2, r3, r4, r5}
   10902:	4690      	mov	r8, r2
   10904:	4699      	mov	r9, r3
   10906:	46a2      	mov	sl, r4
   10908:	46ab      	mov	fp, r5
   1090a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1090c:	20002b3c 	.word	0x20002b3c
   10910:	20002b38 	.word	0x20002b38
   10914:	000100c9 	.word	0x000100c9
   10918:	000203ec 	.word	0x000203ec
   1091c:	00020414 	.word	0x00020414
   10920:	00016e3d 	.word	0x00016e3d
   10924:	00020400 	.word	0x00020400
   10928:	00016f5d 	.word	0x00016f5d
   1092c:	00016e71 	.word	0x00016e71

00010930 <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
   10930:	b538      	push	{r3, r4, r5, lr}
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   10932:	4d0b      	ldr	r5, [pc, #44]	; (10960 <nm_bus_deinit+0x30>)
   10934:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   10936:	1c20      	adds	r0, r4, #0
   10938:	4b0a      	ldr	r3, [pc, #40]	; (10964 <nm_bus_deinit+0x34>)
   1093a:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1093c:	231f      	movs	r3, #31
   1093e:	4018      	ands	r0, r3
   10940:	3b1e      	subs	r3, #30
   10942:	4083      	lsls	r3, r0
   10944:	1c18      	adds	r0, r3, #0
   10946:	2380      	movs	r3, #128	; 0x80
   10948:	4a07      	ldr	r2, [pc, #28]	; (10968 <nm_bus_deinit+0x38>)
   1094a:	50d0      	str	r0, [r2, r3]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   1094c:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
   1094e:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
   10950:	2b00      	cmp	r3, #0
   10952:	d1fc      	bne.n	1094e <nm_bus_deinit+0x1e>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   10954:	6823      	ldr	r3, [r4, #0]
   10956:	2202      	movs	r2, #2
   10958:	4393      	bics	r3, r2
   1095a:	6023      	str	r3, [r4, #0]
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);
#endif /* CONF_WINC_USE_SPI */
	return result;
}
   1095c:	2000      	movs	r0, #0
   1095e:	bd38      	pop	{r3, r4, r5, pc}
   10960:	20002b3c 	.word	0x20002b3c
   10964:	000103f9 	.word	0x000103f9
   10968:	e000e100 	.word	0xe000e100

0001096c <m2m_memcpy>:
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
   1096c:	2a00      	cmp	r2, #0
   1096e:	d006      	beq.n	1097e <m2m_memcpy+0x12>
   10970:	1882      	adds	r2, r0, r2
	do
	{
		*pDst = *pSrc;
   10972:	780b      	ldrb	r3, [r1, #0]
   10974:	7003      	strb	r3, [r0, #0]
		pDst++;
   10976:	3001      	adds	r0, #1
		pSrc++;
   10978:	3101      	adds	r1, #1
	}while(--sz);
   1097a:	4290      	cmp	r0, r2
   1097c:	d1f9      	bne.n	10972 <m2m_memcpy+0x6>
}
   1097e:	4770      	bx	lr

00010980 <m2m_memset>:
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
   10980:	2a00      	cmp	r2, #0
   10982:	d004      	beq.n	1098e <m2m_memset+0xe>
   10984:	1882      	adds	r2, r0, r2
	do
	{
		*pBuf = val;
   10986:	7001      	strb	r1, [r0, #0]
		pBuf++;
   10988:	3001      	adds	r0, #1
	}while(--sz);
   1098a:	4290      	cmp	r0, r2
   1098c:	d1fb      	bne.n	10986 <m2m_memset+0x6>
}
   1098e:	4770      	bx	lr

00010990 <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
   10990:	1c03      	adds	r3, r0, #0
	uint16	u16StrLen = 0;
	while(*pcStr)
   10992:	7802      	ldrb	r2, [r0, #0]
   10994:	2a00      	cmp	r2, #0
   10996:	d007      	beq.n	109a8 <m2m_strlen+0x18>
   10998:	2000      	movs	r0, #0
	{
		u16StrLen ++;
   1099a:	3001      	adds	r0, #1
   1099c:	b280      	uxth	r0, r0
		pcStr++;
   1099e:	3301      	adds	r3, #1
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
   109a0:	781a      	ldrb	r2, [r3, #0]
   109a2:	2a00      	cmp	r2, #0
   109a4:	d1f9      	bne.n	1099a <m2m_strlen+0xa>
   109a6:	e000      	b.n	109aa <m2m_strlen+0x1a>
	}while(--sz);
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
   109a8:	2000      	movs	r0, #0
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
   109aa:	4770      	bx	lr

000109ac <isr>:
tpfHifCallBack pfOtaCb = NULL;		/*!< pointer to OTA call back function */
tpfHifCallBack pfHifCb = NULL;

static void isr(void)
{
	gu8Interrupt++;
   109ac:	4a02      	ldr	r2, [pc, #8]	; (109b8 <isr+0xc>)
   109ae:	7813      	ldrb	r3, [r2, #0]
   109b0:	3301      	adds	r3, #1
   109b2:	b2db      	uxtb	r3, r3
   109b4:	7013      	strb	r3, [r2, #0]
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
   109b6:	4770      	bx	lr
   109b8:	200012f0 	.word	0x200012f0

000109bc <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
   109bc:	4770      	bx	lr
   109be:	46c0      	nop			; (mov r8, r8)

000109c0 <hif_set_rx_done>:
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
static sint8 hif_set_rx_done(void)
{
   109c0:	b500      	push	{lr}
   109c2:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
   109c4:	2001      	movs	r0, #1
   109c6:	4b09      	ldr	r3, [pc, #36]	; (109ec <hif_set_rx_done+0x2c>)
   109c8:	4798      	blx	r3
#endif

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
   109ca:	4809      	ldr	r0, [pc, #36]	; (109f0 <hif_set_rx_done+0x30>)
   109cc:	a901      	add	r1, sp, #4
   109ce:	4b09      	ldr	r3, [pc, #36]	; (109f4 <hif_set_rx_done+0x34>)
   109d0:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   109d2:	2800      	cmp	r0, #0
   109d4:	d106      	bne.n	109e4 <hif_set_rx_done+0x24>
	//reg &= ~(1<<0);

	/* Set RX Done */
	reg |= (1<<1);
   109d6:	2102      	movs	r1, #2
   109d8:	9b01      	ldr	r3, [sp, #4]
   109da:	4319      	orrs	r1, r3
   109dc:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   109de:	4804      	ldr	r0, [pc, #16]	; (109f0 <hif_set_rx_done+0x30>)
   109e0:	4b05      	ldr	r3, [pc, #20]	; (109f8 <hif_set_rx_done+0x38>)
   109e2:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;
   109e4:	b240      	sxtb	r0, r0

}
   109e6:	b003      	add	sp, #12
   109e8:	bd00      	pop	{pc}
   109ea:	46c0      	nop			; (mov r8, r8)
   109ec:	000106dd 	.word	0x000106dd
   109f0:	00001070 	.word	0x00001070
   109f4:	00011b79 	.word	0x00011b79
   109f8:	00011b85 	.word	0x00011b85

000109fc <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
   109fc:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	if(gu8ChipSleep == 0)
   109fe:	4b0f      	ldr	r3, [pc, #60]	; (10a3c <hif_chip_wake+0x40>)
   10a00:	781b      	ldrb	r3, [r3, #0]
   10a02:	2b00      	cmp	r3, #0
   10a04:	d111      	bne.n	10a2a <hif_chip_wake+0x2e>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
   10a06:	4b0e      	ldr	r3, [pc, #56]	; (10a40 <hif_chip_wake+0x44>)
   10a08:	781b      	ldrb	r3, [r3, #0]
   10a0a:	2b03      	cmp	r3, #3
   10a0c:	d003      	beq.n	10a16 <hif_chip_wake+0x1a>
   10a0e:	4b0c      	ldr	r3, [pc, #48]	; (10a40 <hif_chip_wake+0x44>)
   10a10:	781b      	ldrb	r3, [r3, #0]
   10a12:	2b04      	cmp	r3, #4
   10a14:	d109      	bne.n	10a2a <hif_chip_wake+0x2e>
		{
			ret = nm_clkless_wake();
   10a16:	4b0b      	ldr	r3, [pc, #44]	; (10a44 <hif_chip_wake+0x48>)
   10a18:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
   10a1a:	2800      	cmp	r0, #0
   10a1c:	d10b      	bne.n	10a36 <hif_chip_wake+0x3a>
			ret = nm_write_reg(WAKE_REG, WAKE_VALUE);
   10a1e:	480a      	ldr	r0, [pc, #40]	; (10a48 <hif_chip_wake+0x4c>)
   10a20:	490a      	ldr	r1, [pc, #40]	; (10a4c <hif_chip_wake+0x50>)
   10a22:	4b0b      	ldr	r3, [pc, #44]	; (10a50 <hif_chip_wake+0x54>)
   10a24:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
   10a26:	2800      	cmp	r0, #0
   10a28:	d105      	bne.n	10a36 <hif_chip_wake+0x3a>
		}
		else
		{
		}
	}
	gu8ChipSleep++;
   10a2a:	4a04      	ldr	r2, [pc, #16]	; (10a3c <hif_chip_wake+0x40>)
   10a2c:	7813      	ldrb	r3, [r2, #0]
   10a2e:	3301      	adds	r3, #1
   10a30:	b2db      	uxtb	r3, r3
   10a32:	7013      	strb	r3, [r2, #0]
   10a34:	2000      	movs	r0, #0
ERR1:
	return ret;
   10a36:	b240      	sxtb	r0, r0
}
   10a38:	bd08      	pop	{r3, pc}
   10a3a:	46c0      	nop			; (mov r8, r8)
   10a3c:	20001308 	.word	0x20001308
   10a40:	200012f8 	.word	0x200012f8
   10a44:	000116e5 	.word	0x000116e5
   10a48:	00001074 	.word	0x00001074
   10a4c:	00005678 	.word	0x00005678
   10a50:	00011b85 	.word	0x00011b85

00010a54 <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
   10a54:	b500      	push	{lr}
   10a56:	b083      	sub	sp, #12
	sint8 ret = M2M_SUCCESS;

	if(gu8ChipSleep >= 1)
   10a58:	4b17      	ldr	r3, [pc, #92]	; (10ab8 <hif_chip_sleep+0x64>)
   10a5a:	781b      	ldrb	r3, [r3, #0]
   10a5c:	2b00      	cmp	r3, #0
   10a5e:	d004      	beq.n	10a6a <hif_chip_sleep+0x16>
	{
		gu8ChipSleep--;
   10a60:	4a15      	ldr	r2, [pc, #84]	; (10ab8 <hif_chip_sleep+0x64>)
   10a62:	7813      	ldrb	r3, [r2, #0]
   10a64:	3b01      	subs	r3, #1
   10a66:	b2db      	uxtb	r3, r3
   10a68:	7013      	strb	r3, [r2, #0]
	}

	if(gu8ChipSleep == 0)
   10a6a:	4b13      	ldr	r3, [pc, #76]	; (10ab8 <hif_chip_sleep+0x64>)
   10a6c:	781b      	ldrb	r3, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
	sint8 ret = M2M_SUCCESS;
   10a6e:	2000      	movs	r0, #0
	if(gu8ChipSleep >= 1)
	{
		gu8ChipSleep--;
	}

	if(gu8ChipSleep == 0)
   10a70:	2b00      	cmp	r3, #0
   10a72:	d11e      	bne.n	10ab2 <hif_chip_sleep+0x5e>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
   10a74:	4b11      	ldr	r3, [pc, #68]	; (10abc <hif_chip_sleep+0x68>)
   10a76:	781b      	ldrb	r3, [r3, #0]
   10a78:	2b03      	cmp	r3, #3
   10a7a:	d003      	beq.n	10a84 <hif_chip_sleep+0x30>
   10a7c:	4b0f      	ldr	r3, [pc, #60]	; (10abc <hif_chip_sleep+0x68>)
   10a7e:	781b      	ldrb	r3, [r3, #0]
   10a80:	2b04      	cmp	r3, #4
   10a82:	d116      	bne.n	10ab2 <hif_chip_sleep+0x5e>
		{
			uint32 reg = 0;
   10a84:	2300      	movs	r3, #0
   10a86:	9301      	str	r3, [sp, #4]
			ret = nm_write_reg(WAKE_REG, SLEEP_VALUE);
   10a88:	480d      	ldr	r0, [pc, #52]	; (10ac0 <hif_chip_sleep+0x6c>)
   10a8a:	490e      	ldr	r1, [pc, #56]	; (10ac4 <hif_chip_sleep+0x70>)
   10a8c:	4b0e      	ldr	r3, [pc, #56]	; (10ac8 <hif_chip_sleep+0x74>)
   10a8e:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
   10a90:	2800      	cmp	r0, #0
   10a92:	d10e      	bne.n	10ab2 <hif_chip_sleep+0x5e>
			/* Clear bit 1 */
			ret = nm_read_reg_with_ret(0x1, &reg);
   10a94:	3001      	adds	r0, #1
   10a96:	a901      	add	r1, sp, #4
   10a98:	4b0c      	ldr	r3, [pc, #48]	; (10acc <hif_chip_sleep+0x78>)
   10a9a:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
   10a9c:	2800      	cmp	r0, #0
   10a9e:	d108      	bne.n	10ab2 <hif_chip_sleep+0x5e>
			if(reg&0x2)
   10aa0:	9901      	ldr	r1, [sp, #4]
   10aa2:	078b      	lsls	r3, r1, #30
   10aa4:	d505      	bpl.n	10ab2 <hif_chip_sleep+0x5e>
			{
				reg &=~(1 << 1);
   10aa6:	2302      	movs	r3, #2
   10aa8:	4399      	bics	r1, r3
   10aaa:	9101      	str	r1, [sp, #4]
				ret = nm_write_reg(0x1, reg);
   10aac:	3001      	adds	r0, #1
   10aae:	4b06      	ldr	r3, [pc, #24]	; (10ac8 <hif_chip_sleep+0x74>)
   10ab0:	4798      	blx	r3
		else
		{
		}
	}
ERR1:
	return ret;
   10ab2:	b240      	sxtb	r0, r0
}
   10ab4:	b003      	add	sp, #12
   10ab6:	bd00      	pop	{pc}
   10ab8:	20001308 	.word	0x20001308
   10abc:	200012f8 	.word	0x200012f8
   10ac0:	00001074 	.word	0x00001074
   10ac4:	00004321 	.word	0x00004321
   10ac8:	00011b85 	.word	0x00011b85
   10acc:	00011b79 	.word	0x00011b79

00010ad0 <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
   10ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
   10ad2:	465f      	mov	r7, fp
   10ad4:	4656      	mov	r6, sl
   10ad6:	b4c0      	push	{r6, r7}
   10ad8:	b089      	sub	sp, #36	; 0x24
   10ada:	4683      	mov	fp, r0
   10adc:	468a      	mov	sl, r1
   10ade:	9201      	str	r2, [sp, #4]
   10ae0:	9300      	str	r3, [sp, #0]
   10ae2:	ab10      	add	r3, sp, #64	; 0x40
   10ae4:	cb80      	ldmia	r3!, {r7}
   10ae6:	881e      	ldrh	r6, [r3, #0]
   10ae8:	ab12      	add	r3, sp, #72	; 0x48
   10aea:	881d      	ldrh	r5, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
   10aec:	227f      	movs	r2, #127	; 0x7f
   10aee:	400a      	ands	r2, r1
   10af0:	ab07      	add	r3, sp, #28
   10af2:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
   10af4:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
   10af6:	2208      	movs	r2, #8
   10af8:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
   10afa:	2f00      	cmp	r7, #0
   10afc:	d005      	beq.n	10b0a <hif_send+0x3a>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
   10afe:	885a      	ldrh	r2, [r3, #2]
   10b00:	1992      	adds	r2, r2, r6
   10b02:	18aa      	adds	r2, r5, r2
   10b04:	b292      	uxth	r2, r2
   10b06:	805a      	strh	r2, [r3, #2]
   10b08:	e006      	b.n	10b18 <hif_send+0x48>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
   10b0a:	ab07      	add	r3, sp, #28
   10b0c:	885a      	ldrh	r2, [r3, #2]
   10b0e:	9900      	ldr	r1, [sp, #0]
   10b10:	468c      	mov	ip, r1
   10b12:	4462      	add	r2, ip
   10b14:	b292      	uxth	r2, r2
   10b16:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
   10b18:	4b55      	ldr	r3, [pc, #340]	; (10c70 <hif_send+0x1a0>)
   10b1a:	4798      	blx	r3
   10b1c:	1e04      	subs	r4, r0, #0
	if(ret == M2M_SUCCESS)
   10b1e:	d000      	beq.n	10b22 <hif_send+0x52>
   10b20:	e08e      	b.n	10c40 <hif_send+0x170>
	{
		volatile uint32 reg, dma_addr = 0;
   10b22:	2300      	movs	r3, #0
   10b24:	9305      	str	r3, [sp, #20]
		volatile uint16 cnt = 0;
   10b26:	aa02      	add	r2, sp, #8
   10b28:	80d3      	strh	r3, [r2, #6]

		reg = 0UL;
   10b2a:	9304      	str	r3, [sp, #16]
		reg |= (uint32)u8Gid;
   10b2c:	9b04      	ldr	r3, [sp, #16]
   10b2e:	465a      	mov	r2, fp
   10b30:	431a      	orrs	r2, r3
   10b32:	9204      	str	r2, [sp, #16]
		reg |= ((uint32)u8Opcode<<8);
   10b34:	9a04      	ldr	r2, [sp, #16]
   10b36:	4653      	mov	r3, sl
   10b38:	021b      	lsls	r3, r3, #8
   10b3a:	4313      	orrs	r3, r2
   10b3c:	9304      	str	r3, [sp, #16]
		reg |= ((uint32)strHif.u16Length<<16);
   10b3e:	ab07      	add	r3, sp, #28
   10b40:	885b      	ldrh	r3, [r3, #2]
   10b42:	9a04      	ldr	r2, [sp, #16]
   10b44:	041b      	lsls	r3, r3, #16
   10b46:	4313      	orrs	r3, r2
   10b48:	9304      	str	r3, [sp, #16]
		ret = nm_write_reg(NMI_STATE_REG,reg);
   10b4a:	9904      	ldr	r1, [sp, #16]
   10b4c:	4849      	ldr	r0, [pc, #292]	; (10c74 <hif_send+0x1a4>)
   10b4e:	4b4a      	ldr	r3, [pc, #296]	; (10c78 <hif_send+0x1a8>)
   10b50:	4798      	blx	r3
   10b52:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
   10b54:	d000      	beq.n	10b58 <hif_send+0x88>
   10b56:	e085      	b.n	10c64 <hif_send+0x194>


		reg = 0;
   10b58:	2300      	movs	r3, #0
   10b5a:	9304      	str	r3, [sp, #16]
		reg |= (1<<1);
   10b5c:	9a04      	ldr	r2, [sp, #16]
   10b5e:	3302      	adds	r3, #2
   10b60:	4313      	orrs	r3, r2
   10b62:	9304      	str	r3, [sp, #16]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
   10b64:	9904      	ldr	r1, [sp, #16]
   10b66:	4845      	ldr	r0, [pc, #276]	; (10c7c <hif_send+0x1ac>)
   10b68:	4b43      	ldr	r3, [pc, #268]	; (10c78 <hif_send+0x1a8>)
   10b6a:	4798      	blx	r3
   10b6c:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
   10b6e:	d000      	beq.n	10b72 <hif_send+0xa2>
   10b70:	e078      	b.n	10c64 <hif_send+0x194>
		dma_addr = 0;
   10b72:	2200      	movs	r2, #0
   10b74:	9205      	str	r2, [sp, #20]

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
   10b76:	ab02      	add	r3, sp, #8
   10b78:	80da      	strh	r2, [r3, #6]
   10b7a:	3306      	adds	r3, #6
   10b7c:	881b      	ldrh	r3, [r3, #0]
   10b7e:	b29b      	uxth	r3, r3
   10b80:	4a3f      	ldr	r2, [pc, #252]	; (10c80 <hif_send+0x1b0>)
   10b82:	4293      	cmp	r3, r2
   10b84:	d81c      	bhi.n	10bc0 <hif_send+0xf0>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
   10b86:	4c3f      	ldr	r4, [pc, #252]	; (10c84 <hif_send+0x1b4>)
   10b88:	483c      	ldr	r0, [pc, #240]	; (10c7c <hif_send+0x1ac>)
   10b8a:	a904      	add	r1, sp, #16
   10b8c:	47a0      	blx	r4
			if(ret != M2M_SUCCESS) break;
   10b8e:	2800      	cmp	r0, #0
   10b90:	d116      	bne.n	10bc0 <hif_send+0xf0>
			if (!(reg & 0x2))
   10b92:	9b04      	ldr	r3, [sp, #16]
   10b94:	079b      	lsls	r3, r3, #30
   10b96:	d408      	bmi.n	10baa <hif_send+0xda>
			{
				ret = nm_read_reg_with_ret(0x150400,(uint32 *)&dma_addr);
   10b98:	483b      	ldr	r0, [pc, #236]	; (10c88 <hif_send+0x1b8>)
   10b9a:	a905      	add	r1, sp, #20
   10b9c:	4b39      	ldr	r3, [pc, #228]	; (10c84 <hif_send+0x1b4>)
   10b9e:	4798      	blx	r3
				if(ret != M2M_SUCCESS) {
   10ba0:	2800      	cmp	r0, #0
   10ba2:	d00d      	beq.n	10bc0 <hif_send+0xf0>
					/*in case of read error clear the dma address and return error*/
					dma_addr = 0;
   10ba4:	2300      	movs	r3, #0
   10ba6:	9305      	str	r3, [sp, #20]
   10ba8:	e00a      	b.n	10bc0 <hif_send+0xf0>
		if(M2M_SUCCESS != ret) goto ERR1;
		dma_addr = 0;

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
   10baa:	ab02      	add	r3, sp, #8
   10bac:	88da      	ldrh	r2, [r3, #6]
   10bae:	3201      	adds	r2, #1
   10bb0:	b292      	uxth	r2, r2
   10bb2:	80da      	strh	r2, [r3, #6]
   10bb4:	3306      	adds	r3, #6
   10bb6:	881b      	ldrh	r3, [r3, #0]
   10bb8:	b29b      	uxth	r3, r3
   10bba:	4a31      	ldr	r2, [pc, #196]	; (10c80 <hif_send+0x1b0>)
   10bbc:	4293      	cmp	r3, r2
   10bbe:	d9e3      	bls.n	10b88 <hif_send+0xb8>
				break;
			}
		}
		//nm_bsp_interrupt_ctrl(1);

		if (dma_addr != 0)
   10bc0:	9b05      	ldr	r3, [sp, #20]
   10bc2:	2b00      	cmp	r3, #0
   10bc4:	d04d      	beq.n	10c62 <hif_send+0x192>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
   10bc6:	9b05      	ldr	r3, [sp, #20]
   10bc8:	9306      	str	r3, [sp, #24]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
   10bca:	a907      	add	r1, sp, #28
   10bcc:	884b      	ldrh	r3, [r1, #2]
   10bce:	b29b      	uxth	r3, r3
   10bd0:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
   10bd2:	9806      	ldr	r0, [sp, #24]
   10bd4:	2208      	movs	r2, #8
   10bd6:	4b2d      	ldr	r3, [pc, #180]	; (10c8c <hif_send+0x1bc>)
   10bd8:	4798      	blx	r3
   10bda:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
   10bdc:	d142      	bne.n	10c64 <hif_send+0x194>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
   10bde:	9b06      	ldr	r3, [sp, #24]
   10be0:	3308      	adds	r3, #8
   10be2:	9306      	str	r3, [sp, #24]
			if(pu8CtrlBuf != NULL)
   10be4:	9b01      	ldr	r3, [sp, #4]
   10be6:	2b00      	cmp	r3, #0
   10be8:	d00b      	beq.n	10c02 <hif_send+0x132>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
   10bea:	9806      	ldr	r0, [sp, #24]
   10bec:	1c19      	adds	r1, r3, #0
   10bee:	9a00      	ldr	r2, [sp, #0]
   10bf0:	4b26      	ldr	r3, [pc, #152]	; (10c8c <hif_send+0x1bc>)
   10bf2:	4798      	blx	r3
   10bf4:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
   10bf6:	d135      	bne.n	10c64 <hif_send+0x194>
				u32CurrAddr += u16CtrlBufSize;
   10bf8:	9b06      	ldr	r3, [sp, #24]
   10bfa:	9a00      	ldr	r2, [sp, #0]
   10bfc:	4694      	mov	ip, r2
   10bfe:	4463      	add	r3, ip
   10c00:	9306      	str	r3, [sp, #24]
			}
			if(pu8DataBuf != NULL)
   10c02:	2f00      	cmp	r7, #0
   10c04:	d00e      	beq.n	10c24 <hif_send+0x154>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
   10c06:	9b06      	ldr	r3, [sp, #24]
   10c08:	9a00      	ldr	r2, [sp, #0]
   10c0a:	1aad      	subs	r5, r5, r2
   10c0c:	18ed      	adds	r5, r5, r3
   10c0e:	9506      	str	r5, [sp, #24]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
   10c10:	9806      	ldr	r0, [sp, #24]
   10c12:	1c39      	adds	r1, r7, #0
   10c14:	1c32      	adds	r2, r6, #0
   10c16:	4b1d      	ldr	r3, [pc, #116]	; (10c8c <hif_send+0x1bc>)
   10c18:	4798      	blx	r3
   10c1a:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
   10c1c:	d122      	bne.n	10c64 <hif_send+0x194>
				u32CurrAddr += u16DataSize;
   10c1e:	9b06      	ldr	r3, [sp, #24]
   10c20:	18f3      	adds	r3, r6, r3
   10c22:	9306      	str	r3, [sp, #24]
			}

			reg = dma_addr << 2;
   10c24:	9b05      	ldr	r3, [sp, #20]
   10c26:	009b      	lsls	r3, r3, #2
   10c28:	9304      	str	r3, [sp, #16]
			reg |= (1 << 1);
   10c2a:	9a04      	ldr	r2, [sp, #16]
   10c2c:	2302      	movs	r3, #2
   10c2e:	4313      	orrs	r3, r2
   10c30:	9304      	str	r3, [sp, #16]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
   10c32:	9904      	ldr	r1, [sp, #16]
   10c34:	4816      	ldr	r0, [pc, #88]	; (10c90 <hif_send+0x1c0>)
   10c36:	4b10      	ldr	r3, [pc, #64]	; (10c78 <hif_send+0x1a8>)
   10c38:	4798      	blx	r3
   10c3a:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
   10c3c:	d112      	bne.n	10c64 <hif_send+0x194>
   10c3e:	e00c      	b.n	10c5a <hif_send+0x18a>
		}

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
   10c40:	4814      	ldr	r0, [pc, #80]	; (10c94 <hif_send+0x1c4>)
   10c42:	4915      	ldr	r1, [pc, #84]	; (10c98 <hif_send+0x1c8>)
   10c44:	22ca      	movs	r2, #202	; 0xca
   10c46:	0052      	lsls	r2, r2, #1
   10c48:	4b14      	ldr	r3, [pc, #80]	; (10c9c <hif_send+0x1cc>)
   10c4a:	4798      	blx	r3
   10c4c:	4814      	ldr	r0, [pc, #80]	; (10ca0 <hif_send+0x1d0>)
   10c4e:	4b15      	ldr	r3, [pc, #84]	; (10ca4 <hif_send+0x1d4>)
   10c50:	4798      	blx	r3
   10c52:	200d      	movs	r0, #13
   10c54:	4b14      	ldr	r3, [pc, #80]	; (10ca8 <hif_send+0x1d8>)
   10c56:	4798      	blx	r3
		goto ERR1;
   10c58:	e004      	b.n	10c64 <hif_send+0x194>
	}
	ret = hif_chip_sleep();
   10c5a:	4b14      	ldr	r3, [pc, #80]	; (10cac <hif_send+0x1dc>)
   10c5c:	4798      	blx	r3
   10c5e:	1c04      	adds	r4, r0, #0
   10c60:	e000      	b.n	10c64 <hif_send+0x194>
			if(M2M_SUCCESS != ret) goto ERR1;
		}
		else
		{
			M2M_DBG("Failed to alloc rx size\r");
			ret =  M2M_ERR_MEM_ALLOC;
   10c62:	24fd      	movs	r4, #253	; 0xfd
		goto ERR1;
	}
	ret = hif_chip_sleep();

ERR1:
	return ret;
   10c64:	b260      	sxtb	r0, r4
}
   10c66:	b009      	add	sp, #36	; 0x24
   10c68:	bc0c      	pop	{r2, r3}
   10c6a:	4692      	mov	sl, r2
   10c6c:	469b      	mov	fp, r3
   10c6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10c70:	000109fd 	.word	0x000109fd
   10c74:	0000108c 	.word	0x0000108c
   10c78:	00011b85 	.word	0x00011b85
   10c7c:	00001078 	.word	0x00001078
   10c80:	000003e7 	.word	0x000003e7
   10c84:	00011b79 	.word	0x00011b79
   10c88:	00150400 	.word	0x00150400
   10c8c:	00011bfd 	.word	0x00011bfd
   10c90:	0000106c 	.word	0x0000106c
   10c94:	000203ec 	.word	0x000203ec
   10c98:	000206a8 	.word	0x000206a8
   10c9c:	00016e3d 	.word	0x00016e3d
   10ca0:	00020458 	.word	0x00020458
   10ca4:	00016f5d 	.word	0x00016f5d
   10ca8:	00016e71 	.word	0x00016e71
   10cac:	00010a55 	.word	0x00010a55

00010cb0 <hif_handle_isr>:
*	@brief	Handle interrupt received from NMC1500 firmware.
*   @return     The function SHALL return 0 for success and a negative value otherwise.
*/

sint8 hif_handle_isr(void)
{
   10cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   10cb2:	464f      	mov	r7, r9
   10cb4:	4646      	mov	r6, r8
   10cb6:	b4c0      	push	{r6, r7}
   10cb8:	b087      	sub	sp, #28
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
   10cba:	4ba3      	ldr	r3, [pc, #652]	; (10f48 <hif_handle_isr+0x298>)
   10cbc:	4698      	mov	r8, r3
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gu8Interrupt--;
   10cbe:	1c1f      	adds	r7, r3, #0
{
	sint8 ret = M2M_ERR_BUS_FAIL;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
   10cc0:	4ea2      	ldr	r6, [pc, #648]	; (10f4c <hif_handle_isr+0x29c>)

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
   10cc2:	e135      	b.n	10f30 <hif_handle_isr+0x280>
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gu8Interrupt--;
   10cc4:	783b      	ldrb	r3, [r7, #0]
   10cc6:	3b01      	subs	r3, #1
   10cc8:	b2db      	uxtb	r3, r3
   10cca:	703b      	strb	r3, [r7, #0]
{
	sint8 ret = M2M_ERR_BUS_FAIL;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
   10ccc:	47b0      	blx	r6
   10cce:	1e04      	subs	r4, r0, #0
	if(ret == M2M_SUCCESS)
   10cd0:	d000      	beq.n	10cd4 <hif_handle_isr+0x24>
   10cd2:	e110      	b.n	10ef6 <hif_handle_isr+0x246>
	{
		ret = nm_read_reg_with_ret(0x1070, &reg);
   10cd4:	489e      	ldr	r0, [pc, #632]	; (10f50 <hif_handle_isr+0x2a0>)
   10cd6:	a903      	add	r1, sp, #12
   10cd8:	4b9e      	ldr	r3, [pc, #632]	; (10f54 <hif_handle_isr+0x2a4>)
   10cda:	4798      	blx	r3
   10cdc:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS == ret)
   10cde:	d000      	beq.n	10ce2 <hif_handle_isr+0x32>
   10ce0:	e0fd      	b.n	10ede <hif_handle_isr+0x22e>
		{
			if(reg & 0x1)	/* New interrupt has been received */
   10ce2:	9b03      	ldr	r3, [sp, #12]
   10ce4:	07db      	lsls	r3, r3, #31
   10ce6:	d400      	bmi.n	10cea <hif_handle_isr+0x3a>
   10ce8:	e0ed      	b.n	10ec6 <hif_handle_isr+0x216>
			{
				uint16 size;

				nm_bsp_interrupt_ctrl(0);
   10cea:	2000      	movs	r0, #0
   10cec:	4b9a      	ldr	r3, [pc, #616]	; (10f58 <hif_handle_isr+0x2a8>)
   10cee:	4798      	blx	r3
				/*Clearing RX interrupt*/
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
   10cf0:	4897      	ldr	r0, [pc, #604]	; (10f50 <hif_handle_isr+0x2a0>)
   10cf2:	a903      	add	r1, sp, #12
   10cf4:	4b97      	ldr	r3, [pc, #604]	; (10f54 <hif_handle_isr+0x2a4>)
   10cf6:	4798      	blx	r3
   10cf8:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS)goto ERR1;
   10cfa:	d000      	beq.n	10cfe <hif_handle_isr+0x4e>
   10cfc:	e10c      	b.n	10f18 <hif_handle_isr+0x268>
				reg &= ~(1<<0);
   10cfe:	2301      	movs	r3, #1
   10d00:	9903      	ldr	r1, [sp, #12]
   10d02:	4399      	bics	r1, r3
   10d04:	9103      	str	r1, [sp, #12]
				ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   10d06:	4892      	ldr	r0, [pc, #584]	; (10f50 <hif_handle_isr+0x2a0>)
   10d08:	4b94      	ldr	r3, [pc, #592]	; (10f5c <hif_handle_isr+0x2ac>)
   10d0a:	4798      	blx	r3
   10d0c:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS)goto ERR1;
   10d0e:	d000      	beq.n	10d12 <hif_handle_isr+0x62>
   10d10:	e102      	b.n	10f18 <hif_handle_isr+0x268>
				/* read the rx size */
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
   10d12:	488f      	ldr	r0, [pc, #572]	; (10f50 <hif_handle_isr+0x2a0>)
   10d14:	a903      	add	r1, sp, #12
   10d16:	4b8f      	ldr	r3, [pc, #572]	; (10f54 <hif_handle_isr+0x2a4>)
   10d18:	4798      	blx	r3
   10d1a:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret)
   10d1c:	d00f      	beq.n	10d3e <hif_handle_isr+0x8e>
				{
					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_0 bus fail\n");
   10d1e:	4890      	ldr	r0, [pc, #576]	; (10f60 <hif_handle_isr+0x2b0>)
   10d20:	4990      	ldr	r1, [pc, #576]	; (10f64 <hif_handle_isr+0x2b4>)
   10d22:	22c0      	movs	r2, #192	; 0xc0
   10d24:	32ff      	adds	r2, #255	; 0xff
   10d26:	4b90      	ldr	r3, [pc, #576]	; (10f68 <hif_handle_isr+0x2b8>)
   10d28:	4798      	blx	r3
   10d2a:	4890      	ldr	r0, [pc, #576]	; (10f6c <hif_handle_isr+0x2bc>)
   10d2c:	4b90      	ldr	r3, [pc, #576]	; (10f70 <hif_handle_isr+0x2c0>)
   10d2e:	4798      	blx	r3
   10d30:	200d      	movs	r0, #13
   10d32:	4b90      	ldr	r3, [pc, #576]	; (10f74 <hif_handle_isr+0x2c4>)
   10d34:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
   10d36:	2001      	movs	r0, #1
   10d38:	4b87      	ldr	r3, [pc, #540]	; (10f58 <hif_handle_isr+0x2a8>)
   10d3a:	4798      	blx	r3
   10d3c:	e0ec      	b.n	10f18 <hif_handle_isr+0x268>
					goto ERR1;
				}
				gu8HifSizeDone = 0;
   10d3e:	2200      	movs	r2, #0
   10d40:	4b8d      	ldr	r3, [pc, #564]	; (10f78 <hif_handle_isr+0x2c8>)
   10d42:	701a      	strb	r2, [r3, #0]
				size = (uint16)((reg >> 2) & 0xfff);
   10d44:	9b03      	ldr	r3, [sp, #12]
   10d46:	049b      	lsls	r3, r3, #18
   10d48:	0d1b      	lsrs	r3, r3, #20
   10d4a:	4699      	mov	r9, r3
				if (size > 0) {
   10d4c:	d100      	bne.n	10d50 <hif_handle_isr+0xa0>
   10d4e:	e0ad      	b.n	10eac <hif_handle_isr+0x1fc>
					uint32 address = 0;
   10d50:	2300      	movs	r3, #0
   10d52:	9305      	str	r3, [sp, #20]
					/**
					start bus transfer
					**/
					ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
   10d54:	4889      	ldr	r0, [pc, #548]	; (10f7c <hif_handle_isr+0x2cc>)
   10d56:	a905      	add	r1, sp, #20
   10d58:	4b7e      	ldr	r3, [pc, #504]	; (10f54 <hif_handle_isr+0x2a4>)
   10d5a:	4798      	blx	r3
   10d5c:	1e04      	subs	r4, r0, #0
					if(M2M_SUCCESS != ret)
   10d5e:	d00f      	beq.n	10d80 <hif_handle_isr+0xd0>
					{
						M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
   10d60:	487f      	ldr	r0, [pc, #508]	; (10f60 <hif_handle_isr+0x2b0>)
   10d62:	4980      	ldr	r1, [pc, #512]	; (10f64 <hif_handle_isr+0x2b4>)
   10d64:	22ce      	movs	r2, #206	; 0xce
   10d66:	32ff      	adds	r2, #255	; 0xff
   10d68:	4b7f      	ldr	r3, [pc, #508]	; (10f68 <hif_handle_isr+0x2b8>)
   10d6a:	4798      	blx	r3
   10d6c:	4884      	ldr	r0, [pc, #528]	; (10f80 <hif_handle_isr+0x2d0>)
   10d6e:	4b80      	ldr	r3, [pc, #512]	; (10f70 <hif_handle_isr+0x2c0>)
   10d70:	4798      	blx	r3
   10d72:	200d      	movs	r0, #13
   10d74:	4b7f      	ldr	r3, [pc, #508]	; (10f74 <hif_handle_isr+0x2c4>)
   10d76:	4798      	blx	r3
						nm_bsp_interrupt_ctrl(1);
   10d78:	2001      	movs	r0, #1
   10d7a:	4b77      	ldr	r3, [pc, #476]	; (10f58 <hif_handle_isr+0x2a8>)
   10d7c:	4798      	blx	r3
   10d7e:	e0c9      	b.n	10f14 <hif_handle_isr+0x264>
						goto ERR1;
					}
					ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
   10d80:	ad04      	add	r5, sp, #16
   10d82:	9805      	ldr	r0, [sp, #20]
   10d84:	1c29      	adds	r1, r5, #0
   10d86:	2204      	movs	r2, #4
   10d88:	4b7e      	ldr	r3, [pc, #504]	; (10f84 <hif_handle_isr+0x2d4>)
   10d8a:	4798      	blx	r3
   10d8c:	1c04      	adds	r4, r0, #0
					strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
   10d8e:	886b      	ldrh	r3, [r5, #2]
   10d90:	b29b      	uxth	r3, r3
   10d92:	806b      	strh	r3, [r5, #2]
					if(M2M_SUCCESS != ret)
   10d94:	2800      	cmp	r0, #0
   10d96:	d00f      	beq.n	10db8 <hif_handle_isr+0x108>
					{
						M2M_ERR("(hif) address bus fail\n");
   10d98:	4871      	ldr	r0, [pc, #452]	; (10f60 <hif_handle_isr+0x2b0>)
   10d9a:	4972      	ldr	r1, [pc, #456]	; (10f64 <hif_handle_isr+0x2b4>)
   10d9c:	22d6      	movs	r2, #214	; 0xd6
   10d9e:	32ff      	adds	r2, #255	; 0xff
   10da0:	4b71      	ldr	r3, [pc, #452]	; (10f68 <hif_handle_isr+0x2b8>)
   10da2:	4798      	blx	r3
   10da4:	4878      	ldr	r0, [pc, #480]	; (10f88 <hif_handle_isr+0x2d8>)
   10da6:	4b72      	ldr	r3, [pc, #456]	; (10f70 <hif_handle_isr+0x2c0>)
   10da8:	4798      	blx	r3
   10daa:	200d      	movs	r0, #13
   10dac:	4b71      	ldr	r3, [pc, #452]	; (10f74 <hif_handle_isr+0x2c4>)
   10dae:	4798      	blx	r3
						nm_bsp_interrupt_ctrl(1);
   10db0:	2001      	movs	r0, #1
   10db2:	4b69      	ldr	r3, [pc, #420]	; (10f58 <hif_handle_isr+0x2a8>)
   10db4:	4798      	blx	r3
   10db6:	e0ad      	b.n	10f14 <hif_handle_isr+0x264>
						goto ERR1;
					}
					if(strHif.u16Length != size)
   10db8:	ab04      	add	r3, sp, #16
   10dba:	885b      	ldrh	r3, [r3, #2]
   10dbc:	b29b      	uxth	r3, r3
   10dbe:	4599      	cmp	r9, r3
   10dc0:	d01d      	beq.n	10dfe <hif_handle_isr+0x14e>
					{
						if((size - strHif.u16Length) > 4)
   10dc2:	ab04      	add	r3, sp, #16
   10dc4:	885b      	ldrh	r3, [r3, #2]
   10dc6:	464a      	mov	r2, r9
   10dc8:	1ad3      	subs	r3, r2, r3
   10dca:	2b04      	cmp	r3, #4
   10dcc:	dd17      	ble.n	10dfe <hif_handle_isr+0x14e>
						{
							M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
   10dce:	4864      	ldr	r0, [pc, #400]	; (10f60 <hif_handle_isr+0x2b0>)
   10dd0:	4964      	ldr	r1, [pc, #400]	; (10f64 <hif_handle_isr+0x2b4>)
   10dd2:	22ef      	movs	r2, #239	; 0xef
   10dd4:	0052      	lsls	r2, r2, #1
   10dd6:	4c64      	ldr	r4, [pc, #400]	; (10f68 <hif_handle_isr+0x2b8>)
   10dd8:	47a0      	blx	r4
   10dda:	a904      	add	r1, sp, #16
   10ddc:	884a      	ldrh	r2, [r1, #2]
   10dde:	b292      	uxth	r2, r2
   10de0:	780b      	ldrb	r3, [r1, #0]
   10de2:	b2db      	uxtb	r3, r3
   10de4:	7849      	ldrb	r1, [r1, #1]
   10de6:	9100      	str	r1, [sp, #0]
   10de8:	4868      	ldr	r0, [pc, #416]	; (10f8c <hif_handle_isr+0x2dc>)
   10dea:	4649      	mov	r1, r9
   10dec:	47a0      	blx	r4
   10dee:	200d      	movs	r0, #13
   10df0:	4b60      	ldr	r3, [pc, #384]	; (10f74 <hif_handle_isr+0x2c4>)
   10df2:	4798      	blx	r3
								size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
							nm_bsp_interrupt_ctrl(1);
   10df4:	2001      	movs	r0, #1
   10df6:	4b58      	ldr	r3, [pc, #352]	; (10f58 <hif_handle_isr+0x2a8>)
   10df8:	4798      	blx	r3
							ret = M2M_ERR_BUS_FAIL;
   10dfa:	24fa      	movs	r4, #250	; 0xfa
   10dfc:	e08a      	b.n	10f14 <hif_handle_isr+0x264>
							goto ERR1;
						}
					}

					if(M2M_REQ_GRP_WIFI == strHif.u8Gid)
   10dfe:	ab04      	add	r3, sp, #16
   10e00:	781b      	ldrb	r3, [r3, #0]
   10e02:	2b01      	cmp	r3, #1
   10e04:	d10d      	bne.n	10e22 <hif_handle_isr+0x172>
					{
						if(pfWifiCb)
   10e06:	4b62      	ldr	r3, [pc, #392]	; (10f90 <hif_handle_isr+0x2e0>)
   10e08:	681b      	ldr	r3, [r3, #0]
   10e0a:	2b00      	cmp	r3, #0
   10e0c:	d03b      	beq.n	10e86 <hif_handle_isr+0x1d6>
							pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   10e0e:	aa04      	add	r2, sp, #16
   10e10:	7850      	ldrb	r0, [r2, #1]
   10e12:	b2c0      	uxtb	r0, r0
   10e14:	8851      	ldrh	r1, [r2, #2]
   10e16:	3908      	subs	r1, #8
   10e18:	b289      	uxth	r1, r1
   10e1a:	9a05      	ldr	r2, [sp, #20]
   10e1c:	3208      	adds	r2, #8
   10e1e:	4798      	blx	r3
   10e20:	e031      	b.n	10e86 <hif_handle_isr+0x1d6>

					}
					else if(M2M_REQ_GRP_IP == strHif.u8Gid)
   10e22:	ab04      	add	r3, sp, #16
   10e24:	781b      	ldrb	r3, [r3, #0]
   10e26:	2b02      	cmp	r3, #2
   10e28:	d10d      	bne.n	10e46 <hif_handle_isr+0x196>
					{
						if(pfIpCb)
   10e2a:	4b5a      	ldr	r3, [pc, #360]	; (10f94 <hif_handle_isr+0x2e4>)
   10e2c:	681b      	ldr	r3, [r3, #0]
   10e2e:	2b00      	cmp	r3, #0
   10e30:	d029      	beq.n	10e86 <hif_handle_isr+0x1d6>
							pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   10e32:	aa04      	add	r2, sp, #16
   10e34:	7850      	ldrb	r0, [r2, #1]
   10e36:	b2c0      	uxtb	r0, r0
   10e38:	8851      	ldrh	r1, [r2, #2]
   10e3a:	3908      	subs	r1, #8
   10e3c:	b289      	uxth	r1, r1
   10e3e:	9a05      	ldr	r2, [sp, #20]
   10e40:	3208      	adds	r2, #8
   10e42:	4798      	blx	r3
   10e44:	e01f      	b.n	10e86 <hif_handle_isr+0x1d6>
					}
					else if(M2M_REQ_GRP_OTA == strHif.u8Gid)
   10e46:	ab04      	add	r3, sp, #16
   10e48:	781b      	ldrb	r3, [r3, #0]
   10e4a:	2b04      	cmp	r3, #4
   10e4c:	d10d      	bne.n	10e6a <hif_handle_isr+0x1ba>
					{
						if(pfOtaCb)
   10e4e:	4b52      	ldr	r3, [pc, #328]	; (10f98 <hif_handle_isr+0x2e8>)
   10e50:	681b      	ldr	r3, [r3, #0]
   10e52:	2b00      	cmp	r3, #0
   10e54:	d017      	beq.n	10e86 <hif_handle_isr+0x1d6>
							pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   10e56:	aa04      	add	r2, sp, #16
   10e58:	7850      	ldrb	r0, [r2, #1]
   10e5a:	b2c0      	uxtb	r0, r0
   10e5c:	8851      	ldrh	r1, [r2, #2]
   10e5e:	3908      	subs	r1, #8
   10e60:	b289      	uxth	r1, r1
   10e62:	9a05      	ldr	r2, [sp, #20]
   10e64:	3208      	adds	r2, #8
   10e66:	4798      	blx	r3
   10e68:	e00d      	b.n	10e86 <hif_handle_isr+0x1d6>
					}
					else
					{
						M2M_ERR("(hif) invalid group ID\n");
   10e6a:	483d      	ldr	r0, [pc, #244]	; (10f60 <hif_handle_isr+0x2b0>)
   10e6c:	493d      	ldr	r1, [pc, #244]	; (10f64 <hif_handle_isr+0x2b4>)
   10e6e:	22f8      	movs	r2, #248	; 0xf8
   10e70:	32ff      	adds	r2, #255	; 0xff
   10e72:	4b3d      	ldr	r3, [pc, #244]	; (10f68 <hif_handle_isr+0x2b8>)
   10e74:	4798      	blx	r3
   10e76:	4849      	ldr	r0, [pc, #292]	; (10f9c <hif_handle_isr+0x2ec>)
   10e78:	4b3d      	ldr	r3, [pc, #244]	; (10f70 <hif_handle_isr+0x2c0>)
   10e7a:	4798      	blx	r3
   10e7c:	200d      	movs	r0, #13
   10e7e:	4b3d      	ldr	r3, [pc, #244]	; (10f74 <hif_handle_isr+0x2c4>)
   10e80:	4798      	blx	r3
						ret = M2M_ERR_BUS_FAIL;
   10e82:	24fa      	movs	r4, #250	; 0xfa
   10e84:	e046      	b.n	10f14 <hif_handle_isr+0x264>
						goto ERR1;
					}
					#ifndef ENABLE_UNO_BOARD
					if(!gu8HifSizeDone)
   10e86:	4b3c      	ldr	r3, [pc, #240]	; (10f78 <hif_handle_isr+0x2c8>)
   10e88:	781b      	ldrb	r3, [r3, #0]
   10e8a:	2b00      	cmp	r3, #0
   10e8c:	d13f      	bne.n	10f0e <hif_handle_isr+0x25e>
					{
						M2M_ERR("(hif) host app didn't set RX Done\n");
   10e8e:	4834      	ldr	r0, [pc, #208]	; (10f60 <hif_handle_isr+0x2b0>)
   10e90:	4934      	ldr	r1, [pc, #208]	; (10f64 <hif_handle_isr+0x2b4>)
   10e92:	22ff      	movs	r2, #255	; 0xff
   10e94:	0052      	lsls	r2, r2, #1
   10e96:	4b34      	ldr	r3, [pc, #208]	; (10f68 <hif_handle_isr+0x2b8>)
   10e98:	4798      	blx	r3
   10e9a:	4841      	ldr	r0, [pc, #260]	; (10fa0 <hif_handle_isr+0x2f0>)
   10e9c:	4b34      	ldr	r3, [pc, #208]	; (10f70 <hif_handle_isr+0x2c0>)
   10e9e:	4798      	blx	r3
   10ea0:	200d      	movs	r0, #13
   10ea2:	4b34      	ldr	r3, [pc, #208]	; (10f74 <hif_handle_isr+0x2c4>)
   10ea4:	4798      	blx	r3
						ret = hif_set_rx_done();
   10ea6:	4b3f      	ldr	r3, [pc, #252]	; (10fa4 <hif_handle_isr+0x2f4>)
   10ea8:	4798      	blx	r3
   10eaa:	e030      	b.n	10f0e <hif_handle_isr+0x25e>
					#endif
				}
				else
				{
					ret = M2M_ERR_RCV;
					M2M_ERR("(hif) Wrong Size\n");
   10eac:	482c      	ldr	r0, [pc, #176]	; (10f60 <hif_handle_isr+0x2b0>)
   10eae:	492d      	ldr	r1, [pc, #180]	; (10f64 <hif_handle_isr+0x2b4>)
   10eb0:	4a3d      	ldr	r2, [pc, #244]	; (10fa8 <hif_handle_isr+0x2f8>)
   10eb2:	4b2d      	ldr	r3, [pc, #180]	; (10f68 <hif_handle_isr+0x2b8>)
   10eb4:	4798      	blx	r3
   10eb6:	483d      	ldr	r0, [pc, #244]	; (10fac <hif_handle_isr+0x2fc>)
   10eb8:	4b2d      	ldr	r3, [pc, #180]	; (10f70 <hif_handle_isr+0x2c0>)
   10eba:	4798      	blx	r3
   10ebc:	200d      	movs	r0, #13
   10ebe:	4b2d      	ldr	r3, [pc, #180]	; (10f74 <hif_handle_isr+0x2c4>)
   10ec0:	4798      	blx	r3
					}
					#endif
				}
				else
				{
					ret = M2M_ERR_RCV;
   10ec2:	24fe      	movs	r4, #254	; 0xfe
   10ec4:	e028      	b.n	10f18 <hif_handle_isr+0x268>
				}
			}
			else
			{
#ifndef WIN32
				M2M_ERR("(hif) False interrupt %lx",reg);
   10ec6:	4826      	ldr	r0, [pc, #152]	; (10f60 <hif_handle_isr+0x2b0>)
   10ec8:	4926      	ldr	r1, [pc, #152]	; (10f64 <hif_handle_isr+0x2b4>)
   10eca:	4a39      	ldr	r2, [pc, #228]	; (10fb0 <hif_handle_isr+0x300>)
   10ecc:	4c26      	ldr	r4, [pc, #152]	; (10f68 <hif_handle_isr+0x2b8>)
   10ece:	47a0      	blx	r4
   10ed0:	4838      	ldr	r0, [pc, #224]	; (10fb4 <hif_handle_isr+0x304>)
   10ed2:	9903      	ldr	r1, [sp, #12]
   10ed4:	47a0      	blx	r4
   10ed6:	200d      	movs	r0, #13
   10ed8:	4b26      	ldr	r3, [pc, #152]	; (10f74 <hif_handle_isr+0x2c4>)
   10eda:	4798      	blx	r3
   10edc:	e017      	b.n	10f0e <hif_handle_isr+0x25e>
#endif
			}
		}
		else
		{
			M2M_ERR("(hif) Fail to Read interrupt reg\n");
   10ede:	4820      	ldr	r0, [pc, #128]	; (10f60 <hif_handle_isr+0x2b0>)
   10ee0:	4920      	ldr	r1, [pc, #128]	; (10f64 <hif_handle_isr+0x2b4>)
   10ee2:	4a35      	ldr	r2, [pc, #212]	; (10fb8 <hif_handle_isr+0x308>)
   10ee4:	4b20      	ldr	r3, [pc, #128]	; (10f68 <hif_handle_isr+0x2b8>)
   10ee6:	4798      	blx	r3
   10ee8:	4834      	ldr	r0, [pc, #208]	; (10fbc <hif_handle_isr+0x30c>)
   10eea:	4b21      	ldr	r3, [pc, #132]	; (10f70 <hif_handle_isr+0x2c0>)
   10eec:	4798      	blx	r3
   10eee:	200d      	movs	r0, #13
   10ef0:	4b20      	ldr	r3, [pc, #128]	; (10f74 <hif_handle_isr+0x2c4>)
   10ef2:	4798      	blx	r3
   10ef4:	e010      	b.n	10f18 <hif_handle_isr+0x268>
			goto ERR1;
		}
	}
	else
	{
		M2M_ERR("(hif) FAIL to wakeup the chip\n");
   10ef6:	481a      	ldr	r0, [pc, #104]	; (10f60 <hif_handle_isr+0x2b0>)
   10ef8:	491a      	ldr	r1, [pc, #104]	; (10f64 <hif_handle_isr+0x2b4>)
   10efa:	4a31      	ldr	r2, [pc, #196]	; (10fc0 <hif_handle_isr+0x310>)
   10efc:	4b1a      	ldr	r3, [pc, #104]	; (10f68 <hif_handle_isr+0x2b8>)
   10efe:	4798      	blx	r3
   10f00:	4830      	ldr	r0, [pc, #192]	; (10fc4 <hif_handle_isr+0x314>)
   10f02:	4b1b      	ldr	r3, [pc, #108]	; (10f70 <hif_handle_isr+0x2c0>)
   10f04:	4798      	blx	r3
   10f06:	200d      	movs	r0, #13
   10f08:	4b1a      	ldr	r3, [pc, #104]	; (10f74 <hif_handle_isr+0x2c4>)
   10f0a:	4798      	blx	r3
   10f0c:	e004      	b.n	10f18 <hif_handle_isr+0x268>
		goto ERR1;
	}

	ret = hif_chip_sleep();
   10f0e:	4b2e      	ldr	r3, [pc, #184]	; (10fc8 <hif_handle_isr+0x318>)
   10f10:	4798      	blx	r3
   10f12:	1c04      	adds	r4, r0, #0
		/*when the interrupt enabled*/
		gu8Interrupt--;
		while(1)
		{
			ret = hif_isr();
			if(ret == M2M_SUCCESS) 
   10f14:	2c00      	cmp	r4, #0
   10f16:	d00b      	beq.n	10f30 <hif_handle_isr+0x280>
				/*Fail return errors here due to bus errors (reading expected values)*/
				break;
			} 
			else
			{
				M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
   10f18:	4811      	ldr	r0, [pc, #68]	; (10f60 <hif_handle_isr+0x2b0>)
   10f1a:	492c      	ldr	r1, [pc, #176]	; (10fcc <hif_handle_isr+0x31c>)
   10f1c:	4a2c      	ldr	r2, [pc, #176]	; (10fd0 <hif_handle_isr+0x320>)
   10f1e:	4d12      	ldr	r5, [pc, #72]	; (10f68 <hif_handle_isr+0x2b8>)
   10f20:	47a8      	blx	r5
   10f22:	b261      	sxtb	r1, r4
   10f24:	482b      	ldr	r0, [pc, #172]	; (10fd4 <hif_handle_isr+0x324>)
   10f26:	47a8      	blx	r5
   10f28:	200d      	movs	r0, #13
   10f2a:	4b12      	ldr	r3, [pc, #72]	; (10f74 <hif_handle_isr+0x2c4>)
   10f2c:	4798      	blx	r3
			}
		}
   10f2e:	e6cd      	b.n	10ccc <hif_handle_isr+0x1c>

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
   10f30:	4643      	mov	r3, r8
   10f32:	781b      	ldrb	r3, [r3, #0]
   10f34:	2b00      	cmp	r3, #0
   10f36:	d000      	beq.n	10f3a <hif_handle_isr+0x28a>
   10f38:	e6c4      	b.n	10cc4 <hif_handle_isr+0x14>
			}
		}
	}

	return ret;
}
   10f3a:	2000      	movs	r0, #0
   10f3c:	b007      	add	sp, #28
   10f3e:	bc0c      	pop	{r2, r3}
   10f40:	4690      	mov	r8, r2
   10f42:	4699      	mov	r9, r3
   10f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10f46:	46c0      	nop			; (mov r8, r8)
   10f48:	200012f0 	.word	0x200012f0
   10f4c:	000109fd 	.word	0x000109fd
   10f50:	00001070 	.word	0x00001070
   10f54:	00011b79 	.word	0x00011b79
   10f58:	000106dd 	.word	0x000106dd
   10f5c:	00011b85 	.word	0x00011b85
   10f60:	000203ec 	.word	0x000203ec
   10f64:	00020424 	.word	0x00020424
   10f68:	00016e3d 	.word	0x00016e3d
   10f6c:	00020474 	.word	0x00020474
   10f70:	00016f5d 	.word	0x00016f5d
   10f74:	00016e71 	.word	0x00016e71
   10f78:	20001300 	.word	0x20001300
   10f7c:	00001084 	.word	0x00001084
   10f80:	00020498 	.word	0x00020498
   10f84:	00011b91 	.word	0x00011b91
   10f88:	000204bc 	.word	0x000204bc
   10f8c:	000204d4 	.word	0x000204d4
   10f90:	200012ec 	.word	0x200012ec
   10f94:	200012fc 	.word	0x200012fc
   10f98:	20001304 	.word	0x20001304
   10f9c:	00020514 	.word	0x00020514
   10fa0:	0002052c 	.word	0x0002052c
   10fa4:	000109c1 	.word	0x000109c1
   10fa8:	00000206 	.word	0x00000206
   10fac:	00020550 	.word	0x00020550
   10fb0:	0000020d 	.word	0x0000020d
   10fb4:	00020564 	.word	0x00020564
   10fb8:	00000213 	.word	0x00000213
   10fbc:	00020580 	.word	0x00020580
   10fc0:	00000219 	.word	0x00000219
   10fc4:	000205a4 	.word	0x000205a4
   10fc8:	00010a55 	.word	0x00010a55
   10fcc:	00020448 	.word	0x00020448
   10fd0:	0000023b 	.word	0x0000023b
   10fd4:	000205c4 	.word	0x000205c4

00010fd8 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
   10fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
   10fda:	4647      	mov	r7, r8
   10fdc:	b480      	push	{r7}
   10fde:	b082      	sub	sp, #8
   10fe0:	1c06      	adds	r6, r0, #0
   10fe2:	1c0f      	adds	r7, r1, #0
   10fe4:	1c15      	adds	r5, r2, #0
   10fe6:	1c1c      	adds	r4, r3, #0
	uint32 address, reg;
	uint16 size;
	sint8 ret = M2M_SUCCESS;

	if(u32Addr == 0 ||pu8Buf == NULL || u16Sz == 0)
   10fe8:	2800      	cmp	r0, #0
   10fea:	d003      	beq.n	10ff4 <hif_receive+0x1c>
   10fec:	2900      	cmp	r1, #0
   10fee:	d001      	beq.n	10ff4 <hif_receive+0x1c>
   10ff0:	2a00      	cmp	r2, #0
   10ff2:	d114      	bne.n	1101e <hif_receive+0x46>
	{
		if(isDone)
   10ff4:	2c00      	cmp	r4, #0
   10ff6:	d004      	beq.n	11002 <hif_receive+0x2a>
		{
			gu8HifSizeDone = 1;
   10ff8:	2201      	movs	r2, #1
   10ffa:	4b2e      	ldr	r3, [pc, #184]	; (110b4 <hif_receive+0xdc>)
   10ffc:	701a      	strb	r2, [r3, #0]

			/* set RX done */
			ret = hif_set_rx_done();
   10ffe:	4b2e      	ldr	r3, [pc, #184]	; (110b8 <hif_receive+0xe0>)
   11000:	4798      	blx	r3
		}
			
		ret = M2M_ERR_FAIL;
		M2M_ERR(" hif_receive: Invalid argument\n");
   11002:	482e      	ldr	r0, [pc, #184]	; (110bc <hif_receive+0xe4>)
   11004:	492e      	ldr	r1, [pc, #184]	; (110c0 <hif_receive+0xe8>)
   11006:	2298      	movs	r2, #152	; 0x98
   11008:	0092      	lsls	r2, r2, #2
   1100a:	4b2e      	ldr	r3, [pc, #184]	; (110c4 <hif_receive+0xec>)
   1100c:	4798      	blx	r3
   1100e:	482e      	ldr	r0, [pc, #184]	; (110c8 <hif_receive+0xf0>)
   11010:	4b2e      	ldr	r3, [pc, #184]	; (110cc <hif_receive+0xf4>)
   11012:	4798      	blx	r3
   11014:	200d      	movs	r0, #13
   11016:	4b2e      	ldr	r3, [pc, #184]	; (110d0 <hif_receive+0xf8>)
   11018:	4798      	blx	r3

			/* set RX done */
			ret = hif_set_rx_done();
		}
			
		ret = M2M_ERR_FAIL;
   1101a:	20f4      	movs	r0, #244	; 0xf4
		M2M_ERR(" hif_receive: Invalid argument\n");
		goto ERR1;
   1101c:	e044      	b.n	110a8 <hif_receive+0xd0>
	}

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
   1101e:	482d      	ldr	r0, [pc, #180]	; (110d4 <hif_receive+0xfc>)
   11020:	4669      	mov	r1, sp
   11022:	4b2d      	ldr	r3, [pc, #180]	; (110d8 <hif_receive+0x100>)
   11024:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   11026:	2800      	cmp	r0, #0
   11028:	d13e      	bne.n	110a8 <hif_receive+0xd0>


	size = (uint16)((reg >> 2) & 0xfff);
   1102a:	9b00      	ldr	r3, [sp, #0]
   1102c:	4698      	mov	r8, r3
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1,&address);
   1102e:	482b      	ldr	r0, [pc, #172]	; (110dc <hif_receive+0x104>)
   11030:	a901      	add	r1, sp, #4
   11032:	4b29      	ldr	r3, [pc, #164]	; (110d8 <hif_receive+0x100>)
   11034:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   11036:	2800      	cmp	r0, #0
   11038:	d136      	bne.n	110a8 <hif_receive+0xd0>

	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
   1103a:	1c30      	adds	r0, r6, #0
   1103c:	1c39      	adds	r1, r7, #0
   1103e:	1c2a      	adds	r2, r5, #0
   11040:	4b27      	ldr	r3, [pc, #156]	; (110e0 <hif_receive+0x108>)
   11042:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   11044:	2800      	cmp	r0, #0
   11046:	d12f      	bne.n	110a8 <hif_receive+0xd0>

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
	if(ret != M2M_SUCCESS)goto ERR1;


	size = (uint16)((reg >> 2) & 0xfff);
   11048:	4643      	mov	r3, r8
   1104a:	049f      	lsls	r7, r3, #18
   1104c:	0d3f      	lsrs	r7, r7, #20

	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
	if(ret != M2M_SUCCESS)goto ERR1;

	if(u16Sz > size)
   1104e:	42bd      	cmp	r5, r7
   11050:	d90d      	bls.n	1106e <hif_receive+0x96>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
   11052:	481a      	ldr	r0, [pc, #104]	; (110bc <hif_receive+0xe4>)
   11054:	491a      	ldr	r1, [pc, #104]	; (110c0 <hif_receive+0xe8>)
   11056:	4a23      	ldr	r2, [pc, #140]	; (110e4 <hif_receive+0x10c>)
   11058:	4c1a      	ldr	r4, [pc, #104]	; (110c4 <hif_receive+0xec>)
   1105a:	47a0      	blx	r4
   1105c:	4822      	ldr	r0, [pc, #136]	; (110e8 <hif_receive+0x110>)
   1105e:	1c29      	adds	r1, r5, #0
   11060:	1c3a      	adds	r2, r7, #0
   11062:	47a0      	blx	r4
   11064:	200d      	movs	r0, #13
   11066:	4b1a      	ldr	r3, [pc, #104]	; (110d0 <hif_receive+0xf8>)
   11068:	4798      	blx	r3
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
	if(ret != M2M_SUCCESS)goto ERR1;

	if(u16Sz > size)
	{
		ret = M2M_ERR_FAIL;
   1106a:	20f4      	movs	r0, #244	; 0xf4
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
		goto ERR1;
   1106c:	e01c      	b.n	110a8 <hif_receive+0xd0>
	}
	if((u32Addr < address)||((u32Addr + u16Sz)>(address+size)))
   1106e:	9b01      	ldr	r3, [sp, #4]
   11070:	429e      	cmp	r6, r3
   11072:	d303      	bcc.n	1107c <hif_receive+0xa4>
   11074:	1972      	adds	r2, r6, r5
   11076:	18ff      	adds	r7, r7, r3
   11078:	42ba      	cmp	r2, r7
   1107a:	d90c      	bls.n	11096 <hif_receive+0xbe>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
   1107c:	480f      	ldr	r0, [pc, #60]	; (110bc <hif_receive+0xe4>)
   1107e:	4910      	ldr	r1, [pc, #64]	; (110c0 <hif_receive+0xe8>)
   11080:	4a1a      	ldr	r2, [pc, #104]	; (110ec <hif_receive+0x114>)
   11082:	4b10      	ldr	r3, [pc, #64]	; (110c4 <hif_receive+0xec>)
   11084:	4798      	blx	r3
   11086:	481a      	ldr	r0, [pc, #104]	; (110f0 <hif_receive+0x118>)
   11088:	4b10      	ldr	r3, [pc, #64]	; (110cc <hif_receive+0xf4>)
   1108a:	4798      	blx	r3
   1108c:	200d      	movs	r0, #13
   1108e:	4b10      	ldr	r3, [pc, #64]	; (110d0 <hif_receive+0xf8>)
   11090:	4798      	blx	r3
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
		goto ERR1;
	}
	if((u32Addr < address)||((u32Addr + u16Sz)>(address+size)))
	{
		ret = M2M_ERR_FAIL;
   11092:	20f4      	movs	r0, #244	; 0xf4
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
   11094:	e008      	b.n	110a8 <hif_receive+0xd0>
	}

	/* check if this is the last packet */
	if((((address+size) - (u32Addr+u16Sz)) <= 0) || isDone)
   11096:	42ba      	cmp	r2, r7
   11098:	d001      	beq.n	1109e <hif_receive+0xc6>
   1109a:	2c00      	cmp	r4, #0
   1109c:	d004      	beq.n	110a8 <hif_receive+0xd0>
	{
		gu8HifSizeDone = 1;
   1109e:	2201      	movs	r2, #1
   110a0:	4b04      	ldr	r3, [pc, #16]	; (110b4 <hif_receive+0xdc>)
   110a2:	701a      	strb	r2, [r3, #0]

		/* set RX done */
		ret = hif_set_rx_done();
   110a4:	4b04      	ldr	r3, [pc, #16]	; (110b8 <hif_receive+0xe0>)
   110a6:	4798      	blx	r3
	}



ERR1:
	return ret;
   110a8:	b240      	sxtb	r0, r0
}
   110aa:	b002      	add	sp, #8
   110ac:	bc04      	pop	{r2}
   110ae:	4690      	mov	r8, r2
   110b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   110b2:	46c0      	nop			; (mov r8, r8)
   110b4:	20001300 	.word	0x20001300
   110b8:	000109c1 	.word	0x000109c1
   110bc:	000203ec 	.word	0x000203ec
   110c0:	0002042c 	.word	0x0002042c
   110c4:	00016e3d 	.word	0x00016e3d
   110c8:	000205f4 	.word	0x000205f4
   110cc:	00016f5d 	.word	0x00016f5d
   110d0:	00016e71 	.word	0x00016e71
   110d4:	00001070 	.word	0x00001070
   110d8:	00011b79 	.word	0x00011b79
   110dc:	00001084 	.word	0x00001084
   110e0:	00011b91 	.word	0x00011b91
   110e4:	00000273 	.word	0x00000273
   110e8:	00020614 	.word	0x00020614
   110ec:	00000279 	.word	0x00000279
   110f0:	00020658 	.word	0x00020658

000110f4 <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
   110f4:	b538      	push	{r3, r4, r5, lr}
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
   110f6:	2802      	cmp	r0, #2
   110f8:	d008      	beq.n	1110c <hif_register_cb+0x18>
   110fa:	d802      	bhi.n	11102 <hif_register_cb+0xe>
   110fc:	2801      	cmp	r0, #1
   110fe:	d009      	beq.n	11114 <hif_register_cb+0x20>
   11100:	e014      	b.n	1112c <hif_register_cb+0x38>
   11102:	2803      	cmp	r0, #3
   11104:	d00e      	beq.n	11124 <hif_register_cb+0x30>
   11106:	2804      	cmp	r0, #4
   11108:	d008      	beq.n	1111c <hif_register_cb+0x28>
   1110a:	e00f      	b.n	1112c <hif_register_cb+0x38>
	{
		case M2M_REQ_GRP_IP:
			pfIpCb = fn;
   1110c:	4b0f      	ldr	r3, [pc, #60]	; (1114c <hif_register_cb+0x58>)
   1110e:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
   11110:	2000      	movs	r0, #0
	switch(u8Grp)
	{
		case M2M_REQ_GRP_IP:
			pfIpCb = fn;
			break;
   11112:	e019      	b.n	11148 <hif_register_cb+0x54>
		case M2M_REQ_GRP_WIFI:
			pfWifiCb = fn;
   11114:	4b0e      	ldr	r3, [pc, #56]	; (11150 <hif_register_cb+0x5c>)
   11116:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
   11118:	2000      	movs	r0, #0
		case M2M_REQ_GRP_IP:
			pfIpCb = fn;
			break;
		case M2M_REQ_GRP_WIFI:
			pfWifiCb = fn;
			break;
   1111a:	e015      	b.n	11148 <hif_register_cb+0x54>
		case M2M_REQ_GRP_OTA:
			pfOtaCb = fn;
   1111c:	4b0d      	ldr	r3, [pc, #52]	; (11154 <hif_register_cb+0x60>)
   1111e:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
   11120:	2000      	movs	r0, #0
		case M2M_REQ_GRP_WIFI:
			pfWifiCb = fn;
			break;
		case M2M_REQ_GRP_OTA:
			pfOtaCb = fn;
			break;
   11122:	e011      	b.n	11148 <hif_register_cb+0x54>
		case M2M_REQ_GRP_HIF:
			pfHifCb = fn;
   11124:	4b0c      	ldr	r3, [pc, #48]	; (11158 <hif_register_cb+0x64>)
   11126:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
   11128:	2000      	movs	r0, #0
		case M2M_REQ_GRP_OTA:
			pfOtaCb = fn;
			break;
		case M2M_REQ_GRP_HIF:
			pfHifCb = fn;
			break;
   1112a:	e00d      	b.n	11148 <hif_register_cb+0x54>
   1112c:	1c04      	adds	r4, r0, #0
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
   1112e:	480b      	ldr	r0, [pc, #44]	; (1115c <hif_register_cb+0x68>)
   11130:	490b      	ldr	r1, [pc, #44]	; (11160 <hif_register_cb+0x6c>)
   11132:	22aa      	movs	r2, #170	; 0xaa
   11134:	0092      	lsls	r2, r2, #2
   11136:	4d0b      	ldr	r5, [pc, #44]	; (11164 <hif_register_cb+0x70>)
   11138:	47a8      	blx	r5
   1113a:	480b      	ldr	r0, [pc, #44]	; (11168 <hif_register_cb+0x74>)
   1113c:	1c21      	adds	r1, r4, #0
   1113e:	47a8      	blx	r5
   11140:	200d      	movs	r0, #13
   11142:	4b0a      	ldr	r3, [pc, #40]	; (1116c <hif_register_cb+0x78>)
   11144:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   11146:	20f4      	movs	r0, #244	; 0xf4
			break;
	}
	return ret;
   11148:	b240      	sxtb	r0, r0
}
   1114a:	bd38      	pop	{r3, r4, r5, pc}
   1114c:	200012fc 	.word	0x200012fc
   11150:	200012ec 	.word	0x200012ec
   11154:	20001304 	.word	0x20001304
   11158:	200012f4 	.word	0x200012f4
   1115c:	000203ec 	.word	0x000203ec
   11160:	00020438 	.word	0x00020438
   11164:	00016e3d 	.word	0x00016e3d
   11168:	0002069c 	.word	0x0002069c
   1116c:	00016e71 	.word	0x00016e71

00011170 <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
   11170:	b508      	push	{r3, lr}
	pfWifiCb = NULL;
   11172:	2300      	movs	r3, #0
   11174:	4a09      	ldr	r2, [pc, #36]	; (1119c <hif_init+0x2c>)
   11176:	6013      	str	r3, [r2, #0]
	pfIpCb = NULL;
   11178:	4a09      	ldr	r2, [pc, #36]	; (111a0 <hif_init+0x30>)
   1117a:	6013      	str	r3, [r2, #0]

	gu8ChipSleep = 0;
   1117c:	4a09      	ldr	r2, [pc, #36]	; (111a4 <hif_init+0x34>)
   1117e:	7013      	strb	r3, [r2, #0]
	gu8ChipMode = M2M_NO_PS;
   11180:	4a09      	ldr	r2, [pc, #36]	; (111a8 <hif_init+0x38>)
   11182:	7013      	strb	r3, [r2, #0]

	gu8Interrupt = 0;
   11184:	4a09      	ldr	r2, [pc, #36]	; (111ac <hif_init+0x3c>)
   11186:	7013      	strb	r3, [r2, #0]
	nm_bsp_register_isr(isr);
   11188:	4809      	ldr	r0, [pc, #36]	; (111b0 <hif_init+0x40>)
   1118a:	4b0a      	ldr	r3, [pc, #40]	; (111b4 <hif_init+0x44>)
   1118c:	4798      	blx	r3

	hif_register_cb(M2M_REQ_GRP_HIF,m2m_hif_cb);
   1118e:	2003      	movs	r0, #3
   11190:	4909      	ldr	r1, [pc, #36]	; (111b8 <hif_init+0x48>)
   11192:	4b0a      	ldr	r3, [pc, #40]	; (111bc <hif_init+0x4c>)
   11194:	4798      	blx	r3

	return M2M_SUCCESS;
}
   11196:	2000      	movs	r0, #0
   11198:	bd08      	pop	{r3, pc}
   1119a:	46c0      	nop			; (mov r8, r8)
   1119c:	200012ec 	.word	0x200012ec
   111a0:	200012fc 	.word	0x200012fc
   111a4:	20001308 	.word	0x20001308
   111a8:	200012f8 	.word	0x200012f8
   111ac:	200012f0 	.word	0x200012f0
   111b0:	000109ad 	.word	0x000109ad
   111b4:	00010685 	.word	0x00010685
   111b8:	000109bd 	.word	0x000109bd
   111bc:	000110f5 	.word	0x000110f5

000111c0 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
   111c0:	b530      	push	{r4, r5, lr}
   111c2:	b09f      	sub	sp, #124	; 0x7c
   111c4:	1c04      	adds	r4, r0, #0
   111c6:	1c15      	adds	r5, r2, #0
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
   111c8:	282c      	cmp	r0, #44	; 0x2c
   111ca:	d111      	bne.n	111f0 <m2m_wifi_cb+0x30>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
   111cc:	1c10      	adds	r0, r2, #0
   111ce:	a903      	add	r1, sp, #12
   111d0:	2204      	movs	r2, #4
   111d2:	2300      	movs	r3, #0
   111d4:	4c86      	ldr	r4, [pc, #536]	; (113f0 <m2m_wifi_cb+0x230>)
   111d6:	47a0      	blx	r4
   111d8:	2800      	cmp	r0, #0
   111da:	d000      	beq.n	111de <m2m_wifi_cb+0x1e>
   111dc:	e105      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   111de:	4b85      	ldr	r3, [pc, #532]	; (113f4 <m2m_wifi_cb+0x234>)
   111e0:	681b      	ldr	r3, [r3, #0]
   111e2:	2b00      	cmp	r3, #0
   111e4:	d100      	bne.n	111e8 <m2m_wifi_cb+0x28>
   111e6:	e100      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
   111e8:	302c      	adds	r0, #44	; 0x2c
   111ea:	a903      	add	r1, sp, #12
   111ec:	4798      	blx	r3
   111ee:	e0fc      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
   111f0:	281b      	cmp	r0, #27
   111f2:	d111      	bne.n	11218 <m2m_wifi_cb+0x58>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
   111f4:	1c10      	adds	r0, r2, #0
   111f6:	a903      	add	r1, sp, #12
   111f8:	2208      	movs	r2, #8
   111fa:	2300      	movs	r3, #0
   111fc:	4c7c      	ldr	r4, [pc, #496]	; (113f0 <m2m_wifi_cb+0x230>)
   111fe:	47a0      	blx	r4
   11200:	2800      	cmp	r0, #0
   11202:	d000      	beq.n	11206 <m2m_wifi_cb+0x46>
   11204:	e0f1      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   11206:	4b7b      	ldr	r3, [pc, #492]	; (113f4 <m2m_wifi_cb+0x234>)
   11208:	681b      	ldr	r3, [r3, #0]
   1120a:	2b00      	cmp	r3, #0
   1120c:	d100      	bne.n	11210 <m2m_wifi_cb+0x50>
   1120e:	e0ec      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
   11210:	301b      	adds	r0, #27
   11212:	a903      	add	r1, sp, #12
   11214:	4798      	blx	r3
   11216:	e0e8      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
   11218:	2806      	cmp	r0, #6
   1121a:	d111      	bne.n	11240 <m2m_wifi_cb+0x80>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
   1121c:	1c10      	adds	r0, r2, #0
   1121e:	a903      	add	r1, sp, #12
   11220:	2230      	movs	r2, #48	; 0x30
   11222:	2301      	movs	r3, #1
   11224:	4c72      	ldr	r4, [pc, #456]	; (113f0 <m2m_wifi_cb+0x230>)
   11226:	47a0      	blx	r4
   11228:	2800      	cmp	r0, #0
   1122a:	d000      	beq.n	1122e <m2m_wifi_cb+0x6e>
   1122c:	e0dd      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			if(gpfAppWifiCb)
   1122e:	4b71      	ldr	r3, [pc, #452]	; (113f4 <m2m_wifi_cb+0x234>)
   11230:	681b      	ldr	r3, [r3, #0]
   11232:	2b00      	cmp	r3, #0
   11234:	d100      	bne.n	11238 <m2m_wifi_cb+0x78>
   11236:	e0d8      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
   11238:	3006      	adds	r0, #6
   1123a:	a903      	add	r1, sp, #12
   1123c:	4798      	blx	r3
   1123e:	e0d4      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
   11240:	280e      	cmp	r0, #14
   11242:	d100      	bne.n	11246 <m2m_wifi_cb+0x86>
   11244:	e0d1      	b.n	113ea <m2m_wifi_cb+0x22a>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
   11246:	2832      	cmp	r0, #50	; 0x32
   11248:	d111      	bne.n	1126e <m2m_wifi_cb+0xae>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
   1124a:	1c10      	adds	r0, r2, #0
   1124c:	a903      	add	r1, sp, #12
   1124e:	2210      	movs	r2, #16
   11250:	2300      	movs	r3, #0
   11252:	4c67      	ldr	r4, [pc, #412]	; (113f0 <m2m_wifi_cb+0x230>)
   11254:	47a0      	blx	r4
   11256:	2800      	cmp	r0, #0
   11258:	d000      	beq.n	1125c <m2m_wifi_cb+0x9c>
   1125a:	e0c6      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   1125c:	4b65      	ldr	r3, [pc, #404]	; (113f4 <m2m_wifi_cb+0x234>)
   1125e:	681b      	ldr	r3, [r3, #0]
   11260:	2b00      	cmp	r3, #0
   11262:	d100      	bne.n	11266 <m2m_wifi_cb+0xa6>
   11264:	e0c1      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
   11266:	3032      	adds	r0, #50	; 0x32
   11268:	a903      	add	r1, sp, #12
   1126a:	4798      	blx	r3
   1126c:	e0bd      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
   1126e:	282f      	cmp	r0, #47	; 0x2f
   11270:	d116      	bne.n	112a0 <m2m_wifi_cb+0xe0>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
   11272:	a803      	add	r0, sp, #12
   11274:	2100      	movs	r1, #0
   11276:	2264      	movs	r2, #100	; 0x64
   11278:	4b5f      	ldr	r3, [pc, #380]	; (113f8 <m2m_wifi_cb+0x238>)
   1127a:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
   1127c:	1c28      	adds	r0, r5, #0
   1127e:	a903      	add	r1, sp, #12
   11280:	2264      	movs	r2, #100	; 0x64
   11282:	2300      	movs	r3, #0
   11284:	4c5a      	ldr	r4, [pc, #360]	; (113f0 <m2m_wifi_cb+0x230>)
   11286:	47a0      	blx	r4
   11288:	2800      	cmp	r0, #0
   1128a:	d000      	beq.n	1128e <m2m_wifi_cb+0xce>
   1128c:	e0ad      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   1128e:	4b59      	ldr	r3, [pc, #356]	; (113f4 <m2m_wifi_cb+0x234>)
   11290:	681b      	ldr	r3, [r3, #0]
   11292:	2b00      	cmp	r3, #0
   11294:	d100      	bne.n	11298 <m2m_wifi_cb+0xd8>
   11296:	e0a8      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
   11298:	302f      	adds	r0, #47	; 0x2f
   1129a:	a903      	add	r1, sp, #12
   1129c:	4798      	blx	r3
   1129e:	e0a4      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
   112a0:	2834      	cmp	r0, #52	; 0x34
   112a2:	d123      	bne.n	112ec <m2m_wifi_cb+0x12c>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
   112a4:	1c10      	adds	r0, r2, #0
   112a6:	a903      	add	r1, sp, #12
   112a8:	2204      	movs	r2, #4
   112aa:	2300      	movs	r3, #0
   112ac:	4c50      	ldr	r4, [pc, #320]	; (113f0 <m2m_wifi_cb+0x230>)
   112ae:	47a0      	blx	r4
   112b0:	2800      	cmp	r0, #0
   112b2:	d000      	beq.n	112b6 <m2m_wifi_cb+0xf6>
   112b4:	e099      	b.n	113ea <m2m_wifi_cb+0x22a>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n",
   112b6:	4851      	ldr	r0, [pc, #324]	; (113fc <m2m_wifi_cb+0x23c>)
   112b8:	4d51      	ldr	r5, [pc, #324]	; (11400 <m2m_wifi_cb+0x240>)
   112ba:	47a8      	blx	r5
   112bc:	9803      	ldr	r0, [sp, #12]
   112be:	24ff      	movs	r4, #255	; 0xff
   112c0:	1c21      	adds	r1, r4, #0
   112c2:	4001      	ands	r1, r0
   112c4:	0a02      	lsrs	r2, r0, #8
   112c6:	4022      	ands	r2, r4
   112c8:	0c03      	lsrs	r3, r0, #16
   112ca:	4023      	ands	r3, r4
   112cc:	0e00      	lsrs	r0, r0, #24
   112ce:	9000      	str	r0, [sp, #0]
   112d0:	484c      	ldr	r0, [pc, #304]	; (11404 <m2m_wifi_cb+0x244>)
   112d2:	47a8      	blx	r5
   112d4:	200d      	movs	r0, #13
   112d6:	4b4c      	ldr	r3, [pc, #304]	; (11408 <m2m_wifi_cb+0x248>)
   112d8:	4798      	blx	r3
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
   112da:	4b46      	ldr	r3, [pc, #280]	; (113f4 <m2m_wifi_cb+0x234>)
   112dc:	681b      	ldr	r3, [r3, #0]
   112de:	2b00      	cmp	r3, #0
   112e0:	d100      	bne.n	112e4 <m2m_wifi_cb+0x124>
   112e2:	e082      	b.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
   112e4:	2034      	movs	r0, #52	; 0x34
   112e6:	2100      	movs	r1, #0
   112e8:	4798      	blx	r3
   112ea:	e07e      	b.n	113ea <m2m_wifi_cb+0x22a>

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
   112ec:	2811      	cmp	r0, #17
   112ee:	d116      	bne.n	1131e <m2m_wifi_cb+0x15e>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
   112f0:	2200      	movs	r2, #0
   112f2:	4b46      	ldr	r3, [pc, #280]	; (1140c <m2m_wifi_cb+0x24c>)
   112f4:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
   112f6:	1c28      	adds	r0, r5, #0
   112f8:	a903      	add	r1, sp, #12
   112fa:	3204      	adds	r2, #4
   112fc:	2300      	movs	r3, #0
   112fe:	4c3c      	ldr	r4, [pc, #240]	; (113f0 <m2m_wifi_cb+0x230>)
   11300:	47a0      	blx	r4
   11302:	2800      	cmp	r0, #0
   11304:	d171      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			gu8ChNum = strState.u8NumofCh;
   11306:	ab03      	add	r3, sp, #12
   11308:	781a      	ldrb	r2, [r3, #0]
   1130a:	4b41      	ldr	r3, [pc, #260]	; (11410 <m2m_wifi_cb+0x250>)
   1130c:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
   1130e:	4b39      	ldr	r3, [pc, #228]	; (113f4 <m2m_wifi_cb+0x234>)
   11310:	681b      	ldr	r3, [r3, #0]
   11312:	2b00      	cmp	r3, #0
   11314:	d069      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
   11316:	3011      	adds	r0, #17
   11318:	a903      	add	r1, sp, #12
   1131a:	4798      	blx	r3
   1131c:	e065      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
   1131e:	2813      	cmp	r0, #19
   11320:	d10f      	bne.n	11342 <m2m_wifi_cb+0x182>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
   11322:	1c10      	adds	r0, r2, #0
   11324:	a903      	add	r1, sp, #12
   11326:	222c      	movs	r2, #44	; 0x2c
   11328:	2300      	movs	r3, #0
   1132a:	4c31      	ldr	r4, [pc, #196]	; (113f0 <m2m_wifi_cb+0x230>)
   1132c:	47a0      	blx	r4
   1132e:	2800      	cmp	r0, #0
   11330:	d15b      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   11332:	4b30      	ldr	r3, [pc, #192]	; (113f4 <m2m_wifi_cb+0x234>)
   11334:	681b      	ldr	r3, [r3, #0]
   11336:	2b00      	cmp	r3, #0
   11338:	d057      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
   1133a:	3013      	adds	r0, #19
   1133c:	a903      	add	r1, sp, #12
   1133e:	4798      	blx	r3
   11340:	e053      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
   11342:	2804      	cmp	r0, #4
   11344:	d10f      	bne.n	11366 <m2m_wifi_cb+0x1a6>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
   11346:	1c10      	adds	r0, r2, #0
   11348:	a91c      	add	r1, sp, #112	; 0x70
   1134a:	2204      	movs	r2, #4
   1134c:	2300      	movs	r3, #0
   1134e:	4c28      	ldr	r4, [pc, #160]	; (113f0 <m2m_wifi_cb+0x230>)
   11350:	47a0      	blx	r4
   11352:	2800      	cmp	r0, #0
   11354:	d149      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   11356:	4b27      	ldr	r3, [pc, #156]	; (113f4 <m2m_wifi_cb+0x234>)
   11358:	681b      	ldr	r3, [r3, #0]
   1135a:	2b00      	cmp	r3, #0
   1135c:	d045      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
   1135e:	3004      	adds	r0, #4
   11360:	a91c      	add	r1, sp, #112	; 0x70
   11362:	4798      	blx	r3
   11364:	e041      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
   11366:	2879      	cmp	r0, #121	; 0x79
   11368:	d10f      	bne.n	1138a <m2m_wifi_cb+0x1ca>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
   1136a:	1c10      	adds	r0, r2, #0
   1136c:	a91c      	add	r1, sp, #112	; 0x70
   1136e:	2204      	movs	r2, #4
   11370:	2300      	movs	r3, #0
   11372:	4c1f      	ldr	r4, [pc, #124]	; (113f0 <m2m_wifi_cb+0x230>)
   11374:	47a0      	blx	r4
   11376:	2800      	cmp	r0, #0
   11378:	d137      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			if (gpfAppWifiCb)
   1137a:	4b1e      	ldr	r3, [pc, #120]	; (113f4 <m2m_wifi_cb+0x234>)
   1137c:	681b      	ldr	r3, [r3, #0]
   1137e:	2b00      	cmp	r3, #0
   11380:	d033      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
   11382:	3079      	adds	r0, #121	; 0x79
   11384:	a91c      	add	r1, sp, #112	; 0x70
   11386:	4798      	blx	r3
   11388:	e02f      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
   1138a:	2809      	cmp	r0, #9
   1138c:	d10f      	bne.n	113ae <m2m_wifi_cb+0x1ee>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
   1138e:	1c10      	adds	r0, r2, #0
   11390:	a903      	add	r1, sp, #12
   11392:	2264      	movs	r2, #100	; 0x64
   11394:	2301      	movs	r3, #1
   11396:	4c16      	ldr	r4, [pc, #88]	; (113f0 <m2m_wifi_cb+0x230>)
   11398:	47a0      	blx	r4
   1139a:	2800      	cmp	r0, #0
   1139c:	d125      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			if(gpfAppWifiCb)
   1139e:	4b15      	ldr	r3, [pc, #84]	; (113f4 <m2m_wifi_cb+0x234>)
   113a0:	681b      	ldr	r3, [r3, #0]
   113a2:	2b00      	cmp	r3, #0
   113a4:	d021      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
   113a6:	3009      	adds	r0, #9
   113a8:	a903      	add	r1, sp, #12
   113aa:	4798      	blx	r3
   113ac:	e01d      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
   113ae:	282a      	cmp	r0, #42	; 0x2a
   113b0:	d10f      	bne.n	113d2 <m2m_wifi_cb+0x212>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
   113b2:	1c10      	adds	r0, r2, #0
   113b4:	a903      	add	r1, sp, #12
   113b6:	2204      	movs	r2, #4
   113b8:	2301      	movs	r3, #1
   113ba:	4c0d      	ldr	r4, [pc, #52]	; (113f0 <m2m_wifi_cb+0x230>)
   113bc:	47a0      	blx	r4
   113be:	2800      	cmp	r0, #0
   113c0:	d113      	bne.n	113ea <m2m_wifi_cb+0x22a>
		{
			if(gpfAppWifiCb)
   113c2:	4b0c      	ldr	r3, [pc, #48]	; (113f4 <m2m_wifi_cb+0x234>)
   113c4:	681b      	ldr	r3, [r3, #0]
   113c6:	2b00      	cmp	r3, #0
   113c8:	d00f      	beq.n	113ea <m2m_wifi_cb+0x22a>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
   113ca:	302a      	adds	r0, #42	; 0x2a
   113cc:	a903      	add	r1, sp, #12
   113ce:	4798      	blx	r3
   113d0:	e00b      	b.n	113ea <m2m_wifi_cb+0x22a>
		}
	}
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
   113d2:	4810      	ldr	r0, [pc, #64]	; (11414 <m2m_wifi_cb+0x254>)
   113d4:	4910      	ldr	r1, [pc, #64]	; (11418 <m2m_wifi_cb+0x258>)
   113d6:	2218      	movs	r2, #24
   113d8:	32ff      	adds	r2, #255	; 0xff
   113da:	4d09      	ldr	r5, [pc, #36]	; (11400 <m2m_wifi_cb+0x240>)
   113dc:	47a8      	blx	r5
   113de:	480f      	ldr	r0, [pc, #60]	; (1141c <m2m_wifi_cb+0x25c>)
   113e0:	1c21      	adds	r1, r4, #0
   113e2:	47a8      	blx	r5
   113e4:	200d      	movs	r0, #13
   113e6:	4b08      	ldr	r3, [pc, #32]	; (11408 <m2m_wifi_cb+0x248>)
   113e8:	4798      	blx	r3
	}
}
   113ea:	b01f      	add	sp, #124	; 0x7c
   113ec:	bd30      	pop	{r4, r5, pc}
   113ee:	46c0      	nop			; (mov r8, r8)
   113f0:	00010fd9 	.word	0x00010fd9
   113f4:	2000130c 	.word	0x2000130c
   113f8:	00010981 	.word	0x00010981
   113fc:	000206d4 	.word	0x000206d4
   11400:	00016e3d 	.word	0x00016e3d
   11404:	000206e0 	.word	0x000206e0
   11408:	00016e71 	.word	0x00016e71
   1140c:	20001310 	.word	0x20001310
   11410:	20001311 	.word	0x20001311
   11414:	000203ec 	.word	0x000203ec
   11418:	000206b4 	.word	0x000206b4
   1141c:	00020700 	.word	0x00020700

00011420 <m2m_wifi_init>:
	}	
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
   11420:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	
	if(param == NULL) {
   11422:	2800      	cmp	r0, #0
   11424:	d018      	beq.n	11458 <m2m_wifi_init+0x38>
		ret = M2M_ERR_FAIL;
		goto _EXIT0;
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
   11426:	6802      	ldr	r2, [r0, #0]
   11428:	4b0d      	ldr	r3, [pc, #52]	; (11460 <m2m_wifi_init+0x40>)
   1142a:	601a      	str	r2, [r3, #0]
#endif

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
   1142c:	2200      	movs	r2, #0
   1142e:	4b0d      	ldr	r3, [pc, #52]	; (11464 <m2m_wifi_init+0x44>)
   11430:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(NULL);
   11432:	2000      	movs	r0, #0
   11434:	4b0c      	ldr	r3, [pc, #48]	; (11468 <m2m_wifi_init+0x48>)
   11436:	4798      	blx	r3
   11438:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
   1143a:	d10e      	bne.n	1145a <m2m_wifi_init+0x3a>
	/* Initialize host interface module */
	ret = hif_init(NULL);
   1143c:	2000      	movs	r0, #0
   1143e:	4b0b      	ldr	r3, [pc, #44]	; (1146c <m2m_wifi_init+0x4c>)
   11440:	4798      	blx	r3
   11442:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
   11444:	d104      	bne.n	11450 <m2m_wifi_init+0x30>

	hif_register_cb(M2M_REQ_GRP_WIFI,m2m_wifi_cb);
   11446:	2001      	movs	r0, #1
   11448:	4909      	ldr	r1, [pc, #36]	; (11470 <m2m_wifi_init+0x50>)
   1144a:	4b0a      	ldr	r3, [pc, #40]	; (11474 <m2m_wifi_init+0x54>)
   1144c:	4798      	blx	r3

	goto _EXIT0;
   1144e:	e004      	b.n	1145a <m2m_wifi_init+0x3a>

_EXIT1:
	nm_drv_deinit(NULL);
   11450:	2000      	movs	r0, #0
   11452:	4b09      	ldr	r3, [pc, #36]	; (11478 <m2m_wifi_init+0x58>)
   11454:	4798      	blx	r3
   11456:	e000      	b.n	1145a <m2m_wifi_init+0x3a>
sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
	sint8 ret = M2M_SUCCESS;
	
	if(param == NULL) {
		ret = M2M_ERR_FAIL;
   11458:	24f4      	movs	r4, #244	; 0xf4
	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
   1145a:	b260      	sxtb	r0, r4
}
   1145c:	bd10      	pop	{r4, pc}
   1145e:	46c0      	nop			; (mov r8, r8)
   11460:	2000130c 	.word	0x2000130c
   11464:	20001310 	.word	0x20001310
   11468:	00011cfd 	.word	0x00011cfd
   1146c:	00011171 	.word	0x00011171
   11470:	000111c1 	.word	0x000111c1
   11474:	000110f5 	.word	0x000110f5
   11478:	00011e59 	.word	0x00011e59

0001147c <m2m_wifi_handle_events>:
	return M2M_SUCCESS;
}


sint8 m2m_wifi_handle_events(void * arg)
{
   1147c:	b508      	push	{r3, lr}
	return hif_handle_isr();
   1147e:	4b01      	ldr	r3, [pc, #4]	; (11484 <m2m_wifi_handle_events+0x8>)
   11480:	4798      	blx	r3
}
   11482:	bd08      	pop	{r3, pc}
   11484:	00010cb1 	.word	0x00010cb1

00011488 <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
   11488:	b5f0      	push	{r4, r5, r6, r7, lr}
   1148a:	464f      	mov	r7, r9
   1148c:	4646      	mov	r6, r8
   1148e:	b4c0      	push	{r6, r7}
   11490:	b0a3      	sub	sp, #140	; 0x8c
   11492:	9005      	str	r0, [sp, #20]
   11494:	1c0c      	adds	r4, r1, #0
   11496:	1c15      	adds	r5, r2, #0
   11498:	1c1f      	adds	r7, r3, #0
   1149a:	ab2a      	add	r3, sp, #168	; 0xa8
   1149c:	881b      	ldrh	r3, [r3, #0]
   1149e:	4699      	mov	r9, r3
   114a0:	ab2b      	add	r3, sp, #172	; 0xac
   114a2:	781b      	ldrb	r3, [r3, #0]
   114a4:	4698      	mov	r8, r3
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
   114a6:	2a01      	cmp	r2, #1
   114a8:	d00f      	beq.n	114ca <m2m_wifi_connect_sc+0x42>
	{
		if(pvAuthInfo == NULL)
   114aa:	2f00      	cmp	r7, #0
   114ac:	d10d      	bne.n	114ca <m2m_wifi_connect_sc+0x42>
		{
			M2M_ERR("Key is not valid\n");
   114ae:	4865      	ldr	r0, [pc, #404]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   114b0:	4965      	ldr	r1, [pc, #404]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   114b2:	22e4      	movs	r2, #228	; 0xe4
   114b4:	32ff      	adds	r2, #255	; 0xff
   114b6:	4b65      	ldr	r3, [pc, #404]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   114b8:	4798      	blx	r3
   114ba:	4865      	ldr	r0, [pc, #404]	; (11650 <m2m_wifi_connect_sc+0x1c8>)
   114bc:	4b65      	ldr	r3, [pc, #404]	; (11654 <m2m_wifi_connect_sc+0x1cc>)
   114be:	4798      	blx	r3
   114c0:	200d      	movs	r0, #13
   114c2:	4b65      	ldr	r3, [pc, #404]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   114c4:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   114c6:	20f4      	movs	r0, #244	; 0xf4
			goto ERR1;
   114c8:	e0b5      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
   114ca:	1e63      	subs	r3, r4, #1
   114cc:	2b1f      	cmp	r3, #31
   114ce:	d90d      	bls.n	114ec <m2m_wifi_connect_sc+0x64>
	{
		M2M_ERR("SSID LEN INVALID\n");
   114d0:	485c      	ldr	r0, [pc, #368]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   114d2:	495d      	ldr	r1, [pc, #372]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   114d4:	22f5      	movs	r2, #245	; 0xf5
   114d6:	0052      	lsls	r2, r2, #1
   114d8:	4b5c      	ldr	r3, [pc, #368]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   114da:	4798      	blx	r3
   114dc:	485f      	ldr	r0, [pc, #380]	; (1165c <m2m_wifi_connect_sc+0x1d4>)
   114de:	4b5d      	ldr	r3, [pc, #372]	; (11654 <m2m_wifi_connect_sc+0x1cc>)
   114e0:	4798      	blx	r3
   114e2:	200d      	movs	r0, #13
   114e4:	4b5c      	ldr	r3, [pc, #368]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   114e6:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
   114e8:	20f4      	movs	r0, #244	; 0xf4
		goto ERR1;
   114ea:	e0a4      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
	}

	if(u16Ch>M2M_WIFI_CH_14)
   114ec:	464b      	mov	r3, r9
   114ee:	2b0d      	cmp	r3, #13
   114f0:	d90f      	bls.n	11512 <m2m_wifi_connect_sc+0x8a>
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
   114f2:	2bff      	cmp	r3, #255	; 0xff
   114f4:	d00d      	beq.n	11512 <m2m_wifi_connect_sc+0x8a>
		{
			M2M_ERR("CH INVALID\n");
   114f6:	4853      	ldr	r0, [pc, #332]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   114f8:	4953      	ldr	r1, [pc, #332]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   114fa:	22f4      	movs	r2, #244	; 0xf4
   114fc:	32ff      	adds	r2, #255	; 0xff
   114fe:	4b53      	ldr	r3, [pc, #332]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   11500:	4798      	blx	r3
   11502:	4857      	ldr	r0, [pc, #348]	; (11660 <m2m_wifi_connect_sc+0x1d8>)
   11504:	4b53      	ldr	r3, [pc, #332]	; (11654 <m2m_wifi_connect_sc+0x1cc>)
   11506:	4798      	blx	r3
   11508:	200d      	movs	r0, #13
   1150a:	4b53      	ldr	r3, [pc, #332]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   1150c:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   1150e:	20f4      	movs	r0, #244	; 0xf4
			goto ERR1;
   11510:	e091      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
		}
	}


	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
   11512:	ae07      	add	r6, sp, #28
   11514:	205a      	movs	r0, #90	; 0x5a
   11516:	ab02      	add	r3, sp, #8
   11518:	469c      	mov	ip, r3
   1151a:	4460      	add	r0, ip
   1151c:	9905      	ldr	r1, [sp, #20]
   1151e:	1c22      	adds	r2, r4, #0
   11520:	4b50      	ldr	r3, [pc, #320]	; (11664 <m2m_wifi_connect_sc+0x1dc>)
   11522:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
   11524:	1934      	adds	r4, r6, r4
   11526:	3440      	adds	r4, #64	; 0x40
   11528:	2300      	movs	r3, #0
   1152a:	71a3      	strb	r3, [r4, #6]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
   1152c:	3344      	adds	r3, #68	; 0x44
   1152e:	464a      	mov	r2, r9
   11530:	52f2      	strh	r2, [r6, r3]
	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
   11532:	4643      	mov	r3, r8
   11534:	1e5a      	subs	r2, r3, #1
   11536:	4193      	sbcs	r3, r2
   11538:	2267      	movs	r2, #103	; 0x67
   1153a:	54b3      	strb	r3, [r6, r2]
	pstrAuthInfo = &strConnect.strSec;
	pstrAuthInfo->u8SecType		= u8SecType;
   1153c:	2341      	movs	r3, #65	; 0x41
   1153e:	54f5      	strb	r5, [r6, r3]

	if(u8SecType == M2M_WIFI_SEC_WEP)
   11540:	2d03      	cmp	r5, #3
   11542:	d139      	bne.n	115b8 <m2m_wifi_connect_sc+0x130>
	{
		tstrM2mWifiWepParams	* pstrWepParams = (tstrM2mWifiWepParams*)pvAuthInfo;
		tstrM2mWifiWepParams	*pstrWep = &pstrAuthInfo->uniAuth.strWepInfo;
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
   11544:	783b      	ldrb	r3, [r7, #0]
   11546:	3b01      	subs	r3, #1
   11548:	b2db      	uxtb	r3, r3
   1154a:	aa07      	add	r2, sp, #28
   1154c:	7013      	strb	r3, [r2, #0]

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
   1154e:	2b03      	cmp	r3, #3
   11550:	d90d      	bls.n	1156e <m2m_wifi_connect_sc+0xe6>
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
   11552:	483c      	ldr	r0, [pc, #240]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   11554:	493c      	ldr	r1, [pc, #240]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   11556:	4a44      	ldr	r2, [pc, #272]	; (11668 <m2m_wifi_connect_sc+0x1e0>)
   11558:	4c3c      	ldr	r4, [pc, #240]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   1155a:	47a0      	blx	r4
   1155c:	ab07      	add	r3, sp, #28
   1155e:	7819      	ldrb	r1, [r3, #0]
   11560:	4842      	ldr	r0, [pc, #264]	; (1166c <m2m_wifi_connect_sc+0x1e4>)
   11562:	47a0      	blx	r4
   11564:	200d      	movs	r0, #13
   11566:	4b3c      	ldr	r3, [pc, #240]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   11568:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   1156a:	20f4      	movs	r0, #244	; 0xf4
			goto ERR1;
   1156c:	e063      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
   1156e:	787a      	ldrb	r2, [r7, #1]
   11570:	1e51      	subs	r1, r2, #1
   11572:	ab07      	add	r3, sp, #28
   11574:	7059      	strb	r1, [r3, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
   11576:	2310      	movs	r3, #16
   11578:	1c11      	adds	r1, r2, #0
   1157a:	4399      	bics	r1, r3
   1157c:	290b      	cmp	r1, #11
   1157e:	d00d      	beq.n	1159c <m2m_wifi_connect_sc+0x114>
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
   11580:	4830      	ldr	r0, [pc, #192]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   11582:	4931      	ldr	r1, [pc, #196]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   11584:	4a3a      	ldr	r2, [pc, #232]	; (11670 <m2m_wifi_connect_sc+0x1e8>)
   11586:	4c31      	ldr	r4, [pc, #196]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   11588:	47a0      	blx	r4
   1158a:	ab07      	add	r3, sp, #28
   1158c:	7859      	ldrb	r1, [r3, #1]
   1158e:	4839      	ldr	r0, [pc, #228]	; (11674 <m2m_wifi_connect_sc+0x1ec>)
   11590:	47a0      	blx	r4
   11592:	200d      	movs	r0, #13
   11594:	4b30      	ldr	r3, [pc, #192]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   11596:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   11598:	20f4      	movs	r0, #244	; 0xf4
			goto ERR1;
   1159a:	e04c      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
		}
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
   1159c:	1cb9      	adds	r1, r7, #2
   1159e:	2016      	movs	r0, #22
   115a0:	ab02      	add	r3, sp, #8
   115a2:	469c      	mov	ip, r3
   115a4:	4460      	add	r0, ip
   115a6:	4b2f      	ldr	r3, [pc, #188]	; (11664 <m2m_wifi_connect_sc+0x1dc>)
   115a8:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
   115aa:	787b      	ldrb	r3, [r7, #1]
   115ac:	aa07      	add	r2, sp, #28
   115ae:	4694      	mov	ip, r2
   115b0:	4463      	add	r3, ip
   115b2:	2200      	movs	r2, #0
   115b4:	709a      	strb	r2, [r3, #2]
   115b6:	e034      	b.n	11622 <m2m_wifi_connect_sc+0x19a>

	}


	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
   115b8:	2d02      	cmp	r5, #2
   115ba:	d11a      	bne.n	115f2 <m2m_wifi_connect_sc+0x16a>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
   115bc:	1c38      	adds	r0, r7, #0
   115be:	4b2e      	ldr	r3, [pc, #184]	; (11678 <m2m_wifi_connect_sc+0x1f0>)
   115c0:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
   115c2:	1e43      	subs	r3, r0, #1
   115c4:	b29b      	uxth	r3, r3
   115c6:	2b3f      	cmp	r3, #63	; 0x3f
   115c8:	d90d      	bls.n	115e6 <m2m_wifi_connect_sc+0x15e>
		{
			M2M_ERR("Incorrect PSK key length\n");
   115ca:	481e      	ldr	r0, [pc, #120]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   115cc:	491e      	ldr	r1, [pc, #120]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   115ce:	2288      	movs	r2, #136	; 0x88
   115d0:	0092      	lsls	r2, r2, #2
   115d2:	4b1e      	ldr	r3, [pc, #120]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   115d4:	4798      	blx	r3
   115d6:	4829      	ldr	r0, [pc, #164]	; (1167c <m2m_wifi_connect_sc+0x1f4>)
   115d8:	4b1e      	ldr	r3, [pc, #120]	; (11654 <m2m_wifi_connect_sc+0x1cc>)
   115da:	4798      	blx	r3
   115dc:	200d      	movs	r0, #13
   115de:	4b1e      	ldr	r3, [pc, #120]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   115e0:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
   115e2:	20f4      	movs	r0, #244	; 0xf4
			goto ERR1;
   115e4:	e027      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
		}
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
   115e6:	1c42      	adds	r2, r0, #1
   115e8:	a807      	add	r0, sp, #28
   115ea:	1c39      	adds	r1, r7, #0
   115ec:	4b1d      	ldr	r3, [pc, #116]	; (11664 <m2m_wifi_connect_sc+0x1dc>)
   115ee:	4798      	blx	r3
   115f0:	e017      	b.n	11622 <m2m_wifi_connect_sc+0x19a>
	}
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
   115f2:	2d04      	cmp	r5, #4
   115f4:	d105      	bne.n	11602 <m2m_wifi_connect_sc+0x17a>
	{
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
   115f6:	a807      	add	r0, sp, #28
   115f8:	1c39      	adds	r1, r7, #0
   115fa:	223e      	movs	r2, #62	; 0x3e
   115fc:	4b19      	ldr	r3, [pc, #100]	; (11664 <m2m_wifi_connect_sc+0x1dc>)
   115fe:	4798      	blx	r3
   11600:	e00f      	b.n	11622 <m2m_wifi_connect_sc+0x19a>
	}
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
   11602:	2d01      	cmp	r5, #1
   11604:	d00d      	beq.n	11622 <m2m_wifi_connect_sc+0x19a>
	{

	}
	else
	{
		M2M_ERR("undefined sec type\n");
   11606:	480f      	ldr	r0, [pc, #60]	; (11644 <m2m_wifi_connect_sc+0x1bc>)
   11608:	490f      	ldr	r1, [pc, #60]	; (11648 <m2m_wifi_connect_sc+0x1c0>)
   1160a:	228c      	movs	r2, #140	; 0x8c
   1160c:	0092      	lsls	r2, r2, #2
   1160e:	4b0f      	ldr	r3, [pc, #60]	; (1164c <m2m_wifi_connect_sc+0x1c4>)
   11610:	4798      	blx	r3
   11612:	481b      	ldr	r0, [pc, #108]	; (11680 <m2m_wifi_connect_sc+0x1f8>)
   11614:	4b0f      	ldr	r3, [pc, #60]	; (11654 <m2m_wifi_connect_sc+0x1cc>)
   11616:	4798      	blx	r3
   11618:	200d      	movs	r0, #13
   1161a:	4b0f      	ldr	r3, [pc, #60]	; (11658 <m2m_wifi_connect_sc+0x1d0>)
   1161c:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
   1161e:	20f4      	movs	r0, #244	; 0xf4
		goto ERR1;
   11620:	e009      	b.n	11636 <m2m_wifi_connect_sc+0x1ae>
	}

	ret = hif_send(M2M_REQ_GRP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
   11622:	2300      	movs	r3, #0
   11624:	9300      	str	r3, [sp, #0]
   11626:	9301      	str	r3, [sp, #4]
   11628:	9302      	str	r3, [sp, #8]
   1162a:	2001      	movs	r0, #1
   1162c:	2128      	movs	r1, #40	; 0x28
   1162e:	aa07      	add	r2, sp, #28
   11630:	336c      	adds	r3, #108	; 0x6c
   11632:	4c14      	ldr	r4, [pc, #80]	; (11684 <m2m_wifi_connect_sc+0x1fc>)
   11634:	47a0      	blx	r4

ERR1:
	return ret;
   11636:	b240      	sxtb	r0, r0
}
   11638:	b023      	add	sp, #140	; 0x8c
   1163a:	bc0c      	pop	{r2, r3}
   1163c:	4690      	mov	r8, r2
   1163e:	4699      	mov	r9, r3
   11640:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11642:	46c0      	nop			; (mov r8, r8)
   11644:	000203ec 	.word	0x000203ec
   11648:	000206c0 	.word	0x000206c0
   1164c:	00016e3d 	.word	0x00016e3d
   11650:	000207ac 	.word	0x000207ac
   11654:	00016f5d 	.word	0x00016f5d
   11658:	00016e71 	.word	0x00016e71
   1165c:	000207c0 	.word	0x000207c0
   11660:	000207d4 	.word	0x000207d4
   11664:	0001096d 	.word	0x0001096d
   11668:	0000020a 	.word	0x0000020a
   1166c:	000207e0 	.word	0x000207e0
   11670:	00000211 	.word	0x00000211
   11674:	000207fc 	.word	0x000207fc
   11678:	00010991 	.word	0x00010991
   1167c:	00020818 	.word	0x00020818
   11680:	00020834 	.word	0x00020834
   11684:	00010ad1 	.word	0x00010ad1

00011688 <m2m_wifi_connect>:
{
	return hif_send(M2M_REQ_GRP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
}

sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
   11688:	b510      	push	{r4, lr}
   1168a:	b082      	sub	sp, #8
   1168c:	ac04      	add	r4, sp, #16
   1168e:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
   11690:	9400      	str	r4, [sp, #0]
   11692:	2400      	movs	r4, #0
   11694:	9401      	str	r4, [sp, #4]
   11696:	4c02      	ldr	r4, [pc, #8]	; (116a0 <m2m_wifi_connect+0x18>)
   11698:	47a0      	blx	r4
}
   1169a:	b002      	add	sp, #8
   1169c:	bd10      	pop	{r4, pc}
   1169e:	46c0      	nop			; (mov r8, r8)
   116a0:	00011489 	.word	0x00011489

000116a4 <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
   116a4:	2000      	movs	r0, #0
   116a6:	4770      	bx	lr

000116a8 <chip_apply_conf>:
#define M2M_DISABLE_PS        0xD0UL

static uint32 clk_status_reg_adr = 0xf; /* Assume initially it is B0 chip */

sint8 chip_apply_conf(uint32 u32Conf)
{
   116a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   116aa:	b083      	sub	sp, #12
   116ac:	1c04      	adds	r4, r0, #0
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
   116ae:	25a5      	movs	r5, #165	; 0xa5
   116b0:	016d      	lsls	r5, r5, #5
   116b2:	4e0a      	ldr	r6, [pc, #40]	; (116dc <chip_apply_conf+0x34>)
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
   116b4:	4f0a      	ldr	r7, [pc, #40]	; (116e0 <chip_apply_conf+0x38>)
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
   116b6:	1c28      	adds	r0, r5, #0
   116b8:	1c21      	adds	r1, r4, #0
   116ba:	47b0      	blx	r6
		if(val32 != 0) {		
   116bc:	2c00      	cmp	r4, #0
   116be:	d009      	beq.n	116d4 <chip_apply_conf+0x2c>
			uint32 reg = 0;
   116c0:	2300      	movs	r3, #0
   116c2:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
   116c4:	1c28      	adds	r0, r5, #0
   116c6:	a901      	add	r1, sp, #4
   116c8:	47b8      	blx	r7
			if(ret == M2M_SUCCESS) {
   116ca:	2800      	cmp	r0, #0
   116cc:	d1f3      	bne.n	116b6 <chip_apply_conf+0xe>
				if(reg == val32)
   116ce:	9b01      	ldr	r3, [sp, #4]
   116d0:	429c      	cmp	r4, r3
   116d2:	d1f0      	bne.n	116b6 <chip_apply_conf+0xe>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
   116d4:	2000      	movs	r0, #0
   116d6:	b003      	add	sp, #12
   116d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   116da:	46c0      	nop			; (mov r8, r8)
   116dc:	00011b85 	.word	0x00011b85
   116e0:	00011b79 	.word	0x00011b79

000116e4 <nm_clkless_wake>:
*	@author	Samer Sarhan
*	@date	06 June 2014
*	@version	1.0
*/
sint8 nm_clkless_wake(void)
{
   116e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   116e6:	465f      	mov	r7, fp
   116e8:	4656      	mov	r6, sl
   116ea:	4645      	mov	r5, r8
   116ec:	b4e0      	push	{r5, r6, r7}
   116ee:	b084      	sub	sp, #16
	sint8 ret = M2M_SUCCESS;
	uint32 reg, clk_status_reg,trials = 0;
	/* wait 1ms, spi data read */
	nm_bsp_sleep(1);
   116f0:	2001      	movs	r0, #1
   116f2:	4b3c      	ldr	r3, [pc, #240]	; (117e4 <nm_clkless_wake+0x100>)
   116f4:	4798      	blx	r3
	ret = nm_read_reg_with_ret(0x1, &reg);
   116f6:	2001      	movs	r0, #1
   116f8:	a903      	add	r1, sp, #12
   116fa:	4b3b      	ldr	r3, [pc, #236]	; (117e8 <nm_clkless_wake+0x104>)
   116fc:	4798      	blx	r3
   116fe:	9001      	str	r0, [sp, #4]
   11700:	2400      	movs	r4, #0
	if(ret != M2M_SUCCESS) {
   11702:	2800      	cmp	r0, #0
   11704:	d00b      	beq.n	1171e <nm_clkless_wake+0x3a>
		M2M_ERR("Bus error (1). Wake up failed\n");
   11706:	4839      	ldr	r0, [pc, #228]	; (117ec <nm_clkless_wake+0x108>)
   11708:	4939      	ldr	r1, [pc, #228]	; (117f0 <nm_clkless_wake+0x10c>)
   1170a:	2271      	movs	r2, #113	; 0x71
   1170c:	4b39      	ldr	r3, [pc, #228]	; (117f4 <nm_clkless_wake+0x110>)
   1170e:	4798      	blx	r3
   11710:	4839      	ldr	r0, [pc, #228]	; (117f8 <nm_clkless_wake+0x114>)
   11712:	4b3a      	ldr	r3, [pc, #232]	; (117fc <nm_clkless_wake+0x118>)
   11714:	4798      	blx	r3
   11716:	200d      	movs	r0, #13
   11718:	4b39      	ldr	r3, [pc, #228]	; (11800 <nm_clkless_wake+0x11c>)
   1171a:	4798      	blx	r3
		goto _WAKE_EXIT;
   1171c:	e059      	b.n	117d2 <nm_clkless_wake+0xee>
	 * If A0, then clks_enabled bit exists in register 0xe
	 */
	do
	{
		/* Set bit 1 */
		nm_write_reg(0x1, reg | (1 << 1));
   1171e:	4b39      	ldr	r3, [pc, #228]	; (11804 <nm_clkless_wake+0x120>)
   11720:	469b      	mov	fp, r3
		/* wait 1ms, spi data read */
		nm_bsp_sleep(1);
   11722:	4b30      	ldr	r3, [pc, #192]	; (117e4 <nm_clkless_wake+0x100>)
   11724:	469a      	mov	sl, r3
		// Check the clock status
		ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   11726:	4b38      	ldr	r3, [pc, #224]	; (11808 <nm_clkless_wake+0x124>)
   11728:	4698      	mov	r8, r3
	 * If A0, then clks_enabled bit exists in register 0xe
	 */
	do
	{
		/* Set bit 1 */
		nm_write_reg(0x1, reg | (1 << 1));
   1172a:	2102      	movs	r1, #2
   1172c:	9b03      	ldr	r3, [sp, #12]
   1172e:	4319      	orrs	r1, r3
   11730:	2001      	movs	r0, #1
   11732:	47d8      	blx	fp
		/* wait 1ms, spi data read */
		nm_bsp_sleep(1);
   11734:	2001      	movs	r0, #1
   11736:	47d0      	blx	sl
		// Check the clock status
		ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   11738:	4643      	mov	r3, r8
   1173a:	6818      	ldr	r0, [r3, #0]
   1173c:	a902      	add	r1, sp, #8
   1173e:	4b2a      	ldr	r3, [pc, #168]	; (117e8 <nm_clkless_wake+0x104>)
   11740:	4798      	blx	r3
		if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
   11742:	2800      	cmp	r0, #0
   11744:	d106      	bne.n	11754 <nm_clkless_wake+0x70>
   11746:	9b02      	ldr	r3, [sp, #8]
   11748:	2b00      	cmp	r3, #0
   1174a:	d003      	beq.n	11754 <nm_clkless_wake+0x70>
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
   1174c:	4d2f      	ldr	r5, [pc, #188]	; (1180c <nm_clkless_wake+0x128>)
		{
			/* Wait for the chip to stabilize*/
			nm_bsp_sleep(2);
   1174e:	4f25      	ldr	r7, [pc, #148]	; (117e4 <nm_clkless_wake+0x100>)

			// Make sure chip is awake. This is an extra step that can be removed
			// later to avoid the bus access overhead
			nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   11750:	4e2d      	ldr	r6, [pc, #180]	; (11808 <nm_clkless_wake+0x124>)
   11752:	e02c      	b.n	117ae <nm_clkless_wake+0xca>
		if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
			/* Register 0xf did not exist in A0.
			 * If register 0xf fails to read or if it reads 0,
			 * then the chip is A0.
			 */
			clk_status_reg_adr = 0xe;
   11754:	4d2c      	ldr	r5, [pc, #176]	; (11808 <nm_clkless_wake+0x124>)
   11756:	230e      	movs	r3, #14
   11758:	602b      	str	r3, [r5, #0]
			/* wait 1ms, spi data read */
			nm_bsp_sleep(1);
   1175a:	2001      	movs	r0, #1
   1175c:	4b21      	ldr	r3, [pc, #132]	; (117e4 <nm_clkless_wake+0x100>)
   1175e:	4798      	blx	r3
			ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   11760:	6828      	ldr	r0, [r5, #0]
   11762:	a902      	add	r1, sp, #8
   11764:	4b20      	ldr	r3, [pc, #128]	; (117e8 <nm_clkless_wake+0x104>)
   11766:	4798      	blx	r3
   11768:	1e05      	subs	r5, r0, #0
			if(ret != M2M_SUCCESS) {
   1176a:	d0ef      	beq.n	1174c <nm_clkless_wake+0x68>
				M2M_ERR("Bus error (2). Wake up failed\n");
   1176c:	481f      	ldr	r0, [pc, #124]	; (117ec <nm_clkless_wake+0x108>)
   1176e:	4920      	ldr	r1, [pc, #128]	; (117f0 <nm_clkless_wake+0x10c>)
   11770:	228b      	movs	r2, #139	; 0x8b
   11772:	4b20      	ldr	r3, [pc, #128]	; (117f4 <nm_clkless_wake+0x110>)
   11774:	4798      	blx	r3
   11776:	4826      	ldr	r0, [pc, #152]	; (11810 <nm_clkless_wake+0x12c>)
   11778:	4b20      	ldr	r3, [pc, #128]	; (117fc <nm_clkless_wake+0x118>)
   1177a:	4798      	blx	r3
   1177c:	200d      	movs	r0, #13
   1177e:	4b20      	ldr	r3, [pc, #128]	; (11800 <nm_clkless_wake+0x11c>)
   11780:	4798      	blx	r3
			 * then the chip is A0.
			 */
			clk_status_reg_adr = 0xe;
			/* wait 1ms, spi data read */
			nm_bsp_sleep(1);
			ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   11782:	9501      	str	r5, [sp, #4]
			if(ret != M2M_SUCCESS) {
				M2M_ERR("Bus error (2). Wake up failed\n");
				goto _WAKE_EXIT;
   11784:	e025      	b.n	117d2 <nm_clkless_wake+0xee>
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
		{
			/* Wait for the chip to stabilize*/
			nm_bsp_sleep(2);
   11786:	2002      	movs	r0, #2
   11788:	47b8      	blx	r7

			// Make sure chip is awake. This is an extra step that can be removed
			// later to avoid the bus access overhead
			nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
   1178a:	6830      	ldr	r0, [r6, #0]
   1178c:	a902      	add	r1, sp, #8
   1178e:	4b16      	ldr	r3, [pc, #88]	; (117e8 <nm_clkless_wake+0x104>)
   11790:	4798      	blx	r3

			if((clk_status_reg & 0x4) == 0)
   11792:	9b02      	ldr	r3, [sp, #8]
   11794:	075b      	lsls	r3, r3, #29
   11796:	d40a      	bmi.n	117ae <nm_clkless_wake+0xca>
			{
				M2M_ERR("clocks still OFF. Wake up failed\n");
   11798:	4814      	ldr	r0, [pc, #80]	; (117ec <nm_clkless_wake+0x108>)
   1179a:	4915      	ldr	r1, [pc, #84]	; (117f0 <nm_clkless_wake+0x10c>)
   1179c:	229e      	movs	r2, #158	; 0x9e
   1179e:	4b15      	ldr	r3, [pc, #84]	; (117f4 <nm_clkless_wake+0x110>)
   117a0:	4798      	blx	r3
   117a2:	481c      	ldr	r0, [pc, #112]	; (11814 <nm_clkless_wake+0x130>)
   117a4:	4b15      	ldr	r3, [pc, #84]	; (117fc <nm_clkless_wake+0x118>)
   117a6:	4798      	blx	r3
   117a8:	200d      	movs	r0, #13
   117aa:	4b15      	ldr	r3, [pc, #84]	; (11800 <nm_clkless_wake+0x11c>)
   117ac:	4798      	blx	r3
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
   117ae:	9b02      	ldr	r3, [sp, #8]
   117b0:	075b      	lsls	r3, r3, #29
   117b2:	d40e      	bmi.n	117d2 <nm_clkless_wake+0xee>
   117b4:	3401      	adds	r4, #1
   117b6:	1c20      	adds	r0, r4, #0
   117b8:	2103      	movs	r1, #3
   117ba:	47a8      	blx	r5
   117bc:	2900      	cmp	r1, #0
   117be:	d0e2      	beq.n	11786 <nm_clkless_wake+0xa2>
		}
		// in case of failure, Reset the wakeup bit to introduce a new edge on the next loop
		if((clk_status_reg & 0x4) == 0)
		{
			// Reset bit 0
			nm_write_reg(0x1, reg | (1 << 1));
   117c0:	2102      	movs	r1, #2
   117c2:	9b03      	ldr	r3, [sp, #12]
   117c4:	4319      	orrs	r1, r3
   117c6:	2001      	movs	r0, #1
   117c8:	4b0e      	ldr	r3, [pc, #56]	; (11804 <nm_clkless_wake+0x120>)
   117ca:	4798      	blx	r3
		}
	} while((clk_status_reg & 0x4) == 0);
   117cc:	9b02      	ldr	r3, [sp, #8]
   117ce:	075b      	lsls	r3, r3, #29
   117d0:	d5ab      	bpl.n	1172a <nm_clkless_wake+0x46>

_WAKE_EXIT:
	return ret;
   117d2:	466b      	mov	r3, sp
   117d4:	2004      	movs	r0, #4
   117d6:	5618      	ldrsb	r0, [r3, r0]
}
   117d8:	b004      	add	sp, #16
   117da:	bc1c      	pop	{r2, r3, r4}
   117dc:	4690      	mov	r8, r2
   117de:	469a      	mov	sl, r3
   117e0:	46a3      	mov	fp, r4
   117e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   117e4:	000105d5 	.word	0x000105d5
   117e8:	00011b79 	.word	0x00011b79
   117ec:	000203ec 	.word	0x000203ec
   117f0:	00020930 	.word	0x00020930
   117f4:	00016e3d 	.word	0x00016e3d
   117f8:	00020940 	.word	0x00020940
   117fc:	00016f5d 	.word	0x00016f5d
   11800:	00016e71 	.word	0x00016e71
   11804:	00011b85 	.word	0x00011b85
   11808:	2000026c 	.word	0x2000026c
   1180c:	00014fa9 	.word	0x00014fa9
   11810:	00020960 	.word	0x00020960
   11814:	00020980 	.word	0x00020980

00011818 <enable_interrupts>:
	nm_write_reg(0x6, 0x0);
	nm_write_reg(0x7, 0x0);
}

sint8 enable_interrupts(void)
{
   11818:	b500      	push	{lr}
   1181a:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
   1181c:	4816      	ldr	r0, [pc, #88]	; (11878 <enable_interrupts+0x60>)
   1181e:	a901      	add	r1, sp, #4
   11820:	4b16      	ldr	r3, [pc, #88]	; (1187c <enable_interrupts+0x64>)
   11822:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
   11824:	2800      	cmp	r0, #0
   11826:	d11c      	bne.n	11862 <enable_interrupts+0x4a>
		return M2M_ERR_BUS_FAIL;
	}
	reg |= ((uint32) 1 << 8);
   11828:	2180      	movs	r1, #128	; 0x80
   1182a:	0049      	lsls	r1, r1, #1
   1182c:	9b01      	ldr	r3, [sp, #4]
   1182e:	4319      	orrs	r1, r3
   11830:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
   11832:	4811      	ldr	r0, [pc, #68]	; (11878 <enable_interrupts+0x60>)
   11834:	4b12      	ldr	r3, [pc, #72]	; (11880 <enable_interrupts+0x68>)
   11836:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
   11838:	2800      	cmp	r0, #0
   1183a:	d114      	bne.n	11866 <enable_interrupts+0x4e>
		return M2M_ERR_BUS_FAIL;
	}
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
   1183c:	20d0      	movs	r0, #208	; 0xd0
   1183e:	0140      	lsls	r0, r0, #5
   11840:	a901      	add	r1, sp, #4
   11842:	4b0e      	ldr	r3, [pc, #56]	; (1187c <enable_interrupts+0x64>)
   11844:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
   11846:	2800      	cmp	r0, #0
   11848:	d10f      	bne.n	1186a <enable_interrupts+0x52>
		return M2M_ERR_BUS_FAIL;
	}
	reg |= ((uint32) 1 << 16);
   1184a:	2180      	movs	r1, #128	; 0x80
   1184c:	0249      	lsls	r1, r1, #9
   1184e:	9b01      	ldr	r3, [sp, #4]
   11850:	4319      	orrs	r1, r3
   11852:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
   11854:	20d0      	movs	r0, #208	; 0xd0
   11856:	0140      	lsls	r0, r0, #5
   11858:	4b09      	ldr	r3, [pc, #36]	; (11880 <enable_interrupts+0x68>)
   1185a:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
   1185c:	2800      	cmp	r0, #0
   1185e:	d106      	bne.n	1186e <enable_interrupts+0x56>
   11860:	e006      	b.n	11870 <enable_interrupts+0x58>
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
   11862:	20fa      	movs	r0, #250	; 0xfa
   11864:	e004      	b.n	11870 <enable_interrupts+0x58>
	}
	reg |= ((uint32) 1 << 8);
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
   11866:	20fa      	movs	r0, #250	; 0xfa
   11868:	e002      	b.n	11870 <enable_interrupts+0x58>
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
   1186a:	20fa      	movs	r0, #250	; 0xfa
   1186c:	e000      	b.n	11870 <enable_interrupts+0x58>
	}
	reg |= ((uint32) 1 << 16);
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
   1186e:	20fa      	movs	r0, #250	; 0xfa
   11870:	b240      	sxtb	r0, r0
	}
	return M2M_SUCCESS;
}
   11872:	b003      	add	sp, #12
   11874:	bd00      	pop	{pc}
   11876:	46c0      	nop			; (mov r8, r8)
   11878:	00001408 	.word	0x00001408
   1187c:	00011b79 	.word	0x00011b79
   11880:	00011b85 	.word	0x00011b85

00011884 <nmi_get_chipid>:
	nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
	return ret;
}

uint32 nmi_get_chipid(void)
{
   11884:	b510      	push	{r4, lr}
   11886:	b082      	sub	sp, #8
	static uint32 chipid = 0;

	if (chipid == 0) {
   11888:	4b20      	ldr	r3, [pc, #128]	; (1190c <nmi_get_chipid+0x88>)
   1188a:	681c      	ldr	r4, [r3, #0]
   1188c:	2c00      	cmp	r4, #0
   1188e:	d137      	bne.n	11900 <nmi_get_chipid+0x7c>
		//uint32 revid;
		uint32 rfrevid;

		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
   11890:	2080      	movs	r0, #128	; 0x80
   11892:	0140      	lsls	r0, r0, #5
   11894:	1c19      	adds	r1, r3, #0
   11896:	4b1e      	ldr	r3, [pc, #120]	; (11910 <nmi_get_chipid+0x8c>)
   11898:	4798      	blx	r3
   1189a:	2800      	cmp	r0, #0
   1189c:	d003      	beq.n	118a6 <nmi_get_chipid+0x22>
			chipid = 0;
   1189e:	2200      	movs	r2, #0
   118a0:	4b1a      	ldr	r3, [pc, #104]	; (1190c <nmi_get_chipid+0x88>)
   118a2:	601a      	str	r2, [r3, #0]
			return 0;
   118a4:	e02e      	b.n	11904 <nmi_get_chipid+0x80>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
   118a6:	481b      	ldr	r0, [pc, #108]	; (11914 <nmi_get_chipid+0x90>)
   118a8:	a901      	add	r1, sp, #4
   118aa:	4b19      	ldr	r3, [pc, #100]	; (11910 <nmi_get_chipid+0x8c>)
   118ac:	4798      	blx	r3
   118ae:	2800      	cmp	r0, #0
   118b0:	d003      	beq.n	118ba <nmi_get_chipid+0x36>
			chipid = 0;
   118b2:	2200      	movs	r2, #0
   118b4:	4b15      	ldr	r3, [pc, #84]	; (1190c <nmi_get_chipid+0x88>)
   118b6:	601a      	str	r2, [r3, #0]
			return 0;
   118b8:	e024      	b.n	11904 <nmi_get_chipid+0x80>
		}

		if (chipid == 0x1002a0)  {
   118ba:	4b14      	ldr	r3, [pc, #80]	; (1190c <nmi_get_chipid+0x88>)
   118bc:	681b      	ldr	r3, [r3, #0]
   118be:	4a16      	ldr	r2, [pc, #88]	; (11918 <nmi_get_chipid+0x94>)
   118c0:	4293      	cmp	r3, r2
   118c2:	d106      	bne.n	118d2 <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
   118c4:	9b01      	ldr	r3, [sp, #4]
   118c6:	2b01      	cmp	r3, #1
   118c8:	d012      	beq.n	118f0 <nmi_get_chipid+0x6c>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
   118ca:	4a14      	ldr	r2, [pc, #80]	; (1191c <nmi_get_chipid+0x98>)
   118cc:	4b0f      	ldr	r3, [pc, #60]	; (1190c <nmi_get_chipid+0x88>)
   118ce:	601a      	str	r2, [r3, #0]
   118d0:	e00e      	b.n	118f0 <nmi_get_chipid+0x6c>
			}
		} else if(chipid == 0x1002b0) {
   118d2:	4a13      	ldr	r2, [pc, #76]	; (11920 <nmi_get_chipid+0x9c>)
   118d4:	4293      	cmp	r3, r2
   118d6:	d10b      	bne.n	118f0 <nmi_get_chipid+0x6c>
			if(rfrevid == 3) { /* 1002B0 */
   118d8:	9b01      	ldr	r3, [sp, #4]
   118da:	2b03      	cmp	r3, #3
   118dc:	d008      	beq.n	118f0 <nmi_get_chipid+0x6c>
			} else if(rfrevid == 4) { /* 1002B1 */
   118de:	2b04      	cmp	r3, #4
   118e0:	d103      	bne.n	118ea <nmi_get_chipid+0x66>
				chipid = 0x1002b1;
   118e2:	4a10      	ldr	r2, [pc, #64]	; (11924 <nmi_get_chipid+0xa0>)
   118e4:	4b09      	ldr	r3, [pc, #36]	; (1190c <nmi_get_chipid+0x88>)
   118e6:	601a      	str	r2, [r3, #0]
   118e8:	e002      	b.n	118f0 <nmi_get_chipid+0x6c>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
   118ea:	4a0f      	ldr	r2, [pc, #60]	; (11928 <nmi_get_chipid+0xa4>)
   118ec:	4b07      	ldr	r3, [pc, #28]	; (1190c <nmi_get_chipid+0x88>)
   118ee:	601a      	str	r2, [r3, #0]
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
   118f0:	4a06      	ldr	r2, [pc, #24]	; (1190c <nmi_get_chipid+0x88>)
				chipid |= 0x050000;
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
   118f2:	4b0e      	ldr	r3, [pc, #56]	; (1192c <nmi_get_chipid+0xa8>)
   118f4:	6811      	ldr	r1, [r2, #0]
   118f6:	400b      	ands	r3, r1
		chipid |= 0x050000;
   118f8:	21a0      	movs	r1, #160	; 0xa0
   118fa:	02c9      	lsls	r1, r1, #11
   118fc:	430b      	orrs	r3, r1
   118fe:	6013      	str	r3, [r2, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
   11900:	4b02      	ldr	r3, [pc, #8]	; (1190c <nmi_get_chipid+0x88>)
   11902:	681c      	ldr	r4, [r3, #0]
}
   11904:	1c20      	adds	r0, r4, #0
   11906:	b002      	add	sp, #8
   11908:	bd10      	pop	{r4, pc}
   1190a:	46c0      	nop			; (mov r8, r8)
   1190c:	20001314 	.word	0x20001314
   11910:	00011b79 	.word	0x00011b79
   11914:	000013f4 	.word	0x000013f4
   11918:	001002a0 	.word	0x001002a0
   1191c:	001002a1 	.word	0x001002a1
   11920:	001002b0 	.word	0x001002b0
   11924:	001002b1 	.word	0x001002b1
   11928:	001002b2 	.word	0x001002b2
   1192c:	fff0ffff 	.word	0xfff0ffff

00011930 <wait_for_bootrom>:
#endif
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
   11930:	b5f0      	push	{r4, r5, r6, r7, lr}
   11932:	4647      	mov	r7, r8
   11934:	b480      	push	{r7}
   11936:	4680      	mov	r8, r0
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;

	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
   11938:	4d23      	ldr	r5, [pc, #140]	; (119c8 <wait_for_bootrom+0x98>)
   1193a:	4c24      	ldr	r4, [pc, #144]	; (119cc <wait_for_bootrom+0x9c>)
		if (reg & 0x80000000) {
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
   1193c:	4e24      	ldr	r6, [pc, #144]	; (119d0 <wait_for_bootrom+0xa0>)
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;

	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
   1193e:	1c28      	adds	r0, r5, #0
   11940:	47a0      	blx	r4
		if (reg & 0x80000000) {
   11942:	2800      	cmp	r0, #0
   11944:	db02      	blt.n	1194c <wait_for_bootrom+0x1c>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
   11946:	2001      	movs	r0, #1
   11948:	47b0      	blx	r6
	}
   1194a:	e7f8      	b.n	1193e <wait_for_bootrom+0xe>
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
   1194c:	4821      	ldr	r0, [pc, #132]	; (119d4 <wait_for_bootrom+0xa4>)
   1194e:	4b1f      	ldr	r3, [pc, #124]	; (119cc <wait_for_bootrom+0x9c>)
   11950:	4798      	blx	r3
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
   11952:	07c3      	lsls	r3, r0, #31
   11954:	d527      	bpl.n	119a6 <wait_for_bootrom+0x76>
   11956:	e008      	b.n	1196a <wait_for_bootrom+0x3a>
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
   11958:	2001      	movs	r0, #1
   1195a:	47b8      	blx	r7
			reg = nm_read_reg(BOOTROM_REG);
   1195c:	481e      	ldr	r0, [pc, #120]	; (119d8 <wait_for_bootrom+0xa8>)
   1195e:	47b0      	blx	r6
   11960:	3c01      	subs	r4, #1

			if(++cnt > TIMEOUT)
   11962:	2c00      	cmp	r4, #0
   11964:	d01d      	beq.n	119a2 <wait_for_bootrom+0x72>

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
   11966:	42a8      	cmp	r0, r5
   11968:	d1f6      	bne.n	11958 <wait_for_bootrom+0x28>
				goto ERR2;
			}
		}
	}

	if(2 == arg) {
   1196a:	4643      	mov	r3, r8
   1196c:	2b02      	cmp	r3, #2
   1196e:	d103      	bne.n	11978 <wait_for_bootrom+0x48>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
   11970:	481a      	ldr	r0, [pc, #104]	; (119dc <wait_for_bootrom+0xac>)
   11972:	491b      	ldr	r1, [pc, #108]	; (119e0 <wait_for_bootrom+0xb0>)
   11974:	4b1b      	ldr	r3, [pc, #108]	; (119e4 <wait_for_bootrom+0xb4>)
   11976:	4798      	blx	r3
	} else {
		/*bypass this step*/
	}

	if(REV(nmi_get_chipid()) == REV_3A0)
   11978:	4b1b      	ldr	r3, [pc, #108]	; (119e8 <wait_for_bootrom+0xb8>)
   1197a:	4798      	blx	r3
   1197c:	0500      	lsls	r0, r0, #20
   1197e:	0d00      	lsrs	r0, r0, #20
   11980:	23e8      	movs	r3, #232	; 0xe8
   11982:	009b      	lsls	r3, r3, #2
   11984:	4298      	cmp	r0, r3
   11986:	d103      	bne.n	11990 <wait_for_bootrom+0x60>
	{
		chip_apply_conf(rHAVE_USE_PMU_BIT);
   11988:	2002      	movs	r0, #2
   1198a:	4b18      	ldr	r3, [pc, #96]	; (119ec <wait_for_bootrom+0xbc>)
   1198c:	4798      	blx	r3
   1198e:	e002      	b.n	11996 <wait_for_bootrom+0x66>
	}
	else
	{
		chip_apply_conf(0);
   11990:	2000      	movs	r0, #0
   11992:	4b16      	ldr	r3, [pc, #88]	; (119ec <wait_for_bootrom+0xbc>)
   11994:	4798      	blx	r3
	}
	
	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
   11996:	4810      	ldr	r0, [pc, #64]	; (119d8 <wait_for_bootrom+0xa8>)
   11998:	4915      	ldr	r1, [pc, #84]	; (119f0 <wait_for_bootrom+0xc0>)
   1199a:	4b12      	ldr	r3, [pc, #72]	; (119e4 <wait_for_bootrom+0xb4>)
   1199c:	4798      	blx	r3
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
   1199e:	2000      	movs	r0, #0
   119a0:	e00d      	b.n	119be <wait_for_bootrom+0x8e>
			reg = nm_read_reg(BOOTROM_REG);

			if(++cnt > TIMEOUT)
			{
				M2M_DBG("failed to load firmware from flash.\n");
				ret = M2M_ERR_INIT;
   119a2:	20fb      	movs	r0, #251	; 0xfb
   119a4:	e00b      	b.n	119be <wait_for_bootrom+0x8e>
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
   119a6:	2001      	movs	r0, #1
   119a8:	4b09      	ldr	r3, [pc, #36]	; (119d0 <wait_for_bootrom+0xa0>)
   119aa:	4798      	blx	r3
			reg = nm_read_reg(BOOTROM_REG);
   119ac:	480a      	ldr	r0, [pc, #40]	; (119d8 <wait_for_bootrom+0xa8>)
   119ae:	4b07      	ldr	r3, [pc, #28]	; (119cc <wait_for_bootrom+0x9c>)
   119b0:	4798      	blx	r3
   119b2:	24fa      	movs	r4, #250	; 0xfa
   119b4:	00e4      	lsls	r4, r4, #3

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
   119b6:	4d0f      	ldr	r5, [pc, #60]	; (119f4 <wait_for_bootrom+0xc4>)
		{
			nm_bsp_sleep(1);
   119b8:	4f05      	ldr	r7, [pc, #20]	; (119d0 <wait_for_bootrom+0xa0>)
			reg = nm_read_reg(BOOTROM_REG);
   119ba:	4e04      	ldr	r6, [pc, #16]	; (119cc <wait_for_bootrom+0x9c>)
   119bc:	e7d3      	b.n	11966 <wait_for_bootrom+0x36>
#ifdef __ROM_TEST__
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
   119be:	b240      	sxtb	r0, r0
}
   119c0:	bc04      	pop	{r2}
   119c2:	4690      	mov	r8, r2
   119c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   119c6:	46c0      	nop			; (mov r8, r8)
   119c8:	00001014 	.word	0x00001014
   119cc:	00011b6d 	.word	0x00011b6d
   119d0:	000105d5 	.word	0x000105d5
   119d4:	000207bc 	.word	0x000207bc
   119d8:	000c000c 	.word	0x000c000c
   119dc:	000207ac 	.word	0x000207ac
   119e0:	3c1cd57d 	.word	0x3c1cd57d
   119e4:	00011b85 	.word	0x00011b85
   119e8:	00011885 	.word	0x00011885
   119ec:	000116a9 	.word	0x000116a9
   119f0:	ef522f61 	.word	0xef522f61
   119f4:	10add09e 	.word	0x10add09e

000119f8 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
   119f8:	b570      	push	{r4, r5, r6, lr}
   119fa:	b082      	sub	sp, #8
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	volatile uint32 regAddress = NMI_STATE_REG;
   119fc:	4b14      	ldr	r3, [pc, #80]	; (11a50 <wait_for_firmware_start+0x58>)
   119fe:	9301      	str	r3, [sp, #4]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
   11a00:	4b14      	ldr	r3, [pc, #80]	; (11a54 <wait_for_firmware_start+0x5c>)
   11a02:	9300      	str	r3, [sp, #0]

	if(2 == arg) {
   11a04:	2802      	cmp	r0, #2
   11a06:	d10c      	bne.n	11a22 <wait_for_firmware_start+0x2a>
		regAddress = NMI_REV_REG;
   11a08:	4b13      	ldr	r3, [pc, #76]	; (11a58 <wait_for_firmware_start+0x60>)
   11a0a:	9301      	str	r3, [sp, #4]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
   11a0c:	4b13      	ldr	r3, [pc, #76]	; (11a5c <wait_for_firmware_start+0x64>)
   11a0e:	9300      	str	r3, [sp, #0]
   11a10:	e007      	b.n	11a22 <wait_for_firmware_start+0x2a>
		/*bypass this step*/
	}

	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
   11a12:	2002      	movs	r0, #2
   11a14:	47b0      	blx	r6
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
   11a16:	9801      	ldr	r0, [sp, #4]
   11a18:	47a8      	blx	r5
   11a1a:	3c01      	subs	r4, #1
		if(++cnt > TIMEOUT)
   11a1c:	2c00      	cmp	r4, #0
   11a1e:	d104      	bne.n	11a2a <wait_for_firmware_start+0x32>
   11a20:	e011      	b.n	11a46 <wait_for_firmware_start+0x4e>
ERR2:
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
   11a22:	4c0f      	ldr	r4, [pc, #60]	; (11a60 <wait_for_firmware_start+0x68>)
   11a24:	2000      	movs	r0, #0
		/*bypass this step*/
	}

	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
   11a26:	4e0f      	ldr	r6, [pc, #60]	; (11a64 <wait_for_firmware_start+0x6c>)
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
   11a28:	4d0f      	ldr	r5, [pc, #60]	; (11a68 <wait_for_firmware_start+0x70>)
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
	} else {
		/*bypass this step*/
	}

	while (checkValue != reg)
   11a2a:	9b00      	ldr	r3, [sp, #0]
   11a2c:	4283      	cmp	r3, r0
   11a2e:	d1f0      	bne.n	11a12 <wait_for_firmware_start+0x1a>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
   11a30:	9a00      	ldr	r2, [sp, #0]
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
   11a32:	2000      	movs	r0, #0
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
   11a34:	4b07      	ldr	r3, [pc, #28]	; (11a54 <wait_for_firmware_start+0x5c>)
   11a36:	429a      	cmp	r2, r3
   11a38:	d106      	bne.n	11a48 <wait_for_firmware_start+0x50>
	{
		nm_write_reg(NMI_STATE_REG, 0);
   11a3a:	4805      	ldr	r0, [pc, #20]	; (11a50 <wait_for_firmware_start+0x58>)
   11a3c:	2100      	movs	r1, #0
   11a3e:	4b0b      	ldr	r3, [pc, #44]	; (11a6c <wait_for_firmware_start+0x74>)
   11a40:	4798      	blx	r3
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
   11a42:	2000      	movs	r0, #0
   11a44:	e000      	b.n	11a48 <wait_for_firmware_start+0x50>
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
		if(++cnt > TIMEOUT)
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
   11a46:	20fb      	movs	r0, #251	; 0xfb
	if(M2M_FINISH_INIT_STATE == checkValue)
	{
		nm_write_reg(NMI_STATE_REG, 0);
	}
ERR:
	return ret;
   11a48:	b240      	sxtb	r0, r0
}
   11a4a:	b002      	add	sp, #8
   11a4c:	bd70      	pop	{r4, r5, r6, pc}
   11a4e:	46c0      	nop			; (mov r8, r8)
   11a50:	0000108c 	.word	0x0000108c
   11a54:	02532636 	.word	0x02532636
   11a58:	000207ac 	.word	0x000207ac
   11a5c:	d75dc1c3 	.word	0xd75dc1c3
   11a60:	000007d1 	.word	0x000007d1
   11a64:	000105d5 	.word	0x000105d5
   11a68:	00011b6d 	.word	0x00011b6d
   11a6c:	00011b85 	.word	0x00011b85

00011a70 <chip_deinit>:

sint8 chip_deinit(void)
{
   11a70:	b5f0      	push	{r4, r5, r6, r7, lr}
   11a72:	b083      	sub	sp, #12
	uint32 reg = 0;
   11a74:	2300      	movs	r3, #0
   11a76:	9301      	str	r3, [sp, #4]
	uint8 timeout = 10;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   11a78:	20a0      	movs	r0, #160	; 0xa0
   11a7a:	0140      	lsls	r0, r0, #5
   11a7c:	a901      	add	r1, sp, #4
   11a7e:	4b28      	ldr	r3, [pc, #160]	; (11b20 <chip_deinit+0xb0>)
   11a80:	4798      	blx	r3
	if (ret != M2M_SUCCESS) {
   11a82:	2800      	cmp	r0, #0
   11a84:	d00a      	beq.n	11a9c <chip_deinit+0x2c>
		M2M_ERR("failed to de-initialize\n");
   11a86:	4827      	ldr	r0, [pc, #156]	; (11b24 <chip_deinit+0xb4>)
   11a88:	4927      	ldr	r1, [pc, #156]	; (11b28 <chip_deinit+0xb8>)
   11a8a:	4a28      	ldr	r2, [pc, #160]	; (11b2c <chip_deinit+0xbc>)
   11a8c:	4b28      	ldr	r3, [pc, #160]	; (11b30 <chip_deinit+0xc0>)
   11a8e:	4798      	blx	r3
   11a90:	4828      	ldr	r0, [pc, #160]	; (11b34 <chip_deinit+0xc4>)
   11a92:	4b29      	ldr	r3, [pc, #164]	; (11b38 <chip_deinit+0xc8>)
   11a94:	4798      	blx	r3
   11a96:	200d      	movs	r0, #13
   11a98:	4b28      	ldr	r3, [pc, #160]	; (11b3c <chip_deinit+0xcc>)
   11a9a:	4798      	blx	r3
	}
	reg &= ~(1 << 10);
   11a9c:	4928      	ldr	r1, [pc, #160]	; (11b40 <chip_deinit+0xd0>)
   11a9e:	9b01      	ldr	r3, [sp, #4]
   11aa0:	4019      	ands	r1, r3
   11aa2:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   11aa4:	20a0      	movs	r0, #160	; 0xa0
   11aa6:	0140      	lsls	r0, r0, #5
   11aa8:	4b26      	ldr	r3, [pc, #152]	; (11b44 <chip_deinit+0xd4>)
   11aaa:	4798      	blx	r3
   11aac:	1c04      	adds	r4, r0, #0
   11aae:	260a      	movs	r6, #10

	if (ret != M2M_SUCCESS) {
   11ab0:	2800      	cmp	r0, #0
   11ab2:	d00c      	beq.n	11ace <chip_deinit+0x5e>
		M2M_ERR("Error while writing reg\n");
   11ab4:	481b      	ldr	r0, [pc, #108]	; (11b24 <chip_deinit+0xb4>)
   11ab6:	491c      	ldr	r1, [pc, #112]	; (11b28 <chip_deinit+0xb8>)
   11ab8:	4a23      	ldr	r2, [pc, #140]	; (11b48 <chip_deinit+0xd8>)
   11aba:	4b1d      	ldr	r3, [pc, #116]	; (11b30 <chip_deinit+0xc0>)
   11abc:	4798      	blx	r3
   11abe:	4823      	ldr	r0, [pc, #140]	; (11b4c <chip_deinit+0xdc>)
   11ac0:	4b1d      	ldr	r3, [pc, #116]	; (11b38 <chip_deinit+0xc8>)
   11ac2:	4798      	blx	r3
   11ac4:	200d      	movs	r0, #13
   11ac6:	4b1d      	ldr	r3, [pc, #116]	; (11b3c <chip_deinit+0xcc>)
   11ac8:	4798      	blx	r3
		return ret;
   11aca:	1c20      	adds	r0, r4, #0
   11acc:	e024      	b.n	11b18 <chip_deinit+0xa8>
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   11ace:	4f14      	ldr	r7, [pc, #80]	; (11b20 <chip_deinit+0xb0>)
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   11ad0:	4d1c      	ldr	r5, [pc, #112]	; (11b44 <chip_deinit+0xd4>)
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   11ad2:	20a0      	movs	r0, #160	; 0xa0
   11ad4:	0140      	lsls	r0, r0, #5
   11ad6:	a901      	add	r1, sp, #4
   11ad8:	47b8      	blx	r7
   11ada:	1e04      	subs	r4, r0, #0
		if (ret != M2M_SUCCESS) {
   11adc:	d00d      	beq.n	11afa <chip_deinit+0x8a>
			M2M_ERR("Error while reading reg\n");
   11ade:	4811      	ldr	r0, [pc, #68]	; (11b24 <chip_deinit+0xb4>)
   11ae0:	4911      	ldr	r1, [pc, #68]	; (11b28 <chip_deinit+0xb8>)
   11ae2:	2287      	movs	r2, #135	; 0x87
   11ae4:	0092      	lsls	r2, r2, #2
   11ae6:	4b12      	ldr	r3, [pc, #72]	; (11b30 <chip_deinit+0xc0>)
   11ae8:	4798      	blx	r3
   11aea:	4819      	ldr	r0, [pc, #100]	; (11b50 <chip_deinit+0xe0>)
   11aec:	4b12      	ldr	r3, [pc, #72]	; (11b38 <chip_deinit+0xc8>)
   11aee:	4798      	blx	r3
   11af0:	200d      	movs	r0, #13
   11af2:	4b12      	ldr	r3, [pc, #72]	; (11b3c <chip_deinit+0xcc>)
   11af4:	4798      	blx	r3
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   11af6:	1c20      	adds	r0, r4, #0
		if (ret != M2M_SUCCESS) {
			M2M_ERR("Error while reading reg\n");
			return ret;
   11af8:	e00e      	b.n	11b18 <chip_deinit+0xa8>
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
   11afa:	9901      	ldr	r1, [sp, #4]
   11afc:	054b      	lsls	r3, r1, #21
   11afe:	d50a      	bpl.n	11b16 <chip_deinit+0xa6>
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
   11b00:	4b0f      	ldr	r3, [pc, #60]	; (11b40 <chip_deinit+0xd0>)
   11b02:	4019      	ands	r1, r3
   11b04:	9101      	str	r1, [sp, #4]
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   11b06:	20a0      	movs	r0, #160	; 0xa0
   11b08:	0140      	lsls	r0, r0, #5
   11b0a:	47a8      	blx	r5
   11b0c:	3e01      	subs	r6, #1
   11b0e:	b2f6      	uxtb	r6, r6
			timeout--;
		} else {
			break;
		}

	} while (timeout);
   11b10:	2e00      	cmp	r6, #0
   11b12:	d1de      	bne.n	11ad2 <chip_deinit+0x62>
   11b14:	e000      	b.n	11b18 <chip_deinit+0xa8>
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   11b16:	2000      	movs	r0, #0
   11b18:	b240      	sxtb	r0, r0
		}

	} while (timeout);

	return ret;
}
   11b1a:	b003      	add	sp, #12
   11b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11b1e:	46c0      	nop			; (mov r8, r8)
   11b20:	00011b79 	.word	0x00011b79
   11b24:	000203ec 	.word	0x000203ec
   11b28:	00020a54 	.word	0x00020a54
   11b2c:	0000020f 	.word	0x0000020f
   11b30:	00016e3d 	.word	0x00016e3d
   11b34:	000209cc 	.word	0x000209cc
   11b38:	00016f5d 	.word	0x00016f5d
   11b3c:	00016e71 	.word	0x00016e71
   11b40:	fffffbff 	.word	0xfffffbff
   11b44:	00011b85 	.word	0x00011b85
   11b48:	00000215 	.word	0x00000215
   11b4c:	000209e4 	.word	0x000209e4
   11b50:	000209fc 	.word	0x000209fc

00011b54 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
   11b54:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
   11b56:	4b01      	ldr	r3, [pc, #4]	; (11b5c <nm_bus_iface_init+0x8>)
   11b58:	4798      	blx	r3

	return ret;
}
   11b5a:	bd08      	pop	{r3, pc}
   11b5c:	00010701 	.word	0x00010701

00011b60 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
   11b60:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
   11b62:	4b01      	ldr	r3, [pc, #4]	; (11b68 <nm_bus_iface_deinit+0x8>)
   11b64:	4798      	blx	r3

	return ret;
}
   11b66:	bd08      	pop	{r3, pc}
   11b68:	00010931 	.word	0x00010931

00011b6c <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
   11b6c:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
   11b6e:	4b01      	ldr	r3, [pc, #4]	; (11b74 <nm_read_reg+0x8>)
   11b70:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
   11b72:	bd08      	pop	{r3, pc}
   11b74:	00012459 	.word	0x00012459

00011b78 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
   11b78:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
   11b7a:	4b01      	ldr	r3, [pc, #4]	; (11b80 <nm_read_reg_with_ret+0x8>)
   11b7c:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
   11b7e:	bd08      	pop	{r3, pc}
   11b80:	0001246d 	.word	0x0001246d

00011b84 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
   11b84:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
   11b86:	4b01      	ldr	r3, [pc, #4]	; (11b8c <nm_write_reg+0x8>)
   11b88:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
   11b8a:	bd08      	pop	{r3, pc}
   11b8c:	00012485 	.word	0x00012485

00011b90 <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
   11b90:	b5f0      	push	{r4, r5, r6, r7, lr}
   11b92:	464f      	mov	r7, r9
   11b94:	4646      	mov	r6, r8
   11b96:	b4c0      	push	{r6, r7}
   11b98:	b083      	sub	sp, #12
   11b9a:	1c06      	adds	r6, r0, #0
   11b9c:	4689      	mov	r9, r1
   11b9e:	1c15      	adds	r5, r2, #0
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   11ba0:	4b14      	ldr	r3, [pc, #80]	; (11bf4 <nm_read_block+0x64>)
   11ba2:	881b      	ldrh	r3, [r3, #0]
   11ba4:	3b08      	subs	r3, #8
   11ba6:	b29b      	uxth	r3, r3
   11ba8:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11baa:	1c1c      	adds	r4, r3, #0
   11bac:	429a      	cmp	r2, r3
   11bae:	d807      	bhi.n	11bc0 <nm_read_block+0x30>
*	@version	1.0
*/
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
   11bb0:	2700      	movs	r7, #0

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);
   11bb2:	1c39      	adds	r1, r7, #0
   11bb4:	4449      	add	r1, r9
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
   11bb6:	b2aa      	uxth	r2, r5
   11bb8:	1c30      	adds	r0, r6, #0
   11bba:	4b0f      	ldr	r3, [pc, #60]	; (11bf8 <nm_read_block+0x68>)
   11bbc:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);
			break;
   11bbe:	e012      	b.n	11be6 <nm_read_block+0x56>
   11bc0:	9b01      	ldr	r3, [sp, #4]
   11bc2:	1ad5      	subs	r5, r2, r3
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11bc4:	2700      	movs	r7, #0
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
   11bc6:	4b0c      	ldr	r3, [pc, #48]	; (11bf8 <nm_read_block+0x68>)
   11bc8:	4698      	mov	r8, r3
   11bca:	464b      	mov	r3, r9
   11bcc:	19d9      	adds	r1, r3, r7
   11bce:	1c30      	adds	r0, r6, #0
   11bd0:	9a01      	ldr	r2, [sp, #4]
   11bd2:	47c0      	blx	r8
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
   11bd4:	2800      	cmp	r0, #0
   11bd6:	d106      	bne.n	11be6 <nm_read_block+0x56>
			u32Sz -= u16MaxTrxSz;
			off += u16MaxTrxSz;
   11bd8:	193f      	adds	r7, r7, r4
			u32Addr += u16MaxTrxSz;
   11bda:	1936      	adds	r6, r6, r4
   11bdc:	1b2b      	subs	r3, r5, r4
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11bde:	42ac      	cmp	r4, r5
   11be0:	d2e7      	bcs.n	11bb2 <nm_read_block+0x22>
   11be2:	1c1d      	adds	r5, r3, #0
   11be4:	e7f1      	b.n	11bca <nm_read_block+0x3a>
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
   11be6:	b240      	sxtb	r0, r0
}
   11be8:	b003      	add	sp, #12
   11bea:	bc0c      	pop	{r2, r3}
   11bec:	4690      	mov	r8, r2
   11bee:	4699      	mov	r9, r3
   11bf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11bf2:	46c0      	nop			; (mov r8, r8)
   11bf4:	20000268 	.word	0x20000268
   11bf8:	000125c1 	.word	0x000125c1

00011bfc <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
   11bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
   11bfe:	464f      	mov	r7, r9
   11c00:	4646      	mov	r6, r8
   11c02:	b4c0      	push	{r6, r7}
   11c04:	b083      	sub	sp, #12
   11c06:	1c06      	adds	r6, r0, #0
   11c08:	4689      	mov	r9, r1
   11c0a:	1c15      	adds	r5, r2, #0
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   11c0c:	4b14      	ldr	r3, [pc, #80]	; (11c60 <nm_write_block+0x64>)
   11c0e:	881b      	ldrh	r3, [r3, #0]
   11c10:	3b08      	subs	r3, #8
   11c12:	b29b      	uxth	r3, r3
   11c14:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11c16:	1c1c      	adds	r4, r3, #0
   11c18:	429a      	cmp	r2, r3
   11c1a:	d807      	bhi.n	11c2c <nm_write_block+0x30>
*	@version	1.0
*/
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
   11c1c:	2700      	movs	r7, #0

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);
   11c1e:	1c39      	adds	r1, r7, #0
   11c20:	4449      	add	r1, r9
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
   11c22:	b2aa      	uxth	r2, r5
   11c24:	1c30      	adds	r0, r6, #0
   11c26:	4b0f      	ldr	r3, [pc, #60]	; (11c64 <nm_write_block+0x68>)
   11c28:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);
			break;
   11c2a:	e012      	b.n	11c52 <nm_write_block+0x56>
   11c2c:	9b01      	ldr	r3, [sp, #4]
   11c2e:	1ad5      	subs	r5, r2, r3
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11c30:	2700      	movs	r7, #0
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
   11c32:	4b0c      	ldr	r3, [pc, #48]	; (11c64 <nm_write_block+0x68>)
   11c34:	4698      	mov	r8, r3
   11c36:	464b      	mov	r3, r9
   11c38:	19d9      	adds	r1, r3, r7
   11c3a:	1c30      	adds	r0, r6, #0
   11c3c:	9a01      	ldr	r2, [sp, #4]
   11c3e:	47c0      	blx	r8
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
   11c40:	2800      	cmp	r0, #0
   11c42:	d106      	bne.n	11c52 <nm_write_block+0x56>
			u32Sz -= u16MaxTrxSz;
			off += u16MaxTrxSz;
   11c44:	193f      	adds	r7, r7, r4
			u32Addr += u16MaxTrxSz;
   11c46:	1936      	adds	r6, r6, r4
   11c48:	1b2b      	subs	r3, r5, r4
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   11c4a:	42ac      	cmp	r4, r5
   11c4c:	d2e7      	bcs.n	11c1e <nm_write_block+0x22>
   11c4e:	1c1d      	adds	r5, r3, #0
   11c50:	e7f1      	b.n	11c36 <nm_write_block+0x3a>
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
   11c52:	b240      	sxtb	r0, r0
}
   11c54:	b003      	add	sp, #12
   11c56:	bc0c      	pop	{r2, r3}
   11c58:	4690      	mov	r8, r2
   11c5a:	4699      	mov	r9, r3
   11c5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11c5e:	46c0      	nop			; (mov r8, r8)
   11c60:	20000268 	.word	0x20000268
   11c64:	00012699 	.word	0x00012699

00011c68 <nm_get_firmware_info>:
*   @author		Ahmad.Mohammad.Yahya
*   @date		27 MARCH 2013
*	@version	1.0
*/
sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
{
   11c68:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c6a:	b083      	sub	sp, #12
   11c6c:	1c04      	adds	r4, r0, #0
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
   11c6e:	2300      	movs	r3, #0
   11c70:	9301      	str	r3, [sp, #4]
	sint8	ret = M2M_SUCCESS;

	ret = nm_read_reg_with_ret(NMI_REV_REG, &reg);
   11c72:	481d      	ldr	r0, [pc, #116]	; (11ce8 <nm_get_firmware_info+0x80>)
   11c74:	a901      	add	r1, sp, #4
   11c76:	4b1d      	ldr	r3, [pc, #116]	; (11cec <nm_get_firmware_info+0x84>)
   11c78:	4798      	blx	r3
   11c7a:	1c05      	adds	r5, r0, #0

	M2mRev->u8DriverMajor	= M2M_GET_DRV_MAJOR(reg);
   11c7c:	9a01      	ldr	r2, [sp, #4]
   11c7e:	0c11      	lsrs	r1, r2, #16
   11c80:	b28b      	uxth	r3, r1
   11c82:	0a18      	lsrs	r0, r3, #8
   11c84:	70e0      	strb	r0, [r4, #3]
	M2mRev->u8DriverMinor   = M2M_GET_DRV_MINOR(reg);
   11c86:	091b      	lsrs	r3, r3, #4
   11c88:	260f      	movs	r6, #15
   11c8a:	4033      	ands	r3, r6
   11c8c:	7123      	strb	r3, [r4, #4]
	M2mRev->u8DriverPatch	= M2M_GET_DRV_PATCH(reg);
   11c8e:	4031      	ands	r1, r6
   11c90:	7161      	strb	r1, [r4, #5]
	M2mRev->u8FirmwareMajor	= M2M_GET_FW_MAJOR(reg);
   11c92:	b293      	uxth	r3, r2
   11c94:	0a19      	lsrs	r1, r3, #8
   11c96:	7021      	strb	r1, [r4, #0]
	M2mRev->u8FirmwareMinor = M2M_GET_FW_MINOR(reg);
   11c98:	091b      	lsrs	r3, r3, #4
   11c9a:	4033      	ands	r3, r6
   11c9c:	7063      	strb	r3, [r4, #1]
	M2mRev->u8FirmwarePatch = M2M_GET_FW_PATCH(reg);
   11c9e:	4032      	ands	r2, r6
   11ca0:	70a2      	strb	r2, [r4, #2]
	M2mRev->u32Chipid	= nmi_get_chipid();
   11ca2:	4b13      	ldr	r3, [pc, #76]	; (11cf0 <nm_get_firmware_info+0x88>)
   11ca4:	4798      	blx	r3
   11ca6:	61e0      	str	r0, [r4, #28]
	
	curr_firm_ver   = M2M_MAKE_VERSION(M2mRev->u8FirmwareMajor, M2mRev->u8FirmwareMinor,M2mRev->u8FirmwarePatch);
   11ca8:	7823      	ldrb	r3, [r4, #0]
   11caa:	021a      	lsls	r2, r3, #8
   11cac:	78a3      	ldrb	r3, [r4, #2]
   11cae:	4033      	ands	r3, r6
   11cb0:	4313      	orrs	r3, r2
   11cb2:	7860      	ldrb	r0, [r4, #1]
   11cb4:	0100      	lsls	r0, r0, #4
   11cb6:	27ff      	movs	r7, #255	; 0xff
   11cb8:	4038      	ands	r0, r7
   11cba:	4303      	orrs	r3, r0
	curr_drv_ver    = M2M_MAKE_VERSION(M2M_DRIVER_VERSION_MAJOR_NO, M2M_DRIVER_VERSION_MINOR_NO, M2M_DRIVER_VERSION_PATCH_NO);
	min_req_drv_ver = M2M_MAKE_VERSION(M2mRev->u8DriverMajor, M2mRev->u8DriverMinor,M2mRev->u8DriverPatch);
   11cbc:	78e0      	ldrb	r0, [r4, #3]
   11cbe:	0200      	lsls	r0, r0, #8
   11cc0:	7962      	ldrb	r2, [r4, #5]
   11cc2:	4016      	ands	r6, r2
   11cc4:	4306      	orrs	r6, r0
   11cc6:	7921      	ldrb	r1, [r4, #4]
   11cc8:	0109      	lsls	r1, r1, #4
   11cca:	4039      	ands	r1, r7
	if(curr_drv_ver <  min_req_drv_ver) {
   11ccc:	1c32      	adds	r2, r6, #0
   11cce:	430a      	orrs	r2, r1
   11cd0:	4908      	ldr	r1, [pc, #32]	; (11cf4 <nm_get_firmware_info+0x8c>)
   11cd2:	428a      	cmp	r2, r1
   11cd4:	d900      	bls.n	11cd8 <nm_get_firmware_info+0x70>
		/*The current driver version should be larger or equal 
		than the min driver that the current firmware support  */
		ret = M2M_ERR_FW_VER_MISMATCH;
   11cd6:	25f3      	movs	r5, #243	; 0xf3
	}
	if(curr_drv_ver >  curr_firm_ver) {
   11cd8:	4a07      	ldr	r2, [pc, #28]	; (11cf8 <nm_get_firmware_info+0x90>)
   11cda:	4293      	cmp	r3, r2
   11cdc:	d800      	bhi.n	11ce0 <nm_get_firmware_info+0x78>
		/*The current driver should be equal or less than the firmware version*/
		ret = M2M_ERR_FW_VER_MISMATCH;
   11cde:	25f3      	movs	r5, #243	; 0xf3
	}
	return ret;
   11ce0:	b268      	sxtb	r0, r5
}
   11ce2:	b003      	add	sp, #12
   11ce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ce6:	46c0      	nop			; (mov r8, r8)
   11ce8:	000207ac 	.word	0x000207ac
   11cec:	00011b79 	.word	0x00011b79
   11cf0:	00011885 	.word	0x00011885
   11cf4:	00001330 	.word	0x00001330
   11cf8:	0000132f 	.word	0x0000132f

00011cfc <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
   11cfc:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cfe:	b089      	sub	sp, #36	; 0x24
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode = M2M_WIFI_MODE_NORMAL;
	
	if(NULL != arg) {
   11d00:	2800      	cmp	r0, #0
   11d02:	d006      	beq.n	11d12 <nm_drv_init+0x16>
		if(M2M_WIFI_MODE_CONFIG == *((uint8 *)arg)) {
   11d04:	7803      	ldrb	r3, [r0, #0]
			u8Mode = M2M_WIFI_MODE_CONFIG;
   11d06:	3b02      	subs	r3, #2
   11d08:	1e5a      	subs	r2, r3, #1
   11d0a:	4193      	sbcs	r3, r2
   11d0c:	2002      	movs	r0, #2
   11d0e:	1ac5      	subs	r5, r0, r3
   11d10:	e000      	b.n	11d14 <nm_drv_init+0x18>
*/
sint8 nm_drv_init(void * arg)
{
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode = M2M_WIFI_MODE_NORMAL;
   11d12:	2501      	movs	r5, #1
		}
	} else {
		/*continue running*/
	}
	
	ret = nm_bus_iface_init(NULL);
   11d14:	2000      	movs	r0, #0
   11d16:	4a3a      	ldr	r2, [pc, #232]	; (11e00 <nm_drv_init+0x104>)
   11d18:	4790      	blx	r2
   11d1a:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11d1c:	d00b      	beq.n	11d36 <nm_drv_init+0x3a>
		M2M_ERR("[nmi start]: fail init bus\n");
   11d1e:	4839      	ldr	r0, [pc, #228]	; (11e04 <nm_drv_init+0x108>)
   11d20:	4939      	ldr	r1, [pc, #228]	; (11e08 <nm_drv_init+0x10c>)
   11d22:	22a0      	movs	r2, #160	; 0xa0
   11d24:	4b39      	ldr	r3, [pc, #228]	; (11e0c <nm_drv_init+0x110>)
   11d26:	4798      	blx	r3
   11d28:	4839      	ldr	r0, [pc, #228]	; (11e10 <nm_drv_init+0x114>)
   11d2a:	4b3a      	ldr	r3, [pc, #232]	; (11e14 <nm_drv_init+0x118>)
   11d2c:	4798      	blx	r3
   11d2e:	200d      	movs	r0, #13
   11d30:	4b39      	ldr	r3, [pc, #228]	; (11e18 <nm_drv_init+0x11c>)
   11d32:	4798      	blx	r3
		goto ERR1;
   11d34:	e060      	b.n	11df8 <nm_drv_init+0xfc>
	ret = chip_reset();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
   11d36:	4839      	ldr	r0, [pc, #228]	; (11e1c <nm_drv_init+0x120>)
   11d38:	4c34      	ldr	r4, [pc, #208]	; (11e0c <nm_drv_init+0x110>)
   11d3a:	47a0      	blx	r4
   11d3c:	4b38      	ldr	r3, [pc, #224]	; (11e20 <nm_drv_init+0x124>)
   11d3e:	4798      	blx	r3
   11d40:	1c01      	adds	r1, r0, #0
   11d42:	4838      	ldr	r0, [pc, #224]	; (11e24 <nm_drv_init+0x128>)
   11d44:	47a0      	blx	r4
   11d46:	200d      	movs	r0, #13
   11d48:	4b33      	ldr	r3, [pc, #204]	; (11e18 <nm_drv_init+0x11c>)
   11d4a:	4798      	blx	r3
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
   11d4c:	4b36      	ldr	r3, [pc, #216]	; (11e28 <nm_drv_init+0x12c>)
   11d4e:	4798      	blx	r3
	ret = cpu_start();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	ret = wait_for_bootrom(u8Mode);
   11d50:	1c28      	adds	r0, r5, #0
   11d52:	4b36      	ldr	r3, [pc, #216]	; (11e2c <nm_drv_init+0x130>)
   11d54:	4798      	blx	r3
   11d56:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11d58:	d14c      	bne.n	11df4 <nm_drv_init+0xf8>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
   11d5a:	1c28      	adds	r0, r5, #0
   11d5c:	4b34      	ldr	r3, [pc, #208]	; (11e30 <nm_drv_init+0x134>)
   11d5e:	4798      	blx	r3
   11d60:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11d62:	d147      	bne.n	11df4 <nm_drv_init+0xf8>
		goto ERR2;
	}
	
	if(M2M_WIFI_MODE_CONFIG == u8Mode) {
   11d64:	2d02      	cmp	r5, #2
   11d66:	d047      	beq.n	11df8 <nm_drv_init+0xfc>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
   11d68:	4b32      	ldr	r3, [pc, #200]	; (11e34 <nm_drv_init+0x138>)
   11d6a:	4798      	blx	r3
   11d6c:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11d6e:	d00b      	beq.n	11d88 <nm_drv_init+0x8c>
		M2M_ERR("failed to enable interrupts..\n");
   11d70:	4824      	ldr	r0, [pc, #144]	; (11e04 <nm_drv_init+0x108>)
   11d72:	4925      	ldr	r1, [pc, #148]	; (11e08 <nm_drv_init+0x10c>)
   11d74:	22d8      	movs	r2, #216	; 0xd8
   11d76:	4b25      	ldr	r3, [pc, #148]	; (11e0c <nm_drv_init+0x110>)
   11d78:	4798      	blx	r3
   11d7a:	482f      	ldr	r0, [pc, #188]	; (11e38 <nm_drv_init+0x13c>)
   11d7c:	4b25      	ldr	r3, [pc, #148]	; (11e14 <nm_drv_init+0x118>)
   11d7e:	4798      	blx	r3
   11d80:	200d      	movs	r0, #13
   11d82:	4b25      	ldr	r3, [pc, #148]	; (11e18 <nm_drv_init+0x11c>)
   11d84:	4798      	blx	r3
		goto ERR2;
   11d86:	e035      	b.n	11df4 <nm_drv_init+0xf8>
	}
	
	ret = nm_get_firmware_info(&strtmp);
   11d88:	4668      	mov	r0, sp
   11d8a:	4b2c      	ldr	r3, [pc, #176]	; (11e3c <nm_drv_init+0x140>)
   11d8c:	4798      	blx	r3
   11d8e:	1c04      	adds	r4, r0, #0

	M2M_INFO("Firmware ver   : %u.%u.%u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch);
   11d90:	4f22      	ldr	r7, [pc, #136]	; (11e1c <nm_drv_init+0x120>)
   11d92:	1c38      	adds	r0, r7, #0
   11d94:	4e1d      	ldr	r6, [pc, #116]	; (11e0c <nm_drv_init+0x110>)
   11d96:	47b0      	blx	r6
   11d98:	466b      	mov	r3, sp
   11d9a:	7819      	ldrb	r1, [r3, #0]
   11d9c:	785a      	ldrb	r2, [r3, #1]
   11d9e:	789b      	ldrb	r3, [r3, #2]
   11da0:	4827      	ldr	r0, [pc, #156]	; (11e40 <nm_drv_init+0x144>)
   11da2:	47b0      	blx	r6
   11da4:	200d      	movs	r0, #13
   11da6:	4d1c      	ldr	r5, [pc, #112]	; (11e18 <nm_drv_init+0x11c>)
   11da8:	47a8      	blx	r5
	M2M_INFO("Min driver ver : %u.%u.%u\n", strtmp.u8DriverMajor, strtmp.u8DriverMinor, strtmp.u8DriverPatch);
   11daa:	1c38      	adds	r0, r7, #0
   11dac:	47b0      	blx	r6
   11dae:	466b      	mov	r3, sp
   11db0:	78d9      	ldrb	r1, [r3, #3]
   11db2:	791a      	ldrb	r2, [r3, #4]
   11db4:	795b      	ldrb	r3, [r3, #5]
   11db6:	4823      	ldr	r0, [pc, #140]	; (11e44 <nm_drv_init+0x148>)
   11db8:	47b0      	blx	r6
   11dba:	200d      	movs	r0, #13
   11dbc:	47a8      	blx	r5
	M2M_INFO("Curr driver ver: %u.%u.%u\n", M2M_DRIVER_VERSION_MAJOR_NO, M2M_DRIVER_VERSION_MINOR_NO, M2M_DRIVER_VERSION_PATCH_NO);
   11dbe:	1c38      	adds	r0, r7, #0
   11dc0:	47b0      	blx	r6
   11dc2:	4821      	ldr	r0, [pc, #132]	; (11e48 <nm_drv_init+0x14c>)
   11dc4:	2113      	movs	r1, #19
   11dc6:	2203      	movs	r2, #3
   11dc8:	2300      	movs	r3, #0
   11dca:	47b0      	blx	r6
   11dcc:	200d      	movs	r0, #13
   11dce:	47a8      	blx	r5

	if(strtmp.u8FirmwareMajor != M2M_DRIVER_VERSION_MAJOR_NO
   11dd0:	466b      	mov	r3, sp
   11dd2:	881a      	ldrh	r2, [r3, #0]
   11dd4:	4b1d      	ldr	r3, [pc, #116]	; (11e4c <nm_drv_init+0x150>)
   11dd6:	429a      	cmp	r2, r3
   11dd8:	d00e      	beq.n	11df8 <nm_drv_init+0xfc>
			|| strtmp.u8FirmwareMinor != M2M_DRIVER_VERSION_MINOR_NO)
	{
		ret = M2M_ERR_FW_VER_MISMATCH;
		M2M_ERR("Firmware version mismatch!\n");
   11dda:	480a      	ldr	r0, [pc, #40]	; (11e04 <nm_drv_init+0x108>)
   11ddc:	490a      	ldr	r1, [pc, #40]	; (11e08 <nm_drv_init+0x10c>)
   11dde:	22e6      	movs	r2, #230	; 0xe6
   11de0:	4b0a      	ldr	r3, [pc, #40]	; (11e0c <nm_drv_init+0x110>)
   11de2:	4798      	blx	r3
   11de4:	481a      	ldr	r0, [pc, #104]	; (11e50 <nm_drv_init+0x154>)
   11de6:	4b0b      	ldr	r3, [pc, #44]	; (11e14 <nm_drv_init+0x118>)
   11de8:	4798      	blx	r3
   11dea:	200d      	movs	r0, #13
   11dec:	4b0a      	ldr	r3, [pc, #40]	; (11e18 <nm_drv_init+0x11c>)
   11dee:	4798      	blx	r3
	M2M_INFO("Curr driver ver: %u.%u.%u\n", M2M_DRIVER_VERSION_MAJOR_NO, M2M_DRIVER_VERSION_MINOR_NO, M2M_DRIVER_VERSION_PATCH_NO);

	if(strtmp.u8FirmwareMajor != M2M_DRIVER_VERSION_MAJOR_NO
			|| strtmp.u8FirmwareMinor != M2M_DRIVER_VERSION_MINOR_NO)
	{
		ret = M2M_ERR_FW_VER_MISMATCH;
   11df0:	24f3      	movs	r4, #243	; 0xf3
   11df2:	e001      	b.n	11df8 <nm_drv_init+0xfc>
		M2M_ERR("Firmware version mismatch!\n");
	}
	return ret;
ERR2:
	nm_bus_iface_deinit();
   11df4:	4b17      	ldr	r3, [pc, #92]	; (11e54 <nm_drv_init+0x158>)
   11df6:	4798      	blx	r3
   11df8:	b260      	sxtb	r0, r4
ERR1:
	return ret;
}
   11dfa:	b009      	add	sp, #36	; 0x24
   11dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11dfe:	46c0      	nop			; (mov r8, r8)
   11e00:	00011b55 	.word	0x00011b55
   11e04:	000203ec 	.word	0x000203ec
   11e08:	00020a60 	.word	0x00020a60
   11e0c:	00016e3d 	.word	0x00016e3d
   11e10:	00020a7c 	.word	0x00020a7c
   11e14:	00016f5d 	.word	0x00016f5d
   11e18:	00016e71 	.word	0x00016e71
   11e1c:	000206d4 	.word	0x000206d4
   11e20:	00011885 	.word	0x00011885
   11e24:	00020a98 	.word	0x00020a98
   11e28:	0001249d 	.word	0x0001249d
   11e2c:	00011931 	.word	0x00011931
   11e30:	000119f9 	.word	0x000119f9
   11e34:	00011819 	.word	0x00011819
   11e38:	00020aa8 	.word	0x00020aa8
   11e3c:	00011c69 	.word	0x00011c69
   11e40:	00020ac8 	.word	0x00020ac8
   11e44:	00020ae4 	.word	0x00020ae4
   11e48:	00020b00 	.word	0x00020b00
   11e4c:	00000313 	.word	0x00000313
   11e50:	00020b1c 	.word	0x00020b1c
   11e54:	00011b61 	.word	0x00011b61

00011e58 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
   11e58:	b510      	push	{r4, lr}
	sint8 ret;

	ret = chip_deinit();
   11e5a:	4b12      	ldr	r3, [pc, #72]	; (11ea4 <nm_drv_deinit+0x4c>)
   11e5c:	4798      	blx	r3
   11e5e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11e60:	d00b      	beq.n	11e7a <nm_drv_deinit+0x22>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
   11e62:	4811      	ldr	r0, [pc, #68]	; (11ea8 <nm_drv_deinit+0x50>)
   11e64:	4911      	ldr	r1, [pc, #68]	; (11eac <nm_drv_deinit+0x54>)
   11e66:	22fc      	movs	r2, #252	; 0xfc
   11e68:	4b11      	ldr	r3, [pc, #68]	; (11eb0 <nm_drv_deinit+0x58>)
   11e6a:	4798      	blx	r3
   11e6c:	4811      	ldr	r0, [pc, #68]	; (11eb4 <nm_drv_deinit+0x5c>)
   11e6e:	4b12      	ldr	r3, [pc, #72]	; (11eb8 <nm_drv_deinit+0x60>)
   11e70:	4798      	blx	r3
   11e72:	200d      	movs	r0, #13
   11e74:	4b11      	ldr	r3, [pc, #68]	; (11ebc <nm_drv_deinit+0x64>)
   11e76:	4798      	blx	r3
		goto ERR1;
   11e78:	e012      	b.n	11ea0 <nm_drv_deinit+0x48>
	}

	ret = nm_bus_iface_deinit();
   11e7a:	4b11      	ldr	r3, [pc, #68]	; (11ec0 <nm_drv_deinit+0x68>)
   11e7c:	4798      	blx	r3
   11e7e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   11e80:	d00c      	beq.n	11e9c <nm_drv_deinit+0x44>
		M2M_ERR("[nmi stop]: fail init bus\n");
   11e82:	4809      	ldr	r0, [pc, #36]	; (11ea8 <nm_drv_deinit+0x50>)
   11e84:	4909      	ldr	r1, [pc, #36]	; (11eac <nm_drv_deinit+0x54>)
   11e86:	2281      	movs	r2, #129	; 0x81
   11e88:	0052      	lsls	r2, r2, #1
   11e8a:	4b09      	ldr	r3, [pc, #36]	; (11eb0 <nm_drv_deinit+0x58>)
   11e8c:	4798      	blx	r3
   11e8e:	480d      	ldr	r0, [pc, #52]	; (11ec4 <nm_drv_deinit+0x6c>)
   11e90:	4b09      	ldr	r3, [pc, #36]	; (11eb8 <nm_drv_deinit+0x60>)
   11e92:	4798      	blx	r3
   11e94:	200d      	movs	r0, #13
   11e96:	4b09      	ldr	r3, [pc, #36]	; (11ebc <nm_drv_deinit+0x64>)
   11e98:	4798      	blx	r3
		goto ERR1;
   11e9a:	e001      	b.n	11ea0 <nm_drv_deinit+0x48>
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
   11e9c:	4b0a      	ldr	r3, [pc, #40]	; (11ec8 <nm_drv_deinit+0x70>)
   11e9e:	4798      	blx	r3
#endif

ERR1:
	return ret;
   11ea0:	b260      	sxtb	r0, r4
}
   11ea2:	bd10      	pop	{r4, pc}
   11ea4:	00011a71 	.word	0x00011a71
   11ea8:	000203ec 	.word	0x000203ec
   11eac:	00020a6c 	.word	0x00020a6c
   11eb0:	00016e3d 	.word	0x00016e3d
   11eb4:	00020b38 	.word	0x00020b38
   11eb8:	00016f5d 	.word	0x00016f5d
   11ebc:	00016e71 	.word	0x00016e71
   11ec0:	00011b61 	.word	0x00011b61
   11ec4:	00020b58 	.word	0x00020b58
   11ec8:	00012449 	.word	0x00012449

00011ecc <nmi_spi_read>:
#endif

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
   11ecc:	b500      	push	{lr}
   11ece:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
   11ed0:	ab01      	add	r3, sp, #4
   11ed2:	2200      	movs	r2, #0
   11ed4:	9201      	str	r2, [sp, #4]
	spi.pu8OutBuf = b;
   11ed6:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
   11ed8:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   11eda:	2003      	movs	r0, #3
   11edc:	1c19      	adds	r1, r3, #0
   11ede:	4b02      	ldr	r3, [pc, #8]	; (11ee8 <nmi_spi_read+0x1c>)
   11ee0:	4798      	blx	r3
}
   11ee2:	b005      	add	sp, #20
   11ee4:	bd00      	pop	{pc}
   11ee6:	46c0      	nop			; (mov r8, r8)
   11ee8:	000107fd 	.word	0x000107fd

00011eec <spi_cmd_rsp>:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
   11eec:	b5f0      	push	{r4, r5, r6, r7, lr}
   11eee:	b083      	sub	sp, #12
   11ef0:	1e06      	subs	r6, r0, #0
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
   11ef2:	2ecf      	cmp	r6, #207	; 0xcf
   11ef4:	d004      	beq.n	11f00 <spi_cmd_rsp+0x14>
   11ef6:	1c03      	adds	r3, r0, #0
   11ef8:	333b      	adds	r3, #59	; 0x3b
   11efa:	b2db      	uxtb	r3, r3
   11efc:	2b01      	cmp	r3, #1
   11efe:	d807      	bhi.n	11f10 <spi_cmd_rsp+0x24>
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11f00:	466b      	mov	r3, sp
   11f02:	1dd8      	adds	r0, r3, #7
   11f04:	2101      	movs	r1, #1
   11f06:	4b24      	ldr	r3, [pc, #144]	; (11f98 <spi_cmd_rsp+0xac>)
   11f08:	4798      	blx	r3
			result = N_FAIL;
   11f0a:	2300      	movs	r3, #0
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11f0c:	2800      	cmp	r0, #0
   11f0e:	d140      	bne.n	11f92 <spi_cmd_rsp+0xa6>

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
   11f10:	240b      	movs	r4, #11

	/* wait for response */
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11f12:	466b      	mov	r3, sp
   11f14:	1ddd      	adds	r5, r3, #7
   11f16:	4f20      	ldr	r7, [pc, #128]	; (11f98 <spi_cmd_rsp+0xac>)
   11f18:	1c28      	adds	r0, r5, #0
   11f1a:	2101      	movs	r1, #1
   11f1c:	47b8      	blx	r7
   11f1e:	2800      	cmp	r0, #0
   11f20:	d00d      	beq.n	11f3e <spi_cmd_rsp+0x52>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
   11f22:	481e      	ldr	r0, [pc, #120]	; (11f9c <spi_cmd_rsp+0xb0>)
   11f24:	491e      	ldr	r1, [pc, #120]	; (11fa0 <spi_cmd_rsp+0xb4>)
   11f26:	2240      	movs	r2, #64	; 0x40
   11f28:	32ff      	adds	r2, #255	; 0xff
   11f2a:	4b1e      	ldr	r3, [pc, #120]	; (11fa4 <spi_cmd_rsp+0xb8>)
   11f2c:	4798      	blx	r3
   11f2e:	481e      	ldr	r0, [pc, #120]	; (11fa8 <spi_cmd_rsp+0xbc>)
   11f30:	4b1e      	ldr	r3, [pc, #120]	; (11fac <spi_cmd_rsp+0xc0>)
   11f32:	4798      	blx	r3
   11f34:	200d      	movs	r0, #13
   11f36:	4b1e      	ldr	r3, [pc, #120]	; (11fb0 <spi_cmd_rsp+0xc4>)
   11f38:	4798      	blx	r3
			result = N_FAIL;
   11f3a:	2300      	movs	r3, #0
			goto _fail_;
   11f3c:	e029      	b.n	11f92 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
   11f3e:	782b      	ldrb	r3, [r5, #0]
   11f40:	42b3      	cmp	r3, r6
   11f42:	d005      	beq.n	11f50 <spi_cmd_rsp+0x64>
   11f44:	3c01      	subs	r4, #1
   11f46:	b2e4      	uxtb	r4, r4
   11f48:	2c00      	cmp	r4, #0
   11f4a:	d1e5      	bne.n	11f18 <spi_cmd_rsp+0x2c>
   11f4c:	340b      	adds	r4, #11
   11f4e:	e000      	b.n	11f52 <spi_cmd_rsp+0x66>
   11f50:	240b      	movs	r4, #11
	**/
	/* wait for response */
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11f52:	466b      	mov	r3, sp
   11f54:	1ddd      	adds	r5, r3, #7
   11f56:	4e10      	ldr	r6, [pc, #64]	; (11f98 <spi_cmd_rsp+0xac>)
   11f58:	1c28      	adds	r0, r5, #0
   11f5a:	2101      	movs	r1, #1
   11f5c:	47b0      	blx	r6
   11f5e:	2800      	cmp	r0, #0
   11f60:	d00d      	beq.n	11f7e <spi_cmd_rsp+0x92>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
   11f62:	480e      	ldr	r0, [pc, #56]	; (11f9c <spi_cmd_rsp+0xb0>)
   11f64:	490e      	ldr	r1, [pc, #56]	; (11fa0 <spi_cmd_rsp+0xb4>)
   11f66:	224e      	movs	r2, #78	; 0x4e
   11f68:	32ff      	adds	r2, #255	; 0xff
   11f6a:	4b0e      	ldr	r3, [pc, #56]	; (11fa4 <spi_cmd_rsp+0xb8>)
   11f6c:	4798      	blx	r3
   11f6e:	480e      	ldr	r0, [pc, #56]	; (11fa8 <spi_cmd_rsp+0xbc>)
   11f70:	4b0e      	ldr	r3, [pc, #56]	; (11fac <spi_cmd_rsp+0xc0>)
   11f72:	4798      	blx	r3
   11f74:	200d      	movs	r0, #13
   11f76:	4b0e      	ldr	r3, [pc, #56]	; (11fb0 <spi_cmd_rsp+0xc4>)
   11f78:	4798      	blx	r3
			result = N_FAIL;
   11f7a:	2300      	movs	r3, #0
			goto _fail_;
   11f7c:	e009      	b.n	11f92 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
   11f7e:	782b      	ldrb	r3, [r5, #0]
   11f80:	2b00      	cmp	r3, #0
   11f82:	d005      	beq.n	11f90 <spi_cmd_rsp+0xa4>
   11f84:	3c01      	subs	r4, #1
   11f86:	b2e4      	uxtb	r4, r4
   11f88:	2c00      	cmp	r4, #0
   11f8a:	d1e5      	bne.n	11f58 <spi_cmd_rsp+0x6c>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
   11f8c:	2301      	movs	r3, #1
   11f8e:	e000      	b.n	11f92 <spi_cmd_rsp+0xa6>
   11f90:	2301      	movs	r3, #1
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
   11f92:	b258      	sxtb	r0, r3
}
   11f94:	b003      	add	sp, #12
   11f96:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11f98:	00011ecd 	.word	0x00011ecd
   11f9c:	000203ec 	.word	0x000203ec
   11fa0:	00020bd8 	.word	0x00020bd8
   11fa4:	00016e3d 	.word	0x00016e3d
   11fa8:	00020c00 	.word	0x00020c00
   11fac:	00016f5d 	.word	0x00016f5d
   11fb0:	00016e71 	.word	0x00016e71

00011fb4 <spi_data_read>:

static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
   11fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
   11fb6:	465f      	mov	r7, fp
   11fb8:	4656      	mov	r6, sl
   11fba:	464d      	mov	r5, r9
   11fbc:	4644      	mov	r4, r8
   11fbe:	b4f0      	push	{r4, r5, r6, r7}
   11fc0:	b085      	sub	sp, #20
   11fc2:	4682      	mov	sl, r0
   11fc4:	4689      	mov	r9, r1
   11fc6:	4693      	mov	fp, r2
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
   11fc8:	2300      	movs	r3, #0
   11fca:	4698      	mov	r8, r3
		/**
			Data Respnose header
		**/
		retry = 10;
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11fcc:	4f41      	ldr	r7, [pc, #260]	; (120d4 <spi_data_read+0x120>)
	/**
		Data
	**/
	ix = 0;
	do {
		if (sz <= DATA_PKT_SZ)
   11fce:	2380      	movs	r3, #128	; 0x80
   11fd0:	019b      	lsls	r3, r3, #6
   11fd2:	4599      	cmp	r9, r3
   11fd4:	d804      	bhi.n	11fe0 <spi_data_read+0x2c>
			nbytes = sz;
   11fd6:	464b      	mov	r3, r9
   11fd8:	466a      	mov	r2, sp
   11fda:	80d3      	strh	r3, [r2, #6]
   11fdc:	88d6      	ldrh	r6, [r2, #6]
   11fde:	e001      	b.n	11fe4 <spi_data_read+0x30>
		else
			nbytes = DATA_PKT_SZ;
   11fe0:	2680      	movs	r6, #128	; 0x80
   11fe2:	01b6      	lsls	r6, r6, #6

		/**
			Data Respnose header
		**/
		retry = 10;
   11fe4:	240a      	movs	r4, #10
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   11fe6:	ab02      	add	r3, sp, #8
   11fe8:	1cdd      	adds	r5, r3, #3
   11fea:	1c28      	adds	r0, r5, #0
   11fec:	2101      	movs	r1, #1
   11fee:	47b8      	blx	r7
   11ff0:	2800      	cmp	r0, #0
   11ff2:	d00d      	beq.n	12010 <spi_data_read+0x5c>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
   11ff4:	4838      	ldr	r0, [pc, #224]	; (120d8 <spi_data_read+0x124>)
   11ff6:	4939      	ldr	r1, [pc, #228]	; (120dc <spi_data_read+0x128>)
   11ff8:	2270      	movs	r2, #112	; 0x70
   11ffa:	32ff      	adds	r2, #255	; 0xff
   11ffc:	4b38      	ldr	r3, [pc, #224]	; (120e0 <spi_data_read+0x12c>)
   11ffe:	4798      	blx	r3
   12000:	4838      	ldr	r0, [pc, #224]	; (120e4 <spi_data_read+0x130>)
   12002:	4b39      	ldr	r3, [pc, #228]	; (120e8 <spi_data_read+0x134>)
   12004:	4798      	blx	r3
   12006:	200d      	movs	r0, #13
   12008:	4b38      	ldr	r3, [pc, #224]	; (120ec <spi_data_read+0x138>)
   1200a:	4798      	blx	r3
   1200c:	2000      	movs	r0, #0
   1200e:	e058      	b.n	120c2 <spi_data_read+0x10e>
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
   12010:	782b      	ldrb	r3, [r5, #0]
   12012:	091b      	lsrs	r3, r3, #4
   12014:	2b0f      	cmp	r3, #15
   12016:	d005      	beq.n	12024 <spi_data_read+0x70>
   12018:	3c01      	subs	r4, #1
   1201a:	b2a4      	uxth	r4, r4
				break;
		} while (retry--);
   1201c:	b223      	sxth	r3, r4
   1201e:	3301      	adds	r3, #1
   12020:	d1e3      	bne.n	11fea <spi_data_read+0x36>
   12022:	e002      	b.n	1202a <spi_data_read+0x76>

		if (result == N_FAIL)
			break;

		if (retry <= 0) {
   12024:	b224      	sxth	r4, r4
   12026:	2c00      	cmp	r4, #0
   12028:	dc0e      	bgt.n	12048 <spi_data_read+0x94>
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
   1202a:	482b      	ldr	r0, [pc, #172]	; (120d8 <spi_data_read+0x124>)
   1202c:	492b      	ldr	r1, [pc, #172]	; (120dc <spi_data_read+0x128>)
   1202e:	227c      	movs	r2, #124	; 0x7c
   12030:	32ff      	adds	r2, #255	; 0xff
   12032:	4c2b      	ldr	r4, [pc, #172]	; (120e0 <spi_data_read+0x12c>)
   12034:	47a0      	blx	r4
   12036:	ab02      	add	r3, sp, #8
   12038:	78d9      	ldrb	r1, [r3, #3]
   1203a:	482d      	ldr	r0, [pc, #180]	; (120f0 <spi_data_read+0x13c>)
   1203c:	47a0      	blx	r4
   1203e:	200d      	movs	r0, #13
   12040:	4b2a      	ldr	r3, [pc, #168]	; (120ec <spi_data_read+0x138>)
   12042:	4798      	blx	r3
			result = N_FAIL;
   12044:	2000      	movs	r0, #0
			break;
   12046:	e03c      	b.n	120c2 <spi_data_read+0x10e>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
   12048:	b2b6      	uxth	r6, r6
   1204a:	4643      	mov	r3, r8
   1204c:	b218      	sxth	r0, r3
   1204e:	4450      	add	r0, sl
   12050:	1c31      	adds	r1, r6, #0
   12052:	4b20      	ldr	r3, [pc, #128]	; (120d4 <spi_data_read+0x120>)
   12054:	4798      	blx	r3
   12056:	2800      	cmp	r0, #0
   12058:	d00d      	beq.n	12076 <spi_data_read+0xc2>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
   1205a:	481f      	ldr	r0, [pc, #124]	; (120d8 <spi_data_read+0x124>)
   1205c:	491f      	ldr	r1, [pc, #124]	; (120dc <spi_data_read+0x128>)
   1205e:	22c2      	movs	r2, #194	; 0xc2
   12060:	0052      	lsls	r2, r2, #1
   12062:	4b1f      	ldr	r3, [pc, #124]	; (120e0 <spi_data_read+0x12c>)
   12064:	4798      	blx	r3
   12066:	4823      	ldr	r0, [pc, #140]	; (120f4 <spi_data_read+0x140>)
   12068:	4b1f      	ldr	r3, [pc, #124]	; (120e8 <spi_data_read+0x134>)
   1206a:	4798      	blx	r3
   1206c:	200d      	movs	r0, #13
   1206e:	4b1f      	ldr	r3, [pc, #124]	; (120ec <spi_data_read+0x138>)
   12070:	4798      	blx	r3
			result = N_FAIL;
   12072:	2000      	movs	r0, #0
			break;
   12074:	e025      	b.n	120c2 <spi_data_read+0x10e>
		}
		if(!clockless)
   12076:	465b      	mov	r3, fp
   12078:	2b00      	cmp	r3, #0
   1207a:	d117      	bne.n	120ac <spi_data_read+0xf8>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
   1207c:	4b1e      	ldr	r3, [pc, #120]	; (120f8 <spi_data_read+0x144>)
   1207e:	781b      	ldrb	r3, [r3, #0]
   12080:	2b00      	cmp	r3, #0
   12082:	d113      	bne.n	120ac <spi_data_read+0xf8>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
   12084:	a803      	add	r0, sp, #12
   12086:	2102      	movs	r1, #2
   12088:	4b12      	ldr	r3, [pc, #72]	; (120d4 <spi_data_read+0x120>)
   1208a:	4798      	blx	r3
   1208c:	2800      	cmp	r0, #0
   1208e:	d00d      	beq.n	120ac <spi_data_read+0xf8>
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   12090:	4811      	ldr	r0, [pc, #68]	; (120d8 <spi_data_read+0x124>)
   12092:	4912      	ldr	r1, [pc, #72]	; (120dc <spi_data_read+0x128>)
   12094:	2290      	movs	r2, #144	; 0x90
   12096:	32ff      	adds	r2, #255	; 0xff
   12098:	4b11      	ldr	r3, [pc, #68]	; (120e0 <spi_data_read+0x12c>)
   1209a:	4798      	blx	r3
   1209c:	4817      	ldr	r0, [pc, #92]	; (120fc <spi_data_read+0x148>)
   1209e:	4b12      	ldr	r3, [pc, #72]	; (120e8 <spi_data_read+0x134>)
   120a0:	4798      	blx	r3
   120a2:	200d      	movs	r0, #13
   120a4:	4b11      	ldr	r3, [pc, #68]	; (120ec <spi_data_read+0x138>)
   120a6:	4798      	blx	r3
					result = N_FAIL;
   120a8:	2000      	movs	r0, #0
					break;
   120aa:	e00a      	b.n	120c2 <spi_data_read+0x10e>
				}
			}
		}
		ix += nbytes;
   120ac:	4643      	mov	r3, r8
   120ae:	18f3      	adds	r3, r6, r3
   120b0:	b29b      	uxth	r3, r3
   120b2:	4698      	mov	r8, r3
		sz -= nbytes;
   120b4:	464b      	mov	r3, r9
   120b6:	1b9e      	subs	r6, r3, r6
   120b8:	b2b3      	uxth	r3, r6
   120ba:	4699      	mov	r9, r3

	} while (sz);
   120bc:	2b00      	cmp	r3, #0
   120be:	d186      	bne.n	11fce <spi_data_read+0x1a>
   120c0:	2001      	movs	r0, #1

	return result;
   120c2:	b240      	sxtb	r0, r0
}
   120c4:	b005      	add	sp, #20
   120c6:	bc3c      	pop	{r2, r3, r4, r5}
   120c8:	4690      	mov	r8, r2
   120ca:	4699      	mov	r9, r3
   120cc:	46a2      	mov	sl, r4
   120ce:	46ab      	mov	fp, r5
   120d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   120d2:	46c0      	nop			; (mov r8, r8)
   120d4:	00011ecd 	.word	0x00011ecd
   120d8:	000203ec 	.word	0x000203ec
   120dc:	000211c0 	.word	0x000211c0
   120e0:	00016e3d 	.word	0x00016e3d
   120e4:	00020c34 	.word	0x00020c34
   120e8:	00016f5d 	.word	0x00016f5d
   120ec:	00016e71 	.word	0x00016e71
   120f0:	00020c68 	.word	0x00020c68
   120f4:	00020c98 	.word	0x00020c98
   120f8:	20001318 	.word	0x20001318
   120fc:	00020cc8 	.word	0x00020cc8

00012100 <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
   12100:	b500      	push	{lr}
   12102:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
   12104:	ab01      	add	r3, sp, #4
   12106:	9001      	str	r0, [sp, #4]
	spi.pu8OutBuf = NULL;
   12108:	2200      	movs	r2, #0
   1210a:	9202      	str	r2, [sp, #8]
	spi.u16Sz = sz;
   1210c:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   1210e:	2003      	movs	r0, #3
   12110:	1c19      	adds	r1, r3, #0
   12112:	4b02      	ldr	r3, [pc, #8]	; (1211c <nmi_spi_write+0x1c>)
   12114:	4798      	blx	r3
}
   12116:	b005      	add	sp, #20
   12118:	bd00      	pop	{pc}
   1211a:	46c0      	nop			; (mov r8, r8)
   1211c:	000107fd 	.word	0x000107fd

00012120 <spi_cmd>:
#define DATA_PKT_SZ_4K			(4 * 1024)
#define DATA_PKT_SZ_8K			(8 * 1024)
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
   12120:	b570      	push	{r4, r5, r6, lr}
   12122:	b084      	sub	sp, #16
   12124:	ac08      	add	r4, sp, #32
   12126:	7825      	ldrb	r5, [r4, #0]
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
   12128:	ac01      	add	r4, sp, #4
   1212a:	7020      	strb	r0, [r4, #0]
	switch (cmd) {
   1212c:	303f      	adds	r0, #63	; 0x3f
   1212e:	b2c4      	uxtb	r4, r0
   12130:	2c0e      	cmp	r4, #14
   12132:	d900      	bls.n	12136 <spi_cmd+0x16>
   12134:	e092      	b.n	1225c <spi_cmd+0x13c>
   12136:	00a0      	lsls	r0, r4, #2
   12138:	4c50      	ldr	r4, [pc, #320]	; (1227c <spi_cmd+0x15c>)
   1213a:	5820      	ldr	r0, [r4, r0]
   1213c:	4687      	mov	pc, r0
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
   1213e:	ab01      	add	r3, sp, #4
   12140:	0c0a      	lsrs	r2, r1, #16
   12142:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
   12144:	0a0a      	lsrs	r2, r1, #8
   12146:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
   12148:	70d9      	strb	r1, [r3, #3]
		len = 5;
   1214a:	2105      	movs	r1, #5
		break;
   1214c:	e08e      	b.n	1226c <spi_cmd+0x14c>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
   1214e:	0a0b      	lsrs	r3, r1, #8
   12150:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
   12152:	2d00      	cmp	r5, #0
   12154:	d102      	bne.n	1215c <spi_cmd+0x3c>
		bc[2] = (uint8)(adr >> 8);
		bc[3] = (uint8)adr;
		len = 5;
		break;
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
   12156:	aa01      	add	r2, sp, #4
   12158:	7053      	strb	r3, [r2, #1]
   1215a:	e004      	b.n	12166 <spi_cmd+0x46>
		if(clockless)  bc[1] |= (1 << 7);
   1215c:	2280      	movs	r2, #128	; 0x80
   1215e:	4252      	negs	r2, r2
   12160:	4313      	orrs	r3, r2
   12162:	aa01      	add	r2, sp, #4
   12164:	7053      	strb	r3, [r2, #1]
		bc[2] = (uint8)adr;
   12166:	ab01      	add	r3, sp, #4
   12168:	7099      	strb	r1, [r3, #2]
		bc[3] = 0x00;
   1216a:	2200      	movs	r2, #0
   1216c:	70da      	strb	r2, [r3, #3]
		len = 5;
   1216e:	2105      	movs	r1, #5
		break;
   12170:	e07c      	b.n	1226c <spi_cmd+0x14c>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
   12172:	ab01      	add	r3, sp, #4
   12174:	2200      	movs	r2, #0
   12176:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
   12178:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
   1217a:	70da      	strb	r2, [r3, #3]
		len = 5;
   1217c:	2105      	movs	r1, #5
		break;
   1217e:	e075      	b.n	1226c <spi_cmd+0x14c>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
   12180:	ab01      	add	r3, sp, #4
   12182:	2200      	movs	r2, #0
   12184:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
   12186:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
   12188:	70da      	strb	r2, [r3, #3]
		len = 5;
   1218a:	2105      	movs	r1, #5
		break;
   1218c:	e06e      	b.n	1226c <spi_cmd+0x14c>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
   1218e:	ab01      	add	r3, sp, #4
   12190:	22ff      	movs	r2, #255	; 0xff
   12192:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
   12194:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
   12196:	70da      	strb	r2, [r3, #3]
		len = 5;
   12198:	2105      	movs	r1, #5
		break;
   1219a:	e067      	b.n	1226c <spi_cmd+0x14c>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
   1219c:	aa01      	add	r2, sp, #4
   1219e:	0c08      	lsrs	r0, r1, #16
   121a0:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
   121a2:	0a08      	lsrs	r0, r1, #8
   121a4:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
   121a6:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 8);
   121a8:	0a19      	lsrs	r1, r3, #8
   121aa:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz);
   121ac:	7153      	strb	r3, [r2, #5]
		len = 7;
   121ae:	2107      	movs	r1, #7
		break;
   121b0:	e05c      	b.n	1226c <spi_cmd+0x14c>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
   121b2:	aa01      	add	r2, sp, #4
   121b4:	0c08      	lsrs	r0, r1, #16
   121b6:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
   121b8:	0a08      	lsrs	r0, r1, #8
   121ba:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
   121bc:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 16);
   121be:	0c19      	lsrs	r1, r3, #16
   121c0:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz >> 8);
   121c2:	0a19      	lsrs	r1, r3, #8
   121c4:	7151      	strb	r1, [r2, #5]
		bc[6] = (uint8)(sz);
   121c6:	7193      	strb	r3, [r2, #6]
		len = 8;
   121c8:	2108      	movs	r1, #8
		break;
   121ca:	e04f      	b.n	1226c <spi_cmd+0x14c>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
   121cc:	0a0b      	lsrs	r3, r1, #8
   121ce:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
   121d0:	2d00      	cmp	r5, #0
   121d2:	d102      	bne.n	121da <spi_cmd+0xba>
		bc[5] = (uint8)(sz >> 8);
		bc[6] = (uint8)(sz);
		len = 8;
		break;
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
   121d4:	a801      	add	r0, sp, #4
   121d6:	7043      	strb	r3, [r0, #1]
   121d8:	e004      	b.n	121e4 <spi_cmd+0xc4>
		if(clockless)  bc[1] |= (1 << 7);
   121da:	2080      	movs	r0, #128	; 0x80
   121dc:	4240      	negs	r0, r0
   121de:	4303      	orrs	r3, r0
   121e0:	a801      	add	r0, sp, #4
   121e2:	7043      	strb	r3, [r0, #1]
		bc[2] = (uint8)(adr);
   121e4:	ab01      	add	r3, sp, #4
   121e6:	7099      	strb	r1, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
   121e8:	0e11      	lsrs	r1, r2, #24
   121ea:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
   121ec:	0c11      	lsrs	r1, r2, #16
   121ee:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
   121f0:	0a11      	lsrs	r1, r2, #8
   121f2:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data);
   121f4:	719a      	strb	r2, [r3, #6]
		len = 8;
   121f6:	2108      	movs	r1, #8
		break;
   121f8:	e038      	b.n	1226c <spi_cmd+0x14c>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
   121fa:	ab01      	add	r3, sp, #4
   121fc:	0c08      	lsrs	r0, r1, #16
   121fe:	7058      	strb	r0, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
   12200:	0a08      	lsrs	r0, r1, #8
   12202:	7098      	strb	r0, [r3, #2]
		bc[3] = (uint8)(adr);
   12204:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
   12206:	0e11      	lsrs	r1, r2, #24
   12208:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
   1220a:	0c11      	lsrs	r1, r2, #16
   1220c:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
   1220e:	0a11      	lsrs	r1, r2, #8
   12210:	7199      	strb	r1, [r3, #6]
		bc[7] = (uint8)(u32data);
   12212:	71da      	strb	r2, [r3, #7]
		len = 9;
   12214:	2109      	movs	r1, #9
		break;
   12216:	e029      	b.n	1226c <spi_cmd+0x14c>
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
   12218:	7810      	ldrb	r0, [r2, #0]
   1221a:	005b      	lsls	r3, r3, #1
   1221c:	4043      	eors	r3, r0
   1221e:	5ce3      	ldrb	r3, [r4, r3]
   12220:	3201      	adds	r2, #1
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
   12222:	42aa      	cmp	r2, r5
   12224:	d1f8      	bne.n	12218 <spi_cmd+0xf8>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
   12226:	005b      	lsls	r3, r3, #1
   12228:	aa01      	add	r2, sp, #4
   1222a:	5593      	strb	r3, [r2, r6]
   1222c:	e001      	b.n	12232 <spi_cmd+0x112>
		else
			len-=1;
   1222e:	3901      	subs	r1, #1
   12230:	b2c9      	uxtb	r1, r1

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
   12232:	b289      	uxth	r1, r1
   12234:	a801      	add	r0, sp, #4
   12236:	4b12      	ldr	r3, [pc, #72]	; (12280 <spi_cmd+0x160>)
   12238:	4798      	blx	r3
   1223a:	2301      	movs	r3, #1
   1223c:	2800      	cmp	r0, #0
   1223e:	d01a      	beq.n	12276 <spi_cmd+0x156>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
   12240:	4810      	ldr	r0, [pc, #64]	; (12284 <spi_cmd+0x164>)
   12242:	4911      	ldr	r1, [pc, #68]	; (12288 <spi_cmd+0x168>)
   12244:	2290      	movs	r2, #144	; 0x90
   12246:	0052      	lsls	r2, r2, #1
   12248:	4b10      	ldr	r3, [pc, #64]	; (1228c <spi_cmd+0x16c>)
   1224a:	4798      	blx	r3
   1224c:	4810      	ldr	r0, [pc, #64]	; (12290 <spi_cmd+0x170>)
   1224e:	4b11      	ldr	r3, [pc, #68]	; (12294 <spi_cmd+0x174>)
   12250:	4798      	blx	r3
   12252:	200d      	movs	r0, #13
   12254:	4b10      	ldr	r3, [pc, #64]	; (12298 <spi_cmd+0x178>)
   12256:	4798      	blx	r3
			result = N_FAIL;
   12258:	2300      	movs	r3, #0
   1225a:	e00c      	b.n	12276 <spi_cmd+0x156>
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
	switch (cmd) {
   1225c:	2300      	movs	r3, #0
   1225e:	e00a      	b.n	12276 <spi_cmd+0x156>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
   12260:	1e4e      	subs	r6, r1, #1
   12262:	aa01      	add	r2, sp, #4
   12264:	1995      	adds	r5, r2, r6
   12266:	237f      	movs	r3, #127	; 0x7f
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
   12268:	4c0c      	ldr	r4, [pc, #48]	; (1229c <spi_cmd+0x17c>)
   1226a:	e7d5      	b.n	12218 <spi_cmd+0xf8>
		result = N_FAIL;
		break;
	}

	if (result) {
		if (!gu8Crc_off)
   1226c:	4b0c      	ldr	r3, [pc, #48]	; (122a0 <spi_cmd+0x180>)
   1226e:	781b      	ldrb	r3, [r3, #0]
   12270:	2b00      	cmp	r3, #0
   12272:	d0f5      	beq.n	12260 <spi_cmd+0x140>
   12274:	e7db      	b.n	1222e <spi_cmd+0x10e>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
			result = N_FAIL;
		}
	}

	return result;
   12276:	b258      	sxtb	r0, r3
}
   12278:	b004      	add	sp, #16
   1227a:	bd70      	pop	{r4, r5, r6, pc}
   1227c:	00020b74 	.word	0x00020b74
   12280:	00012101 	.word	0x00012101
   12284:	000203ec 	.word	0x000203ec
   12288:	00020bc0 	.word	0x00020bc0
   1228c:	00016e3d 	.word	0x00016e3d
   12290:	00020cfc 	.word	0x00020cfc
   12294:	00016f5d 	.word	0x00016f5d
   12298:	00016e71 	.word	0x00016e71
   1229c:	000210c0 	.word	0x000210c0
   122a0:	20001318 	.word	0x20001318

000122a4 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
   122a4:	b570      	push	{r4, r5, r6, lr}
   122a6:	b082      	sub	sp, #8
   122a8:	1c04      	adds	r4, r0, #0
   122aa:	1c0a      	adds	r2, r1, #0
	sint8 result = N_OK;
	uint8 cmd = CMD_SINGLE_WRITE;
	uint8 clockless = 0;
	if (addr <= 0x30)
   122ac:	2830      	cmp	r0, #48	; 0x30
   122ae:	d902      	bls.n	122b6 <spi_write_reg+0x12>
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
   122b0:	2300      	movs	r3, #0
		cmd = CMD_INTERNAL_WRITE;
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_WRITE;
   122b2:	25c9      	movs	r5, #201	; 0xc9
   122b4:	e001      	b.n	122ba <spi_write_reg+0x16>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_WRITE;
		clockless = 1;
   122b6:	2301      	movs	r3, #1
	if (addr <= 0x30)
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_WRITE;
   122b8:	25c3      	movs	r5, #195	; 0xc3
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
   122ba:	9300      	str	r3, [sp, #0]
   122bc:	1c28      	adds	r0, r5, #0
   122be:	1c21      	adds	r1, r4, #0
   122c0:	2304      	movs	r3, #4
   122c2:	4e16      	ldr	r6, [pc, #88]	; (1231c <spi_write_reg+0x78>)
   122c4:	47b0      	blx	r6
	if (result != N_OK) {
   122c6:	2801      	cmp	r0, #1
   122c8:	d00c      	beq.n	122e4 <spi_write_reg+0x40>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
   122ca:	4815      	ldr	r0, [pc, #84]	; (12320 <spi_write_reg+0x7c>)
   122cc:	4915      	ldr	r1, [pc, #84]	; (12324 <spi_write_reg+0x80>)
   122ce:	4a16      	ldr	r2, [pc, #88]	; (12328 <spi_write_reg+0x84>)
   122d0:	4d16      	ldr	r5, [pc, #88]	; (1232c <spi_write_reg+0x88>)
   122d2:	47a8      	blx	r5
   122d4:	4816      	ldr	r0, [pc, #88]	; (12330 <spi_write_reg+0x8c>)
   122d6:	1c21      	adds	r1, r4, #0
   122d8:	47a8      	blx	r5
   122da:	200d      	movs	r0, #13
   122dc:	4b15      	ldr	r3, [pc, #84]	; (12334 <spi_write_reg+0x90>)
   122de:	4798      	blx	r3
		return N_FAIL;
   122e0:	2300      	movs	r3, #0
   122e2:	e018      	b.n	12316 <spi_write_reg+0x72>
	}

	result = spi_cmd_rsp(cmd);
   122e4:	1c28      	adds	r0, r5, #0
   122e6:	4b14      	ldr	r3, [pc, #80]	; (12338 <spi_write_reg+0x94>)
   122e8:	4798      	blx	r3
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
		return N_FAIL;
	}

	return N_OK;
   122ea:	2301      	movs	r3, #1
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
	if (result != N_OK) {
   122ec:	2801      	cmp	r0, #1
   122ee:	d012      	beq.n	12316 <spi_write_reg+0x72>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
   122f0:	480b      	ldr	r0, [pc, #44]	; (12320 <spi_write_reg+0x7c>)
   122f2:	490c      	ldr	r1, [pc, #48]	; (12324 <spi_write_reg+0x80>)
   122f4:	4a11      	ldr	r2, [pc, #68]	; (1233c <spi_write_reg+0x98>)
   122f6:	4d0d      	ldr	r5, [pc, #52]	; (1232c <spi_write_reg+0x88>)
   122f8:	47a8      	blx	r5
   122fa:	4811      	ldr	r0, [pc, #68]	; (12340 <spi_write_reg+0x9c>)
   122fc:	1c21      	adds	r1, r4, #0
   122fe:	47a8      	blx	r5
   12300:	200d      	movs	r0, #13
   12302:	4b0c      	ldr	r3, [pc, #48]	; (12334 <spi_write_reg+0x90>)
   12304:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   12306:	2300      	movs	r3, #0
   12308:	9300      	str	r3, [sp, #0]
   1230a:	20cf      	movs	r0, #207	; 0xcf
   1230c:	2100      	movs	r1, #0
   1230e:	2200      	movs	r2, #0
   12310:	4c02      	ldr	r4, [pc, #8]	; (1231c <spi_write_reg+0x78>)
   12312:	47a0      	blx	r4
		return N_FAIL;
   12314:	2300      	movs	r3, #0
   12316:	b258      	sxtb	r0, r3
	}

	return result;

#endif
}
   12318:	b002      	add	sp, #8
   1231a:	bd70      	pop	{r4, r5, r6, pc}
   1231c:	00012121 	.word	0x00012121
   12320:	000203ec 	.word	0x000203ec
   12324:	00020bb0 	.word	0x00020bb0
   12328:	00000203 	.word	0x00000203
   1232c:	00016e3d 	.word	0x00016e3d
   12330:	00020d28 	.word	0x00020d28
   12334:	00016e71 	.word	0x00016e71
   12338:	00011eed 	.word	0x00011eed
   1233c:	00000209 	.word	0x00000209
   12340:	00020d54 	.word	0x00020d54

00012344 <spi_read_reg>:

	return N_OK;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
   12344:	b5f0      	push	{r4, r5, r6, r7, lr}
   12346:	b087      	sub	sp, #28
   12348:	1e04      	subs	r4, r0, #0
   1234a:	9103      	str	r1, [sp, #12]
	sint8 result = N_OK;
	uint8 cmd = CMD_SINGLE_READ;
	uint8 tmp[4];
	uint8 clockless = 0;

	if (addr <= 0xff)
   1234c:	2cff      	cmp	r4, #255	; 0xff
   1234e:	d902      	bls.n	12356 <spi_read_reg+0x12>
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_READ;
		clockless = 0;
   12350:	2600      	movs	r6, #0
		cmd = CMD_INTERNAL_READ;
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_READ;
   12352:	25ca      	movs	r5, #202	; 0xca
   12354:	e001      	b.n	1235a <spi_read_reg+0x16>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_READ;
		clockless = 1;
   12356:	2601      	movs	r6, #1
	if (addr <= 0xff)
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_READ;
   12358:	25c4      	movs	r5, #196	; 0xc4
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
   1235a:	9600      	str	r6, [sp, #0]
   1235c:	1c28      	adds	r0, r5, #0
   1235e:	1c21      	adds	r1, r4, #0
   12360:	2200      	movs	r2, #0
   12362:	2304      	movs	r3, #4
   12364:	4f2a      	ldr	r7, [pc, #168]	; (12410 <spi_read_reg+0xcc>)
   12366:	47b8      	blx	r7
	if (result != N_OK) {
   12368:	2801      	cmp	r0, #1
   1236a:	d00c      	beq.n	12386 <spi_read_reg+0x42>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
   1236c:	4829      	ldr	r0, [pc, #164]	; (12414 <spi_read_reg+0xd0>)
   1236e:	492a      	ldr	r1, [pc, #168]	; (12418 <spi_read_reg+0xd4>)
   12370:	4a2a      	ldr	r2, [pc, #168]	; (1241c <spi_read_reg+0xd8>)
   12372:	4d2b      	ldr	r5, [pc, #172]	; (12420 <spi_read_reg+0xdc>)
   12374:	47a8      	blx	r5
   12376:	482b      	ldr	r0, [pc, #172]	; (12424 <spi_read_reg+0xe0>)
   12378:	1c21      	adds	r1, r4, #0
   1237a:	47a8      	blx	r5
   1237c:	200d      	movs	r0, #13
   1237e:	4b2a      	ldr	r3, [pc, #168]	; (12428 <spi_read_reg+0xe4>)
   12380:	4798      	blx	r3
		return N_FAIL;
   12382:	2000      	movs	r0, #0
   12384:	e041      	b.n	1240a <spi_read_reg+0xc6>
	}

	result = spi_cmd_rsp(cmd);
   12386:	1c28      	adds	r0, r5, #0
   12388:	4b28      	ldr	r3, [pc, #160]	; (1242c <spi_read_reg+0xe8>)
   1238a:	4798      	blx	r3
	if (result != N_OK) {
   1238c:	2801      	cmp	r0, #1
   1238e:	d013      	beq.n	123b8 <spi_read_reg+0x74>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
   12390:	4820      	ldr	r0, [pc, #128]	; (12414 <spi_read_reg+0xd0>)
   12392:	4921      	ldr	r1, [pc, #132]	; (12418 <spi_read_reg+0xd4>)
   12394:	4a26      	ldr	r2, [pc, #152]	; (12430 <spi_read_reg+0xec>)
   12396:	4d22      	ldr	r5, [pc, #136]	; (12420 <spi_read_reg+0xdc>)
   12398:	47a8      	blx	r5
   1239a:	4826      	ldr	r0, [pc, #152]	; (12434 <spi_read_reg+0xf0>)
   1239c:	1c21      	adds	r1, r4, #0
   1239e:	47a8      	blx	r5
   123a0:	200d      	movs	r0, #13
   123a2:	4b21      	ldr	r3, [pc, #132]	; (12428 <spi_read_reg+0xe4>)
   123a4:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   123a6:	2300      	movs	r3, #0
   123a8:	9300      	str	r3, [sp, #0]
   123aa:	20cf      	movs	r0, #207	; 0xcf
   123ac:	2100      	movs	r1, #0
   123ae:	2200      	movs	r2, #0
   123b0:	4c17      	ldr	r4, [pc, #92]	; (12410 <spi_read_reg+0xcc>)
   123b2:	47a0      	blx	r4
		return N_FAIL;
   123b4:	2000      	movs	r0, #0
   123b6:	e028      	b.n	1240a <spi_read_reg+0xc6>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
   123b8:	a805      	add	r0, sp, #20
   123ba:	2104      	movs	r1, #4
   123bc:	1c32      	adds	r2, r6, #0
   123be:	4b1e      	ldr	r3, [pc, #120]	; (12438 <spi_read_reg+0xf4>)
   123c0:	4798      	blx	r3
	if (result != N_OK) {
   123c2:	2801      	cmp	r0, #1
   123c4:	d013      	beq.n	123ee <spi_read_reg+0xaa>
		M2M_ERR("[nmi spi]: Failed data read...\n");
   123c6:	4813      	ldr	r0, [pc, #76]	; (12414 <spi_read_reg+0xd0>)
   123c8:	4913      	ldr	r1, [pc, #76]	; (12418 <spi_read_reg+0xd4>)
   123ca:	4a1c      	ldr	r2, [pc, #112]	; (1243c <spi_read_reg+0xf8>)
   123cc:	4b14      	ldr	r3, [pc, #80]	; (12420 <spi_read_reg+0xdc>)
   123ce:	4798      	blx	r3
   123d0:	481b      	ldr	r0, [pc, #108]	; (12440 <spi_read_reg+0xfc>)
   123d2:	4b1c      	ldr	r3, [pc, #112]	; (12444 <spi_read_reg+0x100>)
   123d4:	4798      	blx	r3
   123d6:	200d      	movs	r0, #13
   123d8:	4b13      	ldr	r3, [pc, #76]	; (12428 <spi_read_reg+0xe4>)
   123da:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   123dc:	2300      	movs	r3, #0
   123de:	9300      	str	r3, [sp, #0]
   123e0:	20cf      	movs	r0, #207	; 0xcf
   123e2:	2100      	movs	r1, #0
   123e4:	2200      	movs	r2, #0
   123e6:	4c0a      	ldr	r4, [pc, #40]	; (12410 <spi_read_reg+0xcc>)
   123e8:	47a0      	blx	r4
		return N_FAIL;
   123ea:	2000      	movs	r0, #0
   123ec:	e00d      	b.n	1240a <spi_read_reg+0xc6>
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
   123ee:	aa05      	add	r2, sp, #20
   123f0:	7853      	ldrb	r3, [r2, #1]
   123f2:	0219      	lsls	r1, r3, #8
		((uint32)tmp[2] << 16) |
   123f4:	7893      	ldrb	r3, [r2, #2]
   123f6:	041b      	lsls	r3, r3, #16
   123f8:	430b      	orrs	r3, r1
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
   123fa:	7811      	ldrb	r1, [r2, #0]
		((uint32)tmp[1] << 8) |
   123fc:	430b      	orrs	r3, r1
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);
   123fe:	78d2      	ldrb	r2, [r2, #3]
   12400:	0612      	lsls	r2, r2, #24

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
   12402:	4313      	orrs	r3, r2
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
   12404:	9a03      	ldr	r2, [sp, #12]
   12406:	6013      	str	r3, [r2, #0]
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);

	return N_OK;
   12408:	2001      	movs	r0, #1
   1240a:	b240      	sxtb	r0, r0
}
   1240c:	b007      	add	sp, #28
   1240e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12410:	00012121 	.word	0x00012121
   12414:	000203ec 	.word	0x000203ec
   12418:	00020be4 	.word	0x00020be4
   1241c:	0000025d 	.word	0x0000025d
   12420:	00016e3d 	.word	0x00016e3d
   12424:	00020d8c 	.word	0x00020d8c
   12428:	00016e71 	.word	0x00016e71
   1242c:	00011eed 	.word	0x00011eed
   12430:	00000263 	.word	0x00000263
   12434:	00020db8 	.word	0x00020db8
   12438:	00011fb5 	.word	0x00011fb5
   1243c:	0000026b 	.word	0x0000026b
   12440:	00020dec 	.word	0x00020dec
   12444:	00016f5d 	.word	0x00016f5d

00012448 <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
   12448:	2200      	movs	r2, #0
   1244a:	4b02      	ldr	r3, [pc, #8]	; (12454 <nm_spi_deinit+0xc>)
   1244c:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
}
   1244e:	2000      	movs	r0, #0
   12450:	4770      	bx	lr
   12452:	46c0      	nop			; (mov r8, r8)
   12454:	20001318 	.word	0x20001318

00012458 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
   12458:	b500      	push	{lr}
   1245a:	b083      	sub	sp, #12
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
   1245c:	a901      	add	r1, sp, #4
   1245e:	4b02      	ldr	r3, [pc, #8]	; (12468 <nm_spi_read_reg+0x10>)
   12460:	4798      	blx	r3

	return u32Val;
}
   12462:	9801      	ldr	r0, [sp, #4]
   12464:	b003      	add	sp, #12
   12466:	bd00      	pop	{pc}
   12468:	00012345 	.word	0x00012345

0001246c <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
   1246c:	b508      	push	{r3, lr}
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
   1246e:	4b04      	ldr	r3, [pc, #16]	; (12480 <nm_spi_read_reg_with_ret+0x14>)
   12470:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   12472:	2300      	movs	r3, #0
   12474:	2801      	cmp	r0, #1
   12476:	d000      	beq.n	1247a <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
   12478:	33fa      	adds	r3, #250	; 0xfa

	return s8Ret;
   1247a:	b258      	sxtb	r0, r3
}
   1247c:	bd08      	pop	{r3, pc}
   1247e:	46c0      	nop			; (mov r8, r8)
   12480:	00012345 	.word	0x00012345

00012484 <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
   12484:	b508      	push	{r3, lr}
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
   12486:	4b04      	ldr	r3, [pc, #16]	; (12498 <nm_spi_write_reg+0x14>)
   12488:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   1248a:	2300      	movs	r3, #0
   1248c:	2801      	cmp	r0, #1
   1248e:	d000      	beq.n	12492 <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
   12490:	33fa      	adds	r3, #250	; 0xfa

	return s8Ret;
   12492:	b258      	sxtb	r0, r3
}
   12494:	bd08      	pop	{r3, pc}
   12496:	46c0      	nop			; (mov r8, r8)
   12498:	000122a5 	.word	0x000122a5

0001249c <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
   1249c:	b510      	push	{r4, lr}
   1249e:	b082      	sub	sp, #8
	uint32 chipid;
	uint32 reg =0;
   124a0:	2300      	movs	r3, #0
   124a2:	9300      	str	r3, [sp, #0]

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
   124a4:	4a35      	ldr	r2, [pc, #212]	; (1257c <nm_spi_init+0xe0>)
   124a6:	7013      	strb	r3, [r2, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
   124a8:	4835      	ldr	r0, [pc, #212]	; (12580 <nm_spi_init+0xe4>)
   124aa:	4669      	mov	r1, sp
   124ac:	4b35      	ldr	r3, [pc, #212]	; (12584 <nm_spi_init+0xe8>)
   124ae:	4798      	blx	r3
   124b0:	2800      	cmp	r0, #0
   124b2:	d120      	bne.n	124f6 <nm_spi_init+0x5a>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
   124b4:	2201      	movs	r2, #1
   124b6:	4b31      	ldr	r3, [pc, #196]	; (1257c <nm_spi_init+0xe0>)
   124b8:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
   124ba:	4833      	ldr	r0, [pc, #204]	; (12588 <nm_spi_init+0xec>)
   124bc:	4933      	ldr	r1, [pc, #204]	; (1258c <nm_spi_init+0xf0>)
   124be:	4a34      	ldr	r2, [pc, #208]	; (12590 <nm_spi_init+0xf4>)
   124c0:	4b34      	ldr	r3, [pc, #208]	; (12594 <nm_spi_init+0xf8>)
   124c2:	4798      	blx	r3
   124c4:	4834      	ldr	r0, [pc, #208]	; (12598 <nm_spi_init+0xfc>)
   124c6:	4b35      	ldr	r3, [pc, #212]	; (1259c <nm_spi_init+0x100>)
   124c8:	4798      	blx	r3
   124ca:	200d      	movs	r0, #13
   124cc:	4b34      	ldr	r3, [pc, #208]	; (125a0 <nm_spi_init+0x104>)
   124ce:	4798      	blx	r3
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
   124d0:	482b      	ldr	r0, [pc, #172]	; (12580 <nm_spi_init+0xe4>)
   124d2:	4669      	mov	r1, sp
   124d4:	4b2b      	ldr	r3, [pc, #172]	; (12584 <nm_spi_init+0xe8>)
   124d6:	4798      	blx	r3
   124d8:	1e04      	subs	r4, r0, #0
   124da:	d10c      	bne.n	124f6 <nm_spi_init+0x5a>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
   124dc:	482a      	ldr	r0, [pc, #168]	; (12588 <nm_spi_init+0xec>)
   124de:	492b      	ldr	r1, [pc, #172]	; (1258c <nm_spi_init+0xf0>)
   124e0:	22b8      	movs	r2, #184	; 0xb8
   124e2:	0092      	lsls	r2, r2, #2
   124e4:	4b2b      	ldr	r3, [pc, #172]	; (12594 <nm_spi_init+0xf8>)
   124e6:	4798      	blx	r3
   124e8:	482e      	ldr	r0, [pc, #184]	; (125a4 <nm_spi_init+0x108>)
   124ea:	4b2c      	ldr	r3, [pc, #176]	; (1259c <nm_spi_init+0x100>)
   124ec:	4798      	blx	r3
   124ee:	200d      	movs	r0, #13
   124f0:	4b2b      	ldr	r3, [pc, #172]	; (125a0 <nm_spi_init+0x104>)
   124f2:	4798      	blx	r3
			return 0;
   124f4:	e03f      	b.n	12576 <nm_spi_init+0xda>
		}
	}
	if(gu8Crc_off == 0)
   124f6:	4b21      	ldr	r3, [pc, #132]	; (1257c <nm_spi_init+0xe0>)
   124f8:	781b      	ldrb	r3, [r3, #0]
   124fa:	2b00      	cmp	r3, #0
   124fc:	d119      	bne.n	12532 <nm_spi_init+0x96>
	{
		reg &= ~0xc;	/* disable crc checking */
		reg &= ~0x70;
   124fe:	337c      	adds	r3, #124	; 0x7c
   12500:	9900      	ldr	r1, [sp, #0]
   12502:	4399      	bics	r1, r3
		reg |= (0x5 << 4);
   12504:	3b2c      	subs	r3, #44	; 0x2c
   12506:	4319      	orrs	r1, r3
   12508:	9100      	str	r1, [sp, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
   1250a:	481d      	ldr	r0, [pc, #116]	; (12580 <nm_spi_init+0xe4>)
   1250c:	4b26      	ldr	r3, [pc, #152]	; (125a8 <nm_spi_init+0x10c>)
   1250e:	4798      	blx	r3
   12510:	1e04      	subs	r4, r0, #0
   12512:	d10b      	bne.n	1252c <nm_spi_init+0x90>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
   12514:	481c      	ldr	r0, [pc, #112]	; (12588 <nm_spi_init+0xec>)
   12516:	491d      	ldr	r1, [pc, #116]	; (1258c <nm_spi_init+0xf0>)
   12518:	4a24      	ldr	r2, [pc, #144]	; (125ac <nm_spi_init+0x110>)
   1251a:	4b1e      	ldr	r3, [pc, #120]	; (12594 <nm_spi_init+0xf8>)
   1251c:	4798      	blx	r3
   1251e:	4824      	ldr	r0, [pc, #144]	; (125b0 <nm_spi_init+0x114>)
   12520:	4b1e      	ldr	r3, [pc, #120]	; (1259c <nm_spi_init+0x100>)
   12522:	4798      	blx	r3
   12524:	200d      	movs	r0, #13
   12526:	4b1e      	ldr	r3, [pc, #120]	; (125a0 <nm_spi_init+0x104>)
   12528:	4798      	blx	r3
			return 0;
   1252a:	e024      	b.n	12576 <nm_spi_init+0xda>
		}
		gu8Crc_off = 1;
   1252c:	2201      	movs	r2, #1
   1252e:	4b13      	ldr	r3, [pc, #76]	; (1257c <nm_spi_init+0xe0>)
   12530:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
   12532:	2080      	movs	r0, #128	; 0x80
   12534:	0140      	lsls	r0, r0, #5
   12536:	a901      	add	r1, sp, #4
   12538:	4b12      	ldr	r3, [pc, #72]	; (12584 <nm_spi_init+0xe8>)
   1253a:	4798      	blx	r3
   1253c:	2800      	cmp	r0, #0
   1253e:	d10d      	bne.n	1255c <nm_spi_init+0xc0>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
   12540:	4811      	ldr	r0, [pc, #68]	; (12588 <nm_spi_init+0xec>)
   12542:	4912      	ldr	r1, [pc, #72]	; (1258c <nm_spi_init+0xf0>)
   12544:	22bd      	movs	r2, #189	; 0xbd
   12546:	0092      	lsls	r2, r2, #2
   12548:	4b12      	ldr	r3, [pc, #72]	; (12594 <nm_spi_init+0xf8>)
   1254a:	4798      	blx	r3
   1254c:	4819      	ldr	r0, [pc, #100]	; (125b4 <nm_spi_init+0x118>)
   1254e:	4b13      	ldr	r3, [pc, #76]	; (1259c <nm_spi_init+0x100>)
   12550:	4798      	blx	r3
   12552:	200d      	movs	r0, #13
   12554:	4b12      	ldr	r3, [pc, #72]	; (125a0 <nm_spi_init+0x104>)
   12556:	4798      	blx	r3
		return M2M_ERR_BUS_FAIL;
   12558:	24fa      	movs	r4, #250	; 0xfa
   1255a:	e00c      	b.n	12576 <nm_spi_init+0xda>
static void spi_init_pkt_sz(void)
{
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
   1255c:	4c08      	ldr	r4, [pc, #32]	; (12580 <nm_spi_init+0xe4>)
   1255e:	1c20      	adds	r0, r4, #0
   12560:	4b15      	ldr	r3, [pc, #84]	; (125b8 <nm_spi_init+0x11c>)
   12562:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
   12564:	2370      	movs	r3, #112	; 0x70
   12566:	1c01      	adds	r1, r0, #0
   12568:	4399      	bics	r1, r3
	case 256:  val32 |= (0 << 4); break;
	case 512:  val32 |= (1 << 4); break;
	case 1024: val32 |= (2 << 4); break;
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;
   1256a:	3b20      	subs	r3, #32
   1256c:	4319      	orrs	r1, r3

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
   1256e:	1c20      	adds	r0, r4, #0
   12570:	4b12      	ldr	r3, [pc, #72]	; (125bc <nm_spi_init+0x120>)
   12572:	4798      	blx	r3

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
   12574:	2400      	movs	r4, #0
   12576:	b260      	sxtb	r0, r4
}
   12578:	b002      	add	sp, #8
   1257a:	bd10      	pop	{r4, pc}
   1257c:	20001318 	.word	0x20001318
   12580:	0000e824 	.word	0x0000e824
   12584:	00012345 	.word	0x00012345
   12588:	000203ec 	.word	0x000203ec
   1258c:	000210a4 	.word	0x000210a4
   12590:	000002dd 	.word	0x000002dd
   12594:	00016e3d 	.word	0x00016e3d
   12598:	00020e0c 	.word	0x00020e0c
   1259c:	00016f5d 	.word	0x00016f5d
   125a0:	00016e71 	.word	0x00016e71
   125a4:	00020e5c 	.word	0x00020e5c
   125a8:	000122a5 	.word	0x000122a5
   125ac:	000002ea 	.word	0x000002ea
   125b0:	00020e88 	.word	0x00020e88
   125b4:	00020ebc 	.word	0x00020ebc
   125b8:	00012459 	.word	0x00012459
   125bc:	00012485 	.word	0x00012485

000125c0 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
   125c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   125c2:	b083      	sub	sp, #12
   125c4:	1c04      	adds	r4, r0, #0
   125c6:	1c0e      	adds	r6, r1, #0
   125c8:	1c15      	adds	r5, r2, #0

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
   125ca:	2300      	movs	r3, #0
   125cc:	9300      	str	r3, [sp, #0]
   125ce:	20c8      	movs	r0, #200	; 0xc8
   125d0:	1c21      	adds	r1, r4, #0
   125d2:	2200      	movs	r2, #0
   125d4:	1c2b      	adds	r3, r5, #0
   125d6:	4f24      	ldr	r7, [pc, #144]	; (12668 <nm_spi_read_block+0xa8>)
   125d8:	47b8      	blx	r7
	if (result != N_OK) {
   125da:	2801      	cmp	r0, #1
   125dc:	d00c      	beq.n	125f8 <nm_spi_read_block+0x38>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
   125de:	4823      	ldr	r0, [pc, #140]	; (1266c <nm_spi_read_block+0xac>)
   125e0:	4923      	ldr	r1, [pc, #140]	; (12670 <nm_spi_read_block+0xb0>)
   125e2:	22a3      	movs	r2, #163	; 0xa3
   125e4:	0092      	lsls	r2, r2, #2
   125e6:	4d23      	ldr	r5, [pc, #140]	; (12674 <nm_spi_read_block+0xb4>)
   125e8:	47a8      	blx	r5
   125ea:	4823      	ldr	r0, [pc, #140]	; (12678 <nm_spi_read_block+0xb8>)
   125ec:	1c21      	adds	r1, r4, #0
   125ee:	47a8      	blx	r5
   125f0:	200d      	movs	r0, #13
   125f2:	4b22      	ldr	r3, [pc, #136]	; (1267c <nm_spi_read_block+0xbc>)
   125f4:	4798      	blx	r3
   125f6:	e032      	b.n	1265e <nm_spi_read_block+0x9e>
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
   125f8:	20c8      	movs	r0, #200	; 0xc8
   125fa:	4b21      	ldr	r3, [pc, #132]	; (12680 <nm_spi_read_block+0xc0>)
   125fc:	4798      	blx	r3
	if (result != N_OK) {
   125fe:	2801      	cmp	r0, #1
   12600:	d012      	beq.n	12628 <nm_spi_read_block+0x68>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
   12602:	481a      	ldr	r0, [pc, #104]	; (1266c <nm_spi_read_block+0xac>)
   12604:	491a      	ldr	r1, [pc, #104]	; (12670 <nm_spi_read_block+0xb0>)
   12606:	4a1f      	ldr	r2, [pc, #124]	; (12684 <nm_spi_read_block+0xc4>)
   12608:	4d1a      	ldr	r5, [pc, #104]	; (12674 <nm_spi_read_block+0xb4>)
   1260a:	47a8      	blx	r5
   1260c:	481e      	ldr	r0, [pc, #120]	; (12688 <nm_spi_read_block+0xc8>)
   1260e:	1c21      	adds	r1, r4, #0
   12610:	47a8      	blx	r5
   12612:	200d      	movs	r0, #13
   12614:	4b19      	ldr	r3, [pc, #100]	; (1267c <nm_spi_read_block+0xbc>)
   12616:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   12618:	2300      	movs	r3, #0
   1261a:	9300      	str	r3, [sp, #0]
   1261c:	20cf      	movs	r0, #207	; 0xcf
   1261e:	2100      	movs	r1, #0
   12620:	2200      	movs	r2, #0
   12622:	4c11      	ldr	r4, [pc, #68]	; (12668 <nm_spi_read_block+0xa8>)
   12624:	47a0      	blx	r4
   12626:	e01a      	b.n	1265e <nm_spi_read_block+0x9e>
	}

	/**
		Data
	**/
	result = spi_data_read(buf, size,0);
   12628:	1c30      	adds	r0, r6, #0
   1262a:	1c29      	adds	r1, r5, #0
   1262c:	2200      	movs	r2, #0
   1262e:	4b17      	ldr	r3, [pc, #92]	; (1268c <nm_spi_read_block+0xcc>)
   12630:	4798      	blx	r3
{
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   12632:	2300      	movs	r3, #0

	/**
		Data
	**/
	result = spi_data_read(buf, size,0);
	if (result != N_OK) {
   12634:	2801      	cmp	r0, #1
   12636:	d013      	beq.n	12660 <nm_spi_read_block+0xa0>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
   12638:	480c      	ldr	r0, [pc, #48]	; (1266c <nm_spi_read_block+0xac>)
   1263a:	490d      	ldr	r1, [pc, #52]	; (12670 <nm_spi_read_block+0xb0>)
   1263c:	22a7      	movs	r2, #167	; 0xa7
   1263e:	0092      	lsls	r2, r2, #2
   12640:	4b0c      	ldr	r3, [pc, #48]	; (12674 <nm_spi_read_block+0xb4>)
   12642:	4798      	blx	r3
   12644:	4812      	ldr	r0, [pc, #72]	; (12690 <nm_spi_read_block+0xd0>)
   12646:	4b13      	ldr	r3, [pc, #76]	; (12694 <nm_spi_read_block+0xd4>)
   12648:	4798      	blx	r3
   1264a:	200d      	movs	r0, #13
   1264c:	4b0b      	ldr	r3, [pc, #44]	; (1267c <nm_spi_read_block+0xbc>)
   1264e:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   12650:	2300      	movs	r3, #0
   12652:	9300      	str	r3, [sp, #0]
   12654:	20cf      	movs	r0, #207	; 0xcf
   12656:	2100      	movs	r1, #0
   12658:	2200      	movs	r2, #0
   1265a:	4c03      	ldr	r4, [pc, #12]	; (12668 <nm_spi_read_block+0xa8>)
   1265c:	47a0      	blx	r4
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
   1265e:	23fa      	movs	r3, #250	; 0xfa

	return s8Ret;
   12660:	b258      	sxtb	r0, r3
}
   12662:	b003      	add	sp, #12
   12664:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12666:	46c0      	nop			; (mov r8, r8)
   12668:	00012121 	.word	0x00012121
   1266c:	000203ec 	.word	0x000203ec
   12670:	00020bf4 	.word	0x00020bf4
   12674:	00016e3d 	.word	0x00016e3d
   12678:	00020ee0 	.word	0x00020ee0
   1267c:	00016e71 	.word	0x00016e71
   12680:	00011eed 	.word	0x00011eed
   12684:	00000292 	.word	0x00000292
   12688:	00020f10 	.word	0x00020f10
   1268c:	00011fb5 	.word	0x00011fb5
   12690:	00020f48 	.word	0x00020f48
   12694:	00016f5d 	.word	0x00016f5d

00012698 <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
   12698:	b5f0      	push	{r4, r5, r6, r7, lr}
   1269a:	464f      	mov	r7, r9
   1269c:	4646      	mov	r6, r8
   1269e:	b4c0      	push	{r6, r7}
   126a0:	b087      	sub	sp, #28
   126a2:	1c04      	adds	r4, r0, #0
   126a4:	4689      	mov	r9, r1
   126a6:	1c15      	adds	r5, r2, #0

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
   126a8:	2300      	movs	r3, #0
   126aa:	9300      	str	r3, [sp, #0]
   126ac:	20c7      	movs	r0, #199	; 0xc7
   126ae:	1c21      	adds	r1, r4, #0
   126b0:	2200      	movs	r2, #0
   126b2:	1c2b      	adds	r3, r5, #0
   126b4:	4e55      	ldr	r6, [pc, #340]	; (1280c <nm_spi_write_block+0x174>)
   126b6:	47b0      	blx	r6
	if (result != N_OK) {
   126b8:	2801      	cmp	r0, #1
   126ba:	d00b      	beq.n	126d4 <nm_spi_write_block+0x3c>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
   126bc:	4854      	ldr	r0, [pc, #336]	; (12810 <nm_spi_write_block+0x178>)
   126be:	4955      	ldr	r1, [pc, #340]	; (12814 <nm_spi_write_block+0x17c>)
   126c0:	4a55      	ldr	r2, [pc, #340]	; (12818 <nm_spi_write_block+0x180>)
   126c2:	4d56      	ldr	r5, [pc, #344]	; (1281c <nm_spi_write_block+0x184>)
   126c4:	47a8      	blx	r5
   126c6:	4856      	ldr	r0, [pc, #344]	; (12820 <nm_spi_write_block+0x188>)
   126c8:	1c21      	adds	r1, r4, #0
   126ca:	47a8      	blx	r5
   126cc:	200d      	movs	r0, #13
   126ce:	4b55      	ldr	r3, [pc, #340]	; (12824 <nm_spi_write_block+0x18c>)
   126d0:	4798      	blx	r3
   126d2:	e094      	b.n	127fe <nm_spi_write_block+0x166>
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
   126d4:	20c7      	movs	r0, #199	; 0xc7
   126d6:	4b54      	ldr	r3, [pc, #336]	; (12828 <nm_spi_write_block+0x190>)
   126d8:	4798      	blx	r3
	if (result != N_OK) {
   126da:	2801      	cmp	r0, #1
   126dc:	d012      	beq.n	12704 <nm_spi_write_block+0x6c>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
   126de:	484c      	ldr	r0, [pc, #304]	; (12810 <nm_spi_write_block+0x178>)
   126e0:	494c      	ldr	r1, [pc, #304]	; (12814 <nm_spi_write_block+0x17c>)
   126e2:	4a52      	ldr	r2, [pc, #328]	; (1282c <nm_spi_write_block+0x194>)
   126e4:	4d4d      	ldr	r5, [pc, #308]	; (1281c <nm_spi_write_block+0x184>)
   126e6:	47a8      	blx	r5
   126e8:	4851      	ldr	r0, [pc, #324]	; (12830 <nm_spi_write_block+0x198>)
   126ea:	1c21      	adds	r1, r4, #0
   126ec:	47a8      	blx	r5
   126ee:	200d      	movs	r0, #13
   126f0:	4b4c      	ldr	r3, [pc, #304]	; (12824 <nm_spi_write_block+0x18c>)
   126f2:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   126f4:	2300      	movs	r3, #0
   126f6:	9300      	str	r3, [sp, #0]
   126f8:	20cf      	movs	r0, #207	; 0xcf
   126fa:	2100      	movs	r1, #0
   126fc:	2200      	movs	r2, #0
   126fe:	4c43      	ldr	r4, [pc, #268]	; (1280c <nm_spi_write_block+0x174>)
   12700:	47a0      	blx	r4
   12702:	e07c      	b.n	127fe <nm_spi_write_block+0x166>
static sint8 spi_data_write(uint8 *b, uint16 sz)
{
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
	uint8 cmd, order, crc[2] = {0};
   12704:	2200      	movs	r2, #0
   12706:	ab05      	add	r3, sp, #20
   12708:	801a      	strh	r2, [r3, #0]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
   1270a:	2700      	movs	r7, #0
   1270c:	2380      	movs	r3, #128	; 0x80
   1270e:	019b      	lsls	r3, r3, #6
   12710:	4698      	mov	r8, r3
   12712:	466a      	mov	r2, sp
   12714:	81d3      	strh	r3, [r2, #14]
				order = 0x3;
			else
				order = 0x2;
		}
		cmd |= order;
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
   12716:	4e47      	ldr	r6, [pc, #284]	; (12834 <nm_spi_write_block+0x19c>)
   12718:	1c2c      	adds	r4, r5, #0
   1271a:	4545      	cmp	r5, r8
   1271c:	d901      	bls.n	12722 <nm_spi_write_block+0x8a>
   1271e:	466b      	mov	r3, sp
   12720:	89dc      	ldrh	r4, [r3, #14]
   12722:	b2a4      	uxth	r4, r4

		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
   12724:	2f00      	cmp	r7, #0
   12726:	d104      	bne.n	12732 <nm_spi_write_block+0x9a>
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
   12728:	2303      	movs	r3, #3
		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
			if (sz <= DATA_PKT_SZ)
   1272a:	4545      	cmp	r5, r8
   1272c:	d906      	bls.n	1273c <nm_spi_write_block+0xa4>
				order = 0x3;
			else
				order = 0x1;
   1272e:	3b02      	subs	r3, #2
   12730:	e004      	b.n	1273c <nm_spi_write_block+0xa4>
		} else {
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
			else
				order = 0x2;
   12732:	2300      	movs	r3, #0
   12734:	4642      	mov	r2, r8
   12736:	42aa      	cmp	r2, r5
   12738:	415b      	adcs	r3, r3
   1273a:	3302      	adds	r3, #2
		}
		cmd |= order;
   1273c:	200b      	movs	r0, #11
   1273e:	aa02      	add	r2, sp, #8
   12740:	4694      	mov	ip, r2
   12742:	4460      	add	r0, ip
   12744:	2210      	movs	r2, #16
   12746:	4252      	negs	r2, r2
   12748:	4313      	orrs	r3, r2
   1274a:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
   1274c:	2101      	movs	r1, #1
   1274e:	47b0      	blx	r6
   12750:	2800      	cmp	r0, #0
   12752:	d00c      	beq.n	1276e <nm_spi_write_block+0xd6>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
   12754:	482e      	ldr	r0, [pc, #184]	; (12810 <nm_spi_write_block+0x178>)
   12756:	4938      	ldr	r1, [pc, #224]	; (12838 <nm_spi_write_block+0x1a0>)
   12758:	22e0      	movs	r2, #224	; 0xe0
   1275a:	0052      	lsls	r2, r2, #1
   1275c:	4b2f      	ldr	r3, [pc, #188]	; (1281c <nm_spi_write_block+0x184>)
   1275e:	4798      	blx	r3
   12760:	4836      	ldr	r0, [pc, #216]	; (1283c <nm_spi_write_block+0x1a4>)
   12762:	4b37      	ldr	r3, [pc, #220]	; (12840 <nm_spi_write_block+0x1a8>)
   12764:	4798      	blx	r3
   12766:	200d      	movs	r0, #13
   12768:	4b2e      	ldr	r3, [pc, #184]	; (12824 <nm_spi_write_block+0x18c>)
   1276a:	4798      	blx	r3
   1276c:	e031      	b.n	127d2 <nm_spi_write_block+0x13a>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
   1276e:	b238      	sxth	r0, r7
   12770:	4448      	add	r0, r9
   12772:	1c21      	adds	r1, r4, #0
   12774:	4b2f      	ldr	r3, [pc, #188]	; (12834 <nm_spi_write_block+0x19c>)
   12776:	4798      	blx	r3
   12778:	2800      	cmp	r0, #0
   1277a:	d00c      	beq.n	12796 <nm_spi_write_block+0xfe>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
   1277c:	4824      	ldr	r0, [pc, #144]	; (12810 <nm_spi_write_block+0x178>)
   1277e:	492e      	ldr	r1, [pc, #184]	; (12838 <nm_spi_write_block+0x1a0>)
   12780:	22ca      	movs	r2, #202	; 0xca
   12782:	32ff      	adds	r2, #255	; 0xff
   12784:	4b25      	ldr	r3, [pc, #148]	; (1281c <nm_spi_write_block+0x184>)
   12786:	4798      	blx	r3
   12788:	482e      	ldr	r0, [pc, #184]	; (12844 <nm_spi_write_block+0x1ac>)
   1278a:	4b2d      	ldr	r3, [pc, #180]	; (12840 <nm_spi_write_block+0x1a8>)
   1278c:	4798      	blx	r3
   1278e:	200d      	movs	r0, #13
   12790:	4b24      	ldr	r3, [pc, #144]	; (12824 <nm_spi_write_block+0x18c>)
   12792:	4798      	blx	r3
   12794:	e01d      	b.n	127d2 <nm_spi_write_block+0x13a>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
   12796:	4b2c      	ldr	r3, [pc, #176]	; (12848 <nm_spi_write_block+0x1b0>)
   12798:	781b      	ldrb	r3, [r3, #0]
   1279a:	2b00      	cmp	r3, #0
   1279c:	d112      	bne.n	127c4 <nm_spi_write_block+0x12c>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
   1279e:	a805      	add	r0, sp, #20
   127a0:	2102      	movs	r1, #2
   127a2:	4b24      	ldr	r3, [pc, #144]	; (12834 <nm_spi_write_block+0x19c>)
   127a4:	4798      	blx	r3
   127a6:	2800      	cmp	r0, #0
   127a8:	d00c      	beq.n	127c4 <nm_spi_write_block+0x12c>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
   127aa:	4819      	ldr	r0, [pc, #100]	; (12810 <nm_spi_write_block+0x178>)
   127ac:	4922      	ldr	r1, [pc, #136]	; (12838 <nm_spi_write_block+0x1a0>)
   127ae:	22d4      	movs	r2, #212	; 0xd4
   127b0:	32ff      	adds	r2, #255	; 0xff
   127b2:	4b1a      	ldr	r3, [pc, #104]	; (1281c <nm_spi_write_block+0x184>)
   127b4:	4798      	blx	r3
   127b6:	4825      	ldr	r0, [pc, #148]	; (1284c <nm_spi_write_block+0x1b4>)
   127b8:	4b21      	ldr	r3, [pc, #132]	; (12840 <nm_spi_write_block+0x1a8>)
   127ba:	4798      	blx	r3
   127bc:	200d      	movs	r0, #13
   127be:	4b19      	ldr	r3, [pc, #100]	; (12824 <nm_spi_write_block+0x18c>)
   127c0:	4798      	blx	r3
   127c2:	e006      	b.n	127d2 <nm_spi_write_block+0x13a>
				result = N_FAIL;
				break;
			}
		}

		ix += nbytes;
   127c4:	19e7      	adds	r7, r4, r7
   127c6:	b2bf      	uxth	r7, r7
		sz -= nbytes;
   127c8:	1b2d      	subs	r5, r5, r4
   127ca:	b2ad      	uxth	r5, r5
	} while (sz);
   127cc:	2d00      	cmp	r5, #0
   127ce:	d1a3      	bne.n	12718 <nm_spi_write_block+0x80>
   127d0:	e013      	b.n	127fa <nm_spi_write_block+0x162>
	/**
		Data
	**/
	result = spi_data_write(buf, size);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
   127d2:	480f      	ldr	r0, [pc, #60]	; (12810 <nm_spi_write_block+0x178>)
   127d4:	490f      	ldr	r1, [pc, #60]	; (12814 <nm_spi_write_block+0x17c>)
   127d6:	4a1e      	ldr	r2, [pc, #120]	; (12850 <nm_spi_write_block+0x1b8>)
   127d8:	4b10      	ldr	r3, [pc, #64]	; (1281c <nm_spi_write_block+0x184>)
   127da:	4798      	blx	r3
   127dc:	481d      	ldr	r0, [pc, #116]	; (12854 <nm_spi_write_block+0x1bc>)
   127de:	4b18      	ldr	r3, [pc, #96]	; (12840 <nm_spi_write_block+0x1a8>)
   127e0:	4798      	blx	r3
   127e2:	200d      	movs	r0, #13
   127e4:	4b0f      	ldr	r3, [pc, #60]	; (12824 <nm_spi_write_block+0x18c>)
   127e6:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   127e8:	2300      	movs	r3, #0
   127ea:	9300      	str	r3, [sp, #0]
   127ec:	20cf      	movs	r0, #207	; 0xcf
   127ee:	2100      	movs	r1, #0
   127f0:	2200      	movs	r2, #0
   127f2:	4c06      	ldr	r4, [pc, #24]	; (1280c <nm_spi_write_block+0x174>)
   127f4:	47a0      	blx	r4
{
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   127f6:	2000      	movs	r0, #0
   127f8:	e002      	b.n	12800 <nm_spi_write_block+0x168>
   127fa:	2000      	movs	r0, #0
   127fc:	e000      	b.n	12800 <nm_spi_write_block+0x168>
	else s8Ret = M2M_ERR_BUS_FAIL;
   127fe:	20fa      	movs	r0, #250	; 0xfa

	return s8Ret;
   12800:	b240      	sxtb	r0, r0
}
   12802:	b007      	add	sp, #28
   12804:	bc0c      	pop	{r2, r3}
   12806:	4690      	mov	r8, r2
   12808:	4699      	mov	r9, r3
   1280a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1280c:	00012121 	.word	0x00012121
   12810:	000203ec 	.word	0x000203ec
   12814:	00020bc8 	.word	0x00020bc8
   12818:	00000227 	.word	0x00000227
   1281c:	00016e3d 	.word	0x00016e3d
   12820:	00020f70 	.word	0x00020f70
   12824:	00016e71 	.word	0x00016e71
   12828:	00011eed 	.word	0x00011eed
   1282c:	0000022d 	.word	0x0000022d
   12830:	00020fa0 	.word	0x00020fa0
   12834:	00012101 	.word	0x00012101
   12838:	000210b0 	.word	0x000210b0
   1283c:	00020fd8 	.word	0x00020fd8
   12840:	00016f5d 	.word	0x00016f5d
   12844:	00021010 	.word	0x00021010
   12848:	20001318 	.word	0x20001318
   1284c:	00021044 	.word	0x00021044
   12850:	0000023e 	.word	0x0000023e
   12854:	0002107c 	.word	0x0002107c

00012858 <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
   12858:	b5f0      	push	{r4, r5, r6, r7, lr}
   1285a:	465f      	mov	r7, fp
   1285c:	4656      	mov	r6, sl
   1285e:	464d      	mov	r5, r9
   12860:	4644      	mov	r4, r8
   12862:	b4f0      	push	{r4, r5, r6, r7}
   12864:	b083      	sub	sp, #12
   12866:	1c0e      	adds	r6, r1, #0
   12868:	9200      	str	r2, [sp, #0]
   1286a:	4699      	mov	r9, r3
   1286c:	ab0c      	add	r3, sp, #48	; 0x30
   1286e:	881c      	ldrh	r4, [r3, #0]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
   12870:	2c00      	cmp	r4, #0
   12872:	d057      	beq.n	12924 <Socket_ReadSocketData+0xcc>
   12874:	0043      	lsls	r3, r0, #1
   12876:	181b      	adds	r3, r3, r0
   12878:	009b      	lsls	r3, r3, #2
   1287a:	492e      	ldr	r1, [pc, #184]	; (12934 <Socket_ReadSocketData+0xdc>)
   1287c:	585b      	ldr	r3, [r3, r1]
   1287e:	2b00      	cmp	r3, #0
   12880:	d050      	beq.n	12924 <Socket_ReadSocketData+0xcc>
   12882:	0043      	lsls	r3, r0, #1
   12884:	181b      	adds	r3, r3, r0
   12886:	009b      	lsls	r3, r3, #2
   12888:	18cb      	adds	r3, r1, r3
   1288a:	889b      	ldrh	r3, [r3, #4]
   1288c:	b29b      	uxth	r3, r3
   1288e:	2b00      	cmp	r3, #0
   12890:	d048      	beq.n	12924 <Socket_ReadSocketData+0xcc>
   12892:	0043      	lsls	r3, r0, #1
   12894:	181b      	adds	r3, r3, r0
   12896:	009b      	lsls	r3, r3, #2
   12898:	18cb      	adds	r3, r1, r3
   1289a:	799b      	ldrb	r3, [r3, #6]
   1289c:	2b01      	cmp	r3, #1
   1289e:	d141      	bne.n	12924 <Socket_ReadSocketData+0xcc>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
   128a0:	80f4      	strh	r4, [r6, #6]
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
   128a2:	0043      	lsls	r3, r0, #1
   128a4:	181a      	adds	r2, r3, r0
   128a6:	0093      	lsls	r3, r2, #2
   128a8:	4698      	mov	r8, r3
   128aa:	1c0b      	adds	r3, r1, #0
   128ac:	4443      	add	r3, r8
   128ae:	469a      	mov	sl, r3
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
   128b0:	468b      	mov	fp, r1
   128b2:	9001      	str	r0, [sp, #4]
		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
   128b4:	4653      	mov	r3, sl
   128b6:	889b      	ldrh	r3, [r3, #4]
   128b8:	1ae3      	subs	r3, r4, r3
			if(s16Diff > 0)
   128ba:	b21b      	sxth	r3, r3
   128bc:	2b00      	cmp	r3, #0
   128be:	dd05      	ble.n	128cc <Socket_ReadSocketData+0x74>
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
   128c0:	4b1c      	ldr	r3, [pc, #112]	; (12934 <Socket_ReadSocketData+0xdc>)
   128c2:	4443      	add	r3, r8
   128c4:	889d      	ldrh	r5, [r3, #4]
   128c6:	b2ad      	uxth	r5, r5
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
   128c8:	2300      	movs	r3, #0
   128ca:	e001      	b.n	128d0 <Socket_ReadSocketData+0x78>
   128cc:	1c25      	adds	r5, r4, #0
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
   128ce:	2301      	movs	r3, #1
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
   128d0:	465a      	mov	r2, fp
   128d2:	4641      	mov	r1, r8
   128d4:	5889      	ldr	r1, [r1, r2]
   128d6:	4648      	mov	r0, r9
   128d8:	1c2a      	adds	r2, r5, #0
   128da:	4f17      	ldr	r7, [pc, #92]	; (12938 <Socket_ReadSocketData+0xe0>)
   128dc:	47b8      	blx	r7
   128de:	2800      	cmp	r0, #0
   128e0:	d117      	bne.n	12912 <Socket_ReadSocketData+0xba>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
   128e2:	4b14      	ldr	r3, [pc, #80]	; (12934 <Socket_ReadSocketData+0xdc>)
   128e4:	4642      	mov	r2, r8
   128e6:	58d3      	ldr	r3, [r2, r3]
   128e8:	6033      	str	r3, [r6, #0]
				pstrRecv->s16BufferSize		= u16Read;
   128ea:	80b5      	strh	r5, [r6, #4]
				pstrRecv->u16RemainingSize	-= u16Read;
   128ec:	88f3      	ldrh	r3, [r6, #6]
   128ee:	1b5b      	subs	r3, r3, r5
   128f0:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
   128f2:	4b12      	ldr	r3, [pc, #72]	; (1293c <Socket_ReadSocketData+0xe4>)
   128f4:	681b      	ldr	r3, [r3, #0]
   128f6:	2b00      	cmp	r3, #0
   128f8:	d005      	beq.n	12906 <Socket_ReadSocketData+0xae>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
   128fa:	4b10      	ldr	r3, [pc, #64]	; (1293c <Socket_ReadSocketData+0xe4>)
   128fc:	681b      	ldr	r3, [r3, #0]
   128fe:	9801      	ldr	r0, [sp, #4]
   12900:	9900      	ldr	r1, [sp, #0]
   12902:	1c32      	adds	r2, r6, #0
   12904:	4798      	blx	r3

				u16ReadCount -= u16Read;
   12906:	1b64      	subs	r4, r4, r5
   12908:	b2a4      	uxth	r4, r4
				u32Address += u16Read;
   1290a:	44a9      	add	r9, r5
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
				break;
			}
		}while(u16ReadCount != 0);
   1290c:	2c00      	cmp	r4, #0
   1290e:	d1d1      	bne.n	128b4 <Socket_ReadSocketData+0x5c>
   12910:	e008      	b.n	12924 <Socket_ReadSocketData+0xcc>
				u16ReadCount -= u16Read;
				u32Address += u16Read;
			}
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
   12912:	480b      	ldr	r0, [pc, #44]	; (12940 <Socket_ReadSocketData+0xe8>)
   12914:	4d0b      	ldr	r5, [pc, #44]	; (12944 <Socket_ReadSocketData+0xec>)
   12916:	47a8      	blx	r5
   12918:	480b      	ldr	r0, [pc, #44]	; (12948 <Socket_ReadSocketData+0xf0>)
   1291a:	1c21      	adds	r1, r4, #0
   1291c:	47a8      	blx	r5
   1291e:	200d      	movs	r0, #13
   12920:	4b0a      	ldr	r3, [pc, #40]	; (1294c <Socket_ReadSocketData+0xf4>)
   12922:	4798      	blx	r3
				break;
			}
		}while(u16ReadCount != 0);
	}
}
   12924:	b003      	add	sp, #12
   12926:	bc3c      	pop	{r2, r3, r4, r5}
   12928:	4690      	mov	r8, r2
   1292a:	4699      	mov	r9, r3
   1292c:	46a2      	mov	sl, r4
   1292e:	46ab      	mov	fp, r5
   12930:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12932:	46c0      	nop			; (mov r8, r8)
   12934:	20002b7c 	.word	0x20002b7c
   12938:	00010fd9 	.word	0x00010fd9
   1293c:	20002c00 	.word	0x20002c00
   12940:	000206d4 	.word	0x000206d4
   12944:	00016e3d 	.word	0x00016e3d
   12948:	000211d0 	.word	0x000211d0
   1294c:	00016e71 	.word	0x00016e71

00012950 <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{
   12950:	b5f0      	push	{r4, r5, r6, r7, lr}
   12952:	465f      	mov	r7, fp
   12954:	4656      	mov	r6, sl
   12956:	464d      	mov	r5, r9
   12958:	4644      	mov	r4, r8
   1295a:	b4f0      	push	{r4, r5, r6, r7}
   1295c:	b09b      	sub	sp, #108	; 0x6c
   1295e:	1c0d      	adds	r5, r1, #0
   12960:	1c14      	adds	r4, r2, #0
	if(u8OpCode == SOCKET_CMD_BIND)
   12962:	2841      	cmp	r0, #65	; 0x41
   12964:	d11a      	bne.n	1299c <m2m_ip_cb+0x4c>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
   12966:	1c10      	adds	r0, r2, #0
   12968:	a909      	add	r1, sp, #36	; 0x24
   1296a:	2204      	movs	r2, #4
   1296c:	2300      	movs	r3, #0
   1296e:	4cb3      	ldr	r4, [pc, #716]	; (12c3c <m2m_ip_cb+0x2ec>)
   12970:	47a0      	blx	r4
   12972:	2800      	cmp	r0, #0
   12974:	d000      	beq.n	12978 <m2m_ip_cb+0x28>
   12976:	e159      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			strBind.status = strBindReply.s8Status;
   12978:	ab09      	add	r3, sp, #36	; 0x24
   1297a:	785a      	ldrb	r2, [r3, #1]
   1297c:	ab05      	add	r3, sp, #20
   1297e:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
   12980:	4baf      	ldr	r3, [pc, #700]	; (12c40 <m2m_ip_cb+0x2f0>)
   12982:	681b      	ldr	r3, [r3, #0]
   12984:	2b00      	cmp	r3, #0
   12986:	d100      	bne.n	1298a <m2m_ip_cb+0x3a>
   12988:	e150      	b.n	12c2c <m2m_ip_cb+0x2dc>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
   1298a:	4bad      	ldr	r3, [pc, #692]	; (12c40 <m2m_ip_cb+0x2f0>)
   1298c:	681b      	ldr	r3, [r3, #0]
   1298e:	aa09      	add	r2, sp, #36	; 0x24
   12990:	2000      	movs	r0, #0
   12992:	5610      	ldrsb	r0, [r2, r0]
   12994:	2101      	movs	r1, #1
   12996:	aa05      	add	r2, sp, #20
   12998:	4798      	blx	r3
   1299a:	e147      	b.n	12c2c <m2m_ip_cb+0x2dc>
		}
	}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
   1299c:	2842      	cmp	r0, #66	; 0x42
   1299e:	d11a      	bne.n	129d6 <m2m_ip_cb+0x86>
	{
		tstrListenReply			strListenReply;
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
   129a0:	1c10      	adds	r0, r2, #0
   129a2:	a909      	add	r1, sp, #36	; 0x24
   129a4:	2204      	movs	r2, #4
   129a6:	2300      	movs	r3, #0
   129a8:	4ca4      	ldr	r4, [pc, #656]	; (12c3c <m2m_ip_cb+0x2ec>)
   129aa:	47a0      	blx	r4
   129ac:	2800      	cmp	r0, #0
   129ae:	d000      	beq.n	129b2 <m2m_ip_cb+0x62>
   129b0:	e13c      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			strListen.status = strListenReply.s8Status;
   129b2:	ab09      	add	r3, sp, #36	; 0x24
   129b4:	785a      	ldrb	r2, [r3, #1]
   129b6:	ab05      	add	r3, sp, #20
   129b8:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
   129ba:	4ba1      	ldr	r3, [pc, #644]	; (12c40 <m2m_ip_cb+0x2f0>)
   129bc:	681b      	ldr	r3, [r3, #0]
   129be:	2b00      	cmp	r3, #0
   129c0:	d100      	bne.n	129c4 <m2m_ip_cb+0x74>
   129c2:	e133      	b.n	12c2c <m2m_ip_cb+0x2dc>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
   129c4:	4b9e      	ldr	r3, [pc, #632]	; (12c40 <m2m_ip_cb+0x2f0>)
   129c6:	681b      	ldr	r3, [r3, #0]
   129c8:	aa09      	add	r2, sp, #36	; 0x24
   129ca:	2000      	movs	r0, #0
   129cc:	5610      	ldrsb	r0, [r2, r0]
   129ce:	2102      	movs	r1, #2
   129d0:	aa05      	add	r2, sp, #20
   129d2:	4798      	blx	r3
   129d4:	e12a      	b.n	12c2c <m2m_ip_cb+0x2dc>
		}
	}
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
   129d6:	2843      	cmp	r0, #67	; 0x43
   129d8:	d143      	bne.n	12a62 <m2m_ip_cb+0x112>
	{
		tstrAcceptReply			strAcceptReply;
		tstrSocketAcceptMsg		strAccept;
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
   129da:	1c10      	adds	r0, r2, #0
   129dc:	a905      	add	r1, sp, #20
   129de:	220c      	movs	r2, #12
   129e0:	2300      	movs	r3, #0
   129e2:	4c96      	ldr	r4, [pc, #600]	; (12c3c <m2m_ip_cb+0x2ec>)
   129e4:	47a0      	blx	r4
   129e6:	2800      	cmp	r0, #0
   129e8:	d000      	beq.n	129ec <m2m_ip_cb+0x9c>
   129ea:	e11f      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			if(strAcceptReply.sConnectedSock >= 0)
   129ec:	ab05      	add	r3, sp, #20
   129ee:	7a59      	ldrb	r1, [r3, #9]
   129f0:	b24b      	sxtb	r3, r1
   129f2:	2b00      	cmp	r3, #0
   129f4:	db1e      	blt.n	12a34 <m2m_ip_cb+0xe4>
			{
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 	= 0;
   129f6:	005a      	lsls	r2, r3, #1
   129f8:	18d2      	adds	r2, r2, r3
   129fa:	0092      	lsls	r2, r2, #2
   129fc:	4891      	ldr	r0, [pc, #580]	; (12c44 <m2m_ip_cb+0x2f4>)
   129fe:	1882      	adds	r2, r0, r2
   12a00:	2000      	movs	r0, #0
   12a02:	71d0      	strb	r0, [r2, #7]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 	= 1;
   12a04:	3001      	adds	r0, #1
   12a06:	7190      	strb	r0, [r2, #6]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
   12a08:	488f      	ldr	r0, [pc, #572]	; (12c48 <m2m_ip_cb+0x2f8>)
   12a0a:	8802      	ldrh	r2, [r0, #0]
   12a0c:	3201      	adds	r2, #1
   12a0e:	b292      	uxth	r2, r2
   12a10:	8002      	strh	r2, [r0, #0]
				if(gu16SessionID == 0)
   12a12:	8802      	ldrh	r2, [r0, #0]
   12a14:	b292      	uxth	r2, r2
   12a16:	2a00      	cmp	r2, #0
   12a18:	d103      	bne.n	12a22 <m2m_ip_cb+0xd2>
					++gu16SessionID;
   12a1a:	8802      	ldrh	r2, [r0, #0]
   12a1c:	3201      	adds	r2, #1
   12a1e:	b292      	uxth	r2, r2
   12a20:	8002      	strh	r2, [r0, #0]

				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
   12a22:	4a89      	ldr	r2, [pc, #548]	; (12c48 <m2m_ip_cb+0x2f8>)
   12a24:	8812      	ldrh	r2, [r2, #0]
   12a26:	b292      	uxth	r2, r2
   12a28:	0058      	lsls	r0, r3, #1
   12a2a:	18c3      	adds	r3, r0, r3
   12a2c:	009b      	lsls	r3, r3, #2
   12a2e:	4885      	ldr	r0, [pc, #532]	; (12c44 <m2m_ip_cb+0x2f4>)
   12a30:	18c3      	adds	r3, r0, r3
   12a32:	815a      	strh	r2, [r3, #10]
				M2M_DBG("Socket %d session ID = %d\r\n",strAcceptReply.sConnectedSock , gu16SessionID );		
			}
			strAccept.sock = strAcceptReply.sConnectedSock;
   12a34:	ab09      	add	r3, sp, #36	; 0x24
   12a36:	7019      	strb	r1, [r3, #0]
			strAccept.strAddr.sin_family		= AF_INET;
   12a38:	2202      	movs	r2, #2
   12a3a:	809a      	strh	r2, [r3, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
   12a3c:	aa05      	add	r2, sp, #20
   12a3e:	8851      	ldrh	r1, [r2, #2]
   12a40:	80d9      	strh	r1, [r3, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
   12a42:	9a06      	ldr	r2, [sp, #24]
   12a44:	920b      	str	r2, [sp, #44]	; 0x2c
			if(gpfAppSocketCb)
   12a46:	4b7e      	ldr	r3, [pc, #504]	; (12c40 <m2m_ip_cb+0x2f0>)
   12a48:	681b      	ldr	r3, [r3, #0]
   12a4a:	2b00      	cmp	r3, #0
   12a4c:	d100      	bne.n	12a50 <m2m_ip_cb+0x100>
   12a4e:	e0ed      	b.n	12c2c <m2m_ip_cb+0x2dc>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
   12a50:	4b7b      	ldr	r3, [pc, #492]	; (12c40 <m2m_ip_cb+0x2f0>)
   12a52:	681b      	ldr	r3, [r3, #0]
   12a54:	aa05      	add	r2, sp, #20
   12a56:	2008      	movs	r0, #8
   12a58:	5610      	ldrsb	r0, [r2, r0]
   12a5a:	2104      	movs	r1, #4
   12a5c:	aa09      	add	r2, sp, #36	; 0x24
   12a5e:	4798      	blx	r3
   12a60:	e0e4      	b.n	12c2c <m2m_ip_cb+0x2dc>
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
   12a62:	2844      	cmp	r0, #68	; 0x44
   12a64:	d001      	beq.n	12a6a <m2m_ip_cb+0x11a>
   12a66:	284b      	cmp	r0, #75	; 0x4b
   12a68:	d11a      	bne.n	12aa0 <m2m_ip_cb+0x150>
	{
		tstrConnectReply		strConnectReply;
		tstrSocketConnectMsg	strConnMsg;
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
   12a6a:	1c20      	adds	r0, r4, #0
   12a6c:	a909      	add	r1, sp, #36	; 0x24
   12a6e:	2204      	movs	r2, #4
   12a70:	2300      	movs	r3, #0
   12a72:	4c72      	ldr	r4, [pc, #456]	; (12c3c <m2m_ip_cb+0x2ec>)
   12a74:	47a0      	blx	r4
   12a76:	2800      	cmp	r0, #0
   12a78:	d000      	beq.n	12a7c <m2m_ip_cb+0x12c>
   12a7a:	e0d7      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			strConnMsg.sock		= strConnectReply.sock;
   12a7c:	aa09      	add	r2, sp, #36	; 0x24
   12a7e:	7810      	ldrb	r0, [r2, #0]
   12a80:	ab05      	add	r3, sp, #20
   12a82:	7018      	strb	r0, [r3, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
   12a84:	7852      	ldrb	r2, [r2, #1]
   12a86:	705a      	strb	r2, [r3, #1]
			if(gpfAppSocketCb)
   12a88:	4b6d      	ldr	r3, [pc, #436]	; (12c40 <m2m_ip_cb+0x2f0>)
   12a8a:	681b      	ldr	r3, [r3, #0]
   12a8c:	2b00      	cmp	r3, #0
   12a8e:	d100      	bne.n	12a92 <m2m_ip_cb+0x142>
   12a90:	e0cc      	b.n	12c2c <m2m_ip_cb+0x2dc>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
   12a92:	4b6b      	ldr	r3, [pc, #428]	; (12c40 <m2m_ip_cb+0x2f0>)
   12a94:	681b      	ldr	r3, [r3, #0]
   12a96:	b240      	sxtb	r0, r0
   12a98:	2105      	movs	r1, #5
   12a9a:	aa05      	add	r2, sp, #20
   12a9c:	4798      	blx	r3
			if(gpfAppSocketCb)
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
	{
   12a9e:	e0c5      	b.n	12c2c <m2m_ip_cb+0x2dc>
			strConnMsg.s8Error	= strConnectReply.s8Error;
			if(gpfAppSocketCb)
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
		}
	}
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
   12aa0:	284a      	cmp	r0, #74	; 0x4a
   12aa2:	d113      	bne.n	12acc <m2m_ip_cb+0x17c>
	{
		tstrDnsReply	strDnsReply;
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
   12aa4:	1c10      	adds	r0, r2, #0
   12aa6:	a909      	add	r1, sp, #36	; 0x24
   12aa8:	2244      	movs	r2, #68	; 0x44
   12aaa:	2300      	movs	r3, #0
   12aac:	4c63      	ldr	r4, [pc, #396]	; (12c3c <m2m_ip_cb+0x2ec>)
   12aae:	47a0      	blx	r4
   12ab0:	2800      	cmp	r0, #0
   12ab2:	d000      	beq.n	12ab6 <m2m_ip_cb+0x166>
   12ab4:	e0ba      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			strDnsReply.u32HostIP = strDnsReply.u32HostIP;
   12ab6:	9919      	ldr	r1, [sp, #100]	; 0x64
			if(gpfAppResolveCb)
   12ab8:	4b64      	ldr	r3, [pc, #400]	; (12c4c <m2m_ip_cb+0x2fc>)
   12aba:	681b      	ldr	r3, [r3, #0]
   12abc:	2b00      	cmp	r3, #0
   12abe:	d100      	bne.n	12ac2 <m2m_ip_cb+0x172>
   12ac0:	e0b4      	b.n	12c2c <m2m_ip_cb+0x2dc>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
   12ac2:	4b62      	ldr	r3, [pc, #392]	; (12c4c <m2m_ip_cb+0x2fc>)
   12ac4:	681b      	ldr	r3, [r3, #0]
   12ac6:	a809      	add	r0, sp, #36	; 0x24
   12ac8:	4798      	blx	r3
   12aca:	e0af      	b.n	12c2c <m2m_ip_cb+0x2dc>
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
   12acc:	2846      	cmp	r0, #70	; 0x46
   12ace:	d006      	beq.n	12ade <m2m_ip_cb+0x18e>
   12ad0:	2848      	cmp	r0, #72	; 0x48
   12ad2:	d007      	beq.n	12ae4 <m2m_ip_cb+0x194>
   12ad4:	284d      	cmp	r0, #77	; 0x4d
   12ad6:	d163      	bne.n	12ba0 <m2m_ip_cb+0x250>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
   12ad8:	2306      	movs	r3, #6
   12ada:	4699      	mov	r9, r3
   12adc:	e004      	b.n	12ae8 <m2m_ip_cb+0x198>
   12ade:	2306      	movs	r3, #6
   12ae0:	4699      	mov	r9, r3
   12ae2:	e001      	b.n	12ae8 <m2m_ip_cb+0x198>
		uint16				u16DataOffset;

		if(u8OpCode == SOCKET_CMD_RECVFROM)
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
   12ae4:	2309      	movs	r3, #9
   12ae6:	4699      	mov	r9, r3

		/* Read RECV REPLY data structure.
		*/
		u16ReadSize = sizeof(tstrRecvReply);
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
   12ae8:	1c20      	adds	r0, r4, #0
   12aea:	a905      	add	r1, sp, #20
   12aec:	2210      	movs	r2, #16
   12aee:	2300      	movs	r3, #0
   12af0:	4f52      	ldr	r7, [pc, #328]	; (12c3c <m2m_ip_cb+0x2ec>)
   12af2:	47b8      	blx	r7
   12af4:	2800      	cmp	r0, #0
   12af6:	d000      	beq.n	12afa <m2m_ip_cb+0x1aa>
   12af8:	e098      	b.n	12c2c <m2m_ip_cb+0x2dc>
		{
			uint16 u16SessionID = 0;

			sock			= strRecvReply.sock;
   12afa:	a905      	add	r1, sp, #20
   12afc:	7b0b      	ldrb	r3, [r1, #12]
   12afe:	4698      	mov	r8, r3
			u16SessionID = strRecvReply.u16SessionID;
   12b00:	89cf      	ldrh	r7, [r1, #14]
			M2M_DBG("recv callback session ID = %d\r\n",u16SessionID);
			
			/* Reset the Socket RX Pending Flag.
			*/
			gastrSockets[sock].bIsRecvPending = 0;
   12b02:	466a      	mov	r2, sp
   12b04:	73d3      	strb	r3, [r2, #15]
   12b06:	466b      	mov	r3, sp
   12b08:	220f      	movs	r2, #15
   12b0a:	569a      	ldrsb	r2, [r3, r2]
   12b0c:	0050      	lsls	r0, r2, #1
   12b0e:	1883      	adds	r3, r0, r2
   12b10:	009b      	lsls	r3, r3, #2
   12b12:	4e4c      	ldr	r6, [pc, #304]	; (12c44 <m2m_ip_cb+0x2f4>)
   12b14:	46b4      	mov	ip, r6
   12b16:	4463      	add	r3, ip
   12b18:	2600      	movs	r6, #0
   12b1a:	721e      	strb	r6, [r3, #8]

			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
   12b1c:	890b      	ldrh	r3, [r1, #8]
   12b1e:	469a      	mov	sl, r3
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
   12b20:	894b      	ldrh	r3, [r1, #10]
   12b22:	469c      	mov	ip, r3
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
   12b24:	ab09      	add	r3, sp, #36	; 0x24
   12b26:	884e      	ldrh	r6, [r1, #2]
   12b28:	815e      	strh	r6, [r3, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
   12b2a:	9906      	ldr	r1, [sp, #24]
   12b2c:	910c      	str	r1, [sp, #48]	; 0x30

			if(u16SessionID == gastrSockets[sock].u16SessionID)
   12b2e:	1882      	adds	r2, r0, r2
   12b30:	0092      	lsls	r2, r2, #2
   12b32:	4b44      	ldr	r3, [pc, #272]	; (12c44 <m2m_ip_cb+0x2f4>)
   12b34:	469b      	mov	fp, r3
   12b36:	445a      	add	r2, fp
   12b38:	3208      	adds	r2, #8
   12b3a:	8852      	ldrh	r2, [r2, #2]
   12b3c:	b292      	uxth	r2, r2
   12b3e:	42ba      	cmp	r2, r7
   12b40:	d125      	bne.n	12b8e <m2m_ip_cb+0x23e>
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
   12b42:	4653      	mov	r3, sl
   12b44:	b21a      	sxth	r2, r3
   12b46:	2a00      	cmp	r2, #0
   12b48:	dd0d      	ble.n	12b66 <m2m_ip_cb+0x216>
   12b4a:	42aa      	cmp	r2, r5
   12b4c:	da0b      	bge.n	12b66 <m2m_ip_cb+0x216>
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
   12b4e:	466a      	mov	r2, sp
   12b50:	200f      	movs	r0, #15
   12b52:	5610      	ldrsb	r0, [r2, r0]
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
				{
					/* Skip incoming bytes until reaching the Start of Application Data. 
					*/
					u32Address += u16DataOffset;
   12b54:	4464      	add	r4, ip
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
   12b56:	4653      	mov	r3, sl
   12b58:	9300      	str	r3, [sp, #0]
   12b5a:	a909      	add	r1, sp, #36	; 0x24
   12b5c:	464a      	mov	r2, r9
   12b5e:	1c23      	adds	r3, r4, #0
   12b60:	4c3b      	ldr	r4, [pc, #236]	; (12c50 <m2m_ip_cb+0x300>)
   12b62:	47a0      	blx	r4
   12b64:	e062      	b.n	12c2c <m2m_ip_cb+0x2dc>
				}
				else
				{
					strRecvMsg.s16BufferSize	= s16RecvStatus;
   12b66:	aa09      	add	r2, sp, #36	; 0x24
   12b68:	4653      	mov	r3, sl
   12b6a:	8093      	strh	r3, [r2, #4]
					strRecvMsg.pu8Buffer		= NULL;
   12b6c:	2300      	movs	r3, #0
   12b6e:	9309      	str	r3, [sp, #36]	; 0x24
					if(gpfAppSocketCb)
   12b70:	4b33      	ldr	r3, [pc, #204]	; (12c40 <m2m_ip_cb+0x2f0>)
   12b72:	681b      	ldr	r3, [r3, #0]
   12b74:	2b00      	cmp	r3, #0
   12b76:	d059      	beq.n	12c2c <m2m_ip_cb+0x2dc>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
   12b78:	4b31      	ldr	r3, [pc, #196]	; (12c40 <m2m_ip_cb+0x2f0>)
   12b7a:	681b      	ldr	r3, [r3, #0]
   12b7c:	4642      	mov	r2, r8
   12b7e:	4669      	mov	r1, sp
   12b80:	73ca      	strb	r2, [r1, #15]
   12b82:	200f      	movs	r0, #15
   12b84:	5608      	ldrsb	r0, [r1, r0]
   12b86:	4649      	mov	r1, r9
   12b88:	aa09      	add	r2, sp, #36	; 0x24
   12b8a:	4798      	blx	r3
   12b8c:	e04e      	b.n	12c2c <m2m_ip_cb+0x2dc>
				}
			}
			else
			{
				M2M_DBG("Discard recv callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
				if(u16ReadSize < u16BufferSize)
   12b8e:	2d10      	cmp	r5, #16
   12b90:	d94c      	bls.n	12c2c <m2m_ip_cb+0x2dc>
					hif_receive(0, NULL, 0, 1);
   12b92:	2000      	movs	r0, #0
   12b94:	2100      	movs	r1, #0
   12b96:	2200      	movs	r2, #0
   12b98:	2301      	movs	r3, #1
   12b9a:	4c28      	ldr	r4, [pc, #160]	; (12c3c <m2m_ip_cb+0x2ec>)
   12b9c:	47a0      	blx	r4
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
	{
   12b9e:	e045      	b.n	12c2c <m2m_ip_cb+0x2dc>
				if(u16ReadSize < u16BufferSize)
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
   12ba0:	2845      	cmp	r0, #69	; 0x45
   12ba2:	d005      	beq.n	12bb0 <m2m_ip_cb+0x260>
   12ba4:	2847      	cmp	r0, #71	; 0x47
   12ba6:	d005      	beq.n	12bb4 <m2m_ip_cb+0x264>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
   12ba8:	2507      	movs	r5, #7
				if(u16ReadSize < u16BufferSize)
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
   12baa:	284c      	cmp	r0, #76	; 0x4c
   12bac:	d003      	beq.n	12bb6 <m2m_ip_cb+0x266>
   12bae:	e026      	b.n	12bfe <m2m_ip_cb+0x2ae>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
   12bb0:	2507      	movs	r5, #7
   12bb2:	e000      	b.n	12bb6 <m2m_ip_cb+0x266>

		if(u8OpCode == SOCKET_CMD_SENDTO)
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
   12bb4:	2508      	movs	r5, #8

		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
   12bb6:	1c20      	adds	r0, r4, #0
   12bb8:	a909      	add	r1, sp, #36	; 0x24
   12bba:	2208      	movs	r2, #8
   12bbc:	2300      	movs	r3, #0
   12bbe:	4c1f      	ldr	r4, [pc, #124]	; (12c3c <m2m_ip_cb+0x2ec>)
   12bc0:	47a0      	blx	r4
   12bc2:	2800      	cmp	r0, #0
   12bc4:	d132      	bne.n	12c2c <m2m_ip_cb+0x2dc>
		{
			uint16 u16SessionID = 0;
			
			sock = strReply.sock;
   12bc6:	ab09      	add	r3, sp, #36	; 0x24
   12bc8:	7818      	ldrb	r0, [r3, #0]
			u16SessionID = strReply.u16SessionID;
   12bca:	889a      	ldrh	r2, [r3, #4]
			M2M_DBG("send callback session ID = %d\r\n",u16SessionID);
			
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
   12bcc:	8859      	ldrh	r1, [r3, #2]
   12bce:	ab05      	add	r3, sp, #20
   12bd0:	8019      	strh	r1, [r3, #0]

			if(u16SessionID == gastrSockets[sock].u16SessionID)
   12bd2:	b243      	sxtb	r3, r0
   12bd4:	0059      	lsls	r1, r3, #1
   12bd6:	18cb      	adds	r3, r1, r3
   12bd8:	009b      	lsls	r3, r3, #2
   12bda:	491a      	ldr	r1, [pc, #104]	; (12c44 <m2m_ip_cb+0x2f4>)
   12bdc:	18cb      	adds	r3, r1, r3
   12bde:	3308      	adds	r3, #8
   12be0:	885b      	ldrh	r3, [r3, #2]
   12be2:	b29b      	uxth	r3, r3
   12be4:	4293      	cmp	r3, r2
   12be6:	d121      	bne.n	12c2c <m2m_ip_cb+0x2dc>
			{
				if(gpfAppSocketCb)
   12be8:	4b15      	ldr	r3, [pc, #84]	; (12c40 <m2m_ip_cb+0x2f0>)
   12bea:	681b      	ldr	r3, [r3, #0]
   12bec:	2b00      	cmp	r3, #0
   12bee:	d01d      	beq.n	12c2c <m2m_ip_cb+0x2dc>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
   12bf0:	4b13      	ldr	r3, [pc, #76]	; (12c40 <m2m_ip_cb+0x2f0>)
   12bf2:	681b      	ldr	r3, [r3, #0]
   12bf4:	b240      	sxtb	r0, r0
   12bf6:	1c29      	adds	r1, r5, #0
   12bf8:	aa05      	add	r2, sp, #20
   12bfa:	4798      	blx	r3
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
	{
   12bfc:	e016      	b.n	12c2c <m2m_ip_cb+0x2dc>
			{
				M2M_DBG("Discard send callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
			}
		}
	}
	else if(u8OpCode == SOCKET_CMD_PING)
   12bfe:	2852      	cmp	r0, #82	; 0x52
   12c00:	d114      	bne.n	12c2c <m2m_ip_cb+0x2dc>
	{
		tstrPingReply	strPingReply;
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
   12c02:	1c10      	adds	r0, r2, #0
   12c04:	a909      	add	r1, sp, #36	; 0x24
   12c06:	2214      	movs	r2, #20
   12c08:	2301      	movs	r3, #1
   12c0a:	4c0c      	ldr	r4, [pc, #48]	; (12c3c <m2m_ip_cb+0x2ec>)
   12c0c:	47a0      	blx	r4
   12c0e:	2800      	cmp	r0, #0
   12c10:	d10c      	bne.n	12c2c <m2m_ip_cb+0x2dc>
		{
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
   12c12:	4b10      	ldr	r3, [pc, #64]	; (12c54 <m2m_ip_cb+0x304>)
   12c14:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   12c16:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
   12c18:	681b      	ldr	r3, [r3, #0]
   12c1a:	2b00      	cmp	r3, #0
   12c1c:	d006      	beq.n	12c2c <m2m_ip_cb+0x2dc>
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
   12c1e:	4b0d      	ldr	r3, [pc, #52]	; (12c54 <m2m_ip_cb+0x304>)
   12c20:	681c      	ldr	r4, [r3, #0]
   12c22:	ab09      	add	r3, sp, #36	; 0x24
   12c24:	990b      	ldr	r1, [sp, #44]	; 0x2c
   12c26:	7c1a      	ldrb	r2, [r3, #16]
   12c28:	9809      	ldr	r0, [sp, #36]	; 0x24
   12c2a:	47a0      	blx	r4
			}
		}
	}
}
   12c2c:	b01b      	add	sp, #108	; 0x6c
   12c2e:	bc3c      	pop	{r2, r3, r4, r5}
   12c30:	4690      	mov	r8, r2
   12c32:	4699      	mov	r9, r3
   12c34:	46a2      	mov	sl, r4
   12c36:	46ab      	mov	fp, r5
   12c38:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12c3a:	46c0      	nop			; (mov r8, r8)
   12c3c:	00010fd9 	.word	0x00010fd9
   12c40:	20002c00 	.word	0x20002c00
   12c44:	20002b7c 	.word	0x20002b7c
   12c48:	2000131a 	.word	0x2000131a
   12c4c:	20002c08 	.word	0x20002c08
   12c50:	00012859 	.word	0x00012859
   12c54:	20002c04 	.word	0x20002c04

00012c58 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
   12c58:	b508      	push	{r3, lr}
	if(gbSocketInit==0)
   12c5a:	4b0a      	ldr	r3, [pc, #40]	; (12c84 <socketInit+0x2c>)
   12c5c:	781b      	ldrb	r3, [r3, #0]
   12c5e:	2b00      	cmp	r3, #0
   12c60:	d10e      	bne.n	12c80 <socketInit+0x28>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
   12c62:	4809      	ldr	r0, [pc, #36]	; (12c88 <socketInit+0x30>)
   12c64:	2100      	movs	r1, #0
   12c66:	2284      	movs	r2, #132	; 0x84
   12c68:	4b08      	ldr	r3, [pc, #32]	; (12c8c <socketInit+0x34>)
   12c6a:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GRP_IP,m2m_ip_cb);
   12c6c:	2002      	movs	r0, #2
   12c6e:	4908      	ldr	r1, [pc, #32]	; (12c90 <socketInit+0x38>)
   12c70:	4b08      	ldr	r3, [pc, #32]	; (12c94 <socketInit+0x3c>)
   12c72:	4798      	blx	r3
		gbSocketInit=1;
   12c74:	2201      	movs	r2, #1
   12c76:	4b03      	ldr	r3, [pc, #12]	; (12c84 <socketInit+0x2c>)
   12c78:	701a      	strb	r2, [r3, #0]
		gu16SessionID = 0;
   12c7a:	2200      	movs	r2, #0
   12c7c:	4b06      	ldr	r3, [pc, #24]	; (12c98 <socketInit+0x40>)
   12c7e:	801a      	strh	r2, [r3, #0]
	}
}
   12c80:	bd08      	pop	{r3, pc}
   12c82:	46c0      	nop			; (mov r8, r8)
   12c84:	20001319 	.word	0x20001319
   12c88:	20002b7c 	.word	0x20002b7c
   12c8c:	00010981 	.word	0x00010981
   12c90:	00012951 	.word	0x00012951
   12c94:	000110f5 	.word	0x000110f5
   12c98:	2000131a 	.word	0x2000131a

00012c9c <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
   12c9c:	4b02      	ldr	r3, [pc, #8]	; (12ca8 <registerSocketCallback+0xc>)
   12c9e:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
   12ca0:	4b02      	ldr	r3, [pc, #8]	; (12cac <registerSocketCallback+0x10>)
   12ca2:	6019      	str	r1, [r3, #0]
}
   12ca4:	4770      	bx	lr
   12ca6:	46c0      	nop			; (mov r8, r8)
   12ca8:	20002c00 	.word	0x20002c00
   12cac:	20002c08 	.word	0x20002c08

00012cb0 <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
   12cb0:	b530      	push	{r4, r5, lr}
   12cb2:	b087      	sub	sp, #28
	SOCKET	sock = -1;
   12cb4:	24ff      	movs	r4, #255	; 0xff
	uint8	u8Count,u8SocketCount = MAX_SOCKET;

	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
   12cb6:	2802      	cmp	r0, #2
   12cb8:	d153      	bne.n	12d62 <socket+0xb2>
	{
		if(u8Type == SOCK_STREAM)
   12cba:	2901      	cmp	r1, #1
   12cbc:	d045      	beq.n	12d4a <socket+0x9a>
			u8Count = 0;
		}
		else if(u8Type == SOCK_DGRAM)
		{
			/*--- UDP SOCKET ---*/
			u8SocketCount = MAX_SOCKET;
   12cbe:	3cf4      	subs	r4, #244	; 0xf4
			u8Count = TCP_SOCK_MAX;
   12cc0:	3005      	adds	r0, #5
		if(u8Type == SOCK_STREAM)
		{
			u8SocketCount = TCP_SOCK_MAX;
			u8Count = 0;
		}
		else if(u8Type == SOCK_DGRAM)
   12cc2:	2902      	cmp	r1, #2
   12cc4:	d043      	beq.n	12d4e <socket+0x9e>
			/*--- UDP SOCKET ---*/
			u8SocketCount = MAX_SOCKET;
			u8Count = TCP_SOCK_MAX;
		}
		else
			return sock;
   12cc6:	34f4      	adds	r4, #244	; 0xf4
   12cc8:	e04b      	b.n	12d62 <socket+0xb2>

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			if(gastrSockets[u8Count].bIsUsed == 0)
   12cca:	1c01      	adds	r1, r0, #0
   12ccc:	0043      	lsls	r3, r0, #1
   12cce:	181b      	adds	r3, r3, r0
   12cd0:	009b      	lsls	r3, r3, #2
   12cd2:	18eb      	adds	r3, r5, r3
   12cd4:	799b      	ldrb	r3, [r3, #6]
   12cd6:	2b00      	cmp	r3, #0
   12cd8:	d131      	bne.n	12d3e <socket+0x8e>
			{
				gastrSockets[u8Count].bIsUsed = 1;
   12cda:	004b      	lsls	r3, r1, #1
   12cdc:	185b      	adds	r3, r3, r1
   12cde:	009b      	lsls	r3, r3, #2
   12ce0:	4c21      	ldr	r4, [pc, #132]	; (12d68 <socket+0xb8>)
   12ce2:	18e3      	adds	r3, r4, r3
   12ce4:	2401      	movs	r4, #1
   12ce6:	719c      	strb	r4, [r3, #6]
				
				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
   12ce8:	4c20      	ldr	r4, [pc, #128]	; (12d6c <socket+0xbc>)
   12cea:	8823      	ldrh	r3, [r4, #0]
   12cec:	3301      	adds	r3, #1
   12cee:	b29b      	uxth	r3, r3
   12cf0:	8023      	strh	r3, [r4, #0]
				if(gu16SessionID == 0)
   12cf2:	8823      	ldrh	r3, [r4, #0]
   12cf4:	b29b      	uxth	r3, r3
   12cf6:	2b00      	cmp	r3, #0
   12cf8:	d103      	bne.n	12d02 <socket+0x52>
					++gu16SessionID;
   12cfa:	8823      	ldrh	r3, [r4, #0]
   12cfc:	3301      	adds	r3, #1
   12cfe:	b29b      	uxth	r3, r3
   12d00:	8023      	strh	r3, [r4, #0]
				
				gastrSockets[u8Count].u16SessionID = gu16SessionID;
   12d02:	4b1a      	ldr	r3, [pc, #104]	; (12d6c <socket+0xbc>)
   12d04:	881c      	ldrh	r4, [r3, #0]
   12d06:	b2a4      	uxth	r4, r4
   12d08:	004b      	lsls	r3, r1, #1
   12d0a:	185b      	adds	r3, r3, r1
   12d0c:	009b      	lsls	r3, r3, #2
   12d0e:	4d16      	ldr	r5, [pc, #88]	; (12d68 <socket+0xb8>)
   12d10:	18eb      	adds	r3, r5, r3
   12d12:	815c      	strh	r4, [r3, #10]
				M2M_DBG("1 Socket %d session ID = %d\r\n",u8Count, gu16SessionID );
				sock = (SOCKET)u8Count;
   12d14:	b2c4      	uxtb	r4, r0

				if(u8Flags & SOCKET_FLAGS_SSL)
   12d16:	07d3      	lsls	r3, r2, #31
   12d18:	d523      	bpl.n	12d62 <socket+0xb2>
				{
					tstrSSLSocketCreateCmd	strSSLCreate;
					strSSLCreate.sslSock = sock;
   12d1a:	aa05      	add	r2, sp, #20
   12d1c:	7014      	strb	r4, [r2, #0]
					gastrSockets[u8Count].u8SSLFlags = SSL_FLAGS_ACTIVE;
   12d1e:	004b      	lsls	r3, r1, #1
   12d20:	1859      	adds	r1, r3, r1
   12d22:	0089      	lsls	r1, r1, #2
   12d24:	186b      	adds	r3, r5, r1
   12d26:	2101      	movs	r1, #1
   12d28:	71d9      	strb	r1, [r3, #7]
					SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
   12d2a:	2300      	movs	r3, #0
   12d2c:	9300      	str	r3, [sp, #0]
   12d2e:	9301      	str	r3, [sp, #4]
   12d30:	9302      	str	r3, [sp, #8]
   12d32:	2002      	movs	r0, #2
   12d34:	314f      	adds	r1, #79	; 0x4f
   12d36:	3304      	adds	r3, #4
   12d38:	4d0d      	ldr	r5, [pc, #52]	; (12d70 <socket+0xc0>)
   12d3a:	47a8      	blx	r5
   12d3c:	e011      	b.n	12d62 <socket+0xb2>
			u8Count = TCP_SOCK_MAX;
		}
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
   12d3e:	3001      	adds	r0, #1
   12d40:	b2c0      	uxtb	r0, r0
   12d42:	42a0      	cmp	r0, r4
   12d44:	d3c1      	bcc.n	12cca <socket+0x1a>
Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
	SOCKET	sock = -1;
   12d46:	24ff      	movs	r4, #255	; 0xff
   12d48:	e00b      	b.n	12d62 <socket+0xb2>
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
	{
		if(u8Type == SOCK_STREAM)
		{
			u8SocketCount = TCP_SOCK_MAX;
   12d4a:	2407      	movs	r4, #7
			u8Count = 0;
   12d4c:	2000      	movs	r0, #0
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			if(gastrSockets[u8Count].bIsUsed == 0)
   12d4e:	1c01      	adds	r1, r0, #0
   12d50:	0043      	lsls	r3, r0, #1
   12d52:	181b      	adds	r3, r3, r0
   12d54:	009b      	lsls	r3, r3, #2
   12d56:	4d04      	ldr	r5, [pc, #16]	; (12d68 <socket+0xb8>)
   12d58:	18eb      	adds	r3, r5, r3
   12d5a:	799b      	ldrb	r3, [r3, #6]
   12d5c:	2b00      	cmp	r3, #0
   12d5e:	d0bc      	beq.n	12cda <socket+0x2a>
   12d60:	e7ed      	b.n	12d3e <socket+0x8e>
   12d62:	b260      	sxtb	r0, r4
				break;
			}
		}
	}
	return sock;
}
   12d64:	b007      	add	sp, #28
   12d66:	bd30      	pop	{r4, r5, pc}
   12d68:	20002b7c 	.word	0x20002b7c
   12d6c:	2000131a 	.word	0x2000131a
   12d70:	00010ad1 	.word	0x00010ad1

00012d74 <bind>:

Date
		5 June 2012
*********************************************************************/
sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
   12d74:	b530      	push	{r4, r5, lr}
   12d76:	b089      	sub	sp, #36	; 0x24
   12d78:	1c04      	adds	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((pstrAddr != NULL) && (sock >= 0) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
   12d7a:	2900      	cmp	r1, #0
   12d7c:	d026      	beq.n	12dcc <bind+0x58>
   12d7e:	2800      	cmp	r0, #0
   12d80:	db26      	blt.n	12dd0 <bind+0x5c>
   12d82:	0043      	lsls	r3, r0, #1
   12d84:	181b      	adds	r3, r3, r0
   12d86:	009b      	lsls	r3, r3, #2
   12d88:	4815      	ldr	r0, [pc, #84]	; (12de0 <bind+0x6c>)
   12d8a:	18c3      	adds	r3, r0, r3
   12d8c:	799b      	ldrb	r3, [r3, #6]
   12d8e:	2b01      	cmp	r3, #1
   12d90:	d120      	bne.n	12dd4 <bind+0x60>
   12d92:	2a00      	cmp	r2, #0
   12d94:	d020      	beq.n	12dd8 <bind+0x64>
	{
		tstrBindCmd			strBind;

		/* Build the bind request. */
		strBind.sock = sock;
   12d96:	ad05      	add	r5, sp, #20
   12d98:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strBind.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
   12d9a:	1c28      	adds	r0, r5, #0
   12d9c:	2208      	movs	r2, #8
   12d9e:	4b11      	ldr	r3, [pc, #68]	; (12de4 <bind+0x70>)
   12da0:	4798      	blx	r3
		//strBind.strAddr = *((tstrSockAddr*)pstrAddr);

		strBind.strAddr.u16Family	= strBind.strAddr.u16Family;
		strBind.strAddr.u16Port		= strBind.strAddr.u16Port;
		strBind.strAddr.u32IPAddr	= strBind.strAddr.u32IPAddr;
		strBind.u16SessionID		= gastrSockets[sock].u16SessionID;
   12da2:	0063      	lsls	r3, r4, #1
   12da4:	191c      	adds	r4, r3, r4
   12da6:	00a4      	lsls	r4, r4, #2
   12da8:	4b0d      	ldr	r3, [pc, #52]	; (12de0 <bind+0x6c>)
   12daa:	191c      	adds	r4, r3, r4
   12dac:	8963      	ldrh	r3, [r4, #10]
   12dae:	816b      	strh	r3, [r5, #10]
		
		/* Send the request. */
		s8Ret = SOCKET_REQUEST(SOCKET_CMD_BIND, (uint8*)&strBind,sizeof(tstrBindCmd) , NULL , 0, 0);
   12db0:	2300      	movs	r3, #0
   12db2:	9300      	str	r3, [sp, #0]
   12db4:	9301      	str	r3, [sp, #4]
   12db6:	9302      	str	r3, [sp, #8]
   12db8:	2002      	movs	r0, #2
   12dba:	2141      	movs	r1, #65	; 0x41
   12dbc:	1c2a      	adds	r2, r5, #0
   12dbe:	330c      	adds	r3, #12
   12dc0:	4c09      	ldr	r4, [pc, #36]	; (12de8 <bind+0x74>)
   12dc2:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
   12dc4:	2800      	cmp	r0, #0
   12dc6:	d008      	beq.n	12dda <bind+0x66>
		{
			s8Ret = SOCK_ERR_INVALID;
   12dc8:	20f7      	movs	r0, #247	; 0xf7
   12dca:	e006      	b.n	12dda <bind+0x66>
Date
		5 June 2012
*********************************************************************/
sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   12dcc:	20fa      	movs	r0, #250	; 0xfa
   12dce:	e004      	b.n	12dda <bind+0x66>
   12dd0:	20fa      	movs	r0, #250	; 0xfa
   12dd2:	e002      	b.n	12dda <bind+0x66>
   12dd4:	20fa      	movs	r0, #250	; 0xfa
   12dd6:	e000      	b.n	12dda <bind+0x66>
   12dd8:	20fa      	movs	r0, #250	; 0xfa
		if(s8Ret != SOCK_ERR_NO_ERROR)
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
   12dda:	b240      	sxtb	r0, r0
}
   12ddc:	b009      	add	sp, #36	; 0x24
   12dde:	bd30      	pop	{r4, r5, pc}
   12de0:	20002b7c 	.word	0x20002b7c
   12de4:	0001096d 	.word	0x0001096d
   12de8:	00010ad1 	.word	0x00010ad1

00012dec <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
   12dec:	b570      	push	{r4, r5, r6, lr}
   12dee:	b088      	sub	sp, #32
   12df0:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
   12df2:	db36      	blt.n	12e62 <connect+0x76>
   12df4:	2900      	cmp	r1, #0
   12df6:	d036      	beq.n	12e66 <connect+0x7a>
   12df8:	0043      	lsls	r3, r0, #1
   12dfa:	181b      	adds	r3, r3, r0
   12dfc:	009b      	lsls	r3, r3, #2
   12dfe:	481e      	ldr	r0, [pc, #120]	; (12e78 <connect+0x8c>)
   12e00:	18c3      	adds	r3, r0, r3
   12e02:	799b      	ldrb	r3, [r3, #6]
   12e04:	2b01      	cmp	r3, #1
   12e06:	d130      	bne.n	12e6a <connect+0x7e>
   12e08:	2a00      	cmp	r2, #0
   12e0a:	d030      	beq.n	12e6e <connect+0x82>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
   12e0c:	0063      	lsls	r3, r4, #1
   12e0e:	191b      	adds	r3, r3, r4
   12e10:	009b      	lsls	r3, r3, #2
   12e12:	18c3      	adds	r3, r0, r3
   12e14:	79db      	ldrb	r3, [r3, #7]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
   12e16:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
   12e18:	07db      	lsls	r3, r3, #31
   12e1a:	d507      	bpl.n	12e2c <connect+0x40>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
   12e1c:	0063      	lsls	r3, r4, #1
   12e1e:	191b      	adds	r3, r3, r4
   12e20:	009b      	lsls	r3, r3, #2
   12e22:	18c3      	adds	r3, r0, r3
   12e24:	79da      	ldrb	r2, [r3, #7]
   12e26:	ab05      	add	r3, sp, #20
   12e28:	725a      	strb	r2, [r3, #9]
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
   12e2a:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
		}
		strConnect.sock = sock;
   12e2c:	ad05      	add	r5, sp, #20
   12e2e:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
   12e30:	1c28      	adds	r0, r5, #0
   12e32:	2208      	movs	r2, #8
   12e34:	4b11      	ldr	r3, [pc, #68]	; (12e7c <connect+0x90>)
   12e36:	4798      	blx	r3

		strConnect.strAddr.u16Family	= strConnect.strAddr.u16Family;
		strConnect.strAddr.u16Port		= strConnect.strAddr.u16Port;
		strConnect.strAddr.u32IPAddr	= strConnect.strAddr.u32IPAddr;
		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
   12e38:	0063      	lsls	r3, r4, #1
   12e3a:	191c      	adds	r4, r3, r4
   12e3c:	00a4      	lsls	r4, r4, #2
   12e3e:	4b0e      	ldr	r3, [pc, #56]	; (12e78 <connect+0x8c>)
   12e40:	191c      	adds	r4, r3, r4
   12e42:	8963      	ldrh	r3, [r4, #10]
   12e44:	816b      	strh	r3, [r5, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
   12e46:	2300      	movs	r3, #0
   12e48:	9300      	str	r3, [sp, #0]
   12e4a:	9301      	str	r3, [sp, #4]
   12e4c:	9302      	str	r3, [sp, #8]
   12e4e:	2002      	movs	r0, #2
   12e50:	1c31      	adds	r1, r6, #0
   12e52:	1c2a      	adds	r2, r5, #0
   12e54:	330c      	adds	r3, #12
   12e56:	4c0a      	ldr	r4, [pc, #40]	; (12e80 <connect+0x94>)
   12e58:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
   12e5a:	2800      	cmp	r0, #0
   12e5c:	d008      	beq.n	12e70 <connect+0x84>
		{
			s8Ret = SOCK_ERR_INVALID;
   12e5e:	20f7      	movs	r0, #247	; 0xf7
   12e60:	e006      	b.n	12e70 <connect+0x84>
Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   12e62:	20fa      	movs	r0, #250	; 0xfa
   12e64:	e004      	b.n	12e70 <connect+0x84>
   12e66:	20fa      	movs	r0, #250	; 0xfa
   12e68:	e002      	b.n	12e70 <connect+0x84>
   12e6a:	20fa      	movs	r0, #250	; 0xfa
   12e6c:	e000      	b.n	12e70 <connect+0x84>
   12e6e:	20fa      	movs	r0, #250	; 0xfa
		if(s8Ret != SOCK_ERR_NO_ERROR)
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
   12e70:	b240      	sxtb	r0, r0
}
   12e72:	b008      	add	sp, #32
   12e74:	bd70      	pop	{r4, r5, r6, pc}
   12e76:	46c0      	nop			; (mov r8, r8)
   12e78:	20002b7c 	.word	0x20002b7c
   12e7c:	0001096d 	.word	0x0001096d
   12e80:	00010ad1 	.word	0x00010ad1

00012e84 <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
   12e84:	b530      	push	{r4, r5, lr}
   12e86:	b089      	sub	sp, #36	; 0x24
   12e88:	1c0d      	adds	r5, r1, #0
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
   12e8a:	2800      	cmp	r0, #0
   12e8c:	db35      	blt.n	12efa <send+0x76>
   12e8e:	2900      	cmp	r1, #0
   12e90:	d035      	beq.n	12efe <send+0x7a>
   12e92:	23af      	movs	r3, #175	; 0xaf
   12e94:	00db      	lsls	r3, r3, #3
   12e96:	429a      	cmp	r2, r3
   12e98:	d833      	bhi.n	12f02 <send+0x7e>
   12e9a:	0043      	lsls	r3, r0, #1
   12e9c:	181b      	adds	r3, r3, r0
   12e9e:	009b      	lsls	r3, r3, #2
   12ea0:	491b      	ldr	r1, [pc, #108]	; (12f10 <send+0x8c>)
   12ea2:	18cb      	adds	r3, r1, r3
   12ea4:	799b      	ldrb	r3, [r3, #6]
   12ea6:	2b01      	cmp	r3, #1
   12ea8:	d12d      	bne.n	12f06 <send+0x82>
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock		= sock;
   12eaa:	ac04      	add	r4, sp, #16
   12eac:	7020      	strb	r0, [r4, #0]
		strSend.u16DataSize	= NM_BSP_B_L_16(u16SendLength);
   12eae:	8062      	strh	r2, [r4, #2]
		strSend.u16SessionID		= gastrSockets[sock].u16SessionID;
   12eb0:	0043      	lsls	r3, r0, #1
   12eb2:	181b      	adds	r3, r3, r0
   12eb4:	009b      	lsls	r3, r3, #2
   12eb6:	18cb      	adds	r3, r1, r3
   12eb8:	3308      	adds	r3, #8
   12eba:	885b      	ldrh	r3, [r3, #2]
   12ebc:	81a3      	strh	r3, [r4, #12]
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
   12ebe:	2450      	movs	r4, #80	; 0x50

		strSend.sock		= sock;
		strSend.u16DataSize	= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID		= gastrSockets[sock].u16SessionID;

		if(sock >= TCP_SOCK_MAX)
   12ec0:	2806      	cmp	r0, #6
   12ec2:	dd00      	ble.n	12ec6 <send+0x42>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
   12ec4:	3c0c      	subs	r4, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   12ec6:	0043      	lsls	r3, r0, #1
   12ec8:	1818      	adds	r0, r3, r0
   12eca:	0080      	lsls	r0, r0, #2
   12ecc:	4b10      	ldr	r3, [pc, #64]	; (12f10 <send+0x8c>)
   12ece:	1818      	adds	r0, r3, r0
   12ed0:	79c3      	ldrb	r3, [r0, #7]
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
   12ed2:	2145      	movs	r1, #69	; 0x45

		if(sock >= TCP_SOCK_MAX)
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   12ed4:	07db      	lsls	r3, r3, #31
   12ed6:	d501      	bpl.n	12edc <send+0x58>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
   12ed8:	3107      	adds	r1, #7
			u16DataOffset	= SSL_TX_PACKET_OFFSET;
   12eda:	2455      	movs	r4, #85	; 0x55
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
   12edc:	2380      	movs	r3, #128	; 0x80
   12ede:	4319      	orrs	r1, r3
   12ee0:	9500      	str	r5, [sp, #0]
   12ee2:	9201      	str	r2, [sp, #4]
   12ee4:	9402      	str	r4, [sp, #8]
   12ee6:	2002      	movs	r0, #2
   12ee8:	aa04      	add	r2, sp, #16
   12eea:	3b70      	subs	r3, #112	; 0x70
   12eec:	4c09      	ldr	r4, [pc, #36]	; (12f14 <send+0x90>)
   12eee:	47a0      	blx	r4
   12ef0:	2300      	movs	r3, #0
		if(s16Ret != SOCK_ERR_NO_ERROR)
   12ef2:	2800      	cmp	r0, #0
   12ef4:	d008      	beq.n	12f08 <send+0x84>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
   12ef6:	4b08      	ldr	r3, [pc, #32]	; (12f18 <send+0x94>)
   12ef8:	e006      	b.n	12f08 <send+0x84>
Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   12efa:	4b08      	ldr	r3, [pc, #32]	; (12f1c <send+0x98>)
   12efc:	e004      	b.n	12f08 <send+0x84>
   12efe:	4b07      	ldr	r3, [pc, #28]	; (12f1c <send+0x98>)
   12f00:	e002      	b.n	12f08 <send+0x84>
   12f02:	4b06      	ldr	r3, [pc, #24]	; (12f1c <send+0x98>)
   12f04:	e000      	b.n	12f08 <send+0x84>
   12f06:	4b05      	ldr	r3, [pc, #20]	; (12f1c <send+0x98>)
		if(s16Ret != SOCK_ERR_NO_ERROR)
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
		}
	}
	return s16Ret;
   12f08:	b218      	sxth	r0, r3
}
   12f0a:	b009      	add	sp, #36	; 0x24
   12f0c:	bd30      	pop	{r4, r5, pc}
   12f0e:	46c0      	nop			; (mov r8, r8)
   12f10:	20002b7c 	.word	0x20002b7c
   12f14:	00010ad1 	.word	0x00010ad1
   12f18:	0000fff2 	.word	0x0000fff2
   12f1c:	0000fffa 	.word	0x0000fffa

00012f20 <sendto>:

Date
		4 June 2012
*********************************************************************/
sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen)
{
   12f20:	b5f0      	push	{r4, r5, r6, r7, lr}
   12f22:	4647      	mov	r7, r8
   12f24:	b480      	push	{r7}
   12f26:	b088      	sub	sp, #32
   12f28:	1c04      	adds	r4, r0, #0
   12f2a:	4688      	mov	r8, r1
   12f2c:	1c17      	adds	r7, r2, #0
   12f2e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
   12f30:	2800      	cmp	r0, #0
   12f32:	db3c      	blt.n	12fae <sendto+0x8e>
   12f34:	2900      	cmp	r1, #0
   12f36:	d03c      	beq.n	12fb2 <sendto+0x92>
   12f38:	23af      	movs	r3, #175	; 0xaf
   12f3a:	00db      	lsls	r3, r3, #3
   12f3c:	429a      	cmp	r2, r3
   12f3e:	d83a      	bhi.n	12fb6 <sendto+0x96>
   12f40:	0043      	lsls	r3, r0, #1
   12f42:	181b      	adds	r3, r3, r0
   12f44:	009b      	lsls	r3, r3, #2
   12f46:	4a21      	ldr	r2, [pc, #132]	; (12fcc <sendto+0xac>)
   12f48:	18d3      	adds	r3, r2, r3
   12f4a:	799b      	ldrb	r3, [r3, #6]
   12f4c:	2b01      	cmp	r3, #1
   12f4e:	d134      	bne.n	12fba <sendto+0x9a>
	{
		if(gastrSockets[sock].bIsUsed)
   12f50:	0043      	lsls	r3, r0, #1
   12f52:	181b      	adds	r3, r3, r0
   12f54:	009b      	lsls	r3, r3, #2
   12f56:	18d3      	adds	r3, r2, r3
   12f58:	799b      	ldrb	r3, [r3, #6]
   12f5a:	2b00      	cmp	r3, #0
   12f5c:	d02f      	beq.n	12fbe <sendto+0x9e>
		{
			tstrSendCmd	strSendTo;

			m2m_memset((uint8*)&strSendTo, 0, sizeof(tstrSendCmd));
   12f5e:	ad04      	add	r5, sp, #16
   12f60:	1c28      	adds	r0, r5, #0
   12f62:	2100      	movs	r1, #0
   12f64:	2210      	movs	r2, #16
   12f66:	4b1a      	ldr	r3, [pc, #104]	; (12fd0 <sendto+0xb0>)
   12f68:	4798      	blx	r3

			strSendTo.sock			= sock;
   12f6a:	702c      	strb	r4, [r5, #0]
			strSendTo.u16DataSize	= NM_BSP_B_L_16(u16SendLength);
   12f6c:	806f      	strh	r7, [r5, #2]
			strSendTo.u16SessionID		= gastrSockets[sock].u16SessionID;
   12f6e:	0063      	lsls	r3, r4, #1
   12f70:	191c      	adds	r4, r3, r4
   12f72:	00a4      	lsls	r4, r4, #2
   12f74:	4b15      	ldr	r3, [pc, #84]	; (12fcc <sendto+0xac>)
   12f76:	191c      	adds	r4, r3, r4
   12f78:	8963      	ldrh	r3, [r4, #10]
   12f7a:	81ab      	strh	r3, [r5, #12]
			
			if(pstrDestAddr != NULL)
   12f7c:	2e00      	cmp	r6, #0
   12f7e:	d006      	beq.n	12f8e <sendto+0x6e>
			{
				struct sockaddr_in	*pstrAddr;
				pstrAddr = (void*)pstrDestAddr;

				strSendTo.strAddr.u16Family	= pstrAddr->sin_family;
   12f80:	ab04      	add	r3, sp, #16
   12f82:	8832      	ldrh	r2, [r6, #0]
   12f84:	809a      	strh	r2, [r3, #4]
				strSendTo.strAddr.u16Port	= pstrAddr->sin_port;
   12f86:	8872      	ldrh	r2, [r6, #2]
   12f88:	80da      	strh	r2, [r3, #6]
				strSendTo.strAddr.u32IPAddr	= pstrAddr->sin_addr.s_addr;
   12f8a:	6872      	ldr	r2, [r6, #4]
   12f8c:	9206      	str	r2, [sp, #24]
			}
			s16Ret = SOCKET_REQUEST(SOCKET_CMD_SENDTO|M2M_REQ_DATA_PKT, (uint8*)&strSendTo,  sizeof(tstrSendCmd),
   12f8e:	4643      	mov	r3, r8
   12f90:	9300      	str	r3, [sp, #0]
   12f92:	9701      	str	r7, [sp, #4]
   12f94:	2344      	movs	r3, #68	; 0x44
   12f96:	9302      	str	r3, [sp, #8]
   12f98:	2002      	movs	r0, #2
   12f9a:	21c7      	movs	r1, #199	; 0xc7
   12f9c:	aa04      	add	r2, sp, #16
   12f9e:	3b34      	subs	r3, #52	; 0x34
   12fa0:	4c0c      	ldr	r4, [pc, #48]	; (12fd4 <sendto+0xb4>)
   12fa2:	47a0      	blx	r4
   12fa4:	2300      	movs	r3, #0
				pvSendBuffer, u16SendLength, UDP_TX_PACKET_OFFSET);

			if(s16Ret != SOCK_ERR_NO_ERROR)
   12fa6:	2800      	cmp	r0, #0
   12fa8:	d00a      	beq.n	12fc0 <sendto+0xa0>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
   12faa:	4b0b      	ldr	r3, [pc, #44]	; (12fd8 <sendto+0xb8>)
   12fac:	e008      	b.n	12fc0 <sendto+0xa0>
Date
		4 June 2012
*********************************************************************/
sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   12fae:	4b0b      	ldr	r3, [pc, #44]	; (12fdc <sendto+0xbc>)
   12fb0:	e006      	b.n	12fc0 <sendto+0xa0>
   12fb2:	4b0a      	ldr	r3, [pc, #40]	; (12fdc <sendto+0xbc>)
   12fb4:	e004      	b.n	12fc0 <sendto+0xa0>
   12fb6:	4b09      	ldr	r3, [pc, #36]	; (12fdc <sendto+0xbc>)
   12fb8:	e002      	b.n	12fc0 <sendto+0xa0>
   12fba:	4b08      	ldr	r3, [pc, #32]	; (12fdc <sendto+0xbc>)
   12fbc:	e000      	b.n	12fc0 <sendto+0xa0>
   12fbe:	4b07      	ldr	r3, [pc, #28]	; (12fdc <sendto+0xbc>)
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
   12fc0:	b218      	sxth	r0, r3
}
   12fc2:	b008      	add	sp, #32
   12fc4:	bc04      	pop	{r2}
   12fc6:	4690      	mov	r8, r2
   12fc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12fca:	46c0      	nop			; (mov r8, r8)
   12fcc:	20002b7c 	.word	0x20002b7c
   12fd0:	00010981 	.word	0x00010981
   12fd4:	00010ad1 	.word	0x00010ad1
   12fd8:	0000fff2 	.word	0x0000fff2
   12fdc:	0000fffa 	.word	0x0000fffa

00012fe0 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
   12fe0:	b570      	push	{r4, r5, r6, lr}
   12fe2:	b086      	sub	sp, #24
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
   12fe4:	2800      	cmp	r0, #0
   12fe6:	db3a      	blt.n	1305e <recv+0x7e>
   12fe8:	2900      	cmp	r1, #0
   12fea:	d03a      	beq.n	13062 <recv+0x82>
   12fec:	2a00      	cmp	r2, #0
   12fee:	d03a      	beq.n	13066 <recv+0x86>
   12ff0:	0044      	lsls	r4, r0, #1
   12ff2:	1824      	adds	r4, r4, r0
   12ff4:	00a4      	lsls	r4, r4, #2
   12ff6:	4d1f      	ldr	r5, [pc, #124]	; (13074 <recv+0x94>)
   12ff8:	192c      	adds	r4, r5, r4
   12ffa:	79a4      	ldrb	r4, [r4, #6]
   12ffc:	2c01      	cmp	r4, #1
   12ffe:	d134      	bne.n	1306a <recv+0x8a>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
   13000:	1c2e      	adds	r6, r5, #0
   13002:	0044      	lsls	r4, r0, #1
   13004:	1825      	adds	r5, r4, r0
   13006:	00ad      	lsls	r5, r5, #2
   13008:	51a9      	str	r1, [r5, r6]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
   1300a:	1971      	adds	r1, r6, r5
   1300c:	808a      	strh	r2, [r1, #4]

		if(!gastrSockets[sock].bIsRecvPending)
   1300e:	7a09      	ldrb	r1, [r1, #8]
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
	{
		s16Ret = SOCK_ERR_NO_ERROR;
   13010:	2200      	movs	r2, #0
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
   13012:	2900      	cmp	r1, #0
   13014:	d12a      	bne.n	1306c <recv+0x8c>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
   13016:	1972      	adds	r2, r6, r5
   13018:	2101      	movs	r1, #1
   1301a:	7211      	strb	r1, [r2, #8]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1301c:	79d2      	ldrb	r2, [r2, #7]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
   1301e:	3145      	adds	r1, #69	; 0x45

			gastrSockets[sock].bIsRecvPending = 1;
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   13020:	07d2      	lsls	r2, r2, #31
   13022:	d500      	bpl.n	13026 <recv+0x46>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
   13024:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
   13026:	2b00      	cmp	r3, #0
   13028:	d102      	bne.n	13030 <recv+0x50>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
   1302a:	3b01      	subs	r3, #1
   1302c:	9304      	str	r3, [sp, #16]
   1302e:	e000      	b.n	13032 <recv+0x52>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
   13030:	9304      	str	r3, [sp, #16]
			strRecv.sock = sock;
   13032:	aa04      	add	r2, sp, #16
   13034:	7110      	strb	r0, [r2, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
   13036:	0043      	lsls	r3, r0, #1
   13038:	1818      	adds	r0, r3, r0
   1303a:	0080      	lsls	r0, r0, #2
   1303c:	4b0d      	ldr	r3, [pc, #52]	; (13074 <recv+0x94>)
   1303e:	1818      	adds	r0, r3, r0
   13040:	8943      	ldrh	r3, [r0, #10]
   13042:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
   13044:	2300      	movs	r3, #0
   13046:	9300      	str	r3, [sp, #0]
   13048:	9301      	str	r3, [sp, #4]
   1304a:	9302      	str	r3, [sp, #8]
   1304c:	2002      	movs	r0, #2
   1304e:	3308      	adds	r3, #8
   13050:	4c09      	ldr	r4, [pc, #36]	; (13078 <recv+0x98>)
   13052:	47a0      	blx	r4
   13054:	2200      	movs	r2, #0
			if(s16Ret != SOCK_ERR_NO_ERROR)
   13056:	2800      	cmp	r0, #0
   13058:	d008      	beq.n	1306c <recv+0x8c>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
   1305a:	4a08      	ldr	r2, [pc, #32]	; (1307c <recv+0x9c>)
   1305c:	e006      	b.n	1306c <recv+0x8c>
Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   1305e:	4a08      	ldr	r2, [pc, #32]	; (13080 <recv+0xa0>)
   13060:	e004      	b.n	1306c <recv+0x8c>
   13062:	4a07      	ldr	r2, [pc, #28]	; (13080 <recv+0xa0>)
   13064:	e002      	b.n	1306c <recv+0x8c>
   13066:	4a06      	ldr	r2, [pc, #24]	; (13080 <recv+0xa0>)
   13068:	e000      	b.n	1306c <recv+0x8c>
   1306a:	4a05      	ldr	r2, [pc, #20]	; (13080 <recv+0xa0>)
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
   1306c:	b210      	sxth	r0, r2
}
   1306e:	b006      	add	sp, #24
   13070:	bd70      	pop	{r4, r5, r6, pc}
   13072:	46c0      	nop			; (mov r8, r8)
   13074:	20002b7c 	.word	0x20002b7c
   13078:	00010ad1 	.word	0x00010ad1
   1307c:	0000fff2 	.word	0x0000fff2
   13080:	0000fffa 	.word	0x0000fffa

00013084 <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
   13084:	b530      	push	{r4, r5, lr}
   13086:	b087      	sub	sp, #28
   13088:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
   1308a:	db2d      	blt.n	130e8 <close+0x64>
   1308c:	0043      	lsls	r3, r0, #1
   1308e:	181b      	adds	r3, r3, r0
   13090:	009b      	lsls	r3, r3, #2
   13092:	4a18      	ldr	r2, [pc, #96]	; (130f4 <close+0x70>)
   13094:	18d3      	adds	r3, r2, r3
   13096:	799b      	ldrb	r3, [r3, #6]
   13098:	2b01      	cmp	r3, #1
   1309a:	d127      	bne.n	130ec <close+0x68>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
   1309c:	a905      	add	r1, sp, #20
   1309e:	7008      	strb	r0, [r1, #0]
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
   130a0:	0043      	lsls	r3, r0, #1
   130a2:	181b      	adds	r3, r3, r0
   130a4:	009b      	lsls	r3, r3, #2
   130a6:	18d3      	adds	r3, r2, r3
   130a8:	8958      	ldrh	r0, [r3, #10]
   130aa:	8048      	strh	r0, [r1, #2]
		
		gastrSockets[sock].bIsUsed = 0;
   130ac:	2100      	movs	r1, #0
   130ae:	7199      	strb	r1, [r3, #6]
		gastrSockets[sock].u16SessionID =0;
   130b0:	8159      	strh	r1, [r3, #10]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   130b2:	79db      	ldrb	r3, [r3, #7]
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
   130b4:	3149      	adds	r1, #73	; 0x49
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
		
		gastrSockets[sock].bIsUsed = 0;
		gastrSockets[sock].u16SessionID =0;
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   130b6:	07db      	lsls	r3, r3, #31
   130b8:	d500      	bpl.n	130bc <close+0x38>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
   130ba:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
   130bc:	2300      	movs	r3, #0
   130be:	9300      	str	r3, [sp, #0]
   130c0:	9301      	str	r3, [sp, #4]
   130c2:	9302      	str	r3, [sp, #8]
   130c4:	2002      	movs	r0, #2
   130c6:	aa05      	add	r2, sp, #20
   130c8:	3304      	adds	r3, #4
   130ca:	4d0b      	ldr	r5, [pc, #44]	; (130f8 <close+0x74>)
   130cc:	47a8      	blx	r5
   130ce:	1e05      	subs	r5, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
   130d0:	d000      	beq.n	130d4 <close+0x50>
		{
			s8Ret = SOCK_ERR_INVALID;
   130d2:	25f7      	movs	r5, #247	; 0xf7
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
   130d4:	0060      	lsls	r0, r4, #1
   130d6:	1904      	adds	r4, r0, r4
   130d8:	00a4      	lsls	r4, r4, #2
   130da:	4806      	ldr	r0, [pc, #24]	; (130f4 <close+0x70>)
   130dc:	1820      	adds	r0, r4, r0
   130de:	2100      	movs	r1, #0
   130e0:	220c      	movs	r2, #12
   130e2:	4b06      	ldr	r3, [pc, #24]	; (130fc <close+0x78>)
   130e4:	4798      	blx	r3
   130e6:	e002      	b.n	130ee <close+0x6a>
Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   130e8:	25fa      	movs	r5, #250	; 0xfa
   130ea:	e000      	b.n	130ee <close+0x6a>
   130ec:	25fa      	movs	r5, #250	; 0xfa
		{
			s8Ret = SOCK_ERR_INVALID;
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
	}
	return s8Ret;
   130ee:	b268      	sxtb	r0, r5
}
   130f0:	b007      	add	sp, #28
   130f2:	bd30      	pop	{r4, r5, pc}
   130f4:	20002b7c 	.word	0x20002b7c
   130f8:	00010ad1 	.word	0x00010ad1
   130fc:	00010981 	.word	0x00010981

00013100 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
   13100:	4b0c      	ldr	r3, [pc, #48]	; (13134 <cpu_irq_enter_critical+0x34>)
   13102:	681b      	ldr	r3, [r3, #0]
   13104:	2b00      	cmp	r3, #0
   13106:	d110      	bne.n	1312a <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   13108:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
   1310c:	2b00      	cmp	r3, #0
   1310e:	d109      	bne.n	13124 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   13110:	b672      	cpsid	i
   13112:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
   13116:	2200      	movs	r2, #0
   13118:	4b07      	ldr	r3, [pc, #28]	; (13138 <cpu_irq_enter_critical+0x38>)
   1311a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
   1311c:	3201      	adds	r2, #1
   1311e:	4b07      	ldr	r3, [pc, #28]	; (1313c <cpu_irq_enter_critical+0x3c>)
   13120:	701a      	strb	r2, [r3, #0]
   13122:	e002      	b.n	1312a <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
   13124:	2200      	movs	r2, #0
   13126:	4b05      	ldr	r3, [pc, #20]	; (1313c <cpu_irq_enter_critical+0x3c>)
   13128:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
   1312a:	4a02      	ldr	r2, [pc, #8]	; (13134 <cpu_irq_enter_critical+0x34>)
   1312c:	6813      	ldr	r3, [r2, #0]
   1312e:	3301      	adds	r3, #1
   13130:	6013      	str	r3, [r2, #0]
}
   13132:	4770      	bx	lr
   13134:	2000131c 	.word	0x2000131c
   13138:	20000270 	.word	0x20000270
   1313c:	20001320 	.word	0x20001320

00013140 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
   13140:	4b08      	ldr	r3, [pc, #32]	; (13164 <cpu_irq_leave_critical+0x24>)
   13142:	681a      	ldr	r2, [r3, #0]
   13144:	3a01      	subs	r2, #1
   13146:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
   13148:	681b      	ldr	r3, [r3, #0]
   1314a:	2b00      	cmp	r3, #0
   1314c:	d109      	bne.n	13162 <cpu_irq_leave_critical+0x22>
   1314e:	4b06      	ldr	r3, [pc, #24]	; (13168 <cpu_irq_leave_critical+0x28>)
   13150:	781b      	ldrb	r3, [r3, #0]
   13152:	2b00      	cmp	r3, #0
   13154:	d005      	beq.n	13162 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
   13156:	2201      	movs	r2, #1
   13158:	4b04      	ldr	r3, [pc, #16]	; (1316c <cpu_irq_leave_critical+0x2c>)
   1315a:	701a      	strb	r2, [r3, #0]
   1315c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   13160:	b662      	cpsie	i
	}
}
   13162:	4770      	bx	lr
   13164:	2000131c 	.word	0x2000131c
   13168:	20001320 	.word	0x20001320
   1316c:	20000270 	.word	0x20000270

00013170 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
   13170:	b5f0      	push	{r4, r5, r6, r7, lr}
   13172:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
   13174:	ac01      	add	r4, sp, #4
   13176:	2501      	movs	r5, #1
   13178:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
   1317a:	2700      	movs	r7, #0
   1317c:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   1317e:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
   13180:	203e      	movs	r0, #62	; 0x3e
   13182:	1c21      	adds	r1, r4, #0
   13184:	4e06      	ldr	r6, [pc, #24]	; (131a0 <system_board_init+0x30>)
   13186:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
   13188:	2280      	movs	r2, #128	; 0x80
   1318a:	05d2      	lsls	r2, r2, #23
   1318c:	4b05      	ldr	r3, [pc, #20]	; (131a4 <system_board_init+0x34>)
   1318e:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
   13190:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
   13192:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
   13194:	200f      	movs	r0, #15
   13196:	1c21      	adds	r1, r4, #0
   13198:	47b0      	blx	r6
	port_pin_set_output_level(AT86RFX_RST_PIN, true);
	port_pin_set_output_level(AT86RFX_SLP_PIN, true);
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
#endif	
}
   1319a:	b003      	add	sp, #12
   1319c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1319e:	46c0      	nop			; (mov r8, r8)
   131a0:	000131a9 	.word	0x000131a9
   131a4:	41004480 	.word	0x41004480

000131a8 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
   131a8:	b500      	push	{lr}
   131aa:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
   131ac:	ab01      	add	r3, sp, #4
   131ae:	2280      	movs	r2, #128	; 0x80
   131b0:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
   131b2:	780a      	ldrb	r2, [r1, #0]
   131b4:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
   131b6:	784a      	ldrb	r2, [r1, #1]
   131b8:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
   131ba:	788a      	ldrb	r2, [r1, #2]
   131bc:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
   131be:	1c19      	adds	r1, r3, #0
   131c0:	4b01      	ldr	r3, [pc, #4]	; (131c8 <port_pin_set_config+0x20>)
   131c2:	4798      	blx	r3
}
   131c4:	b003      	add	sp, #12
   131c6:	bd00      	pop	{pc}
   131c8:	00013a25 	.word	0x00013a25

000131cc <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
   131cc:	b508      	push	{r3, lr}
	switch (clock_source) {
   131ce:	2808      	cmp	r0, #8
   131d0:	d803      	bhi.n	131da <system_clock_source_get_hz+0xe>
   131d2:	0080      	lsls	r0, r0, #2
   131d4:	4b1b      	ldr	r3, [pc, #108]	; (13244 <system_clock_source_get_hz+0x78>)
   131d6:	581b      	ldr	r3, [r3, r0]
   131d8:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
   131da:	2000      	movs	r0, #0
   131dc:	e031      	b.n	13242 <system_clock_source_get_hz+0x76>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
   131de:	4b1a      	ldr	r3, [pc, #104]	; (13248 <system_clock_source_get_hz+0x7c>)
   131e0:	6918      	ldr	r0, [r3, #16]
   131e2:	e02e      	b.n	13242 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
   131e4:	4b19      	ldr	r3, [pc, #100]	; (1324c <system_clock_source_get_hz+0x80>)
   131e6:	6a18      	ldr	r0, [r3, #32]
   131e8:	0580      	lsls	r0, r0, #22
   131ea:	0f80      	lsrs	r0, r0, #30
   131ec:	4b18      	ldr	r3, [pc, #96]	; (13250 <system_clock_source_get_hz+0x84>)
   131ee:	40c3      	lsrs	r3, r0
   131f0:	1c18      	adds	r0, r3, #0
   131f2:	e026      	b.n	13242 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
   131f4:	4b14      	ldr	r3, [pc, #80]	; (13248 <system_clock_source_get_hz+0x7c>)
   131f6:	6958      	ldr	r0, [r3, #20]
   131f8:	e023      	b.n	13242 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
   131fa:	4b13      	ldr	r3, [pc, #76]	; (13248 <system_clock_source_get_hz+0x7c>)
   131fc:	681b      	ldr	r3, [r3, #0]
   131fe:	2002      	movs	r0, #2
   13200:	4018      	ands	r0, r3
   13202:	d01e      	beq.n	13242 <system_clock_source_get_hz+0x76>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   13204:	4911      	ldr	r1, [pc, #68]	; (1324c <system_clock_source_get_hz+0x80>)
   13206:	2210      	movs	r2, #16
   13208:	68cb      	ldr	r3, [r1, #12]
   1320a:	421a      	tst	r2, r3
   1320c:	d0fc      	beq.n	13208 <system_clock_source_get_hz+0x3c>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
   1320e:	4b0e      	ldr	r3, [pc, #56]	; (13248 <system_clock_source_get_hz+0x7c>)
   13210:	681b      	ldr	r3, [r3, #0]
   13212:	075b      	lsls	r3, r3, #29
   13214:	d514      	bpl.n	13240 <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   13216:	2000      	movs	r0, #0
   13218:	4b0e      	ldr	r3, [pc, #56]	; (13254 <system_clock_source_get_hz+0x88>)
   1321a:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
   1321c:	4b0a      	ldr	r3, [pc, #40]	; (13248 <system_clock_source_get_hz+0x7c>)
   1321e:	689b      	ldr	r3, [r3, #8]
   13220:	041b      	lsls	r3, r3, #16
   13222:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   13224:	4358      	muls	r0, r3
   13226:	e00c      	b.n	13242 <system_clock_source_get_hz+0x76>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   13228:	2350      	movs	r3, #80	; 0x50
   1322a:	4a08      	ldr	r2, [pc, #32]	; (1324c <system_clock_source_get_hz+0x80>)
   1322c:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
   1322e:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   13230:	075b      	lsls	r3, r3, #29
   13232:	d506      	bpl.n	13242 <system_clock_source_get_hz+0x76>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
   13234:	4b04      	ldr	r3, [pc, #16]	; (13248 <system_clock_source_get_hz+0x7c>)
   13236:	68d8      	ldr	r0, [r3, #12]
   13238:	e003      	b.n	13242 <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
   1323a:	2080      	movs	r0, #128	; 0x80
   1323c:	0200      	lsls	r0, r0, #8
   1323e:	e000      	b.n	13242 <system_clock_source_get_hz+0x76>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
   13240:	4805      	ldr	r0, [pc, #20]	; (13258 <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
   13242:	bd08      	pop	{r3, pc}
   13244:	0002122c 	.word	0x0002122c
   13248:	20001324 	.word	0x20001324
   1324c:	40000800 	.word	0x40000800
   13250:	007a1200 	.word	0x007a1200
   13254:	00013949 	.word	0x00013949
   13258:	02dc6c00 	.word	0x02dc6c00

0001325c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
   1325c:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
   1325e:	4c0c      	ldr	r4, [pc, #48]	; (13290 <system_clock_source_osc8m_set_config+0x34>)
   13260:	6a23      	ldr	r3, [r4, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
   13262:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
   13264:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
   13266:	7842      	ldrb	r2, [r0, #1]
   13268:	2001      	movs	r0, #1
   1326a:	4002      	ands	r2, r0
   1326c:	0192      	lsls	r2, r2, #6
   1326e:	2640      	movs	r6, #64	; 0x40
   13270:	43b3      	bics	r3, r6
   13272:	4313      	orrs	r3, r2
   13274:	1c02      	adds	r2, r0, #0
   13276:	402a      	ands	r2, r5
   13278:	01d2      	lsls	r2, r2, #7
   1327a:	307f      	adds	r0, #127	; 0x7f
   1327c:	4383      	bics	r3, r0
   1327e:	4313      	orrs	r3, r2
   13280:	2203      	movs	r2, #3
   13282:	400a      	ands	r2, r1
   13284:	0212      	lsls	r2, r2, #8
   13286:	4903      	ldr	r1, [pc, #12]	; (13294 <system_clock_source_osc8m_set_config+0x38>)
   13288:	400b      	ands	r3, r1
   1328a:	4313      	orrs	r3, r2
   1328c:	6223      	str	r3, [r4, #32]
}
   1328e:	bd70      	pop	{r4, r5, r6, pc}
   13290:	40000800 	.word	0x40000800
   13294:	fffffcff 	.word	0xfffffcff

00013298 <system_clock_source_osc32k_set_config>:
 *
 * \param[in] config  OSC32K configuration structure containing the new config
 */
void system_clock_source_osc32k_set_config(
		struct system_clock_source_osc32k_config *const config)
{
   13298:	b5f0      	push	{r4, r5, r6, r7, lr}
   1329a:	4657      	mov	r7, sl
   1329c:	464e      	mov	r6, r9
   1329e:	4645      	mov	r5, r8
   132a0:	b4e0      	push	{r5, r6, r7}
	SYSCTRL_OSC32K_Type temp = SYSCTRL->OSC32K;
   132a2:	4e1c      	ldr	r6, [pc, #112]	; (13314 <system_clock_source_osc32k_set_config+0x7c>)
   132a4:	69b3      	ldr	r3, [r6, #24]
   132a6:	469c      	mov	ip, r3

	/* Update settings via a temporary struct to reduce register access */
	temp.bit.EN1K     = config->enable_1khz_output;
   132a8:	7841      	ldrb	r1, [r0, #1]
	temp.bit.EN32K    = config->enable_32khz_output;
	temp.bit.STARTUP  = config->startup_time;
   132aa:	7805      	ldrb	r5, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
   132ac:	7907      	ldrb	r7, [r0, #4]
	temp.bit.RUNSTDBY = config->run_in_standby;
   132ae:	78c3      	ldrb	r3, [r0, #3]
   132b0:	4699      	mov	r9, r3
	temp.bit.WRTLOCK  = config->write_once;
   132b2:	7944      	ldrb	r4, [r0, #5]

	SYSCTRL->OSC32K  = temp;
   132b4:	7883      	ldrb	r3, [r0, #2]
   132b6:	2001      	movs	r0, #1
   132b8:	4003      	ands	r3, r0
   132ba:	009b      	lsls	r3, r3, #2
   132bc:	469a      	mov	sl, r3
   132be:	2204      	movs	r2, #4
   132c0:	4690      	mov	r8, r2
   132c2:	4662      	mov	r2, ip
   132c4:	4643      	mov	r3, r8
   132c6:	439a      	bics	r2, r3
   132c8:	1c13      	adds	r3, r2, #0
   132ca:	4652      	mov	r2, sl
   132cc:	431a      	orrs	r2, r3
   132ce:	1c13      	adds	r3, r2, #0
   132d0:	4001      	ands	r1, r0
   132d2:	00c9      	lsls	r1, r1, #3
   132d4:	2208      	movs	r2, #8
   132d6:	4393      	bics	r3, r2
   132d8:	430b      	orrs	r3, r1
   132da:	464a      	mov	r2, r9
   132dc:	4002      	ands	r2, r0
   132de:	0192      	lsls	r2, r2, #6
   132e0:	2140      	movs	r1, #64	; 0x40
   132e2:	438b      	bics	r3, r1
   132e4:	4313      	orrs	r3, r2
   132e6:	4007      	ands	r7, r0
   132e8:	01ff      	lsls	r7, r7, #7
   132ea:	2280      	movs	r2, #128	; 0x80
   132ec:	4393      	bics	r3, r2
   132ee:	433b      	orrs	r3, r7
   132f0:	3a79      	subs	r2, #121	; 0x79
   132f2:	4015      	ands	r5, r2
   132f4:	022d      	lsls	r5, r5, #8
   132f6:	4f08      	ldr	r7, [pc, #32]	; (13318 <system_clock_source_osc32k_set_config+0x80>)
   132f8:	403b      	ands	r3, r7
   132fa:	432b      	orrs	r3, r5
   132fc:	4004      	ands	r4, r0
   132fe:	0320      	lsls	r0, r4, #12
   13300:	4c06      	ldr	r4, [pc, #24]	; (1331c <system_clock_source_osc32k_set_config+0x84>)
   13302:	401c      	ands	r4, r3
   13304:	4304      	orrs	r4, r0
   13306:	61b4      	str	r4, [r6, #24]
}
   13308:	bc1c      	pop	{r2, r3, r4}
   1330a:	4690      	mov	r8, r2
   1330c:	4699      	mov	r9, r3
   1330e:	46a2      	mov	sl, r4
   13310:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13312:	46c0      	nop			; (mov r8, r8)
   13314:	40000800 	.word	0x40000800
   13318:	fffff8ff 	.word	0xfffff8ff
   1331c:	ffffefff 	.word	0xffffefff

00013320 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
   13320:	b5f0      	push	{r4, r5, r6, r7, lr}
   13322:	465f      	mov	r7, fp
   13324:	4656      	mov	r6, sl
   13326:	464d      	mov	r5, r9
   13328:	4644      	mov	r4, r8
   1332a:	b4f0      	push	{r4, r5, r6, r7}
   1332c:	b083      	sub	sp, #12
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
   1332e:	4e2e      	ldr	r6, [pc, #184]	; (133e8 <system_clock_source_xosc32k_set_config+0xc8>)
   13330:	8ab3      	ldrh	r3, [r6, #20]
   13332:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
   13334:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
   13336:	7803      	ldrb	r3, [r0, #0]
   13338:	425a      	negs	r2, r3
   1333a:	415a      	adcs	r2, r3
   1333c:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
   1333e:	7883      	ldrb	r3, [r0, #2]
   13340:	469b      	mov	fp, r3
	temp.bit.EN1K = config->enable_1khz_output;
   13342:	78c3      	ldrb	r3, [r0, #3]
	temp.bit.EN32K = config->enable_32khz_output;
   13344:	7902      	ldrb	r2, [r0, #4]
   13346:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
   13348:	7b47      	ldrb	r7, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
   1334a:	7b02      	ldrb	r2, [r0, #12]
   1334c:	9201      	str	r2, [sp, #4]
	temp.bit.WRTLOCK  = config->write_once;
   1334e:	7b84      	ldrb	r4, [r0, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
   13350:	6882      	ldr	r2, [r0, #8]
   13352:	4826      	ldr	r0, [pc, #152]	; (133ec <system_clock_source_xosc32k_set_config+0xcc>)
   13354:	6142      	str	r2, [r0, #20]

	SYSCTRL->XOSC32K = temp;
   13356:	2001      	movs	r0, #1
   13358:	464a      	mov	r2, r9
   1335a:	0092      	lsls	r2, r2, #2
   1335c:	4691      	mov	r9, r2
   1335e:	2204      	movs	r2, #4
   13360:	4692      	mov	sl, r2
   13362:	4662      	mov	r2, ip
   13364:	4651      	mov	r1, sl
   13366:	438a      	bics	r2, r1
   13368:	4694      	mov	ip, r2
   1336a:	464a      	mov	r2, r9
   1336c:	4661      	mov	r1, ip
   1336e:	430a      	orrs	r2, r1
   13370:	4694      	mov	ip, r2
   13372:	4642      	mov	r2, r8
   13374:	4002      	ands	r2, r0
   13376:	00d2      	lsls	r2, r2, #3
   13378:	4690      	mov	r8, r2
   1337a:	2208      	movs	r2, #8
   1337c:	4691      	mov	r9, r2
   1337e:	4662      	mov	r2, ip
   13380:	4649      	mov	r1, r9
   13382:	438a      	bics	r2, r1
   13384:	4694      	mov	ip, r2
   13386:	4642      	mov	r2, r8
   13388:	4661      	mov	r1, ip
   1338a:	430a      	orrs	r2, r1
   1338c:	4694      	mov	ip, r2
   1338e:	4003      	ands	r3, r0
   13390:	011b      	lsls	r3, r3, #4
   13392:	2210      	movs	r2, #16
   13394:	4690      	mov	r8, r2
   13396:	4662      	mov	r2, ip
   13398:	4641      	mov	r1, r8
   1339a:	438a      	bics	r2, r1
   1339c:	4313      	orrs	r3, r2
   1339e:	4659      	mov	r1, fp
   133a0:	4001      	ands	r1, r0
   133a2:	0149      	lsls	r1, r1, #5
   133a4:	2220      	movs	r2, #32
   133a6:	4393      	bics	r3, r2
   133a8:	430b      	orrs	r3, r1
   133aa:	9a01      	ldr	r2, [sp, #4]
   133ac:	4002      	ands	r2, r0
   133ae:	0192      	lsls	r2, r2, #6
   133b0:	2140      	movs	r1, #64	; 0x40
   133b2:	438b      	bics	r3, r1
   133b4:	4313      	orrs	r3, r2
   133b6:	4007      	ands	r7, r0
   133b8:	01ff      	lsls	r7, r7, #7
   133ba:	2280      	movs	r2, #128	; 0x80
   133bc:	4393      	bics	r3, r2
   133be:	433b      	orrs	r3, r7
   133c0:	3a79      	subs	r2, #121	; 0x79
   133c2:	4015      	ands	r5, r2
   133c4:	022d      	lsls	r5, r5, #8
   133c6:	4f0a      	ldr	r7, [pc, #40]	; (133f0 <system_clock_source_xosc32k_set_config+0xd0>)
   133c8:	403b      	ands	r3, r7
   133ca:	432b      	orrs	r3, r5
   133cc:	4004      	ands	r4, r0
   133ce:	0320      	lsls	r0, r4, #12
   133d0:	4c08      	ldr	r4, [pc, #32]	; (133f4 <system_clock_source_xosc32k_set_config+0xd4>)
   133d2:	401c      	ands	r4, r3
   133d4:	4304      	orrs	r4, r0
   133d6:	82b4      	strh	r4, [r6, #20]
}
   133d8:	b003      	add	sp, #12
   133da:	bc3c      	pop	{r2, r3, r4, r5}
   133dc:	4690      	mov	r8, r2
   133de:	4699      	mov	r9, r3
   133e0:	46a2      	mov	sl, r4
   133e2:	46ab      	mov	fp, r5
   133e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   133e6:	46c0      	nop			; (mov r8, r8)
   133e8:	40000800 	.word	0x40000800
   133ec:	20001324 	.word	0x20001324
   133f0:	fffff8ff 	.word	0xfffff8ff
   133f4:	ffffefff 	.word	0xffffefff

000133f8 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
   133f8:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   133fa:	7a03      	ldrb	r3, [r0, #8]
   133fc:	069b      	lsls	r3, r3, #26
   133fe:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
   13400:	8943      	ldrh	r3, [r0, #10]
   13402:	059b      	lsls	r3, r3, #22
   13404:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
   13406:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
   13408:	4c19      	ldr	r4, [pc, #100]	; (13470 <system_clock_source_dfll_set_config+0x78>)
   1340a:	6063      	str	r3, [r4, #4]
   1340c:	8881      	ldrh	r1, [r0, #4]
   1340e:	8843      	ldrh	r3, [r0, #2]
   13410:	4319      	orrs	r1, r3
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
   13412:	79c3      	ldrb	r3, [r0, #7]
   13414:	7982      	ldrb	r2, [r0, #6]
   13416:	4313      	orrs	r3, r2
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
   13418:	430b      	orrs	r3, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
   1341a:	7842      	ldrb	r2, [r0, #1]
   1341c:	01d2      	lsls	r2, r2, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
   1341e:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
   13420:	6023      	str	r3, [r4, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
   13422:	7803      	ldrb	r3, [r0, #0]
   13424:	2b04      	cmp	r3, #4
   13426:	d10f      	bne.n	13448 <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   13428:	7b03      	ldrb	r3, [r0, #12]
   1342a:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   1342c:	8a02      	ldrh	r2, [r0, #16]
   1342e:	4313      	orrs	r3, r2
   13430:	1c19      	adds	r1, r3, #0

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   13432:	89c3      	ldrh	r3, [r0, #14]
   13434:	041b      	lsls	r3, r3, #16
   13436:	4a0f      	ldr	r2, [pc, #60]	; (13474 <system_clock_source_dfll_set_config+0x7c>)
   13438:	4013      	ands	r3, r2
   1343a:	430b      	orrs	r3, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
   1343c:	60a3      	str	r3, [r4, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
   1343e:	6821      	ldr	r1, [r4, #0]
   13440:	2304      	movs	r3, #4
   13442:	430b      	orrs	r3, r1
   13444:	6023      	str	r3, [r4, #0]
   13446:	e011      	b.n	1346c <system_clock_source_dfll_set_config+0x74>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
   13448:	2b20      	cmp	r3, #32
   1344a:	d10f      	bne.n	1346c <system_clock_source_dfll_set_config+0x74>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
   1344c:	7b03      	ldrb	r3, [r0, #12]
   1344e:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
   13450:	8a02      	ldrh	r2, [r0, #16]
   13452:	4313      	orrs	r3, r2
   13454:	1c19      	adds	r1, r3, #0
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
   13456:	89c3      	ldrh	r3, [r0, #14]
   13458:	041b      	lsls	r3, r3, #16
   1345a:	4a06      	ldr	r2, [pc, #24]	; (13474 <system_clock_source_dfll_set_config+0x7c>)
   1345c:	4013      	ands	r3, r2
   1345e:	430b      	orrs	r3, r1
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
   13460:	4a03      	ldr	r2, [pc, #12]	; (13470 <system_clock_source_dfll_set_config+0x78>)
   13462:	6093      	str	r3, [r2, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
   13464:	6813      	ldr	r3, [r2, #0]
   13466:	4904      	ldr	r1, [pc, #16]	; (13478 <system_clock_source_dfll_set_config+0x80>)
   13468:	430b      	orrs	r3, r1
   1346a:	6013      	str	r3, [r2, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
   1346c:	bd10      	pop	{r4, pc}
   1346e:	46c0      	nop			; (mov r8, r8)
   13470:	20001324 	.word	0x20001324
   13474:	03ff0000 	.word	0x03ff0000
   13478:	00000424 	.word	0x00000424

0001347c <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
   1347c:	2808      	cmp	r0, #8
   1347e:	d803      	bhi.n	13488 <system_clock_source_enable+0xc>
   13480:	0080      	lsls	r0, r0, #2
   13482:	4b25      	ldr	r3, [pc, #148]	; (13518 <system_clock_source_enable+0x9c>)
   13484:	581b      	ldr	r3, [r3, r0]
   13486:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   13488:	2017      	movs	r0, #23
   1348a:	e044      	b.n	13516 <system_clock_source_enable+0x9a>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
   1348c:	4a23      	ldr	r2, [pc, #140]	; (1351c <system_clock_source_enable+0xa0>)
   1348e:	6a11      	ldr	r1, [r2, #32]
   13490:	2302      	movs	r3, #2
   13492:	430b      	orrs	r3, r1
   13494:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
   13496:	2000      	movs	r0, #0
   13498:	e03d      	b.n	13516 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
   1349a:	4a20      	ldr	r2, [pc, #128]	; (1351c <system_clock_source_enable+0xa0>)
   1349c:	6991      	ldr	r1, [r2, #24]
   1349e:	2302      	movs	r3, #2
   134a0:	430b      	orrs	r3, r1
   134a2:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   134a4:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
   134a6:	e036      	b.n	13516 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
   134a8:	4a1c      	ldr	r2, [pc, #112]	; (1351c <system_clock_source_enable+0xa0>)
   134aa:	8a11      	ldrh	r1, [r2, #16]
   134ac:	2302      	movs	r3, #2
   134ae:	430b      	orrs	r3, r1
   134b0:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   134b2:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
   134b4:	e02f      	b.n	13516 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
   134b6:	4a19      	ldr	r2, [pc, #100]	; (1351c <system_clock_source_enable+0xa0>)
   134b8:	8a91      	ldrh	r1, [r2, #20]
   134ba:	2302      	movs	r3, #2
   134bc:	430b      	orrs	r3, r1
   134be:	8293      	strh	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   134c0:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
   134c2:	e028      	b.n	13516 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   134c4:	4916      	ldr	r1, [pc, #88]	; (13520 <system_clock_source_enable+0xa4>)
   134c6:	680b      	ldr	r3, [r1, #0]
   134c8:	2202      	movs	r2, #2
   134ca:	4313      	orrs	r3, r2
   134cc:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
   134ce:	4b13      	ldr	r3, [pc, #76]	; (1351c <system_clock_source_enable+0xa0>)
   134d0:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   134d2:	1c19      	adds	r1, r3, #0
   134d4:	320e      	adds	r2, #14
   134d6:	68cb      	ldr	r3, [r1, #12]
   134d8:	421a      	tst	r2, r3
   134da:	d0fc      	beq.n	134d6 <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
   134dc:	4a10      	ldr	r2, [pc, #64]	; (13520 <system_clock_source_enable+0xa4>)
   134de:	6891      	ldr	r1, [r2, #8]
   134e0:	4b0e      	ldr	r3, [pc, #56]	; (1351c <system_clock_source_enable+0xa0>)
   134e2:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
   134e4:	6852      	ldr	r2, [r2, #4]
   134e6:	629a      	str	r2, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
   134e8:	2200      	movs	r2, #0
   134ea:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   134ec:	1c19      	adds	r1, r3, #0
   134ee:	3210      	adds	r2, #16
   134f0:	68cb      	ldr	r3, [r1, #12]
   134f2:	421a      	tst	r2, r3
   134f4:	d0fc      	beq.n	134f0 <system_clock_source_enable+0x74>
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
   134f6:	4b0a      	ldr	r3, [pc, #40]	; (13520 <system_clock_source_enable+0xa4>)
   134f8:	681b      	ldr	r3, [r3, #0]
   134fa:	b29b      	uxth	r3, r3
   134fc:	4a07      	ldr	r2, [pc, #28]	; (1351c <system_clock_source_enable+0xa0>)
   134fe:	8493      	strh	r3, [r2, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   13500:	2000      	movs	r0, #0
   13502:	e008      	b.n	13516 <system_clock_source_enable+0x9a>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
   13504:	4905      	ldr	r1, [pc, #20]	; (1351c <system_clock_source_enable+0xa0>)
   13506:	2244      	movs	r2, #68	; 0x44
   13508:	5c88      	ldrb	r0, [r1, r2]
   1350a:	2302      	movs	r3, #2
   1350c:	4303      	orrs	r3, r0
   1350e:	548b      	strb	r3, [r1, r2]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
   13510:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
   13512:	e000      	b.n	13516 <system_clock_source_enable+0x9a>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
   13514:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
   13516:	4770      	bx	lr
   13518:	00021250 	.word	0x00021250
   1351c:	40000800 	.word	0x40000800
   13520:	20001324 	.word	0x20001324

00013524 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
   13524:	b5f0      	push	{r4, r5, r6, r7, lr}
   13526:	464f      	mov	r7, r9
   13528:	4646      	mov	r6, r8
   1352a:	b4c0      	push	{r6, r7}
   1352c:	b091      	sub	sp, #68	; 0x44
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
   1352e:	22c2      	movs	r2, #194	; 0xc2
   13530:	00d2      	lsls	r2, r2, #3
   13532:	4b60      	ldr	r3, [pc, #384]	; (136b4 <system_clock_init+0x190>)
   13534:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
   13536:	4960      	ldr	r1, [pc, #384]	; (136b8 <system_clock_init+0x194>)
   13538:	684b      	ldr	r3, [r1, #4]
   1353a:	221e      	movs	r2, #30
   1353c:	4393      	bics	r3, r2
   1353e:	3a1a      	subs	r2, #26
   13540:	4313      	orrs	r3, r2
   13542:	604b      	str	r3, [r1, #4]
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
#elif CONF_CLOCK_GCLK_3_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_3;
#elif CONF_CLOCK_GCLK_4_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_4;
   13544:	ab01      	add	r3, sp, #4
   13546:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   13548:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
   1354a:	4d5c      	ldr	r5, [pc, #368]	; (136bc <system_clock_init+0x198>)
   1354c:	b2e0      	uxtb	r0, r4
   1354e:	a901      	add	r1, sp, #4
   13550:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   13552:	3401      	adds	r4, #1
   13554:	2c25      	cmp	r4, #37	; 0x25
   13556:	d1f9      	bne.n	1354c <system_clock_init+0x28>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
   13558:	a80c      	add	r0, sp, #48	; 0x30
   1355a:	2300      	movs	r3, #0
   1355c:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
   1355e:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
   13560:	2280      	movs	r2, #128	; 0x80
   13562:	0212      	lsls	r2, r2, #8
   13564:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
   13566:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
   13568:	2201      	movs	r2, #1
   1356a:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
   1356c:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
   1356e:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
   13570:	3202      	adds	r2, #2
   13572:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
   13574:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
   13576:	4b52      	ldr	r3, [pc, #328]	; (136c0 <system_clock_init+0x19c>)
   13578:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
   1357a:	2005      	movs	r0, #5
   1357c:	4b51      	ldr	r3, [pc, #324]	; (136c4 <system_clock_init+0x1a0>)
   1357e:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
   13580:	494c      	ldr	r1, [pc, #304]	; (136b4 <system_clock_init+0x190>)
   13582:	2202      	movs	r2, #2
   13584:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
   13586:	421a      	tst	r2, r3
   13588:	d0fc      	beq.n	13584 <system_clock_init+0x60>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
   1358a:	494a      	ldr	r1, [pc, #296]	; (136b4 <system_clock_init+0x190>)
   1358c:	8a8a      	ldrh	r2, [r1, #20]
   1358e:	2380      	movs	r3, #128	; 0x80
   13590:	4313      	orrs	r3, r2
   13592:	828b      	strh	r3, [r1, #20]


	/* OSCK32K */
#if CONF_CLOCK_OSC32K_ENABLE == true
	SYSCTRL->OSC32K.bit.CALIB =
			((*(uint32_t *)SYSCTRL_FUSES_OSC32K_ADDR >> 
   13594:	4c4c      	ldr	r4, [pc, #304]	; (136c8 <system_clock_init+0x1a4>)
#endif


	/* OSCK32K */
#if CONF_CLOCK_OSC32K_ENABLE == true
	SYSCTRL->OSC32K.bit.CALIB =
   13596:	6823      	ldr	r3, [r4, #0]
   13598:	04db      	lsls	r3, r3, #19
   1359a:	0e5b      	lsrs	r3, r3, #25
   1359c:	041a      	lsls	r2, r3, #16
   1359e:	6988      	ldr	r0, [r1, #24]
   135a0:	4b4a      	ldr	r3, [pc, #296]	; (136cc <system_clock_init+0x1a8>)
   135a2:	4003      	ands	r3, r0
   135a4:	4313      	orrs	r3, r2
   135a6:	618b      	str	r3, [r1, #24]
static inline void system_clock_source_osc32k_get_config_defaults(
		struct system_clock_source_osc32k_config *const config)
{
	Assert(config);

	config->enable_1khz_output  = true;
   135a8:	a80a      	add	r0, sp, #40	; 0x28
   135aa:	2301      	movs	r3, #1
   135ac:	7043      	strb	r3, [r0, #1]
	config->enable_32khz_output = true;
   135ae:	7083      	strb	r3, [r0, #2]
	config->run_in_standby      = false;
	config->on_demand           = true;
   135b0:	7103      	strb	r3, [r0, #4]
	config->startup_time        = SYSTEM_OSC32K_STARTUP_130;
   135b2:	2207      	movs	r2, #7
   135b4:	7002      	strb	r2, [r0, #0]
	config->write_once          = false;
   135b6:	2500      	movs	r5, #0
   135b8:	7145      	strb	r5, [r0, #5]

	osc32k_conf.startup_time        = CONF_CLOCK_OSC32K_STARTUP_TIME;
	osc32k_conf.enable_1khz_output  = CONF_CLOCK_OSC32K_ENABLE_1KHZ_OUTPUT;
	osc32k_conf.enable_32khz_output = CONF_CLOCK_OSC32K_ENABLE_32KHZ_OUTPUT;
	osc32k_conf.on_demand           = CONF_CLOCK_OSC32K_ON_DEMAND;
	osc32k_conf.run_in_standby      = CONF_CLOCK_OSC32K_RUN_IN_STANDBY;
   135ba:	70c3      	strb	r3, [r0, #3]

	system_clock_source_osc32k_set_config(&osc32k_conf);
   135bc:	4b44      	ldr	r3, [pc, #272]	; (136d0 <system_clock_init+0x1ac>)
   135be:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC32K);
   135c0:	2004      	movs	r0, #4
   135c2:	4b40      	ldr	r3, [pc, #256]	; (136c4 <system_clock_init+0x1a0>)
   135c4:	4798      	blx	r3
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
   135c6:	ab05      	add	r3, sp, #20
   135c8:	2200      	movs	r2, #0
   135ca:	805d      	strh	r5, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
   135cc:	809d      	strh	r5, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
   135ce:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
   135d0:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
   135d2:	213f      	movs	r1, #63	; 0x3f
   135d4:	8159      	strh	r1, [r3, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
   135d6:	393b      	subs	r1, #59	; 0x3b
   135d8:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
   135da:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
   135dc:	6823      	ldr	r3, [r4, #0]
   135de:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
   135e0:	2b3f      	cmp	r3, #63	; 0x3f
   135e2:	d100      	bne.n	135e6 <system_clock_init+0xc2>
		coarse = 0x1f;
   135e4:	3b20      	subs	r3, #32
	}
	dfll_conf.coarse_value = coarse;
   135e6:	a805      	add	r0, sp, #20
   135e8:	7203      	strb	r3, [r0, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
   135ea:	4b3a      	ldr	r3, [pc, #232]	; (136d4 <system_clock_init+0x1b0>)
   135ec:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
   135ee:	2307      	movs	r3, #7
   135f0:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
   135f2:	3338      	adds	r3, #56	; 0x38
   135f4:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
   135f6:	4b38      	ldr	r3, [pc, #224]	; (136d8 <system_clock_init+0x1b4>)
   135f8:	4798      	blx	r3
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
	config->on_demand       = true;
   135fa:	a804      	add	r0, sp, #16
   135fc:	2601      	movs	r6, #1
   135fe:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
   13600:	2500      	movs	r5, #0
   13602:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
   13604:	7046      	strb	r6, [r0, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
   13606:	4b35      	ldr	r3, [pc, #212]	; (136dc <system_clock_init+0x1b8>)
   13608:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
   1360a:	2006      	movs	r0, #6
   1360c:	4b2d      	ldr	r3, [pc, #180]	; (136c4 <system_clock_init+0x1a0>)
   1360e:	4699      	mov	r9, r3
   13610:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
   13612:	4b33      	ldr	r3, [pc, #204]	; (136e0 <system_clock_init+0x1bc>)
   13614:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
   13616:	ac01      	add	r4, sp, #4
   13618:	6066      	str	r6, [r4, #4]
	config->high_when_disabled = false;
   1361a:	7065      	strb	r5, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
   1361c:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
   1361e:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
   13620:	2305      	movs	r3, #5
   13622:	7023      	strb	r3, [r4, #0]
   13624:	2001      	movs	r0, #1
   13626:	1c21      	adds	r1, r4, #0
   13628:	4b2e      	ldr	r3, [pc, #184]	; (136e4 <system_clock_init+0x1c0>)
   1362a:	4698      	mov	r8, r3
   1362c:	4798      	blx	r3
   1362e:	2001      	movs	r0, #1
   13630:	4f2d      	ldr	r7, [pc, #180]	; (136e8 <system_clock_init+0x1c4>)
   13632:	47b8      	blx	r7
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
   13634:	6066      	str	r6, [r4, #4]
	config->high_when_disabled = false;
   13636:	7065      	strb	r5, [r4, #1]
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
	config->output_enable      = false;
   13638:	7265      	strb	r5, [r4, #9]
   1363a:	2304      	movs	r3, #4
   1363c:	7023      	strb	r3, [r4, #0]
   1363e:	7226      	strb	r6, [r4, #8]
   13640:	2002      	movs	r0, #2
   13642:	1c21      	adds	r1, r4, #0
   13644:	47c0      	blx	r8
   13646:	2002      	movs	r0, #2
   13648:	47b8      	blx	r7
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
	config->high_when_disabled = false;
   1364a:	7065      	strb	r5, [r4, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
   1364c:	2306      	movs	r3, #6
   1364e:	7023      	strb	r3, [r4, #0]
#endif
	config->run_in_standby     = false;
   13650:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
   13652:	7265      	strb	r5, [r4, #9]
   13654:	3b04      	subs	r3, #4
   13656:	6063      	str	r3, [r4, #4]
   13658:	2003      	movs	r0, #3
   1365a:	1c21      	adds	r1, r4, #0
   1365c:	47c0      	blx	r8
   1365e:	2003      	movs	r0, #3
   13660:	47b8      	blx	r7
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
   13662:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
   13664:	2000      	movs	r0, #0
   13666:	1c21      	adds	r1, r4, #0
   13668:	4b14      	ldr	r3, [pc, #80]	; (136bc <system_clock_init+0x198>)
   1366a:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
   1366c:	2000      	movs	r0, #0
   1366e:	4b1f      	ldr	r3, [pc, #124]	; (136ec <system_clock_init+0x1c8>)
   13670:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
   13672:	2007      	movs	r0, #7
   13674:	47c8      	blx	r9

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
   13676:	490f      	ldr	r1, [pc, #60]	; (136b4 <system_clock_init+0x190>)
   13678:	22d0      	movs	r2, #208	; 0xd0
   1367a:	68cb      	ldr	r3, [r1, #12]
   1367c:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
   1367e:	2bd0      	cmp	r3, #208	; 0xd0
   13680:	d1fb      	bne.n	1367a <system_clock_init+0x156>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
   13682:	4a1b      	ldr	r2, [pc, #108]	; (136f0 <system_clock_init+0x1cc>)
   13684:	2300      	movs	r3, #0
   13686:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
   13688:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
   1368a:	7293      	strb	r3, [r2, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
   1368c:	72d3      	strb	r3, [r2, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
   1368e:	a901      	add	r1, sp, #4
   13690:	2201      	movs	r2, #1
   13692:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
   13694:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
   13696:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
   13698:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
   1369a:	3307      	adds	r3, #7
   1369c:	700b      	strb	r3, [r1, #0]
   1369e:	2000      	movs	r0, #0
   136a0:	4b10      	ldr	r3, [pc, #64]	; (136e4 <system_clock_init+0x1c0>)
   136a2:	4798      	blx	r3
   136a4:	2000      	movs	r0, #0
   136a6:	4b10      	ldr	r3, [pc, #64]	; (136e8 <system_clock_init+0x1c4>)
   136a8:	4798      	blx	r3
#endif
}
   136aa:	b011      	add	sp, #68	; 0x44
   136ac:	bc0c      	pop	{r2, r3}
   136ae:	4690      	mov	r8, r2
   136b0:	4699      	mov	r9, r3
   136b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   136b4:	40000800 	.word	0x40000800
   136b8:	41004000 	.word	0x41004000
   136bc:	0001392d 	.word	0x0001392d
   136c0:	00013321 	.word	0x00013321
   136c4:	0001347d 	.word	0x0001347d
   136c8:	00806024 	.word	0x00806024
   136cc:	ff80ffff 	.word	0xff80ffff
   136d0:	00013299 	.word	0x00013299
   136d4:	000005b9 	.word	0x000005b9
   136d8:	000133f9 	.word	0x000133f9
   136dc:	0001325d 	.word	0x0001325d
   136e0:	000136f5 	.word	0x000136f5
   136e4:	00013719 	.word	0x00013719
   136e8:	000137d1 	.word	0x000137d1
   136ec:	000138a1 	.word	0x000138a1
   136f0:	40000400 	.word	0x40000400

000136f4 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
   136f4:	4a06      	ldr	r2, [pc, #24]	; (13710 <system_gclk_init+0x1c>)
   136f6:	6991      	ldr	r1, [r2, #24]
   136f8:	2308      	movs	r3, #8
   136fa:	430b      	orrs	r3, r1
   136fc:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
   136fe:	2201      	movs	r2, #1
   13700:	4b04      	ldr	r3, [pc, #16]	; (13714 <system_gclk_init+0x20>)
   13702:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
   13704:	1c19      	adds	r1, r3, #0
   13706:	780b      	ldrb	r3, [r1, #0]
   13708:	4213      	tst	r3, r2
   1370a:	d1fc      	bne.n	13706 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
   1370c:	4770      	bx	lr
   1370e:	46c0      	nop			; (mov r8, r8)
   13710:	40000400 	.word	0x40000400
   13714:	40000c00 	.word	0x40000c00

00013718 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
   13718:	b570      	push	{r4, r5, r6, lr}
   1371a:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
   1371c:	1c04      	adds	r4, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   1371e:	780d      	ldrb	r5, [r1, #0]
   13720:	022d      	lsls	r5, r5, #8
   13722:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
   13724:	784b      	ldrb	r3, [r1, #1]
   13726:	2b00      	cmp	r3, #0
   13728:	d002      	beq.n	13730 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
   1372a:	2380      	movs	r3, #128	; 0x80
   1372c:	02db      	lsls	r3, r3, #11
   1372e:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
   13730:	7a4b      	ldrb	r3, [r1, #9]
   13732:	2b00      	cmp	r3, #0
   13734:	d002      	beq.n	1373c <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
   13736:	2380      	movs	r3, #128	; 0x80
   13738:	031b      	lsls	r3, r3, #12
   1373a:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
   1373c:	6848      	ldr	r0, [r1, #4]
   1373e:	2801      	cmp	r0, #1
   13740:	d918      	bls.n	13774 <system_gclk_gen_set_config+0x5c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
   13742:	1e43      	subs	r3, r0, #1
   13744:	4218      	tst	r0, r3
   13746:	d110      	bne.n	1376a <system_gclk_gen_set_config+0x52>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   13748:	2802      	cmp	r0, #2
   1374a:	d906      	bls.n	1375a <system_gclk_gen_set_config+0x42>
   1374c:	2302      	movs	r3, #2
   1374e:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
   13750:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
   13752:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
   13754:	4298      	cmp	r0, r3
   13756:	d8fb      	bhi.n	13750 <system_gclk_gen_set_config+0x38>
   13758:	e000      	b.n	1375c <system_gclk_gen_set_config+0x44>
   1375a:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
   1375c:	0212      	lsls	r2, r2, #8
   1375e:	4332      	orrs	r2, r6
   13760:	1c14      	adds	r4, r2, #0
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
   13762:	2380      	movs	r3, #128	; 0x80
   13764:	035b      	lsls	r3, r3, #13
   13766:	431d      	orrs	r5, r3
   13768:	e004      	b.n	13774 <system_gclk_gen_set_config+0x5c>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
   1376a:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
   1376c:	4334      	orrs	r4, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   1376e:	2380      	movs	r3, #128	; 0x80
   13770:	029b      	lsls	r3, r3, #10
   13772:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
   13774:	7a0b      	ldrb	r3, [r1, #8]
   13776:	2b00      	cmp	r3, #0
   13778:	d002      	beq.n	13780 <system_gclk_gen_set_config+0x68>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
   1377a:	2380      	movs	r3, #128	; 0x80
   1377c:	039b      	lsls	r3, r3, #14
   1377e:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   13780:	4a0f      	ldr	r2, [pc, #60]	; (137c0 <system_gclk_gen_set_config+0xa8>)
   13782:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
   13784:	b25b      	sxtb	r3, r3
   13786:	2b00      	cmp	r3, #0
   13788:	dbfb      	blt.n	13782 <system_gclk_gen_set_config+0x6a>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   1378a:	4b0e      	ldr	r3, [pc, #56]	; (137c4 <system_gclk_gen_set_config+0xac>)
   1378c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   1378e:	4b0e      	ldr	r3, [pc, #56]	; (137c8 <system_gclk_gen_set_config+0xb0>)
   13790:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   13792:	4a0b      	ldr	r2, [pc, #44]	; (137c0 <system_gclk_gen_set_config+0xa8>)
   13794:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
   13796:	b25b      	sxtb	r3, r3
   13798:	2b00      	cmp	r3, #0
   1379a:	dbfb      	blt.n	13794 <system_gclk_gen_set_config+0x7c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
   1379c:	4b08      	ldr	r3, [pc, #32]	; (137c0 <system_gclk_gen_set_config+0xa8>)
   1379e:	609c      	str	r4, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   137a0:	1c1a      	adds	r2, r3, #0
   137a2:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
   137a4:	b25b      	sxtb	r3, r3
   137a6:	2b00      	cmp	r3, #0
   137a8:	dbfb      	blt.n	137a2 <system_gclk_gen_set_config+0x8a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
   137aa:	4a05      	ldr	r2, [pc, #20]	; (137c0 <system_gclk_gen_set_config+0xa8>)
   137ac:	6851      	ldr	r1, [r2, #4]
   137ae:	2380      	movs	r3, #128	; 0x80
   137b0:	025b      	lsls	r3, r3, #9
   137b2:	400b      	ands	r3, r1
   137b4:	431d      	orrs	r5, r3
   137b6:	6055      	str	r5, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   137b8:	4b04      	ldr	r3, [pc, #16]	; (137cc <system_gclk_gen_set_config+0xb4>)
   137ba:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   137bc:	bd70      	pop	{r4, r5, r6, pc}
   137be:	46c0      	nop			; (mov r8, r8)
   137c0:	40000c00 	.word	0x40000c00
   137c4:	00013101 	.word	0x00013101
   137c8:	40000c08 	.word	0x40000c08
   137cc:	00013141 	.word	0x00013141

000137d0 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
   137d0:	b510      	push	{r4, lr}
   137d2:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   137d4:	4a0b      	ldr	r2, [pc, #44]	; (13804 <system_gclk_gen_enable+0x34>)
   137d6:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
   137d8:	b25b      	sxtb	r3, r3
   137da:	2b00      	cmp	r3, #0
   137dc:	dbfb      	blt.n	137d6 <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   137de:	4b0a      	ldr	r3, [pc, #40]	; (13808 <system_gclk_gen_enable+0x38>)
   137e0:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   137e2:	4b0a      	ldr	r3, [pc, #40]	; (1380c <system_gclk_gen_enable+0x3c>)
   137e4:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   137e6:	4a07      	ldr	r2, [pc, #28]	; (13804 <system_gclk_gen_enable+0x34>)
   137e8:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
   137ea:	b25b      	sxtb	r3, r3
   137ec:	2b00      	cmp	r3, #0
   137ee:	dbfb      	blt.n	137e8 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
   137f0:	4a04      	ldr	r2, [pc, #16]	; (13804 <system_gclk_gen_enable+0x34>)
   137f2:	6853      	ldr	r3, [r2, #4]
   137f4:	2180      	movs	r1, #128	; 0x80
   137f6:	0249      	lsls	r1, r1, #9
   137f8:	430b      	orrs	r3, r1
   137fa:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   137fc:	4b04      	ldr	r3, [pc, #16]	; (13810 <system_gclk_gen_enable+0x40>)
   137fe:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   13800:	bd10      	pop	{r4, pc}
   13802:	46c0      	nop			; (mov r8, r8)
   13804:	40000c00 	.word	0x40000c00
   13808:	00013101 	.word	0x00013101
   1380c:	40000c04 	.word	0x40000c04
   13810:	00013141 	.word	0x00013141

00013814 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
   13814:	b570      	push	{r4, r5, r6, lr}
   13816:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   13818:	4a1a      	ldr	r2, [pc, #104]	; (13884 <system_gclk_gen_get_hz+0x70>)
   1381a:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
   1381c:	b25b      	sxtb	r3, r3
   1381e:	2b00      	cmp	r3, #0
   13820:	dbfb      	blt.n	1381a <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   13822:	4b19      	ldr	r3, [pc, #100]	; (13888 <system_gclk_gen_get_hz+0x74>)
   13824:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   13826:	4b19      	ldr	r3, [pc, #100]	; (1388c <system_gclk_gen_get_hz+0x78>)
   13828:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   1382a:	4a16      	ldr	r2, [pc, #88]	; (13884 <system_gclk_gen_get_hz+0x70>)
   1382c:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
   1382e:	b25b      	sxtb	r3, r3
   13830:	2b00      	cmp	r3, #0
   13832:	dbfb      	blt.n	1382c <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
   13834:	4e13      	ldr	r6, [pc, #76]	; (13884 <system_gclk_gen_get_hz+0x70>)
   13836:	6870      	ldr	r0, [r6, #4]
   13838:	04c0      	lsls	r0, r0, #19
   1383a:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
   1383c:	4b14      	ldr	r3, [pc, #80]	; (13890 <system_gclk_gen_get_hz+0x7c>)
   1383e:	4798      	blx	r3
   13840:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   13842:	4b12      	ldr	r3, [pc, #72]	; (1388c <system_gclk_gen_get_hz+0x78>)
   13844:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
   13846:	6876      	ldr	r6, [r6, #4]
   13848:	02f6      	lsls	r6, r6, #11
   1384a:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   1384c:	4b11      	ldr	r3, [pc, #68]	; (13894 <system_gclk_gen_get_hz+0x80>)
   1384e:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   13850:	4a0c      	ldr	r2, [pc, #48]	; (13884 <system_gclk_gen_get_hz+0x70>)
   13852:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
   13854:	b25b      	sxtb	r3, r3
   13856:	2b00      	cmp	r3, #0
   13858:	dbfb      	blt.n	13852 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
   1385a:	4b0a      	ldr	r3, [pc, #40]	; (13884 <system_gclk_gen_get_hz+0x70>)
   1385c:	689c      	ldr	r4, [r3, #8]
   1385e:	0a24      	lsrs	r4, r4, #8
   13860:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   13862:	4b0d      	ldr	r3, [pc, #52]	; (13898 <system_gclk_gen_get_hz+0x84>)
   13864:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
   13866:	2e00      	cmp	r6, #0
   13868:	d107      	bne.n	1387a <system_gclk_gen_get_hz+0x66>
   1386a:	2c01      	cmp	r4, #1
   1386c:	d907      	bls.n	1387e <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
   1386e:	1c28      	adds	r0, r5, #0
   13870:	1c21      	adds	r1, r4, #0
   13872:	4b0a      	ldr	r3, [pc, #40]	; (1389c <system_gclk_gen_get_hz+0x88>)
   13874:	4798      	blx	r3
   13876:	1c05      	adds	r5, r0, #0
   13878:	e001      	b.n	1387e <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
   1387a:	3401      	adds	r4, #1
   1387c:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
   1387e:	1c28      	adds	r0, r5, #0
   13880:	bd70      	pop	{r4, r5, r6, pc}
   13882:	46c0      	nop			; (mov r8, r8)
   13884:	40000c00 	.word	0x40000c00
   13888:	00013101 	.word	0x00013101
   1388c:	40000c04 	.word	0x40000c04
   13890:	000131cd 	.word	0x000131cd
   13894:	40000c08 	.word	0x40000c08
   13898:	00013141 	.word	0x00013141
   1389c:	00014e9d 	.word	0x00014e9d

000138a0 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
   138a0:	b510      	push	{r4, lr}
   138a2:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   138a4:	4b06      	ldr	r3, [pc, #24]	; (138c0 <system_gclk_chan_enable+0x20>)
   138a6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   138a8:	4b06      	ldr	r3, [pc, #24]	; (138c4 <system_gclk_chan_enable+0x24>)
   138aa:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
   138ac:	4a06      	ldr	r2, [pc, #24]	; (138c8 <system_gclk_chan_enable+0x28>)
   138ae:	8851      	ldrh	r1, [r2, #2]
   138b0:	2380      	movs	r3, #128	; 0x80
   138b2:	01db      	lsls	r3, r3, #7
   138b4:	430b      	orrs	r3, r1
   138b6:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   138b8:	4b04      	ldr	r3, [pc, #16]	; (138cc <system_gclk_chan_enable+0x2c>)
   138ba:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   138bc:	bd10      	pop	{r4, pc}
   138be:	46c0      	nop			; (mov r8, r8)
   138c0:	00013101 	.word	0x00013101
   138c4:	40000c02 	.word	0x40000c02
   138c8:	40000c00 	.word	0x40000c00
   138cc:	00013141 	.word	0x00013141

000138d0 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
   138d0:	b510      	push	{r4, lr}
   138d2:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   138d4:	4b0f      	ldr	r3, [pc, #60]	; (13914 <system_gclk_chan_disable+0x44>)
   138d6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   138d8:	4b0f      	ldr	r3, [pc, #60]	; (13918 <system_gclk_chan_disable+0x48>)
   138da:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   138dc:	4b0f      	ldr	r3, [pc, #60]	; (1391c <system_gclk_chan_disable+0x4c>)
   138de:	885a      	ldrh	r2, [r3, #2]
   138e0:	0512      	lsls	r2, r2, #20
   138e2:	0f10      	lsrs	r0, r2, #28
	GCLK->CLKCTRL.bit.GEN = 0;
   138e4:	8859      	ldrh	r1, [r3, #2]
   138e6:	4a0e      	ldr	r2, [pc, #56]	; (13920 <system_gclk_chan_disable+0x50>)
   138e8:	400a      	ands	r2, r1
   138ea:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   138ec:	8859      	ldrh	r1, [r3, #2]
   138ee:	4a0d      	ldr	r2, [pc, #52]	; (13924 <system_gclk_chan_disable+0x54>)
   138f0:	400a      	ands	r2, r1
   138f2:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
   138f4:	1c19      	adds	r1, r3, #0
   138f6:	2280      	movs	r2, #128	; 0x80
   138f8:	01d2      	lsls	r2, r2, #7
   138fa:	884b      	ldrh	r3, [r1, #2]
   138fc:	4213      	tst	r3, r2
   138fe:	d1fc      	bne.n	138fa <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
   13900:	4906      	ldr	r1, [pc, #24]	; (1391c <system_gclk_chan_disable+0x4c>)
   13902:	0202      	lsls	r2, r0, #8
   13904:	8848      	ldrh	r0, [r1, #2]
   13906:	4b06      	ldr	r3, [pc, #24]	; (13920 <system_gclk_chan_disable+0x50>)
   13908:	4003      	ands	r3, r0
   1390a:	4313      	orrs	r3, r2
   1390c:	804b      	strh	r3, [r1, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   1390e:	4b06      	ldr	r3, [pc, #24]	; (13928 <system_gclk_chan_disable+0x58>)
   13910:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   13912:	bd10      	pop	{r4, pc}
   13914:	00013101 	.word	0x00013101
   13918:	40000c02 	.word	0x40000c02
   1391c:	40000c00 	.word	0x40000c00
   13920:	fffff0ff 	.word	0xfffff0ff
   13924:	ffffbfff 	.word	0xffffbfff
   13928:	00013141 	.word	0x00013141

0001392c <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
   1392c:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
   1392e:	780c      	ldrb	r4, [r1, #0]
   13930:	0224      	lsls	r4, r4, #8
   13932:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
   13934:	4b02      	ldr	r3, [pc, #8]	; (13940 <system_gclk_chan_set_config+0x14>)
   13936:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
   13938:	b2a4      	uxth	r4, r4
   1393a:	4b02      	ldr	r3, [pc, #8]	; (13944 <system_gclk_chan_set_config+0x18>)
   1393c:	805c      	strh	r4, [r3, #2]
}
   1393e:	bd10      	pop	{r4, pc}
   13940:	000138d1 	.word	0x000138d1
   13944:	40000c00 	.word	0x40000c00

00013948 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
   13948:	b510      	push	{r4, lr}
   1394a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   1394c:	4b06      	ldr	r3, [pc, #24]	; (13968 <system_gclk_chan_get_hz+0x20>)
   1394e:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   13950:	4b06      	ldr	r3, [pc, #24]	; (1396c <system_gclk_chan_get_hz+0x24>)
   13952:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
   13954:	4b06      	ldr	r3, [pc, #24]	; (13970 <system_gclk_chan_get_hz+0x28>)
   13956:	885c      	ldrh	r4, [r3, #2]
   13958:	0524      	lsls	r4, r4, #20
   1395a:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   1395c:	4b05      	ldr	r3, [pc, #20]	; (13974 <system_gclk_chan_get_hz+0x2c>)
   1395e:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
   13960:	1c20      	adds	r0, r4, #0
   13962:	4b05      	ldr	r3, [pc, #20]	; (13978 <system_gclk_chan_get_hz+0x30>)
   13964:	4798      	blx	r3
}
   13966:	bd10      	pop	{r4, pc}
   13968:	00013101 	.word	0x00013101
   1396c:	40000c02 	.word	0x40000c02
   13970:	40000c00 	.word	0x40000c00
   13974:	00013141 	.word	0x00013141
   13978:	00013815 	.word	0x00013815

0001397c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
   1397c:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
   1397e:	78d3      	ldrb	r3, [r2, #3]
   13980:	2b00      	cmp	r3, #0
   13982:	d11e      	bne.n	139c2 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
   13984:	7814      	ldrb	r4, [r2, #0]
   13986:	2c80      	cmp	r4, #128	; 0x80
   13988:	d004      	beq.n	13994 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
   1398a:	0624      	lsls	r4, r4, #24
   1398c:	2380      	movs	r3, #128	; 0x80
   1398e:	025b      	lsls	r3, r3, #9
   13990:	431c      	orrs	r4, r3
   13992:	e000      	b.n	13996 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
   13994:	2400      	movs	r4, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   13996:	7853      	ldrb	r3, [r2, #1]
   13998:	2502      	movs	r5, #2
   1399a:	43ab      	bics	r3, r5
   1399c:	d10a      	bne.n	139b4 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
   1399e:	7893      	ldrb	r3, [r2, #2]
   139a0:	2b00      	cmp	r3, #0
   139a2:	d103      	bne.n	139ac <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
   139a4:	2380      	movs	r3, #128	; 0x80
   139a6:	029b      	lsls	r3, r3, #10
   139a8:	431c      	orrs	r4, r3
   139aa:	e002      	b.n	139b2 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
   139ac:	23c0      	movs	r3, #192	; 0xc0
   139ae:	02db      	lsls	r3, r3, #11
   139b0:	431c      	orrs	r4, r3
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
   139b2:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   139b4:	7853      	ldrb	r3, [r2, #1]
   139b6:	3b01      	subs	r3, #1
   139b8:	2b01      	cmp	r3, #1
   139ba:	d812      	bhi.n	139e2 <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
   139bc:	4b18      	ldr	r3, [pc, #96]	; (13a20 <_system_pinmux_config+0xa4>)
   139be:	401c      	ands	r4, r3
   139c0:	e00f      	b.n	139e2 <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
   139c2:	6041      	str	r1, [r0, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
   139c4:	040b      	lsls	r3, r1, #16
   139c6:	0c1b      	lsrs	r3, r3, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   139c8:	24a0      	movs	r4, #160	; 0xa0
   139ca:	05e4      	lsls	r4, r4, #23
   139cc:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   139ce:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
   139d0:	0c0b      	lsrs	r3, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   139d2:	24d0      	movs	r4, #208	; 0xd0
   139d4:	0624      	lsls	r4, r4, #24
   139d6:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   139d8:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
   139da:	78d3      	ldrb	r3, [r2, #3]
   139dc:	2b00      	cmp	r3, #0
   139de:	d018      	beq.n	13a12 <_system_pinmux_config+0x96>
   139e0:	e01c      	b.n	13a1c <_system_pinmux_config+0xa0>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
   139e2:	040b      	lsls	r3, r1, #16
   139e4:	0c1b      	lsrs	r3, r3, #16
   139e6:	25a0      	movs	r5, #160	; 0xa0
   139e8:	05ed      	lsls	r5, r5, #23
   139ea:	432b      	orrs	r3, r5

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   139ec:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   139ee:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
   139f0:	0c0b      	lsrs	r3, r1, #16
   139f2:	25d0      	movs	r5, #208	; 0xd0
   139f4:	062d      	lsls	r5, r5, #24
   139f6:	432b      	orrs	r3, r5

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   139f8:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   139fa:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
   139fc:	78d3      	ldrb	r3, [r2, #3]
   139fe:	2b00      	cmp	r3, #0
   13a00:	d10c      	bne.n	13a1c <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
   13a02:	0363      	lsls	r3, r4, #13
   13a04:	d505      	bpl.n	13a12 <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
   13a06:	7893      	ldrb	r3, [r2, #2]
   13a08:	2b01      	cmp	r3, #1
   13a0a:	d101      	bne.n	13a10 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
   13a0c:	6181      	str	r1, [r0, #24]
   13a0e:	e000      	b.n	13a12 <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
   13a10:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   13a12:	7853      	ldrb	r3, [r2, #1]
   13a14:	3b01      	subs	r3, #1
   13a16:	2b01      	cmp	r3, #1
   13a18:	d800      	bhi.n	13a1c <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
   13a1a:	6081      	str	r1, [r0, #8]
		}
	}
}
   13a1c:	bd30      	pop	{r4, r5, pc}
   13a1e:	46c0      	nop			; (mov r8, r8)
   13a20:	fffbffff 	.word	0xfffbffff

00013a24 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
   13a24:	b508      	push	{r3, lr}
   13a26:	1c03      	adds	r3, r0, #0
   13a28:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   13a2a:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   13a2c:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   13a2e:	2900      	cmp	r1, #0
   13a30:	d104      	bne.n	13a3c <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
   13a32:	0958      	lsrs	r0, r3, #5
   13a34:	01c0      	lsls	r0, r0, #7
   13a36:	4905      	ldr	r1, [pc, #20]	; (13a4c <system_pinmux_pin_set_config+0x28>)
   13a38:	468c      	mov	ip, r1
   13a3a:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
   13a3c:	211f      	movs	r1, #31
   13a3e:	400b      	ands	r3, r1
   13a40:	391e      	subs	r1, #30
   13a42:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
   13a44:	4b02      	ldr	r3, [pc, #8]	; (13a50 <system_pinmux_pin_set_config+0x2c>)
   13a46:	4798      	blx	r3
}
   13a48:	bd08      	pop	{r3, pc}
   13a4a:	46c0      	nop			; (mov r8, r8)
   13a4c:	41004400 	.word	0x41004400
   13a50:	0001397d 	.word	0x0001397d

00013a54 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
   13a54:	4770      	bx	lr
   13a56:	46c0      	nop			; (mov r8, r8)

00013a58 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
   13a58:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
   13a5a:	4b05      	ldr	r3, [pc, #20]	; (13a70 <system_init+0x18>)
   13a5c:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
   13a5e:	4b05      	ldr	r3, [pc, #20]	; (13a74 <system_init+0x1c>)
   13a60:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
   13a62:	4b05      	ldr	r3, [pc, #20]	; (13a78 <system_init+0x20>)
   13a64:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
   13a66:	4b05      	ldr	r3, [pc, #20]	; (13a7c <system_init+0x24>)
   13a68:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
   13a6a:	4b05      	ldr	r3, [pc, #20]	; (13a80 <system_init+0x28>)
   13a6c:	4798      	blx	r3
}
   13a6e:	bd08      	pop	{r3, pc}
   13a70:	00013525 	.word	0x00013525
   13a74:	00013171 	.word	0x00013171
   13a78:	00013a55 	.word	0x00013a55
   13a7c:	0000f269 	.word	0x0000f269
   13a80:	00013a55 	.word	0x00013a55

00013a84 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
   13a84:	e7fe      	b.n	13a84 <Dummy_Handler>
   13a86:	46c0      	nop			; (mov r8, r8)

00013a88 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   13a88:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
   13a8a:	4b2e      	ldr	r3, [pc, #184]	; (13b44 <Reset_Handler+0xbc>)
   13a8c:	4a2e      	ldr	r2, [pc, #184]	; (13b48 <Reset_Handler+0xc0>)
   13a8e:	429a      	cmp	r2, r3
   13a90:	d003      	beq.n	13a9a <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
   13a92:	4b2e      	ldr	r3, [pc, #184]	; (13b4c <Reset_Handler+0xc4>)
   13a94:	4a2b      	ldr	r2, [pc, #172]	; (13b44 <Reset_Handler+0xbc>)
   13a96:	429a      	cmp	r2, r3
   13a98:	d304      	bcc.n	13aa4 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   13a9a:	4b2d      	ldr	r3, [pc, #180]	; (13b50 <Reset_Handler+0xc8>)
   13a9c:	4a2d      	ldr	r2, [pc, #180]	; (13b54 <Reset_Handler+0xcc>)
   13a9e:	429a      	cmp	r2, r3
   13aa0:	d310      	bcc.n	13ac4 <Reset_Handler+0x3c>
   13aa2:	e01e      	b.n	13ae2 <Reset_Handler+0x5a>
   13aa4:	4a2c      	ldr	r2, [pc, #176]	; (13b58 <Reset_Handler+0xd0>)
   13aa6:	4b29      	ldr	r3, [pc, #164]	; (13b4c <Reset_Handler+0xc4>)
   13aa8:	3303      	adds	r3, #3
   13aaa:	1a9b      	subs	r3, r3, r2
   13aac:	089b      	lsrs	r3, r3, #2
   13aae:	3301      	adds	r3, #1
   13ab0:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   13ab2:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
   13ab4:	4823      	ldr	r0, [pc, #140]	; (13b44 <Reset_Handler+0xbc>)
   13ab6:	4924      	ldr	r1, [pc, #144]	; (13b48 <Reset_Handler+0xc0>)
   13ab8:	588c      	ldr	r4, [r1, r2]
   13aba:	5084      	str	r4, [r0, r2]
   13abc:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   13abe:	429a      	cmp	r2, r3
   13ac0:	d1fa      	bne.n	13ab8 <Reset_Handler+0x30>
   13ac2:	e7ea      	b.n	13a9a <Reset_Handler+0x12>
   13ac4:	4a25      	ldr	r2, [pc, #148]	; (13b5c <Reset_Handler+0xd4>)
   13ac6:	4b22      	ldr	r3, [pc, #136]	; (13b50 <Reset_Handler+0xc8>)
   13ac8:	3303      	adds	r3, #3
   13aca:	1a9b      	subs	r3, r3, r2
   13acc:	089b      	lsrs	r3, r3, #2
   13ace:	3301      	adds	r3, #1
   13ad0:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   13ad2:	2200      	movs	r2, #0
                *pDest++ = 0;
   13ad4:	481f      	ldr	r0, [pc, #124]	; (13b54 <Reset_Handler+0xcc>)
   13ad6:	2100      	movs	r1, #0
   13ad8:	1814      	adds	r4, r2, r0
   13ada:	6021      	str	r1, [r4, #0]
   13adc:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   13ade:	429a      	cmp	r2, r3
   13ae0:	d1fa      	bne.n	13ad8 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   13ae2:	4a1f      	ldr	r2, [pc, #124]	; (13b60 <Reset_Handler+0xd8>)
   13ae4:	21ff      	movs	r1, #255	; 0xff
   13ae6:	4b1f      	ldr	r3, [pc, #124]	; (13b64 <Reset_Handler+0xdc>)
   13ae8:	438b      	bics	r3, r1
   13aea:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   13aec:	39fd      	subs	r1, #253	; 0xfd
   13aee:	2390      	movs	r3, #144	; 0x90
   13af0:	005b      	lsls	r3, r3, #1
   13af2:	4a1d      	ldr	r2, [pc, #116]	; (13b68 <Reset_Handler+0xe0>)
   13af4:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   13af6:	481d      	ldr	r0, [pc, #116]	; (13b6c <Reset_Handler+0xe4>)
   13af8:	78c3      	ldrb	r3, [r0, #3]
   13afa:	2403      	movs	r4, #3
   13afc:	43a3      	bics	r3, r4
   13afe:	2202      	movs	r2, #2
   13b00:	4313      	orrs	r3, r2
   13b02:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   13b04:	78c3      	ldrb	r3, [r0, #3]
   13b06:	260c      	movs	r6, #12
   13b08:	43b3      	bics	r3, r6
   13b0a:	2108      	movs	r1, #8
   13b0c:	430b      	orrs	r3, r1
   13b0e:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
   13b10:	4b17      	ldr	r3, [pc, #92]	; (13b70 <Reset_Handler+0xe8>)
   13b12:	7b98      	ldrb	r0, [r3, #14]
   13b14:	2530      	movs	r5, #48	; 0x30
   13b16:	43a8      	bics	r0, r5
   13b18:	1c05      	adds	r5, r0, #0
   13b1a:	2020      	movs	r0, #32
   13b1c:	4328      	orrs	r0, r5
   13b1e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
   13b20:	7b98      	ldrb	r0, [r3, #14]
   13b22:	43b0      	bics	r0, r6
   13b24:	4301      	orrs	r1, r0
   13b26:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
   13b28:	7b99      	ldrb	r1, [r3, #14]
   13b2a:	43a1      	bics	r1, r4
   13b2c:	430a      	orrs	r2, r1
   13b2e:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
   13b30:	4a10      	ldr	r2, [pc, #64]	; (13b74 <Reset_Handler+0xec>)
   13b32:	6851      	ldr	r1, [r2, #4]
   13b34:	2380      	movs	r3, #128	; 0x80
   13b36:	430b      	orrs	r3, r1
   13b38:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
   13b3a:	4b0f      	ldr	r3, [pc, #60]	; (13b78 <Reset_Handler+0xf0>)
   13b3c:	4798      	blx	r3

        /* Branch to main function */
        main();
   13b3e:	4b0f      	ldr	r3, [pc, #60]	; (13b7c <Reset_Handler+0xf4>)
   13b40:	4798      	blx	r3

        /* Infinite loop */
        while (1);
   13b42:	e7fe      	b.n	13b42 <Reset_Handler+0xba>
   13b44:	20000000 	.word	0x20000000
   13b48:	000220ec 	.word	0x000220ec
   13b4c:	200002fc 	.word	0x200002fc
   13b50:	20002cc0 	.word	0x20002cc0
   13b54:	20000300 	.word	0x20000300
   13b58:	20000004 	.word	0x20000004
   13b5c:	20000304 	.word	0x20000304
   13b60:	e000ed00 	.word	0xe000ed00
   13b64:	00000000 	.word	0x00000000
   13b68:	41007000 	.word	0x41007000
   13b6c:	41005000 	.word	0x41005000
   13b70:	41004800 	.word	0x41004800
   13b74:	41004000 	.word	0x41004000
   13b78:	00016691 	.word	0x00016691
   13b7c:	00014291 	.word	0x00014291

00013b80 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
   13b80:	1c03      	adds	r3, r0, #0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
   13b82:	4a06      	ldr	r2, [pc, #24]	; (13b9c <_sbrk+0x1c>)
   13b84:	6812      	ldr	r2, [r2, #0]
   13b86:	2a00      	cmp	r2, #0
   13b88:	d102      	bne.n	13b90 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
   13b8a:	4905      	ldr	r1, [pc, #20]	; (13ba0 <_sbrk+0x20>)
   13b8c:	4a03      	ldr	r2, [pc, #12]	; (13b9c <_sbrk+0x1c>)
   13b8e:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
   13b90:	4a02      	ldr	r2, [pc, #8]	; (13b9c <_sbrk+0x1c>)
   13b92:	6810      	ldr	r0, [r2, #0]

	heap += incr;
   13b94:	18c3      	adds	r3, r0, r3
   13b96:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
   13b98:	4770      	bx	lr
   13b9a:	46c0      	nop			; (mov r8, r8)
   13b9c:	2000133c 	.word	0x2000133c
   13ba0:	20004cc0 	.word	0x20004cc0

00013ba4 <_close>:
}

extern int _close(int file)
{
	return -1;
}
   13ba4:	2001      	movs	r0, #1
   13ba6:	4240      	negs	r0, r0
   13ba8:	4770      	bx	lr
   13baa:	46c0      	nop			; (mov r8, r8)

00013bac <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
   13bac:	2380      	movs	r3, #128	; 0x80
   13bae:	019b      	lsls	r3, r3, #6
   13bb0:	604b      	str	r3, [r1, #4]

	return 0;
}
   13bb2:	2000      	movs	r0, #0
   13bb4:	4770      	bx	lr
   13bb6:	46c0      	nop			; (mov r8, r8)

00013bb8 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
   13bb8:	2001      	movs	r0, #1
   13bba:	4770      	bx	lr

00013bbc <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
   13bbc:	2000      	movs	r0, #0
   13bbe:	4770      	bx	lr

00013bc0 <_exit>:

extern void _exit(int status)
{
   13bc0:	b508      	push	{r3, lr}
   13bc2:	1c01      	adds	r1, r0, #0
	printf("Exiting with status %d.\n", status);
   13bc4:	4801      	ldr	r0, [pc, #4]	; (13bcc <_exit+0xc>)
   13bc6:	4b02      	ldr	r3, [pc, #8]	; (13bd0 <_exit+0x10>)
   13bc8:	4798      	blx	r3

	for (;;);
   13bca:	e7fe      	b.n	13bca <_exit+0xa>
   13bcc:	00021274 	.word	0x00021274
   13bd0:	00016e3d 	.word	0x00016e3d

00013bd4 <_kill>:
}

extern void _kill(int pid, int sig)
{
	return;
}
   13bd4:	4770      	bx	lr
   13bd6:	46c0      	nop			; (mov r8, r8)

00013bd8 <_getpid>:

extern int _getpid(void)
{
	return -1;
}
   13bd8:	2001      	movs	r0, #1
   13bda:	4240      	negs	r0, r0
   13bdc:	4770      	bx	lr
   13bde:	46c0      	nop			; (mov r8, r8)

00013be0 <MyBusAuthPwdCB>:
{
	ms_ticks++;
}

static uint32_t MyBusAuthPwdCB(uint8_t* buf, uint32_t bufLen)
{
   13be0:	b508      	push	{r3, lr}
   13be2:	1c0a      	adds	r2, r1, #0
	const char* myPwd = "000000";
	strncpy((char*) buf, myPwd, bufLen);
   13be4:	4902      	ldr	r1, [pc, #8]	; (13bf0 <MyBusAuthPwdCB+0x10>)
   13be6:	4b03      	ldr	r3, [pc, #12]	; (13bf4 <MyBusAuthPwdCB+0x14>)
   13be8:	4798      	blx	r3
	return (uint32_t) strlen(myPwd);
}
   13bea:	2006      	movs	r0, #6
   13bec:	bd08      	pop	{r3, pc}
   13bee:	46c0      	nop			; (mov r8, r8)
   13bf0:	0002133c 	.word	0x0002133c
   13bf4:	00017191 	.word	0x00017191

00013bf8 <socket_cb>:
 *  - tstrSocketAcceptMsg
 *  - tstrSocketConnectMsg
 *  - tstrSocketRecvMsg
 */
static void socket_cb(SOCKET sock, uint8_t u8Msg, void *pvMsg)
{
   13bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13bfa:	1c04      	adds	r4, r0, #0
   13bfc:	1c0d      	adds	r5, r1, #0
   13bfe:	1c16      	adds	r6, r2, #0
	// Check for socket event on RX socket. 
	if (sock == rx_socket)
   13c00:	4b48      	ldr	r3, [pc, #288]	; (13d24 <socket_cb+0x12c>)
   13c02:	781b      	ldrb	r3, [r3, #0]
   13c04:	b25b      	sxtb	r3, r3
   13c06:	4283      	cmp	r3, r0
   13c08:	d146      	bne.n	13c98 <socket_cb+0xa0>
	{
		if (u8Msg == SOCKET_MSG_BIND) 
   13c0a:	2901      	cmp	r1, #1
   13c0c:	d112      	bne.n	13c34 <socket_cb+0x3c>
		{
			tstrSocketBindMsg *pstrBind = (tstrSocketBindMsg *)pvMsg;
			if (pstrBind && pstrBind->status == 0) 
   13c0e:	2a00      	cmp	r2, #0
   13c10:	d00c      	beq.n	13c2c <socket_cb+0x34>
   13c12:	2300      	movs	r3, #0
   13c14:	56d3      	ldrsb	r3, [r2, r3]
   13c16:	2b00      	cmp	r3, #0
   13c18:	d108      	bne.n	13c2c <socket_cb+0x34>
			{
				// Prepare next buffer reception. 
				sock_bind_state = 1;
   13c1a:	2201      	movs	r2, #1
   13c1c:	4b42      	ldr	r3, [pc, #264]	; (13d28 <socket_cb+0x130>)
   13c1e:	701a      	strb	r2, [r3, #0]
		//		printf("socket_cb udp: bind ok!\r\n");
				recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
   13c20:	4942      	ldr	r1, [pc, #264]	; (13d2c <socket_cb+0x134>)
   13c22:	4a43      	ldr	r2, [pc, #268]	; (13d30 <socket_cb+0x138>)
   13c24:	2300      	movs	r3, #0
   13c26:	4f43      	ldr	r7, [pc, #268]	; (13d34 <socket_cb+0x13c>)
   13c28:	47b8      	blx	r7
   13c2a:	e035      	b.n	13c98 <socket_cb+0xa0>
			} 
			else 
			{
				printf("socket_cb: bind error!\r\n");
   13c2c:	4842      	ldr	r0, [pc, #264]	; (13d38 <socket_cb+0x140>)
   13c2e:	4b43      	ldr	r3, [pc, #268]	; (13d3c <socket_cb+0x144>)
   13c30:	4798      	blx	r3
   13c32:	e031      	b.n	13c98 <socket_cb+0xa0>
			}
		} 
		else if (u8Msg == SOCKET_MSG_RECVFROM) 
   13c34:	2909      	cmp	r1, #9
   13c36:	d124      	bne.n	13c82 <socket_cb+0x8a>
		{
			tstrSocketRecvMsg *pstrRx = (tstrSocketRecvMsg *)pvMsg;
			if (pstrRx->pu8Buffer && pstrRx->s16BufferSize) 
   13c38:	6813      	ldr	r3, [r2, #0]
   13c3a:	2b00      	cmp	r3, #0
   13c3c:	d017      	beq.n	13c6e <socket_cb+0x76>
   13c3e:	8893      	ldrh	r3, [r2, #4]
   13c40:	2b00      	cmp	r3, #0
   13c42:	d029      	beq.n	13c98 <socket_cb+0xa0>
			{
				delay = 0;
   13c44:	2100      	movs	r1, #0
   13c46:	4a3e      	ldr	r2, [pc, #248]	; (13d40 <socket_cb+0x148>)
   13c48:	6011      	str	r1, [r2, #0]
				sock_rx_state = pstrRx->s16BufferSize;
   13c4a:	b21b      	sxth	r3, r3
   13c4c:	4a3d      	ldr	r2, [pc, #244]	; (13d44 <socket_cb+0x14c>)
   13c4e:	6013      	str	r3, [r2, #0]
				printf("socket_cb udp recv!\r\n");
   13c50:	483d      	ldr	r0, [pc, #244]	; (13d48 <socket_cb+0x150>)
   13c52:	4b3a      	ldr	r3, [pc, #232]	; (13d3c <socket_cb+0x144>)
   13c54:	4798      	blx	r3
				printf("rx packet length= %d\n",pstrRx->s16BufferSize);
   13c56:	2304      	movs	r3, #4
   13c58:	5ef1      	ldrsh	r1, [r6, r3]
   13c5a:	483c      	ldr	r0, [pc, #240]	; (13d4c <socket_cb+0x154>)
   13c5c:	4b3c      	ldr	r3, [pc, #240]	; (13d50 <socket_cb+0x158>)
   13c5e:	4798      	blx	r3
				// Prepare next buffer reception. 
				recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
   13c60:	1c20      	adds	r0, r4, #0
   13c62:	4932      	ldr	r1, [pc, #200]	; (13d2c <socket_cb+0x134>)
   13c64:	4a32      	ldr	r2, [pc, #200]	; (13d30 <socket_cb+0x138>)
   13c66:	2300      	movs	r3, #0
   13c68:	4f32      	ldr	r7, [pc, #200]	; (13d34 <socket_cb+0x13c>)
   13c6a:	47b8      	blx	r7
   13c6c:	e014      	b.n	13c98 <socket_cb+0xa0>
			} 
			else
			{
				if (pstrRx->s16BufferSize == SOCK_ERR_TIMEOUT) 
   13c6e:	2204      	movs	r2, #4
   13c70:	5eb3      	ldrsh	r3, [r6, r2]
   13c72:	330d      	adds	r3, #13
   13c74:	d110      	bne.n	13c98 <socket_cb+0xa0>
				{
					// Prepare next buffer reception. 
				   recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
   13c76:	492d      	ldr	r1, [pc, #180]	; (13d2c <socket_cb+0x134>)
   13c78:	4a2d      	ldr	r2, [pc, #180]	; (13d30 <socket_cb+0x138>)
   13c7a:	2300      	movs	r3, #0
   13c7c:	4f2d      	ldr	r7, [pc, #180]	; (13d34 <socket_cb+0x13c>)
   13c7e:	47b8      	blx	r7
   13c80:	e00a      	b.n	13c98 <socket_cb+0xa0>
				}
			}
		}
		if (u8Msg == SOCKET_MSG_SENDTO) 
   13c82:	2908      	cmp	r1, #8
   13c84:	d108      	bne.n	13c98 <socket_cb+0xa0>
		{
	//		printf("socket_cb udp send!\r\n");
			recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0);
   13c86:	4929      	ldr	r1, [pc, #164]	; (13d2c <socket_cb+0x134>)
   13c88:	4a29      	ldr	r2, [pc, #164]	; (13d30 <socket_cb+0x138>)
   13c8a:	2300      	movs	r3, #0
   13c8c:	4c29      	ldr	r4, [pc, #164]	; (13d34 <socket_cb+0x13c>)
   13c8e:	47a0      	blx	r4
			sock_tx_state = 1;
   13c90:	2201      	movs	r2, #1
   13c92:	4b30      	ldr	r3, [pc, #192]	; (13d54 <socket_cb+0x15c>)
   13c94:	701a      	strb	r2, [r3, #0]
   13c96:	e043      	b.n	13d20 <socket_cb+0x128>
		}
	}
	if (sock == tcp_client_socket)
   13c98:	4b2f      	ldr	r3, [pc, #188]	; (13d58 <socket_cb+0x160>)
   13c9a:	781b      	ldrb	r3, [r3, #0]
   13c9c:	b25b      	sxtb	r3, r3
   13c9e:	42a3      	cmp	r3, r4
   13ca0:	d13e      	bne.n	13d20 <socket_cb+0x128>
	{		
	   switch (u8Msg) 
   13ca2:	2d06      	cmp	r5, #6
   13ca4:	d026      	beq.n	13cf4 <socket_cb+0xfc>
   13ca6:	2d07      	cmp	r5, #7
   13ca8:	d014      	beq.n	13cd4 <socket_cb+0xdc>
   13caa:	2d05      	cmp	r5, #5
   13cac:	d138      	bne.n	13d20 <socket_cb+0x128>
	   {
		   // Socket connected
		   case SOCKET_MSG_CONNECT:
		   {
		      tstrSocketConnectMsg *pstrConnect = (tstrSocketConnectMsg *)pvMsg;
			  if (pstrConnect && pstrConnect->s8Error >= 0)
   13cae:	2e00      	cmp	r6, #0
   13cb0:	d009      	beq.n	13cc6 <socket_cb+0xce>
   13cb2:	7873      	ldrb	r3, [r6, #1]
   13cb4:	2b7f      	cmp	r3, #127	; 0x7f
   13cb6:	d806      	bhi.n	13cc6 <socket_cb+0xce>
			  {
				  printf("socket_cb tcp connect!\r\n");
   13cb8:	4828      	ldr	r0, [pc, #160]	; (13d5c <socket_cb+0x164>)
   13cba:	4b20      	ldr	r3, [pc, #128]	; (13d3c <socket_cb+0x144>)
   13cbc:	4798      	blx	r3
				  tcp_ready_to_send=1;
   13cbe:	2201      	movs	r2, #1
   13cc0:	4b27      	ldr	r3, [pc, #156]	; (13d60 <socket_cb+0x168>)
   13cc2:	701a      	strb	r2, [r3, #0]
   13cc4:	e02c      	b.n	13d20 <socket_cb+0x128>
			  }
			  else
			  {
				  close(tcp_client_socket);
   13cc6:	1c20      	adds	r0, r4, #0
   13cc8:	4b26      	ldr	r3, [pc, #152]	; (13d64 <socket_cb+0x16c>)
   13cca:	4798      	blx	r3
				  tcp_client_socket = -1;
   13ccc:	22ff      	movs	r2, #255	; 0xff
   13cce:	4b22      	ldr	r3, [pc, #136]	; (13d58 <socket_cb+0x160>)
   13cd0:	701a      	strb	r2, [r3, #0]
   13cd2:	e025      	b.n	13d20 <socket_cb+0x128>
		  break;

		  // Message send
		  case SOCKET_MSG_SEND:
		  {
			  printf("socket_cb tcp send!\r\n");
   13cd4:	4824      	ldr	r0, [pc, #144]	; (13d68 <socket_cb+0x170>)
   13cd6:	4b19      	ldr	r3, [pc, #100]	; (13d3c <socket_cb+0x144>)
   13cd8:	4798      	blx	r3
			  recv(tcp_client_socket, tcp_data_rx, sizeof(tcp_data_rx), 0);
   13cda:	4b1f      	ldr	r3, [pc, #124]	; (13d58 <socket_cb+0x160>)
   13cdc:	2000      	movs	r0, #0
   13cde:	5618      	ldrsb	r0, [r3, r0]
   13ce0:	4922      	ldr	r1, [pc, #136]	; (13d6c <socket_cb+0x174>)
   13ce2:	22af      	movs	r2, #175	; 0xaf
   13ce4:	00d2      	lsls	r2, r2, #3
   13ce6:	2300      	movs	r3, #0
   13ce8:	4c12      	ldr	r4, [pc, #72]	; (13d34 <socket_cb+0x13c>)
   13cea:	47a0      	blx	r4
			  tcp_tx_ready=1;
   13cec:	2201      	movs	r2, #1
   13cee:	4b20      	ldr	r3, [pc, #128]	; (13d70 <socket_cb+0x178>)
   13cf0:	701a      	strb	r2, [r3, #0]
		  }
		  break;
   13cf2:	e015      	b.n	13d20 <socket_cb+0x128>
		  // Message receive
		  case SOCKET_MSG_RECV:
		  {
			  
			  tstrSocketRecvMsg *pstrRecv = (tstrSocketRecvMsg *)pvMsg;
			  printf("-----------------pstrRecv->s16BufferSize= %d-----------------\n", pstrRecv->s16BufferSize);
   13cf4:	2304      	movs	r3, #4
   13cf6:	5ef1      	ldrsh	r1, [r6, r3]
   13cf8:	481e      	ldr	r0, [pc, #120]	; (13d74 <socket_cb+0x17c>)
   13cfa:	4b15      	ldr	r3, [pc, #84]	; (13d50 <socket_cb+0x158>)
   13cfc:	4798      	blx	r3
			//  printf("tcp_data_rx[0]= %d\n", tcp_data_rx[0]);
			  if (pstrRecv && pstrRecv->s16BufferSize > 0)
   13cfe:	2e00      	cmp	r6, #0
   13d00:	d007      	beq.n	13d12 <socket_cb+0x11a>
   13d02:	88b3      	ldrh	r3, [r6, #4]
   13d04:	b21a      	sxth	r2, r3
   13d06:	2a00      	cmp	r2, #0
   13d08:	dd03      	ble.n	13d12 <socket_cb+0x11a>
			  {
				  tcp_rx_ready=pstrRecv->s16BufferSize;
   13d0a:	b29b      	uxth	r3, r3
   13d0c:	4a1a      	ldr	r2, [pc, #104]	; (13d78 <socket_cb+0x180>)
   13d0e:	8013      	strh	r3, [r2, #0]
   13d10:	e006      	b.n	13d20 <socket_cb+0x128>
			  }
			  else
			  {
				  close(tcp_client_socket);
   13d12:	4c11      	ldr	r4, [pc, #68]	; (13d58 <socket_cb+0x160>)
   13d14:	2000      	movs	r0, #0
   13d16:	5620      	ldrsb	r0, [r4, r0]
   13d18:	4b12      	ldr	r3, [pc, #72]	; (13d64 <socket_cb+0x16c>)
   13d1a:	4798      	blx	r3
				  tcp_client_socket = -1;
   13d1c:	23ff      	movs	r3, #255	; 0xff
   13d1e:	7023      	strb	r3, [r4, #0]

		  default:
		    break;
	   }		
	}
}
   13d20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13d22:	46c0      	nop			; (mov r8, r8)
   13d24:	20000271 	.word	0x20000271
   13d28:	20002449 	.word	0x20002449
   13d2c:	20001914 	.word	0x20001914
   13d30:	000005b4 	.word	0x000005b4
   13d34:	00012fe1 	.word	0x00012fe1
   13d38:	00021344 	.word	0x00021344
   13d3c:	00016f5d 	.word	0x00016f5d
   13d40:	20001908 	.word	0x20001908
   13d44:	20001ec8 	.word	0x20001ec8
   13d48:	0002135c 	.word	0x0002135c
   13d4c:	00021374 	.word	0x00021374
   13d50:	00016e3d 	.word	0x00016e3d
   13d54:	20001ece 	.word	0x20001ece
   13d58:	20000272 	.word	0x20000272
   13d5c:	0002138c 	.word	0x0002138c
   13d60:	20001348 	.word	0x20001348
   13d64:	00013085 	.word	0x00013085
   13d68:	000213a4 	.word	0x000213a4
   13d6c:	20001ed0 	.word	0x20001ed0
   13d70:	20001349 	.word	0x20001349
   13d74:	000213bc 	.word	0x000213bc
   13d78:	20001ecc 	.word	0x20001ecc

00013d7c <wifi_cb>:
 *  - tstrM2mWifiscanResult
 */
uint32_t own_IPAddress;
	
static void wifi_cb(uint8_t u8MsgType, void *pvMsg)
{
   13d7c:	b530      	push	{r4, r5, lr}
   13d7e:	b083      	sub	sp, #12
   13d80:	1c0c      	adds	r4, r1, #0
	switch (u8MsgType) 
   13d82:	282c      	cmp	r0, #44	; 0x2c
   13d84:	d002      	beq.n	13d8c <wifi_cb+0x10>
   13d86:	2832      	cmp	r0, #50	; 0x32
   13d88:	d017      	beq.n	13dba <wifi_cb+0x3e>
   13d8a:	e032      	b.n	13df2 <wifi_cb+0x76>
	{
	case M2M_WIFI_RESP_CON_STATE_CHANGED:
	{
		tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg;
		if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) 
   13d8c:	780b      	ldrb	r3, [r1, #0]
   13d8e:	2b01      	cmp	r3, #1
   13d90:	d105      	bne.n	13d9e <wifi_cb+0x22>
		{
			printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n");
   13d92:	4819      	ldr	r0, [pc, #100]	; (13df8 <wifi_cb+0x7c>)
   13d94:	4b19      	ldr	r3, [pc, #100]	; (13dfc <wifi_cb+0x80>)
   13d96:	4798      	blx	r3
			m2m_wifi_request_dhcp_client();
   13d98:	4b19      	ldr	r3, [pc, #100]	; (13e00 <wifi_cb+0x84>)
   13d9a:	4798      	blx	r3
   13d9c:	e029      	b.n	13df2 <wifi_cb+0x76>
		} 
		else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) 
   13d9e:	2b00      	cmp	r3, #0
   13da0:	d127      	bne.n	13df2 <wifi_cb+0x76>
		{
			printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n");
   13da2:	4818      	ldr	r0, [pc, #96]	; (13e04 <wifi_cb+0x88>)
   13da4:	4b15      	ldr	r3, [pc, #84]	; (13dfc <wifi_cb+0x80>)
   13da6:	4798      	blx	r3
			m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
   13da8:	23ff      	movs	r3, #255	; 0xff
   13daa:	9300      	str	r3, [sp, #0]
   13dac:	4816      	ldr	r0, [pc, #88]	; (13e08 <wifi_cb+0x8c>)
   13dae:	2107      	movs	r1, #7
   13db0:	2202      	movs	r2, #2
   13db2:	4b16      	ldr	r3, [pc, #88]	; (13e0c <wifi_cb+0x90>)
   13db4:	4c16      	ldr	r4, [pc, #88]	; (13e10 <wifi_cb+0x94>)
   13db6:	47a0      	blx	r4
   13db8:	e01b      	b.n	13df2 <wifi_cb+0x76>
	break;

	case M2M_WIFI_REQ_DHCP_CONF:
	{
		uint8_t *pu8IPAddress = (uint8_t *)pvMsg;
		wifi_connected = M2M_WIFI_CONNECTED;
   13dba:	2201      	movs	r2, #1
   13dbc:	4b15      	ldr	r3, [pc, #84]	; (13e14 <wifi_cb+0x98>)
   13dbe:	701a      	strb	r2, [r3, #0]
		printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF : IP is %u.%u.%u.%u\r\n", pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
   13dc0:	7809      	ldrb	r1, [r1, #0]
   13dc2:	7862      	ldrb	r2, [r4, #1]
   13dc4:	78a3      	ldrb	r3, [r4, #2]
   13dc6:	78e0      	ldrb	r0, [r4, #3]
   13dc8:	9000      	str	r0, [sp, #0]
   13dca:	4813      	ldr	r0, [pc, #76]	; (13e18 <wifi_cb+0x9c>)
   13dcc:	4d13      	ldr	r5, [pc, #76]	; (13e1c <wifi_cb+0xa0>)
   13dce:	47a8      	blx	r5
		own_IPAddress=0;
   13dd0:	4913      	ldr	r1, [pc, #76]	; (13e20 <wifi_cb+0xa4>)
   13dd2:	2300      	movs	r3, #0
   13dd4:	600b      	str	r3, [r1, #0]
		own_IPAddress=pu8IPAddress[0];
   13dd6:	7823      	ldrb	r3, [r4, #0]
		own_IPAddress<<=8;
   13dd8:	021b      	lsls	r3, r3, #8
   13dda:	600b      	str	r3, [r1, #0]
		own_IPAddress|=pu8IPAddress[1];
   13ddc:	7862      	ldrb	r2, [r4, #1]
   13dde:	4313      	orrs	r3, r2
		own_IPAddress<<=8;
   13de0:	021b      	lsls	r3, r3, #8
   13de2:	600b      	str	r3, [r1, #0]
		own_IPAddress|=pu8IPAddress[2];
   13de4:	78a2      	ldrb	r2, [r4, #2]
   13de6:	4313      	orrs	r3, r2
		own_IPAddress<<=8;
   13de8:	021b      	lsls	r3, r3, #8
   13dea:	600b      	str	r3, [r1, #0]
		own_IPAddress|=pu8IPAddress[3];
   13dec:	78e2      	ldrb	r2, [r4, #3]
   13dee:	4313      	orrs	r3, r2
   13df0:	600b      	str	r3, [r1, #0]
	break;

	default:
		break;
	}
}
   13df2:	b003      	add	sp, #12
   13df4:	bd30      	pop	{r4, r5, pc}
   13df6:	46c0      	nop			; (mov r8, r8)
   13df8:	000213fc 	.word	0x000213fc
   13dfc:	00016f5d 	.word	0x00016f5d
   13e00:	000116a5 	.word	0x000116a5
   13e04:	00021434 	.word	0x00021434
   13e08:	0002146c 	.word	0x0002146c
   13e0c:	00021474 	.word	0x00021474
   13e10:	00011689 	.word	0x00011689
   13e14:	20001340 	.word	0x20001340
   13e18:	00021480 	.word	0x00021480
   13e1c:	00016e3d 	.word	0x00016e3d
   13e20:	20002c1c 	.word	0x20002c1c

00013e24 <PropSetHandler>:
	AJSVC_DisconnectHandler(&Bus);
}

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
   13e24:	b510      	push	{r4, lr}
   13e26:	b082      	sub	sp, #8
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;

	AJ_InfoPrintf(("%s\n", __func__));

	switch (propId)
   13e28:	4b26      	ldr	r3, [pc, #152]	; (13ec4 <PropSetHandler+0xa0>)
   13e2a:	469c      	mov	ip, r3
   13e2c:	4461      	add	r1, ip
   13e2e:	2904      	cmp	r1, #4
   13e30:	d840      	bhi.n	13eb4 <PropSetHandler+0x90>
   13e32:	0089      	lsls	r1, r1, #2
   13e34:	4b24      	ldr	r3, [pc, #144]	; (13ec8 <PropSetHandler+0xa4>)
   13e36:	585b      	ldr	r3, [r3, r1]
   13e38:	469f      	mov	pc, r3
	{
		case LSF_PROP_STATE_ONOFF:
		{
			uint32_t onoff;
			status = AJ_UnmarshalArgs(msg, "b", &onoff);
   13e3a:	4924      	ldr	r1, [pc, #144]	; (13ecc <PropSetHandler+0xa8>)
   13e3c:	aa01      	add	r2, sp, #4
   13e3e:	4b24      	ldr	r3, [pc, #144]	; (13ed0 <PropSetHandler+0xac>)
   13e40:	4798      	blx	r3
   13e42:	1c04      	adds	r4, r0, #0

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13e44:	2000      	movs	r0, #0
	{
		case LSF_PROP_STATE_ONOFF:
		{
			uint32_t onoff;
			status = AJ_UnmarshalArgs(msg, "b", &onoff);
			if (status == AJ_OK)
   13e46:	2c00      	cmp	r4, #0
   13e48:	d136      	bne.n	13eb8 <PropSetHandler+0x94>
			{
				responseCode = OEM_LS_SetOnOff(onoff);
   13e4a:	9b01      	ldr	r3, [sp, #4]
   13e4c:	b2d8      	uxtb	r0, r3
   13e4e:	4b21      	ldr	r3, [pc, #132]	; (13ed4 <PropSetHandler+0xb0>)
   13e50:	4798      	blx	r3
   13e52:	e031      	b.n	13eb8 <PropSetHandler+0x94>
		}

		case LSF_PROP_STATE_HUE:
		{
			uint32_t hue;
			status = AJ_UnmarshalArgs(msg, "u", &hue);
   13e54:	4920      	ldr	r1, [pc, #128]	; (13ed8 <PropSetHandler+0xb4>)
   13e56:	aa01      	add	r2, sp, #4
   13e58:	4b1d      	ldr	r3, [pc, #116]	; (13ed0 <PropSetHandler+0xac>)
   13e5a:	4798      	blx	r3
   13e5c:	1c04      	adds	r4, r0, #0

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13e5e:	2000      	movs	r0, #0

		case LSF_PROP_STATE_HUE:
		{
			uint32_t hue;
			status = AJ_UnmarshalArgs(msg, "u", &hue);
			if (status == AJ_OK)
   13e60:	2c00      	cmp	r4, #0
   13e62:	d129      	bne.n	13eb8 <PropSetHandler+0x94>
			{
				responseCode = OEM_LS_SetHue(hue);
   13e64:	9801      	ldr	r0, [sp, #4]
   13e66:	4b1d      	ldr	r3, [pc, #116]	; (13edc <PropSetHandler+0xb8>)
   13e68:	4798      	blx	r3
   13e6a:	e025      	b.n	13eb8 <PropSetHandler+0x94>
		}

		case LSF_PROP_STATE_SAT:
		{
			uint32_t saturation;
			status = AJ_UnmarshalArgs(msg, "u", &saturation);
   13e6c:	491a      	ldr	r1, [pc, #104]	; (13ed8 <PropSetHandler+0xb4>)
   13e6e:	aa01      	add	r2, sp, #4
   13e70:	4b17      	ldr	r3, [pc, #92]	; (13ed0 <PropSetHandler+0xac>)
   13e72:	4798      	blx	r3
   13e74:	1c04      	adds	r4, r0, #0

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13e76:	2000      	movs	r0, #0

		case LSF_PROP_STATE_SAT:
		{
			uint32_t saturation;
			status = AJ_UnmarshalArgs(msg, "u", &saturation);
			if (status == AJ_OK)
   13e78:	2c00      	cmp	r4, #0
   13e7a:	d11d      	bne.n	13eb8 <PropSetHandler+0x94>
			{
				responseCode = OEM_LS_SetSaturation(saturation);
   13e7c:	9801      	ldr	r0, [sp, #4]
   13e7e:	4b18      	ldr	r3, [pc, #96]	; (13ee0 <PropSetHandler+0xbc>)
   13e80:	4798      	blx	r3
   13e82:	e019      	b.n	13eb8 <PropSetHandler+0x94>
		}

		case LSF_PROP_STATE_TEMP:
		{
			uint32_t colorTemp;
			status = AJ_UnmarshalArgs(msg, "u", &colorTemp);
   13e84:	4914      	ldr	r1, [pc, #80]	; (13ed8 <PropSetHandler+0xb4>)
   13e86:	aa01      	add	r2, sp, #4
   13e88:	4b11      	ldr	r3, [pc, #68]	; (13ed0 <PropSetHandler+0xac>)
   13e8a:	4798      	blx	r3
   13e8c:	1c04      	adds	r4, r0, #0

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13e8e:	2000      	movs	r0, #0

		case LSF_PROP_STATE_TEMP:
		{
			uint32_t colorTemp;
			status = AJ_UnmarshalArgs(msg, "u", &colorTemp);
			if (status == AJ_OK)
   13e90:	2c00      	cmp	r4, #0
   13e92:	d111      	bne.n	13eb8 <PropSetHandler+0x94>
			{
				responseCode = OEM_LS_SetColorTemp(colorTemp);
   13e94:	9801      	ldr	r0, [sp, #4]
   13e96:	4b13      	ldr	r3, [pc, #76]	; (13ee4 <PropSetHandler+0xc0>)
   13e98:	4798      	blx	r3
   13e9a:	e00d      	b.n	13eb8 <PropSetHandler+0x94>
		}

		case LSF_PROP_STATE_BRIGHT:
		{
			uint32_t brightness;
			status = AJ_UnmarshalArgs(msg, "u", &brightness);
   13e9c:	490e      	ldr	r1, [pc, #56]	; (13ed8 <PropSetHandler+0xb4>)
   13e9e:	aa01      	add	r2, sp, #4
   13ea0:	4b0b      	ldr	r3, [pc, #44]	; (13ed0 <PropSetHandler+0xac>)
   13ea2:	4798      	blx	r3
   13ea4:	1c04      	adds	r4, r0, #0

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13ea6:	2000      	movs	r0, #0

		case LSF_PROP_STATE_BRIGHT:
		{
			uint32_t brightness;
			status = AJ_UnmarshalArgs(msg, "u", &brightness);
			if (status == AJ_OK)
   13ea8:	2c00      	cmp	r4, #0
   13eaa:	d105      	bne.n	13eb8 <PropSetHandler+0x94>
			{
				responseCode = OEM_LS_SetBrightness(brightness);
   13eac:	9801      	ldr	r0, [sp, #4]
   13eae:	4b0e      	ldr	r3, [pc, #56]	; (13ee8 <PropSetHandler+0xc4>)
   13eb0:	4798      	blx	r3
   13eb2:	e001      	b.n	13eb8 <PropSetHandler+0x94>

#define MIN_ROUTER_VERSION 10
static AJ_Status PropSetHandler(AJ_Message* msg, uint32_t propId, void* context)
{
	AJ_Status status = AJ_OK;
	LampResponseCode responseCode = LAMP_OK;
   13eb4:	2000      	movs	r0, #0
			}
			break;
		}

		default:
		status = AJ_ERR_DISALLOWED;
   13eb6:	2412      	movs	r4, #18
		break;
	}

	// need to indicate some kind of failure
	if (responseCode != LAMP_OK)
   13eb8:	2800      	cmp	r0, #0
   13eba:	d000      	beq.n	13ebe <PropSetHandler+0x9a>
	{
		status = AJ_ERR_FAILURE;
   13ebc:	2413      	movs	r4, #19
	}

	return status;
}
   13ebe:	1c20      	adds	r0, r4, #0
   13ec0:	b002      	add	sp, #8
   13ec2:	bd10      	pop	{r4, pc}
   13ec4:	fefffbfc 	.word	0xfefffbfc
   13ec8:	00021290 	.word	0x00021290
   13ecc:	0001ed84 	.word	0x0001ed84
   13ed0:	0000b5f5 	.word	0x0000b5f5
   13ed4:	00000569 	.word	0x00000569
   13ed8:	0002192c 	.word	0x0002192c
   13edc:	000005a5 	.word	0x000005a5
   13ee0:	0000069d 	.word	0x0000069d
   13ee4:	00000711 	.word	0x00000711
   13ee8:	00000629 	.word	0x00000629

00013eec <PropGetHandler>:
		default:
		return AJ_ERR_UNEXPECTED;
	}
}
static AJ_Status PropGetHandler(AJ_Message* replyMsg, uint32_t propId, void* context)
{
   13eec:	b530      	push	{r4, r5, lr}
   13eee:	b087      	sub	sp, #28
   13ef0:	1c05      	adds	r5, r0, #0
   13ef2:	1e0c      	subs	r4, r1, #0
	switch (propId) 
   13ef4:	4ba4      	ldr	r3, [pc, #656]	; (14188 <PropGetHandler+0x29c>)
   13ef6:	429c      	cmp	r4, r3
   13ef8:	d100      	bne.n	13efc <PropGetHandler+0x10>
   13efa:	e0bc      	b.n	14076 <PropGetHandler+0x18a>
   13efc:	4299      	cmp	r1, r3
   13efe:	d82b      	bhi.n	13f58 <PropGetHandler+0x6c>
   13f00:	4ba2      	ldr	r3, [pc, #648]	; (1418c <PropGetHandler+0x2a0>)
   13f02:	4299      	cmp	r1, r3
   13f04:	d100      	bne.n	13f08 <PropGetHandler+0x1c>
   13f06:	e085      	b.n	14014 <PropGetHandler+0x128>
   13f08:	d815      	bhi.n	13f36 <PropGetHandler+0x4a>
   13f0a:	4ba1      	ldr	r3, [pc, #644]	; (14190 <PropGetHandler+0x2a4>)
   13f0c:	4299      	cmp	r1, r3
   13f0e:	d05f      	beq.n	13fd0 <PropGetHandler+0xe4>
   13f10:	d806      	bhi.n	13f20 <PropGetHandler+0x34>
   13f12:	4ba0      	ldr	r3, [pc, #640]	; (14194 <PropGetHandler+0x2a8>)
   13f14:	4299      	cmp	r1, r3
   13f16:	d051      	beq.n	13fbc <PropGetHandler+0xd0>
   13f18:	4b9f      	ldr	r3, [pc, #636]	; (14198 <PropGetHandler+0x2ac>)
   13f1a:	4299      	cmp	r1, r3
   13f1c:	d053      	beq.n	13fc6 <PropGetHandler+0xda>
   13f1e:	e12f      	b.n	14180 <PropGetHandler+0x294>
   13f20:	4b9e      	ldr	r3, [pc, #632]	; (1419c <PropGetHandler+0x2b0>)
   13f22:	4299      	cmp	r1, r3
   13f24:	d066      	beq.n	13ff4 <PropGetHandler+0x108>
   13f26:	4b9e      	ldr	r3, [pc, #632]	; (141a0 <PropGetHandler+0x2b4>)
   13f28:	4299      	cmp	r1, r3
   13f2a:	d06b      	beq.n	14004 <PropGetHandler+0x118>
   13f2c:	4b9d      	ldr	r3, [pc, #628]	; (141a4 <PropGetHandler+0x2b8>)
   13f2e:	4299      	cmp	r1, r3
   13f30:	d000      	beq.n	13f34 <PropGetHandler+0x48>
   13f32:	e125      	b.n	14180 <PropGetHandler+0x294>
   13f34:	e059      	b.n	13fea <PropGetHandler+0xfe>
   13f36:	4b9c      	ldr	r3, [pc, #624]	; (141a8 <PropGetHandler+0x2bc>)
   13f38:	4299      	cmp	r1, r3
   13f3a:	d100      	bne.n	13f3e <PropGetHandler+0x52>
   13f3c:	e081      	b.n	14042 <PropGetHandler+0x156>
   13f3e:	d804      	bhi.n	13f4a <PropGetHandler+0x5e>
   13f40:	4b9a      	ldr	r3, [pc, #616]	; (141ac <PropGetHandler+0x2c0>)
   13f42:	4299      	cmp	r1, r3
   13f44:	d071      	beq.n	1402a <PropGetHandler+0x13e>
   13f46:	d96a      	bls.n	1401e <PropGetHandler+0x132>
   13f48:	e075      	b.n	14036 <PropGetHandler+0x14a>
   13f4a:	4b99      	ldr	r3, [pc, #612]	; (141b0 <PropGetHandler+0x2c4>)
   13f4c:	4299      	cmp	r1, r3
   13f4e:	d100      	bne.n	13f52 <PropGetHandler+0x66>
   13f50:	e083      	b.n	1405a <PropGetHandler+0x16e>
   13f52:	d800      	bhi.n	13f56 <PropGetHandler+0x6a>
   13f54:	e07b      	b.n	1404e <PropGetHandler+0x162>
   13f56:	e086      	b.n	14066 <PropGetHandler+0x17a>
   13f58:	4b96      	ldr	r3, [pc, #600]	; (141b4 <PropGetHandler+0x2c8>)
   13f5a:	4299      	cmp	r1, r3
   13f5c:	d100      	bne.n	13f60 <PropGetHandler+0x74>
   13f5e:	e0ba      	b.n	140d6 <PropGetHandler+0x1ea>
   13f60:	d814      	bhi.n	13f8c <PropGetHandler+0xa0>
   13f62:	4b95      	ldr	r3, [pc, #596]	; (141b8 <PropGetHandler+0x2cc>)
   13f64:	4299      	cmp	r1, r3
   13f66:	d100      	bne.n	13f6a <PropGetHandler+0x7e>
   13f68:	e09d      	b.n	140a6 <PropGetHandler+0x1ba>
   13f6a:	d808      	bhi.n	13f7e <PropGetHandler+0x92>
   13f6c:	4b93      	ldr	r3, [pc, #588]	; (141bc <PropGetHandler+0x2d0>)
   13f6e:	4299      	cmp	r1, r3
   13f70:	d100      	bne.n	13f74 <PropGetHandler+0x88>
   13f72:	e088      	b.n	14086 <PropGetHandler+0x19a>
   13f74:	4b92      	ldr	r3, [pc, #584]	; (141c0 <PropGetHandler+0x2d4>)
   13f76:	4299      	cmp	r1, r3
   13f78:	d100      	bne.n	13f7c <PropGetHandler+0x90>
   13f7a:	e08c      	b.n	14096 <PropGetHandler+0x1aa>
   13f7c:	e100      	b.n	14180 <PropGetHandler+0x294>
   13f7e:	4b91      	ldr	r3, [pc, #580]	; (141c4 <PropGetHandler+0x2d8>)
   13f80:	4299      	cmp	r1, r3
   13f82:	d100      	bne.n	13f86 <PropGetHandler+0x9a>
   13f84:	e09b      	b.n	140be <PropGetHandler+0x1d2>
   13f86:	d800      	bhi.n	13f8a <PropGetHandler+0x9e>
   13f88:	e093      	b.n	140b2 <PropGetHandler+0x1c6>
   13f8a:	e09e      	b.n	140ca <PropGetHandler+0x1de>
   13f8c:	4b8e      	ldr	r3, [pc, #568]	; (141c8 <PropGetHandler+0x2dc>)
   13f8e:	4299      	cmp	r1, r3
   13f90:	d100      	bne.n	13f94 <PropGetHandler+0xa8>
   13f92:	e0b8      	b.n	14106 <PropGetHandler+0x21a>
   13f94:	d806      	bhi.n	13fa4 <PropGetHandler+0xb8>
   13f96:	4b8d      	ldr	r3, [pc, #564]	; (141cc <PropGetHandler+0x2e0>)
   13f98:	4299      	cmp	r1, r3
   13f9a:	d100      	bne.n	13f9e <PropGetHandler+0xb2>
   13f9c:	e0a7      	b.n	140ee <PropGetHandler+0x202>
   13f9e:	d800      	bhi.n	13fa2 <PropGetHandler+0xb6>
   13fa0:	e09f      	b.n	140e2 <PropGetHandler+0x1f6>
   13fa2:	e0aa      	b.n	140fa <PropGetHandler+0x20e>
   13fa4:	4b8a      	ldr	r3, [pc, #552]	; (141d0 <PropGetHandler+0x2e4>)
   13fa6:	4299      	cmp	r1, r3
   13fa8:	d100      	bne.n	13fac <PropGetHandler+0xc0>
   13faa:	e0b5      	b.n	14118 <PropGetHandler+0x22c>
   13fac:	d200      	bcs.n	13fb0 <PropGetHandler+0xc4>
   13fae:	e0e7      	b.n	14180 <PropGetHandler+0x294>
   13fb0:	4b88      	ldr	r3, [pc, #544]	; (141d4 <PropGetHandler+0x2e8>)
   13fb2:	18cb      	adds	r3, r1, r3
   13fb4:	2b04      	cmp	r3, #4
   13fb6:	d800      	bhi.n	13fba <PropGetHandler+0xce>
   13fb8:	e0b3      	b.n	14122 <PropGetHandler+0x236>
   13fba:	e0e1      	b.n	14180 <PropGetHandler+0x294>
	{
		// org.allseen.LSF.LampService
		case LSF_PROP_VERSION:
		AJ_InfoPrintf(("LSF_PROP_VERSION: %u\n", LSF_Interface_Version));
		return AJ_MarshalArgs(replyMsg, "u", LSF_Interface_Version);
   13fbc:	4986      	ldr	r1, [pc, #536]	; (141d8 <PropGetHandler+0x2ec>)
   13fbe:	2201      	movs	r2, #1
   13fc0:	4b86      	ldr	r3, [pc, #536]	; (141dc <PropGetHandler+0x2f0>)
   13fc2:	4798      	blx	r3
   13fc4:	e0dd      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_LSF_VERSION:
		AJ_InfoPrintf(("LSF_PROP_LSF_VERSION: %u\n", LAMP_GetServiceVersion()));
		return AJ_MarshalArgs(replyMsg, "u", LAMP_GetServiceVersion());
   13fc6:	4984      	ldr	r1, [pc, #528]	; (141d8 <PropGetHandler+0x2ec>)
   13fc8:	2201      	movs	r2, #1
   13fca:	4b84      	ldr	r3, [pc, #528]	; (141dc <PropGetHandler+0x2f0>)
   13fcc:	4798      	blx	r3
   13fce:	e0d8      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_FAULTS:
		{
			AJ_Arg array1;

			AJ_MarshalContainer(replyMsg, &array1, AJ_ARG_ARRAY);
   13fd0:	a901      	add	r1, sp, #4
   13fd2:	2261      	movs	r2, #97	; 0x61
   13fd4:	4b82      	ldr	r3, [pc, #520]	; (141e0 <PropGetHandler+0x2f4>)
   13fd6:	4798      	blx	r3
			OEM_LS_PopulateFaults(replyMsg);
   13fd8:	1c28      	adds	r0, r5, #0
   13fda:	4b82      	ldr	r3, [pc, #520]	; (141e4 <PropGetHandler+0x2f8>)
   13fdc:	4798      	blx	r3
			AJ_MarshalCloseContainer(replyMsg, &array1);
   13fde:	1c28      	adds	r0, r5, #0
   13fe0:	a901      	add	r1, sp, #4
   13fe2:	4b81      	ldr	r3, [pc, #516]	; (141e8 <PropGetHandler+0x2fc>)
   13fe4:	4798      	blx	r3
			return AJ_OK;
   13fe6:	2000      	movs	r0, #0
   13fe8:	e0cb      	b.n	14182 <PropGetHandler+0x296>
		}

		// run-time parameters
		case LSF_PROP_PARAMS_VERSION:
		AJ_InfoPrintf(("LSF_PROP_FAULTS: %u\n", LSF_Parameters_Interface_Version));
		return AJ_MarshalArgs(replyMsg, "u", LSF_Parameters_Interface_Version);
   13fea:	497b      	ldr	r1, [pc, #492]	; (141d8 <PropGetHandler+0x2ec>)
   13fec:	2201      	movs	r2, #1
   13fee:	4b7b      	ldr	r3, [pc, #492]	; (141dc <PropGetHandler+0x2f0>)
   13ff0:	4798      	blx	r3
   13ff2:	e0c6      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_PARAMS_ENERGY_USAGE_MILLIWATTS:
		AJ_InfoPrintf(("LSF_PROP_PARAMS_ENERGY_USAGE_MILLIWATTS: %u\n", OEM_LS_GetEnergyUsageMilliwatts()));
		return AJ_MarshalArgs(replyMsg, "u", OEM_LS_GetEnergyUsageMilliwatts());
   13ff4:	4b7d      	ldr	r3, [pc, #500]	; (141ec <PropGetHandler+0x300>)
   13ff6:	4798      	blx	r3
   13ff8:	1c02      	adds	r2, r0, #0
   13ffa:	1c28      	adds	r0, r5, #0
   13ffc:	4976      	ldr	r1, [pc, #472]	; (141d8 <PropGetHandler+0x2ec>)
   13ffe:	4b77      	ldr	r3, [pc, #476]	; (141dc <PropGetHandler+0x2f0>)
   14000:	4798      	blx	r3
   14002:	e0be      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_PARAMS_BRIGHTNESS_LUMENS:
		AJ_InfoPrintf(("LSF_PROP_PARAMS_BRIGHTNESS_LUMENS: %u\n", OEM_LS_GetBrightnessLumens()));
		return AJ_MarshalArgs(replyMsg, "u", OEM_LS_GetBrightnessLumens());
   14004:	4b7a      	ldr	r3, [pc, #488]	; (141f0 <PropGetHandler+0x304>)
   14006:	4798      	blx	r3
   14008:	1c02      	adds	r2, r0, #0
   1400a:	1c28      	adds	r0, r5, #0
   1400c:	4972      	ldr	r1, [pc, #456]	; (141d8 <PropGetHandler+0x2ec>)
   1400e:	4b73      	ldr	r3, [pc, #460]	; (141dc <PropGetHandler+0x2f0>)
   14010:	4798      	blx	r3
   14012:	e0b6      	b.n	14182 <PropGetHandler+0x296>

		// Compile-time Details
		case LSF_PROP_DETAILS_VERSION:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_VERSION: %u\n", LSF_Parameters_Interface_Version));
		return AJ_MarshalArgs(replyMsg, "u", LSF_Details_Interface_Version);
   14014:	4970      	ldr	r1, [pc, #448]	; (141d8 <PropGetHandler+0x2ec>)
   14016:	2201      	movs	r2, #1
   14018:	4b70      	ldr	r3, [pc, #448]	; (141dc <PropGetHandler+0x2f0>)
   1401a:	4798      	blx	r3
   1401c:	e0b1      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MAKE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MAKE: %u\n", LampDetails.lampMake));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.lampMake);
   1401e:	4b75      	ldr	r3, [pc, #468]	; (141f4 <PropGetHandler+0x308>)
   14020:	781a      	ldrb	r2, [r3, #0]
   14022:	496d      	ldr	r1, [pc, #436]	; (141d8 <PropGetHandler+0x2ec>)
   14024:	4b6d      	ldr	r3, [pc, #436]	; (141dc <PropGetHandler+0x2f0>)
   14026:	4798      	blx	r3
   14028:	e0ab      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MODEL:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MODEL: %u\n", LampDetails.lampModel));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.lampModel);
   1402a:	4b72      	ldr	r3, [pc, #456]	; (141f4 <PropGetHandler+0x308>)
   1402c:	785a      	ldrb	r2, [r3, #1]
   1402e:	496a      	ldr	r1, [pc, #424]	; (141d8 <PropGetHandler+0x2ec>)
   14030:	4b6a      	ldr	r3, [pc, #424]	; (141dc <PropGetHandler+0x2f0>)
   14032:	4798      	blx	r3
   14034:	e0a5      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_DEV_TYPE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_DEV_TYPE: %u\n", LampDetails.deviceType));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceType);
   14036:	4b6f      	ldr	r3, [pc, #444]	; (141f4 <PropGetHandler+0x308>)
   14038:	789a      	ldrb	r2, [r3, #2]
   1403a:	4967      	ldr	r1, [pc, #412]	; (141d8 <PropGetHandler+0x2ec>)
   1403c:	4b67      	ldr	r3, [pc, #412]	; (141dc <PropGetHandler+0x2f0>)
   1403e:	4798      	blx	r3
   14040:	e09f      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_LAMP_TYPE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_LAMP_TYPE: %u\n", LampDetails.lampType));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.lampType);
   14042:	4b6c      	ldr	r3, [pc, #432]	; (141f4 <PropGetHandler+0x308>)
   14044:	78da      	ldrb	r2, [r3, #3]
   14046:	4964      	ldr	r1, [pc, #400]	; (141d8 <PropGetHandler+0x2ec>)
   14048:	4b64      	ldr	r3, [pc, #400]	; (141dc <PropGetHandler+0x2f0>)
   1404a:	4798      	blx	r3
   1404c:	e099      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_BASETYPE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_BASETYPE: %u\n", LampDetails.baseType));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.baseType);
   1404e:	4b69      	ldr	r3, [pc, #420]	; (141f4 <PropGetHandler+0x308>)
   14050:	791a      	ldrb	r2, [r3, #4]
   14052:	4961      	ldr	r1, [pc, #388]	; (141d8 <PropGetHandler+0x2ec>)
   14054:	4b61      	ldr	r3, [pc, #388]	; (141dc <PropGetHandler+0x2f0>)
   14056:	4798      	blx	r3
   14058:	e093      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_BEAMANGLE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_BEAMANGLE: %u\n", LampDetails.deviceLampBeamAngle));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceLampBeamAngle);
   1405a:	4b66      	ldr	r3, [pc, #408]	; (141f4 <PropGetHandler+0x308>)
   1405c:	689a      	ldr	r2, [r3, #8]
   1405e:	495e      	ldr	r1, [pc, #376]	; (141d8 <PropGetHandler+0x2ec>)
   14060:	4b5e      	ldr	r3, [pc, #376]	; (141dc <PropGetHandler+0x2f0>)
   14062:	4798      	blx	r3
   14064:	e08d      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_DIMMABLE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_DIMMABLE: %s\n", (LampDetails.deviceDimmable ? "TRUE" : "FALSE")));
		return AJ_MarshalArgs(replyMsg, "b", (LampDetails.deviceDimmable ? TRUE : FALSE));
   14066:	4b63      	ldr	r3, [pc, #396]	; (141f4 <PropGetHandler+0x308>)
   14068:	7b1a      	ldrb	r2, [r3, #12]
   1406a:	1e53      	subs	r3, r2, #1
   1406c:	419a      	sbcs	r2, r3
   1406e:	4962      	ldr	r1, [pc, #392]	; (141f8 <PropGetHandler+0x30c>)
   14070:	4b5a      	ldr	r3, [pc, #360]	; (141dc <PropGetHandler+0x2f0>)
   14072:	4798      	blx	r3
   14074:	e085      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_COLOR:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_COLOR: %s\n", (LampDetails.deviceColor ? "TRUE" : "FALSE")));
		return AJ_MarshalArgs(replyMsg, "b", (LampDetails.deviceColor ? TRUE : FALSE));
   14076:	4b5f      	ldr	r3, [pc, #380]	; (141f4 <PropGetHandler+0x308>)
   14078:	7b5a      	ldrb	r2, [r3, #13]
   1407a:	1e53      	subs	r3, r2, #1
   1407c:	419a      	sbcs	r2, r3
   1407e:	495e      	ldr	r1, [pc, #376]	; (141f8 <PropGetHandler+0x30c>)
   14080:	4b56      	ldr	r3, [pc, #344]	; (141dc <PropGetHandler+0x2f0>)
   14082:	4798      	blx	r3
   14084:	e07d      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_VARCOLORTEMP:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_VARCOLORTEMP: %s\n", (LampDetails.variableColorTemp ? "TRUE" : "FALSE")));
		return AJ_MarshalArgs(replyMsg, "b", (LampDetails.variableColorTemp ? TRUE : FALSE));
   14086:	4b5b      	ldr	r3, [pc, #364]	; (141f4 <PropGetHandler+0x308>)
   14088:	7b9a      	ldrb	r2, [r3, #14]
   1408a:	1e53      	subs	r3, r2, #1
   1408c:	419a      	sbcs	r2, r3
   1408e:	495a      	ldr	r1, [pc, #360]	; (141f8 <PropGetHandler+0x30c>)
   14090:	4b52      	ldr	r3, [pc, #328]	; (141dc <PropGetHandler+0x2f0>)
   14092:	4798      	blx	r3
   14094:	e075      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_HASEFFECTS:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_HASEFFECTS: %s\n", (LampDetails.deviceHasEffects ? "TRUE" : "FALSE")));
		return AJ_MarshalArgs(replyMsg, "b", (LampDetails.deviceHasEffects ? TRUE : FALSE));
   14096:	4b57      	ldr	r3, [pc, #348]	; (141f4 <PropGetHandler+0x308>)
   14098:	7bda      	ldrb	r2, [r3, #15]
   1409a:	1e53      	subs	r3, r2, #1
   1409c:	419a      	sbcs	r2, r3
   1409e:	4956      	ldr	r1, [pc, #344]	; (141f8 <PropGetHandler+0x30c>)
   140a0:	4b4e      	ldr	r3, [pc, #312]	; (141dc <PropGetHandler+0x2f0>)
   140a2:	4798      	blx	r3
   140a4:	e06d      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MINVOLTAGE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MINVOLTAGE: %u\n", LampDetails.deviceMinVoltage));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceMinVoltage);
   140a6:	4b53      	ldr	r3, [pc, #332]	; (141f4 <PropGetHandler+0x308>)
   140a8:	691a      	ldr	r2, [r3, #16]
   140aa:	494b      	ldr	r1, [pc, #300]	; (141d8 <PropGetHandler+0x2ec>)
   140ac:	4b4b      	ldr	r3, [pc, #300]	; (141dc <PropGetHandler+0x2f0>)
   140ae:	4798      	blx	r3
   140b0:	e067      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MAXVOLTAGE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MAXVOLTAGE: %u\n", LampDetails.deviceMaxVoltage));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceMaxVoltage);
   140b2:	4b50      	ldr	r3, [pc, #320]	; (141f4 <PropGetHandler+0x308>)
   140b4:	695a      	ldr	r2, [r3, #20]
   140b6:	4948      	ldr	r1, [pc, #288]	; (141d8 <PropGetHandler+0x2ec>)
   140b8:	4b48      	ldr	r3, [pc, #288]	; (141dc <PropGetHandler+0x2f0>)
   140ba:	4798      	blx	r3
   140bc:	e061      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_WATTAGE:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_WATTAGE: %u\n", LampDetails.deviceWattage));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceWattage);
   140be:	4b4d      	ldr	r3, [pc, #308]	; (141f4 <PropGetHandler+0x308>)
   140c0:	699a      	ldr	r2, [r3, #24]
   140c2:	4945      	ldr	r1, [pc, #276]	; (141d8 <PropGetHandler+0x2ec>)
   140c4:	4b45      	ldr	r3, [pc, #276]	; (141dc <PropGetHandler+0x2f0>)
   140c6:	4798      	blx	r3
   140c8:	e05b      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_INCANEQV:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_INCANEQV: %u\n", LampDetails.deviceIncandescentEquivalent));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceIncandescentEquivalent);
   140ca:	4b4a      	ldr	r3, [pc, #296]	; (141f4 <PropGetHandler+0x308>)
   140cc:	69da      	ldr	r2, [r3, #28]
   140ce:	4942      	ldr	r1, [pc, #264]	; (141d8 <PropGetHandler+0x2ec>)
   140d0:	4b42      	ldr	r3, [pc, #264]	; (141dc <PropGetHandler+0x2f0>)
   140d2:	4798      	blx	r3
   140d4:	e055      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MAXLUMENS:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MAXLUMENS: %u\n", LampDetails.deviceMaxLumens));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceMaxLumens);
   140d6:	4b47      	ldr	r3, [pc, #284]	; (141f4 <PropGetHandler+0x308>)
   140d8:	6a1a      	ldr	r2, [r3, #32]
   140da:	493f      	ldr	r1, [pc, #252]	; (141d8 <PropGetHandler+0x2ec>)
   140dc:	4b3f      	ldr	r3, [pc, #252]	; (141dc <PropGetHandler+0x2f0>)
   140de:	4798      	blx	r3
   140e0:	e04f      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MINTEMP:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MINTEMP: %u\n", LampDetails.deviceMinTemperature));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceMinTemperature);
   140e2:	4b44      	ldr	r3, [pc, #272]	; (141f4 <PropGetHandler+0x308>)
   140e4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   140e6:	493c      	ldr	r1, [pc, #240]	; (141d8 <PropGetHandler+0x2ec>)
   140e8:	4b3c      	ldr	r3, [pc, #240]	; (141dc <PropGetHandler+0x2f0>)
   140ea:	4798      	blx	r3
   140ec:	e049      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_MAXTEMP:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_MAXTEMP: %u\n", LampDetails.deviceMaxTemperature));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceMaxTemperature);
   140ee:	4b41      	ldr	r3, [pc, #260]	; (141f4 <PropGetHandler+0x308>)
   140f0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   140f2:	4939      	ldr	r1, [pc, #228]	; (141d8 <PropGetHandler+0x2ec>)
   140f4:	4b39      	ldr	r3, [pc, #228]	; (141dc <PropGetHandler+0x2f0>)
   140f6:	4798      	blx	r3
   140f8:	e043      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_CRI:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_CRI: %u\n", LampDetails.deviceColorRenderingIndex));
		return AJ_MarshalArgs(replyMsg, "u", LampDetails.deviceColorRenderingIndex);
   140fa:	4b3e      	ldr	r3, [pc, #248]	; (141f4 <PropGetHandler+0x308>)
   140fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   140fe:	4936      	ldr	r1, [pc, #216]	; (141d8 <PropGetHandler+0x2ec>)
   14100:	4b36      	ldr	r3, [pc, #216]	; (141dc <PropGetHandler+0x2f0>)
   14102:	4798      	blx	r3
   14104:	e03d      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_DETAILS_LAMPID:
		AJ_InfoPrintf(("LSF_PROP_DETAILS_LAMPID: %s\n", AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID)));
		return AJ_MarshalArgs(replyMsg, "s", AJSVC_PropertyStore_GetValue(AJSVC_PROPERTY_STORE_DEVICE_ID));
   14106:	2000      	movs	r0, #0
   14108:	4b3c      	ldr	r3, [pc, #240]	; (141fc <PropGetHandler+0x310>)
   1410a:	4798      	blx	r3
   1410c:	1c02      	adds	r2, r0, #0
   1410e:	1c28      	adds	r0, r5, #0
   14110:	493b      	ldr	r1, [pc, #236]	; (14200 <PropGetHandler+0x314>)
   14112:	4b32      	ldr	r3, [pc, #200]	; (141dc <PropGetHandler+0x2f0>)
   14114:	4798      	blx	r3
   14116:	e034      	b.n	14182 <PropGetHandler+0x296>


		// LampState properties
		case LSF_PROP_STATE_VERSION:
		AJ_InfoPrintf(("LSF_PROP_STATE_VERSION: %u\n", LSF_State_Interface_Version));
		return AJ_MarshalArgs(replyMsg, "u", LSF_State_Interface_Version);
   14118:	492f      	ldr	r1, [pc, #188]	; (141d8 <PropGetHandler+0x2ec>)
   1411a:	2201      	movs	r2, #1
   1411c:	4b2f      	ldr	r3, [pc, #188]	; (141dc <PropGetHandler+0x2f0>)
   1411e:	4798      	blx	r3
   14120:	e02f      	b.n	14182 <PropGetHandler+0x296>
	return status;
}
static AJ_Status MarshalStateField(AJ_Message* replyMsg, uint32_t propId)
{
	LampState state;
	LAMP_GetState(&state);
   14122:	a801      	add	r0, sp, #4
   14124:	4b37      	ldr	r3, [pc, #220]	; (14204 <PropGetHandler+0x318>)
   14126:	4798      	blx	r3
	AJ_InfoPrintf(("%s\n", __func__));

	switch (propId) 
   14128:	4b2a      	ldr	r3, [pc, #168]	; (141d4 <PropGetHandler+0x2e8>)
   1412a:	469c      	mov	ip, r3
   1412c:	4464      	add	r4, ip
   1412e:	2c04      	cmp	r4, #4
   14130:	d824      	bhi.n	1417c <PropGetHandler+0x290>
   14132:	00a4      	lsls	r4, r4, #2
   14134:	4b34      	ldr	r3, [pc, #208]	; (14208 <PropGetHandler+0x31c>)
   14136:	591b      	ldr	r3, [r3, r4]
   14138:	469f      	mov	pc, r3
	{
		case LSF_PROP_STATE_ONOFF:
		AJ_InfoPrintf(("onOff: %s\n", (state.onOff ? "TRUE" : "FALSE")));
		return AJ_MarshalArgs(replyMsg, "b", (state.onOff ? TRUE : FALSE));
   1413a:	ab01      	add	r3, sp, #4
   1413c:	7c1a      	ldrb	r2, [r3, #16]
   1413e:	1e53      	subs	r3, r2, #1
   14140:	419a      	sbcs	r2, r3
   14142:	1c28      	adds	r0, r5, #0
   14144:	492c      	ldr	r1, [pc, #176]	; (141f8 <PropGetHandler+0x30c>)
   14146:	4b25      	ldr	r3, [pc, #148]	; (141dc <PropGetHandler+0x2f0>)
   14148:	4798      	blx	r3
   1414a:	e01a      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_STATE_HUE:
		AJ_InfoPrintf(("Hue: %u\n", state.hue));
		return AJ_MarshalArgs(replyMsg, "u", state.hue);
   1414c:	1c28      	adds	r0, r5, #0
   1414e:	4922      	ldr	r1, [pc, #136]	; (141d8 <PropGetHandler+0x2ec>)
   14150:	9a01      	ldr	r2, [sp, #4]
   14152:	4b22      	ldr	r3, [pc, #136]	; (141dc <PropGetHandler+0x2f0>)
   14154:	4798      	blx	r3
   14156:	e014      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_STATE_SAT:
		AJ_InfoPrintf(("Saturation: %u\n", state.saturation));
		return AJ_MarshalArgs(replyMsg, "u", state.saturation);
   14158:	1c28      	adds	r0, r5, #0
   1415a:	491f      	ldr	r1, [pc, #124]	; (141d8 <PropGetHandler+0x2ec>)
   1415c:	9a02      	ldr	r2, [sp, #8]
   1415e:	4b1f      	ldr	r3, [pc, #124]	; (141dc <PropGetHandler+0x2f0>)
   14160:	4798      	blx	r3
   14162:	e00e      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_STATE_TEMP:
		AJ_InfoPrintf(("Color: %u\n", state.colorTemp));
		return AJ_MarshalArgs(replyMsg, "u", state.colorTemp);
   14164:	1c28      	adds	r0, r5, #0
   14166:	491c      	ldr	r1, [pc, #112]	; (141d8 <PropGetHandler+0x2ec>)
   14168:	9a03      	ldr	r2, [sp, #12]
   1416a:	4b1c      	ldr	r3, [pc, #112]	; (141dc <PropGetHandler+0x2f0>)
   1416c:	4798      	blx	r3
   1416e:	e008      	b.n	14182 <PropGetHandler+0x296>

		case LSF_PROP_STATE_BRIGHT:
		AJ_InfoPrintf(("Brightness: %u\n", state.brightness));
		return AJ_MarshalArgs(replyMsg, "u", state.brightness);
   14170:	1c28      	adds	r0, r5, #0
   14172:	4919      	ldr	r1, [pc, #100]	; (141d8 <PropGetHandler+0x2ec>)
   14174:	9a04      	ldr	r2, [sp, #16]
   14176:	4b19      	ldr	r3, [pc, #100]	; (141dc <PropGetHandler+0x2f0>)
   14178:	4798      	blx	r3
   1417a:	e002      	b.n	14182 <PropGetHandler+0x296>

		default:
		return AJ_ERR_UNEXPECTED;
   1417c:	2002      	movs	r0, #2
		case LSF_PROP_STATE_ONOFF:
		case LSF_PROP_STATE_HUE:
		case LSF_PROP_STATE_SAT:
		case LSF_PROP_STATE_TEMP:
		case LSF_PROP_STATE_BRIGHT:
		return MarshalStateField(replyMsg, propId);
   1417e:	e000      	b.n	14182 <PropGetHandler+0x296>

		default:
		return AJ_ERR_UNEXPECTED;
   14180:	2002      	movs	r0, #2
	}
}
   14182:	b007      	add	sp, #28
   14184:	bd30      	pop	{r4, r5, pc}
   14186:	46c0      	nop			; (mov r8, r8)
   14188:	01000308 	.word	0x01000308
   1418c:	01000300 	.word	0x01000300
   14190:	01000103 	.word	0x01000103
   14194:	01000100 	.word	0x01000100
   14198:	01000101 	.word	0x01000101
   1419c:	01000201 	.word	0x01000201
   141a0:	01000202 	.word	0x01000202
   141a4:	01000200 	.word	0x01000200
   141a8:	01000304 	.word	0x01000304
   141ac:	01000302 	.word	0x01000302
   141b0:	01000306 	.word	0x01000306
   141b4:	0100030f 	.word	0x0100030f
   141b8:	0100030b 	.word	0x0100030b
   141bc:	01000309 	.word	0x01000309
   141c0:	0100030a 	.word	0x0100030a
   141c4:	0100030d 	.word	0x0100030d
   141c8:	01000313 	.word	0x01000313
   141cc:	01000311 	.word	0x01000311
   141d0:	01000400 	.word	0x01000400
   141d4:	fefffbfc 	.word	0xfefffbfc
   141d8:	0002192c 	.word	0x0002192c
   141dc:	0000bc85 	.word	0x0000bc85
   141e0:	0000b8a1 	.word	0x0000b8a1
   141e4:	00000afd 	.word	0x00000afd
   141e8:	0000b8d1 	.word	0x0000b8d1
   141ec:	00000ac5 	.word	0x00000ac5
   141f0:	00000ac9 	.word	0x00000ac9
   141f4:	00019afc 	.word	0x00019afc
   141f8:	0001ed84 	.word	0x0001ed84
   141fc:	00000e39 	.word	0x00000e39
   14200:	0001f054 	.word	0x0001f054
   14204:	00000525 	.word	0x00000525
   14208:	000212a4 	.word	0x000212a4

0001420c <LAMP_GetServiceVersion>:
#define LSF_VERSION ((LSF_MAJOR_VERSION) << 24) | ((LSF_MINOR_VERSION) << 16) | (LSF_RELEASE_VERSION)

uint32_t LAMP_GetServiceVersion(void)
{
	return (uint32_t) LSF_VERSION;
}
   1420c:	2001      	movs	r0, #1
   1420e:	4770      	bx	lr

00014210 <SysTick_Handler>:
}

//brief SysTick handler used to measure precise delay.
void SysTick_Handler(void)
{
	ms_ticks++;
   14210:	4a02      	ldr	r2, [pc, #8]	; (1421c <SysTick_Handler+0xc>)
   14212:	6813      	ldr	r3, [r2, #0]
   14214:	3301      	adds	r3, #1
   14216:	6013      	str	r3, [r2, #0]
}
   14218:	4770      	bx	lr
   1421a:	46c0      	nop			; (mov r8, r8)
   1421c:	2000134c 	.word	0x2000134c

00014220 <init_allyojn>:
	strncpy((char*) buf, myPwd, bufLen);
	return (uint32_t) strlen(myPwd);
}

void init_allyojn(void)
{
   14220:	b510      	push	{r4, lr}
   // One time initialization before calling any other AllJoyn APIs
    AJ_Status status = AJ_OK;
    uint8_t connected = FALSE;
    
    AJ_Initialize();
   14222:	4b0b      	ldr	r3, [pc, #44]	; (14250 <init_allyojn+0x30>)
   14224:	4798      	blx	r3

    AJ_PrintXML(LSF_AllJoynObjects);
   14226:	4c0b      	ldr	r4, [pc, #44]	; (14254 <init_allyojn+0x34>)
   14228:	1c20      	adds	r0, r4, #0
   1422a:	4b0b      	ldr	r3, [pc, #44]	; (14258 <init_allyojn+0x38>)
   1422c:	4798      	blx	r3
    AJ_RegisterObjects(LSF_AllJoynObjects, NULL);
   1422e:	1c20      	adds	r0, r4, #0
   14230:	2100      	movs	r1, #0
   14232:	4b0a      	ldr	r3, [pc, #40]	; (1425c <init_allyojn+0x3c>)
   14234:	4798      	blx	r3

    SetBusAuthPwdCallback(MyBusAuthPwdCB);
   14236:	480a      	ldr	r0, [pc, #40]	; (14260 <init_allyojn+0x40>)
   14238:	4b0a      	ldr	r3, [pc, #40]	; (14264 <init_allyojn+0x44>)
   1423a:	4798      	blx	r3

    LAMP_SetupAboutConfigData();
   1423c:	4b0a      	ldr	r3, [pc, #40]	; (14268 <init_allyojn+0x48>)
   1423e:	4798      	blx	r3

    AJNS_Producer_Start();
   14240:	4b0a      	ldr	r3, [pc, #40]	; (1426c <init_allyojn+0x4c>)
   14242:	4798      	blx	r3

    LAMP_InitializeState();
   14244:	4b0a      	ldr	r3, [pc, #40]	; (14270 <init_allyojn+0x50>)
   14246:	4798      	blx	r3
    LAMP_InitOnboarding();
#endif

    // announce all of our IOE objects;
    // this call might not be necessary
    AJ_AboutSetAnnounceObjects(LSF_AllJoynObjects);
   14248:	1c20      	adds	r0, r4, #0
   1424a:	4b0a      	ldr	r3, [pc, #40]	; (14274 <init_allyojn+0x54>)
   1424c:	4798      	blx	r3
}
   1424e:	bd10      	pop	{r4, pc}
   14250:	00007fcd 	.word	0x00007fcd
   14254:	20000274 	.word	0x20000274
   14258:	00009785 	.word	0x00009785
   1425c:	000088e1 	.word	0x000088e1
   14260:	00013be1 	.word	0x00013be1
   14264:	00003a0d 	.word	0x00003a0d
   14268:	0000023d 	.word	0x0000023d
   1426c:	0000e1e5 	.word	0x0000e1e5
   14270:	00000511 	.word	0x00000511
   14274:	00001971 	.word	0x00001971

00014278 <millis>:

uint32_t millis(void)
{
	return ms_ticks;
   14278:	4b01      	ldr	r3, [pc, #4]	; (14280 <millis+0x8>)
   1427a:	6818      	ldr	r0, [r3, #0]
}
   1427c:	4770      	bx	lr
   1427e:	46c0      	nop			; (mov r8, r8)
   14280:	2000134c 	.word	0x2000134c

00014284 <LAMP_SendStateChangedSignal>:
    return AJ_OK;
}
void LAMP_SendStateChangedSignal(void)
{
	AJ_InfoPrintf(("%s\n", __func__));
	SendStateChanged = TRUE;
   14284:	2201      	movs	r2, #1
   14286:	4b01      	ldr	r3, [pc, #4]	; (1428c <LAMP_SendStateChangedSignal+0x8>)
   14288:	701a      	strb	r2, [r3, #0]
}
   1428a:	4770      	bx	lr
   1428c:	20002448 	.word	0x20002448

00014290 <main>:
 *
 * \return program return value.
 */

int main(void)
{
   14290:	b5f0      	push	{r4, r5, r6, r7, lr}
   14292:	464f      	mov	r7, r9
   14294:	b480      	push	{r7}
   14296:	b0c2      	sub	sp, #264	; 0x108
    AJ_Status status = AJ_OK;
   14298:	2300      	movs	r3, #0
   1429a:	2208      	movs	r2, #8
   1429c:	32ff      	adds	r2, #255	; 0xff
   1429e:	446a      	add	r2, sp
   142a0:	7013      	strb	r3, [r2, #0]
    AJ_Time timer;
    uint8_t connected = FALSE;
   142a2:	466a      	mov	r2, sp
   142a4:	3207      	adds	r2, #7
   142a6:	32ff      	adds	r2, #255	; 0xff
   142a8:	7013      	strb	r3, [r2, #0]
		
	uint16_t port;
	char* joiner;
	
	// Initialize the board. 
	system_init();
   142aa:	4bd5      	ldr	r3, [pc, #852]	; (14600 <main+0x370>)
   142ac:	4798      	blx	r3
    init_MC();
   142ae:	4bd5      	ldr	r3, [pc, #852]	; (14604 <main+0x374>)
   142b0:	4798      	blx	r3
	//Initialize the BSP. 	
	nm_bsp_init();
   142b2:	4bd5      	ldr	r3, [pc, #852]	; (14608 <main+0x378>)
   142b4:	4798      	blx	r3
	} else {
		port_base->OUTCLR.reg = pin_mask;
   142b6:	2280      	movs	r2, #128	; 0x80
   142b8:	05d2      	lsls	r2, r2, #23
   142ba:	4bd4      	ldr	r3, [pc, #848]	; (1460c <main+0x37c>)
   142bc:	615a      	str	r2, [r3, #20]
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> PM->CPUSEL.reg);
   142be:	2000      	movs	r0, #0
   142c0:	4bd3      	ldr	r3, [pc, #844]	; (14610 <main+0x380>)
   142c2:	4798      	blx	r3
   142c4:	4bd3      	ldr	r3, [pc, #844]	; (14614 <main+0x384>)
   142c6:	7a1b      	ldrb	r3, [r3, #8]
   142c8:	b2db      	uxtb	r3, r3
   142ca:	40d8      	lsrs	r0, r3
    port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
	// Enable SysTick interrupt for non busy wait delay.
	if (SysTick_Config(system_cpu_clock_get_hz() / 1000))
   142cc:	21fa      	movs	r1, #250	; 0xfa
   142ce:	0089      	lsls	r1, r1, #2
   142d0:	4bd1      	ldr	r3, [pc, #836]	; (14618 <main+0x388>)
   142d2:	4798      	blx	r3
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
   142d4:	3801      	subs	r0, #1
   142d6:	4bd1      	ldr	r3, [pc, #836]	; (1461c <main+0x38c>)
   142d8:	4298      	cmp	r0, r3
   142da:	d901      	bls.n	142e0 <main+0x50>
   142dc:	f000 fd78 	bl	14dd0 <main+0xb40>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
   142e0:	4acf      	ldr	r2, [pc, #828]	; (14620 <main+0x390>)
   142e2:	6050      	str	r0, [r2, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
   142e4:	49cf      	ldr	r1, [pc, #828]	; (14624 <main+0x394>)
   142e6:	6a0b      	ldr	r3, [r1, #32]
   142e8:	021b      	lsls	r3, r3, #8
   142ea:	0a1b      	lsrs	r3, r3, #8
   142ec:	20c0      	movs	r0, #192	; 0xc0
   142ee:	0600      	lsls	r0, r0, #24
   142f0:	4303      	orrs	r3, r0
   142f2:	620b      	str	r3, [r1, #32]
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
   142f4:	2300      	movs	r3, #0
   142f6:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
   142f8:	2107      	movs	r1, #7
   142fa:	6011      	str	r1, [r2, #0]
	   puts("main: SysTick configuration error!");
	   while (1);
    }

	// Initialize socket address structure.
	addr.sin_family = AF_INET;
   142fc:	4aca      	ldr	r2, [pc, #808]	; (14628 <main+0x398>)
   142fe:	2402      	movs	r4, #2
   14300:	8014      	strh	r4, [r2, #0]
	addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT);
   14302:	48ca      	ldr	r0, [pc, #808]	; (1462c <main+0x39c>)
   14304:	8050      	strh	r0, [r2, #2]
	addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP);
   14306:	49ca      	ldr	r1, [pc, #808]	; (14630 <main+0x3a0>)
   14308:	6051      	str	r1, [r2, #4]
		
	src_addr.sin_family = AF_INET;
   1430a:	4aca      	ldr	r2, [pc, #808]	; (14634 <main+0x3a4>)
   1430c:	8014      	strh	r4, [r2, #0]
	src_addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT);
   1430e:	8050      	strh	r0, [r2, #2]
	//_htons(52148);
	src_addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP);
   14310:	6051      	str	r1, [r2, #4]
				
	// Initialize Wi-Fi parameters structure.
	memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
   14312:	932c      	str	r3, [sp, #176]	; 0xb0
   14314:	932d      	str	r3, [sp, #180]	; 0xb4
   14316:	932e      	str	r3, [sp, #184]	; 0xb8
   14318:	932f      	str	r3, [sp, #188]	; 0xbc
   1431a:	9330      	str	r3, [sp, #192]	; 0xc0
	 // Initialize Wi-Fi driver with data and status callbacks.
    param.pfAppWifiCb = wifi_cb;
   1431c:	4bc6      	ldr	r3, [pc, #792]	; (14638 <main+0x3a8>)
   1431e:	932b      	str	r3, [sp, #172]	; 0xac
	ret = m2m_wifi_init(&param);
   14320:	a82b      	add	r0, sp, #172	; 0xac
   14322:	4bc6      	ldr	r3, [pc, #792]	; (1463c <main+0x3ac>)
   14324:	4798      	blx	r3
   14326:	1e01      	subs	r1, r0, #0
	if (M2M_SUCCESS != ret)
   14328:	d101      	bne.n	1432e <main+0x9e>
   1432a:	e004      	b.n	14336 <main+0xa6>
    port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
	// Enable SysTick interrupt for non busy wait delay.
	if (SysTick_Config(system_cpu_clock_get_hz() / 1000))
	{
	   puts("main: SysTick configuration error!");
	   while (1);
   1432c:	e7fe      	b.n	1432c <main+0x9c>
	 // Initialize Wi-Fi driver with data and status callbacks.
    param.pfAppWifiCb = wifi_cb;
	ret = m2m_wifi_init(&param);
	if (M2M_SUCCESS != ret)
	{
	   printf("main: m2m_wifi_init call error!(%d)\r\n", ret);
   1432e:	48c4      	ldr	r0, [pc, #784]	; (14640 <main+0x3b0>)
   14330:	4bc4      	ldr	r3, [pc, #784]	; (14644 <main+0x3b4>)
   14332:	4798      	blx	r3
	   while (1);
   14334:	e7fe      	b.n	14334 <main+0xa4>
	}
	// Initialize socket module
	socketInit();
   14336:	4bc4      	ldr	r3, [pc, #784]	; (14648 <main+0x3b8>)
   14338:	4798      	blx	r3
	registerSocketCallback(socket_cb, NULL);
   1433a:	48c4      	ldr	r0, [pc, #784]	; (1464c <main+0x3bc>)
   1433c:	2100      	movs	r1, #0
   1433e:	4bc4      	ldr	r3, [pc, #784]	; (14650 <main+0x3c0>)
   14340:	4798      	blx	r3

	// Connect to router.
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
   14342:	23ff      	movs	r3, #255	; 0xff
   14344:	9300      	str	r3, [sp, #0]
   14346:	48c3      	ldr	r0, [pc, #780]	; (14654 <main+0x3c4>)
   14348:	2107      	movs	r1, #7
   1434a:	2202      	movs	r2, #2
   1434c:	4bc2      	ldr	r3, [pc, #776]	; (14658 <main+0x3c8>)
   1434e:	4cc3      	ldr	r4, [pc, #780]	; (1465c <main+0x3cc>)
   14350:	47a0      	blx	r4
	printf("m2m_wifi_connect!\r\n");
   14352:	48c3      	ldr	r0, [pc, #780]	; (14660 <main+0x3d0>)
   14354:	4bc3      	ldr	r3, [pc, #780]	; (14664 <main+0x3d4>)
   14356:	4798      	blx	r3
    init_allyojn();
   14358:	4bc3      	ldr	r3, [pc, #780]	; (14668 <main+0x3d8>)
   1435a:	4798      	blx	r3
    
	while (1) 
	{
		if (rx_socket < 0)
   1435c:	4cc3      	ldr	r4, [pc, #780]	; (1466c <main+0x3dc>)
		   // Socket bind 
		   bind(rx_socket, (struct sockaddr *)&src_addr, sizeof(struct sockaddr_in));

		}
		// Handle pending events from network controller.
		m2m_wifi_handle_events(NULL);
   1435e:	4dc4      	ldr	r5, [pc, #784]	; (14670 <main+0x3e0>)
	printf("m2m_wifi_connect!\r\n");
    init_allyojn();
    
	while (1) 
	{
		if (rx_socket < 0)
   14360:	7823      	ldrb	r3, [r4, #0]
   14362:	2b7f      	cmp	r3, #127	; 0x7f
   14364:	d910      	bls.n	14388 <main+0xf8>
		{
		   if ((rx_socket = socket(AF_INET, SOCK_DGRAM, 0)) < 0) 
   14366:	2002      	movs	r0, #2
   14368:	2102      	movs	r1, #2
   1436a:	2200      	movs	r2, #0
   1436c:	4bc1      	ldr	r3, [pc, #772]	; (14674 <main+0x3e4>)
   1436e:	4798      	blx	r3
   14370:	4bbe      	ldr	r3, [pc, #760]	; (1466c <main+0x3dc>)
   14372:	7018      	strb	r0, [r3, #0]
   14374:	2800      	cmp	r0, #0
   14376:	da03      	bge.n	14380 <main+0xf0>
		   {
		      printf("main: failed to create RX UDP Client socket error!\r\n");
   14378:	48bf      	ldr	r0, [pc, #764]	; (14678 <main+0x3e8>)
   1437a:	4bba      	ldr	r3, [pc, #744]	; (14664 <main+0x3d4>)
   1437c:	4798      	blx	r3
			  continue;
   1437e:	e7ef      	b.n	14360 <main+0xd0>
		   }
		   // Socket bind 
		   bind(rx_socket, (struct sockaddr *)&src_addr, sizeof(struct sockaddr_in));
   14380:	49ac      	ldr	r1, [pc, #688]	; (14634 <main+0x3a4>)
   14382:	2210      	movs	r2, #16
   14384:	4bbd      	ldr	r3, [pc, #756]	; (1467c <main+0x3ec>)
   14386:	4798      	blx	r3

		}
		// Handle pending events from network controller.
		m2m_wifi_handle_events(NULL);
   14388:	2000      	movs	r0, #0
   1438a:	47a8      	blx	r5
	   

        if ((connected == FALSE))/*&&(wifi_connected == M2M_WIFI_CONNECTED)) */
   1438c:	466b      	mov	r3, sp
   1438e:	3307      	adds	r3, #7
   14390:	33ff      	adds	r3, #255	; 0xff
   14392:	781b      	ldrb	r3, [r3, #0]
   14394:	2b00      	cmp	r3, #0
   14396:	d12a      	bne.n	143ee <main+0x15e>
		{
		//	delay_ms(10000);
			printf("----!!!!CONNECTING STARTED!!!!----\n");
   14398:	48b9      	ldr	r0, [pc, #740]	; (14680 <main+0x3f0>)
   1439a:	4bb2      	ldr	r3, [pc, #712]	; (14664 <main+0x3d4>)
   1439c:	4798      	blx	r3
            status = AJSVC_RoutingNodeConnect(&Bus, routingNodePrefix, CONNECT_TIMEOUT, 2000, 60, &connected);
   1439e:	4bb9      	ldr	r3, [pc, #740]	; (14684 <main+0x3f4>)
   143a0:	6819      	ldr	r1, [r3, #0]
   143a2:	233c      	movs	r3, #60	; 0x3c
   143a4:	9300      	str	r3, [sp, #0]
   143a6:	466b      	mov	r3, sp
   143a8:	1dde      	adds	r6, r3, #7
   143aa:	36ff      	adds	r6, #255	; 0xff
   143ac:	9601      	str	r6, [sp, #4]
   143ae:	48b6      	ldr	r0, [pc, #728]	; (14688 <main+0x3f8>)
   143b0:	4ab6      	ldr	r2, [pc, #728]	; (1468c <main+0x3fc>)
   143b2:	23fa      	movs	r3, #250	; 0xfa
   143b4:	00db      	lsls	r3, r3, #3
   143b6:	4fb6      	ldr	r7, [pc, #728]	; (14690 <main+0x400>)
   143b8:	47b8      	blx	r7
   143ba:	2308      	movs	r3, #8
   143bc:	33ff      	adds	r3, #255	; 0xff
   143be:	446b      	add	r3, sp
   143c0:	7018      	strb	r0, [r3, #0]

            if (connected == FALSE) 
   143c2:	7833      	ldrb	r3, [r6, #0]
   143c4:	2b00      	cmp	r3, #0
   143c6:	d0cb      	beq.n	14360 <main+0xd0>
			{
                continue;
            }

            AJ_BusSetPasswordCallback(&Bus, LAMP_PasswordCallback);
   143c8:	4eaf      	ldr	r6, [pc, #700]	; (14688 <main+0x3f8>)
   143ca:	1c30      	adds	r0, r6, #0
   143cc:	49b1      	ldr	r1, [pc, #708]	; (14694 <main+0x404>)
   143ce:	4bb2      	ldr	r3, [pc, #712]	; (14698 <main+0x408>)
   143d0:	4798      	blx	r3
            AJ_SessionOpts session_opts = { AJ_SESSION_TRAFFIC_MESSAGES, AJ_SESSION_PROXIMITY_ANY, AJ_TRANSPORT_ANY, TRUE };
   143d2:	aa1b      	add	r2, sp, #108	; 0x6c
   143d4:	4bb1      	ldr	r3, [pc, #708]	; (1469c <main+0x40c>)
   143d6:	1c11      	adds	r1, r2, #0
   143d8:	cb81      	ldmia	r3!, {r0, r7}
   143da:	c181      	stmia	r1!, {r0, r7}
            // we need to bind the session port to run a service
            status = AJ_BusBindSessionPort(&Bus, LSF_ServicePort, &session_opts, 0);			
   143dc:	1c30      	adds	r0, r6, #0
   143de:	212a      	movs	r1, #42	; 0x2a
   143e0:	2300      	movs	r3, #0
   143e2:	4eaf      	ldr	r6, [pc, #700]	; (146a0 <main+0x410>)
   143e4:	47b0      	blx	r6
   143e6:	2308      	movs	r3, #8
   143e8:	33ff      	adds	r3, #255	; 0xff
   143ea:	446b      	add	r3, sp
   143ec:	7018      	strb	r0, [r3, #0]
        }

        // use a minimum two-second timeout to ensure the callback is *eventually* reached
        status = AJ_UnmarshalMsg(&Bus, &msg, UNMARSHAL_TIMEOUT);
   143ee:	48a6      	ldr	r0, [pc, #664]	; (14688 <main+0x3f8>)
   143f0:	a931      	add	r1, sp, #196	; 0xc4
   143f2:	4aac      	ldr	r2, [pc, #688]	; (146a4 <main+0x414>)
   143f4:	4bac      	ldr	r3, [pc, #688]	; (146a8 <main+0x418>)
   143f6:	4798      	blx	r3
   143f8:	2308      	movs	r3, #8
   143fa:	33ff      	adds	r3, #255	; 0xff
   143fc:	446b      	add	r3, sp
   143fe:	7018      	strb	r0, [r3, #0]
        if (status == AJ_OK) 
   14400:	2800      	cmp	r0, #0
   14402:	d001      	beq.n	14408 <main+0x178>
   14404:	f000 fbf1 	bl	14bea <main+0x95a>
		{
            switch (msg.msgId) 
   14408:	9b31      	ldr	r3, [sp, #196]	; 0xc4
   1440a:	4aa8      	ldr	r2, [pc, #672]	; (146ac <main+0x41c>)
   1440c:	4293      	cmp	r3, r2
   1440e:	d100      	bne.n	14412 <main+0x182>
   14410:	e1a2      	b.n	14758 <main+0x4c8>
   14412:	d808      	bhi.n	14426 <main+0x196>
   14414:	4aa6      	ldr	r2, [pc, #664]	; (146b0 <main+0x420>)
   14416:	4293      	cmp	r3, r2
   14418:	d100      	bne.n	1441c <main+0x18c>
   1441a:	e1c9      	b.n	147b0 <main+0x520>
   1441c:	2280      	movs	r2, #128	; 0x80
   1441e:	0292      	lsls	r2, r2, #10
   14420:	4293      	cmp	r3, r2
   14422:	d03d      	beq.n	144a0 <main+0x210>
   14424:	e1db      	b.n	147de <main+0x54e>
   14426:	4aa3      	ldr	r2, [pc, #652]	; (146b4 <main+0x424>)
   14428:	4293      	cmp	r3, r2
   1442a:	d012      	beq.n	14452 <main+0x1c2>
   1442c:	4aa2      	ldr	r2, [pc, #648]	; (146b8 <main+0x428>)
   1442e:	4293      	cmp	r3, r2
   14430:	d100      	bne.n	14434 <main+0x1a4>
   14432:	e1a7      	b.n	14784 <main+0x4f4>
   14434:	4aa1      	ldr	r2, [pc, #644]	; (146bc <main+0x42c>)
   14436:	4293      	cmp	r3, r2
   14438:	d000      	beq.n	1443c <main+0x1ac>
   1443a:	e1d0      	b.n	147de <main+0x54e>
			{

            case AJ_REPLY_ID(AJ_METHOD_ADD_MATCH):
                if (msg.hdr->msgType == AJ_MSG_ERROR) 
   1443c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
   1443e:	785b      	ldrb	r3, [r3, #1]
   14440:	2b03      	cmp	r3, #3
   14442:	d000      	beq.n	14446 <main+0x1b6>
   14444:	e3cf      	b.n	14be6 <main+0x956>
				{
                    AJ_InfoPrintf(("%s: Failed to add match\n", __func__));
                    status = AJ_ERR_FAILURE;
   14446:	2213      	movs	r2, #19
   14448:	2308      	movs	r3, #8
   1444a:	33ff      	adds	r3, #255	; 0xff
   1444c:	446b      	add	r3, sp
   1444e:	701a      	strb	r2, [r3, #0]
   14450:	e3c9      	b.n	14be6 <main+0x956>
                    status = AJ_OK;
                }
                break;

            case AJ_REPLY_ID(AJ_METHOD_BIND_SESSION_PORT):
                if (msg.hdr->msgType == AJ_MSG_ERROR) 
   14452:	9b32      	ldr	r3, [sp, #200]	; 0xc8
   14454:	785b      	ldrb	r3, [r3, #1]
   14456:	2b03      	cmp	r3, #3
   14458:	d111      	bne.n	1447e <main+0x1ee>
				{
                    AJ_ErrPrintf(("%s: AJ_METHOD_BIND_SESSION_PORT: AJ_ERR_FAILURE\n", __func__));
   1445a:	2001      	movs	r0, #1
   1445c:	4998      	ldr	r1, [pc, #608]	; (146c0 <main+0x430>)
   1445e:	2298      	movs	r2, #152	; 0x98
   14460:	00d2      	lsls	r2, r2, #3
   14462:	4b98      	ldr	r3, [pc, #608]	; (146c4 <main+0x434>)
   14464:	4798      	blx	r3
   14466:	2800      	cmp	r0, #0
   14468:	d003      	beq.n	14472 <main+0x1e2>
   1446a:	4897      	ldr	r0, [pc, #604]	; (146c8 <main+0x438>)
   1446c:	4997      	ldr	r1, [pc, #604]	; (146cc <main+0x43c>)
   1446e:	4b75      	ldr	r3, [pc, #468]	; (14644 <main+0x3b4>)
   14470:	4798      	blx	r3
                    status = AJ_ERR_FAILURE;
   14472:	2213      	movs	r2, #19
   14474:	2308      	movs	r3, #8
   14476:	33ff      	adds	r3, #255	; 0xff
   14478:	446b      	add	r3, sp
   1447a:	701a      	strb	r2, [r3, #0]
   1447c:	e3b3      	b.n	14be6 <main+0x956>
                }
				else
				{
                    printf("%s: AJ_BusRequestName()\n", __func__);
   1447e:	4e93      	ldr	r6, [pc, #588]	; (146cc <main+0x43c>)
   14480:	4893      	ldr	r0, [pc, #588]	; (146d0 <main+0x440>)
   14482:	1c31      	adds	r1, r6, #0
   14484:	4f6f      	ldr	r7, [pc, #444]	; (14644 <main+0x3b4>)
   14486:	47b8      	blx	r7
                    // announce now
                    printf("%s: Initializing About!\n", __func__);
   14488:	4892      	ldr	r0, [pc, #584]	; (146d4 <main+0x444>)
   1448a:	1c31      	adds	r1, r6, #0
   1448c:	47b8      	blx	r7
                    status = AJ_AboutInit(&Bus, LSF_ServicePort);
   1448e:	487e      	ldr	r0, [pc, #504]	; (14688 <main+0x3f8>)
   14490:	212a      	movs	r1, #42	; 0x2a
   14492:	4b91      	ldr	r3, [pc, #580]	; (146d8 <main+0x448>)
   14494:	4798      	blx	r3
   14496:	2308      	movs	r3, #8
   14498:	33ff      	adds	r3, #255	; 0xff
   1449a:	446b      	add	r3, sp
   1449c:	7018      	strb	r0, [r3, #0]
   1449e:	e3a2      	b.n	14be6 <main+0x956>
                }
                break;

            case AJ_METHOD_ACCEPT_SESSION:
                {
                    printf("%s: Got Accept Session\n", __func__);
   144a0:	488e      	ldr	r0, [pc, #568]	; (146dc <main+0x44c>)
   144a2:	498a      	ldr	r1, [pc, #552]	; (146cc <main+0x43c>)
   144a4:	4b67      	ldr	r3, [pc, #412]	; (14644 <main+0x3b4>)
   144a6:	4798      	blx	r3
                    uint16_t port;
                    uint32_t session;
                    char* joiner;
                    AJ_UnmarshalArgs(&msg, "qus", &port, &session, &joiner);
   144a8:	2616      	movs	r6, #22
   144aa:	446e      	add	r6, sp
   144ac:	ab07      	add	r3, sp, #28
   144ae:	9300      	str	r3, [sp, #0]
   144b0:	a831      	add	r0, sp, #196	; 0xc4
   144b2:	498b      	ldr	r1, [pc, #556]	; (146e0 <main+0x450>)
   144b4:	1c32      	adds	r2, r6, #0
   144b6:	ab06      	add	r3, sp, #24
   144b8:	4f8a      	ldr	r7, [pc, #552]	; (146e4 <main+0x454>)
   144ba:	47b8      	blx	r7

                    if (port == LSF_ServicePort) 
   144bc:	8833      	ldrh	r3, [r6, #0]
   144be:	2b2a      	cmp	r3, #42	; 0x2a
   144c0:	d000      	beq.n	144c4 <main+0x234>
   144c2:	e139      	b.n	14738 <main+0x4a8>
	return serv_status;
}
static AJ_Status ParseOptions(AJ_SessionOpts* opts, AJ_Message* msg)
{
	AJ_Arg array1, struct1;
	AJ_Status status = AJ_UnmarshalContainer(msg, &array1, AJ_ARG_ARRAY);
   144c4:	a831      	add	r0, sp, #196	; 0xc4
   144c6:	a915      	add	r1, sp, #84	; 0x54
   144c8:	2261      	movs	r2, #97	; 0x61
   144ca:	4b87      	ldr	r3, [pc, #540]	; (146e8 <main+0x458>)
   144cc:	4798      	blx	r3

	do {
		char* field;
		char* sig;

		status = AJ_UnmarshalContainer(msg, &struct1, AJ_ARG_DICT_ENTRY);
   144ce:	4f86      	ldr	r7, [pc, #536]	; (146e8 <main+0x458>)
		if (status != AJ_OK) 
		{
			break;
		}

		status = AJ_UnmarshalArgs(msg, "s", &field);
   144d0:	4b84      	ldr	r3, [pc, #528]	; (146e4 <main+0x454>)
   144d2:	4699      	mov	r9, r3

	do {
		char* field;
		char* sig;

		status = AJ_UnmarshalContainer(msg, &struct1, AJ_ARG_DICT_ENTRY);
   144d4:	a831      	add	r0, sp, #196	; 0xc4
   144d6:	a91b      	add	r1, sp, #108	; 0x6c
   144d8:	227b      	movs	r2, #123	; 0x7b
   144da:	47b8      	blx	r7
		if (status != AJ_OK) 
   144dc:	2800      	cmp	r0, #0
   144de:	d170      	bne.n	145c2 <main+0x332>
		{
			break;
		}

		status = AJ_UnmarshalArgs(msg, "s", &field);
   144e0:	a831      	add	r0, sp, #196	; 0xc4
   144e2:	4982      	ldr	r1, [pc, #520]	; (146ec <main+0x45c>)
   144e4:	aa08      	add	r2, sp, #32
   144e6:	47c8      	blx	r9
   144e8:	1e06      	subs	r6, r0, #0
		if (status != AJ_OK)
   144ea:	d00f      	beq.n	1450c <main+0x27c>
		{
			AJ_ErrPrintf(("AJ_UnmarshalArgs: %s\n", AJ_StatusText(status)));
   144ec:	2001      	movs	r0, #1
   144ee:	4974      	ldr	r1, [pc, #464]	; (146c0 <main+0x430>)
   144f0:	22f7      	movs	r2, #247	; 0xf7
   144f2:	0092      	lsls	r2, r2, #2
   144f4:	4b73      	ldr	r3, [pc, #460]	; (146c4 <main+0x434>)
   144f6:	4798      	blx	r3
   144f8:	2800      	cmp	r0, #0
   144fa:	d062      	beq.n	145c2 <main+0x332>
   144fc:	1c30      	adds	r0, r6, #0
   144fe:	4b7c      	ldr	r3, [pc, #496]	; (146f0 <main+0x460>)
   14500:	4798      	blx	r3
   14502:	1c01      	adds	r1, r0, #0
   14504:	487b      	ldr	r0, [pc, #492]	; (146f4 <main+0x464>)
   14506:	4b4f      	ldr	r3, [pc, #316]	; (14644 <main+0x3b4>)
   14508:	4798      	blx	r3
   1450a:	e05a      	b.n	145c2 <main+0x332>
			break;
		}

		// Process the field!
		status = AJ_UnmarshalVariant(msg, (const char**) &sig);
   1450c:	a831      	add	r0, sp, #196	; 0xc4
   1450e:	a909      	add	r1, sp, #36	; 0x24
   14510:	4b79      	ldr	r3, [pc, #484]	; (146f8 <main+0x468>)
   14512:	4798      	blx	r3
   14514:	1e06      	subs	r6, r0, #0
		if (status != AJ_OK) 
   14516:	d00f      	beq.n	14538 <main+0x2a8>
		{
			AJ_ErrPrintf(("AJ_UnmarshalVariant: %s\n", AJ_StatusText(status)));
   14518:	2001      	movs	r0, #1
   1451a:	4969      	ldr	r1, [pc, #420]	; (146c0 <main+0x430>)
   1451c:	22f9      	movs	r2, #249	; 0xf9
   1451e:	0092      	lsls	r2, r2, #2
   14520:	4b68      	ldr	r3, [pc, #416]	; (146c4 <main+0x434>)
   14522:	4798      	blx	r3
   14524:	2800      	cmp	r0, #0
   14526:	d04c      	beq.n	145c2 <main+0x332>
   14528:	1c30      	adds	r0, r6, #0
   1452a:	4b71      	ldr	r3, [pc, #452]	; (146f0 <main+0x460>)
   1452c:	4798      	blx	r3
   1452e:	1c01      	adds	r1, r0, #0
   14530:	4872      	ldr	r0, [pc, #456]	; (146fc <main+0x46c>)
   14532:	4b44      	ldr	r3, [pc, #272]	; (14644 <main+0x3b4>)
   14534:	4798      	blx	r3
   14536:	e044      	b.n	145c2 <main+0x332>
			break;
		}

		if (0 == strcmp(field, "traf"))
   14538:	9e08      	ldr	r6, [sp, #32]
   1453a:	1c30      	adds	r0, r6, #0
   1453c:	4970      	ldr	r1, [pc, #448]	; (14700 <main+0x470>)
   1453e:	4b71      	ldr	r3, [pc, #452]	; (14704 <main+0x474>)
   14540:	4798      	blx	r3
   14542:	2800      	cmp	r0, #0
   14544:	d108      	bne.n	14558 <main+0x2c8>
	    {
			uint32_t traf;
			status = AJ_UnmarshalArgs(msg, "y", &traf);
   14546:	a831      	add	r0, sp, #196	; 0xc4
   14548:	496f      	ldr	r1, [pc, #444]	; (14708 <main+0x478>)
   1454a:	aa0a      	add	r2, sp, #40	; 0x28
   1454c:	4b65      	ldr	r3, [pc, #404]	; (146e4 <main+0x454>)
   1454e:	4798      	blx	r3
			opts->traffic = traf;
   14550:	ab0e      	add	r3, sp, #56	; 0x38
   14552:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14554:	701a      	strb	r2, [r3, #0]
   14556:	e02e      	b.n	145b6 <main+0x326>
		}
	    else if (0 == strcmp(field, "multi")) 
   14558:	1c30      	adds	r0, r6, #0
   1455a:	496c      	ldr	r1, [pc, #432]	; (1470c <main+0x47c>)
   1455c:	4b69      	ldr	r3, [pc, #420]	; (14704 <main+0x474>)
   1455e:	4798      	blx	r3
   14560:	2800      	cmp	r0, #0
   14562:	d109      	bne.n	14578 <main+0x2e8>
		{
			uint32_t multi;
			status = AJ_UnmarshalArgs(msg, "b", &multi);
   14564:	a831      	add	r0, sp, #196	; 0xc4
   14566:	496a      	ldr	r1, [pc, #424]	; (14710 <main+0x480>)
   14568:	aa0a      	add	r2, sp, #40	; 0x28
   1456a:	4b5e      	ldr	r3, [pc, #376]	; (146e4 <main+0x454>)
   1456c:	4798      	blx	r3
			opts->isMultipoint = multi ? TRUE : FALSE;
   1456e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14570:	1e5a      	subs	r2, r3, #1
   14572:	4193      	sbcs	r3, r2
   14574:	930f      	str	r3, [sp, #60]	; 0x3c
   14576:	e01e      	b.n	145b6 <main+0x326>
		} 
		else if (0 == strcmp(field, "prox")) 
   14578:	1c30      	adds	r0, r6, #0
   1457a:	4966      	ldr	r1, [pc, #408]	; (14714 <main+0x484>)
   1457c:	4b61      	ldr	r3, [pc, #388]	; (14704 <main+0x474>)
   1457e:	4798      	blx	r3
   14580:	2800      	cmp	r0, #0
   14582:	d108      	bne.n	14596 <main+0x306>
		{
			uint32_t prox;
			status = AJ_UnmarshalArgs(msg, "y", &prox);
   14584:	a831      	add	r0, sp, #196	; 0xc4
   14586:	4960      	ldr	r1, [pc, #384]	; (14708 <main+0x478>)
   14588:	aa0a      	add	r2, sp, #40	; 0x28
   1458a:	4b56      	ldr	r3, [pc, #344]	; (146e4 <main+0x454>)
   1458c:	4798      	blx	r3
			opts->proximity = prox;
   1458e:	ab0e      	add	r3, sp, #56	; 0x38
   14590:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14592:	705a      	strb	r2, [r3, #1]
   14594:	e00f      	b.n	145b6 <main+0x326>
		}
		else if (0 == strcmp(field, "trans")) 
   14596:	1c30      	adds	r0, r6, #0
   14598:	495f      	ldr	r1, [pc, #380]	; (14718 <main+0x488>)
   1459a:	4b5a      	ldr	r3, [pc, #360]	; (14704 <main+0x474>)
   1459c:	4798      	blx	r3
   1459e:	2800      	cmp	r0, #0
   145a0:	d106      	bne.n	145b0 <main+0x320>
		{
			status = AJ_UnmarshalArgs(msg, "q", &opts->transports);
   145a2:	a831      	add	r0, sp, #196	; 0xc4
   145a4:	495d      	ldr	r1, [pc, #372]	; (1471c <main+0x48c>)
   145a6:	223a      	movs	r2, #58	; 0x3a
   145a8:	446a      	add	r2, sp
   145aa:	4b4e      	ldr	r3, [pc, #312]	; (146e4 <main+0x454>)
   145ac:	4798      	blx	r3
   145ae:	e002      	b.n	145b6 <main+0x326>
		} 
		else 
		{
			// don't print becuase this isn't really an error
			AJ_SkipArg(msg);
   145b0:	a831      	add	r0, sp, #196	; 0xc4
   145b2:	4b5b      	ldr	r3, [pc, #364]	; (14720 <main+0x490>)
   145b4:	4798      	blx	r3
		}

		status = AJ_UnmarshalCloseContainer(msg, &struct1);
   145b6:	a831      	add	r0, sp, #196	; 0xc4
   145b8:	a91b      	add	r1, sp, #108	; 0x6c
   145ba:	4b5a      	ldr	r3, [pc, #360]	; (14724 <main+0x494>)
   145bc:	4798      	blx	r3
		// if field invalid, throw the whole thing out and return the error
	} while (status == AJ_OK);
   145be:	2800      	cmp	r0, #0
   145c0:	d088      	beq.n	144d4 <main+0x244>

	AJ_UnmarshalCloseContainer(msg, &array1);
   145c2:	a831      	add	r0, sp, #196	; 0xc4
   145c4:	a915      	add	r1, sp, #84	; 0x54
   145c6:	4b57      	ldr	r3, [pc, #348]	; (14724 <main+0x494>)
   145c8:	4798      	blx	r3
                    if (port == LSF_ServicePort) 
					{
                        AJ_SessionOpts opts;
                        ParseOptions(&opts, &msg);

                        if (opts.isMultipoint) 
   145ca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   145cc:	2b00      	cmp	r3, #0
   145ce:	d008      	beq.n	145e2 <main+0x352>
						{
                            ControllerSessionID = session;
   145d0:	4b55      	ldr	r3, [pc, #340]	; (14728 <main+0x498>)
   145d2:	9a06      	ldr	r2, [sp, #24]
   145d4:	601a      	str	r2, [r3, #0]
                            printf("%s: Accepted multipoint session id=%u from joiner=%s\n", __func__, session, joiner);
   145d6:	4855      	ldr	r0, [pc, #340]	; (1472c <main+0x49c>)
   145d8:	493c      	ldr	r1, [pc, #240]	; (146cc <main+0x43c>)
   145da:	9b07      	ldr	r3, [sp, #28]
   145dc:	4e19      	ldr	r6, [pc, #100]	; (14644 <main+0x3b4>)
   145de:	47b0      	blx	r6
   145e0:	e005      	b.n	145ee <main+0x35e>
                        }
						else
						{
                           printf("%s: Accepted session id=%u from joiner=%s\n", __func__, session, joiner);
   145e2:	4853      	ldr	r0, [pc, #332]	; (14730 <main+0x4a0>)
   145e4:	4939      	ldr	r1, [pc, #228]	; (146cc <main+0x43c>)
   145e6:	9a06      	ldr	r2, [sp, #24]
   145e8:	9b07      	ldr	r3, [sp, #28]
   145ea:	4e16      	ldr	r6, [pc, #88]	; (14644 <main+0x3b4>)
   145ec:	47b0      	blx	r6
                        }

                        status = AJ_BusReplyAcceptSession(&msg, TRUE);
   145ee:	a831      	add	r0, sp, #196	; 0xc4
   145f0:	2101      	movs	r1, #1
   145f2:	4b50      	ldr	r3, [pc, #320]	; (14734 <main+0x4a4>)
   145f4:	4798      	blx	r3
   145f6:	2308      	movs	r3, #8
   145f8:	33ff      	adds	r3, #255	; 0xff
   145fa:	446b      	add	r3, sp
   145fc:	7018      	strb	r0, [r3, #0]
   145fe:	e2f2      	b.n	14be6 <main+0x956>
   14600:	00013a59 	.word	0x00013a59
   14604:	0000f839 	.word	0x0000f839
   14608:	00010619 	.word	0x00010619
   1460c:	41004480 	.word	0x41004480
   14610:	00013815 	.word	0x00013815
   14614:	40000400 	.word	0x40000400
   14618:	00014e9d 	.word	0x00014e9d
   1461c:	00ffffff 	.word	0x00ffffff
   14620:	e000e010 	.word	0xe000e010
   14624:	e000ed00 	.word	0xe000ed00
   14628:	20002c48 	.word	0x20002c48
   1462c:	ffffe914 	.word	0xffffe914
   14630:	ff14a8c0 	.word	0xff14a8c0
   14634:	20002c38 	.word	0x20002c38
   14638:	00013d7d 	.word	0x00013d7d
   1463c:	00011421 	.word	0x00011421
   14640:	000214b8 	.word	0x000214b8
   14644:	00016e3d 	.word	0x00016e3d
   14648:	00012c59 	.word	0x00012c59
   1464c:	00013bf9 	.word	0x00013bf9
   14650:	00012c9d 	.word	0x00012c9d
   14654:	0002146c 	.word	0x0002146c
   14658:	00021474 	.word	0x00021474
   1465c:	00011689 	.word	0x00011689
   14660:	000214e0 	.word	0x000214e0
   14664:	00016f5d 	.word	0x00016f5d
   14668:	00014221 	.word	0x00014221
   1466c:	20000271 	.word	0x20000271
   14670:	0001147d 	.word	0x0001147d
   14674:	00012cb1 	.word	0x00012cb1
   14678:	000214f4 	.word	0x000214f4
   1467c:	00012d75 	.word	0x00012d75
   14680:	00021528 	.word	0x00021528
   14684:	20000000 	.word	0x20000000
   14688:	20002c58 	.word	0x20002c58
   1468c:	000f4240 	.word	0x000f4240
   14690:	0000ec45 	.word	0x0000ec45
   14694:	000001d5 	.word	0x000001d5
   14698:	000030b5 	.word	0x000030b5
   1469c:	000212b8 	.word	0x000212b8
   146a0:	000028f9 	.word	0x000028f9
   146a4:	00001388 	.word	0x00001388
   146a8:	0000acb5 	.word	0x0000acb5
   146ac:	00020001 	.word	0x00020001
   146b0:	00010011 	.word	0x00010011
   146b4:	80010008 	.word	0x80010008
   146b8:	8001000f 	.word	0x8001000f
   146bc:	80000006 	.word	0x80000006
   146c0:	0002154c 	.word	0x0002154c
   146c4:	0000636d 	.word	0x0000636d
   146c8:	0002155c 	.word	0x0002155c
   146cc:	00021318 	.word	0x00021318
   146d0:	00021590 	.word	0x00021590
   146d4:	000215ac 	.word	0x000215ac
   146d8:	00001899 	.word	0x00001899
   146dc:	000215c8 	.word	0x000215c8
   146e0:	000215e0 	.word	0x000215e0
   146e4:	0000b5f5 	.word	0x0000b5f5
   146e8:	0000a951 	.word	0x0000a951
   146ec:	0001f054 	.word	0x0001f054
   146f0:	000063c5 	.word	0x000063c5
   146f4:	0001849c 	.word	0x0001849c
   146f8:	0000b319 	.word	0x0000b319
   146fc:	000184e0 	.word	0x000184e0
   14700:	0001a4d4 	.word	0x0001a4d4
   14704:	00017137 	.word	0x00017137
   14708:	0001ccb0 	.word	0x0001ccb0
   1470c:	0001a4dc 	.word	0x0001a4dc
   14710:	0001ed84 	.word	0x0001ed84
   14714:	0001a4e4 	.word	0x0001a4e4
   14718:	0001a4ec 	.word	0x0001a4ec
   1471c:	0001eda8 	.word	0x0001eda8
   14720:	0000aae5 	.word	0x0000aae5
   14724:	0000a9d9 	.word	0x0000a9d9
   14728:	20001344 	.word	0x20001344
   1472c:	000215e4 	.word	0x000215e4
   14730:	0002161c 	.word	0x0002161c
   14734:	00002ba9 	.word	0x00002ba9
                    } 
					else
					{
                        status = AJ_BusReplyAcceptSession(&msg, FALSE);
   14738:	a831      	add	r0, sp, #196	; 0xc4
   1473a:	2100      	movs	r1, #0
   1473c:	4bd7      	ldr	r3, [pc, #860]	; (14a9c <main+0x80c>)
   1473e:	4798      	blx	r3
   14740:	2308      	movs	r3, #8
   14742:	33ff      	adds	r3, #255	; 0xff
   14744:	446b      	add	r3, sp
   14746:	7018      	strb	r0, [r3, #0]
                        printf("%s: Accepted rejected session_id=%u joiner=%s\n", __func__, ControllerSessionID, joiner);
   14748:	4bd5      	ldr	r3, [pc, #852]	; (14aa0 <main+0x810>)
   1474a:	681a      	ldr	r2, [r3, #0]
   1474c:	48d5      	ldr	r0, [pc, #852]	; (14aa4 <main+0x814>)
   1474e:	49d6      	ldr	r1, [pc, #856]	; (14aa8 <main+0x818>)
   14750:	9b07      	ldr	r3, [sp, #28]
   14752:	4ed6      	ldr	r6, [pc, #856]	; (14aac <main+0x81c>)
   14754:	47b0      	blx	r6
   14756:	e246      	b.n	14be6 <main+0x956>

                    break;
                }

            case AJ_SIGNAL_SESSION_JOINED:
                printf("@@@@@@@@@@@@@@@%s: Got Session Joined@@@@@@@@@@@@@@\n", __func__);
   14758:	48d5      	ldr	r0, [pc, #852]	; (14ab0 <main+0x820>)
   1475a:	49d3      	ldr	r1, [pc, #844]	; (14aa8 <main+0x818>)
   1475c:	4bd3      	ldr	r3, [pc, #844]	; (14aac <main+0x81c>)
   1475e:	4798      	blx	r3
                uint16_t port;
                uint32_t session;
                char* joiner;
                status = AJ_UnmarshalArgs(&msg, "qus", &port, &session, &joiner);
   14760:	ab1b      	add	r3, sp, #108	; 0x6c
   14762:	9300      	str	r3, [sp, #0]
   14764:	a831      	add	r0, sp, #196	; 0xc4
   14766:	49d3      	ldr	r1, [pc, #844]	; (14ab4 <main+0x824>)
   14768:	aa0e      	add	r2, sp, #56	; 0x38
   1476a:	ab15      	add	r3, sp, #84	; 0x54
   1476c:	4ed2      	ldr	r6, [pc, #840]	; (14ab8 <main+0x828>)
   1476e:	47b0      	blx	r6
   14770:	2308      	movs	r3, #8
   14772:	33ff      	adds	r3, #255	; 0xff
   14774:	446b      	add	r3, sp
   14776:	7018      	strb	r0, [r3, #0]
                // Set a link timeout of LSF_MIN_LINK_TIMEOUT_IN_SECONDS on the accepted session
                AJ_BusSetLinkTimeout(&Bus, session, LSF_MIN_LINK_TIMEOUT_IN_SECONDS);
   14778:	48d0      	ldr	r0, [pc, #832]	; (14abc <main+0x82c>)
   1477a:	9915      	ldr	r1, [sp, #84]	; 0x54
   1477c:	2228      	movs	r2, #40	; 0x28
   1477e:	4bd0      	ldr	r3, [pc, #832]	; (14ac0 <main+0x830>)
   14780:	4798      	blx	r3
                break;
   14782:	e230      	b.n	14be6 <main+0x956>

            case AJ_REPLY_ID(AJ_METHOD_SET_LINK_TIMEOUT):
                {
                    uint32_t disposition;
                    uint32_t timeout;
                    status = AJ_UnmarshalArgs(&msg, "uu", &disposition, &timeout);
   14784:	a831      	add	r0, sp, #196	; 0xc4
   14786:	49cf      	ldr	r1, [pc, #828]	; (14ac4 <main+0x834>)
   14788:	aa15      	add	r2, sp, #84	; 0x54
   1478a:	ab1b      	add	r3, sp, #108	; 0x6c
   1478c:	4eca      	ldr	r6, [pc, #808]	; (14ab8 <main+0x828>)
   1478e:	47b0      	blx	r6
   14790:	2308      	movs	r3, #8
   14792:	33ff      	adds	r3, #255	; 0xff
   14794:	446b      	add	r3, sp
   14796:	7018      	strb	r0, [r3, #0]
                    if (disposition == AJ_SETLINKTIMEOUT_SUCCESS) 
   14798:	9915      	ldr	r1, [sp, #84]	; 0x54
   1479a:	2901      	cmp	r1, #1
   1479c:	d104      	bne.n	147a8 <main+0x518>
					{
                        AJ_AlwaysPrintf(("Link timeout set to %d\n", timeout));
   1479e:	48ca      	ldr	r0, [pc, #808]	; (14ac8 <main+0x838>)
   147a0:	991b      	ldr	r1, [sp, #108]	; 0x6c
   147a2:	4bc2      	ldr	r3, [pc, #776]	; (14aac <main+0x81c>)
   147a4:	4798      	blx	r3
   147a6:	e21e      	b.n	14be6 <main+0x956>
                    }
					else
					{
                        AJ_AlwaysPrintf(("SetLinkTimeout failed %d\n", disposition));
   147a8:	48c8      	ldr	r0, [pc, #800]	; (14acc <main+0x83c>)
   147aa:	4bc0      	ldr	r3, [pc, #768]	; (14aac <main+0x81c>)
   147ac:	4798      	blx	r3
                    }
                }
                break;
   147ae:	e21a      	b.n	14be6 <main+0x956>

            case AJ_SIGNAL_SESSION_LOST_WITH_REASON:
                {
                    // this might not be an error.
                    uint32_t sessionId, reason;
                    AJ_UnmarshalArgs(&msg, "uu", &sessionId, &reason);
   147b0:	a831      	add	r0, sp, #196	; 0xc4
   147b2:	49c4      	ldr	r1, [pc, #784]	; (14ac4 <main+0x834>)
   147b4:	aa15      	add	r2, sp, #84	; 0x54
   147b6:	ab1b      	add	r3, sp, #108	; 0x6c
   147b8:	4ebf      	ldr	r6, [pc, #764]	; (14ab8 <main+0x828>)
   147ba:	47b0      	blx	r6

                    if (sessionId == ControllerSessionID) 
   147bc:	4bb8      	ldr	r3, [pc, #736]	; (14aa0 <main+0x810>)
   147be:	681b      	ldr	r3, [r3, #0]
   147c0:	9a15      	ldr	r2, [sp, #84]	; 0x54
   147c2:	429a      	cmp	r2, r3
   147c4:	d000      	beq.n	147c8 <main+0x538>
   147c6:	e20e      	b.n	14be6 <main+0x956>
					{
                        // we don't care if a point-to-point session is lost
                        ControllerSessionID = 0;
   147c8:	2300      	movs	r3, #0
   147ca:	4ab5      	ldr	r2, [pc, #724]	; (14aa0 <main+0x810>)
   147cc:	6013      	str	r3, [r2, #0]
                        SendStateChanged = FALSE;
   147ce:	4ac0      	ldr	r2, [pc, #768]	; (14ad0 <main+0x840>)
   147d0:	7013      	strb	r3, [r2, #0]
                        status = AJ_ERR_SESSION_LOST;
   147d2:	221b      	movs	r2, #27
   147d4:	2308      	movs	r3, #8
   147d6:	33ff      	adds	r3, #255	; 0xff
   147d8:	446b      	add	r3, sp
   147da:	701a      	strb	r2, [r3, #0]
   147dc:	e203      	b.n	14be6 <main+0x956>
                }

            default:
                {
                    // try to process with Config
                    AJSVC_ServiceStatus serv_status = AJCFG_MessageProcessor(&Bus, &msg, &status);
   147de:	2608      	movs	r6, #8
   147e0:	36ff      	adds	r6, #255	; 0xff
   147e2:	446e      	add	r6, sp
   147e4:	48b5      	ldr	r0, [pc, #724]	; (14abc <main+0x82c>)
   147e6:	a931      	add	r1, sp, #196	; 0xc4
   147e8:	1c32      	adds	r2, r6, #0
   147ea:	4bba      	ldr	r3, [pc, #744]	; (14ad4 <main+0x844>)
   147ec:	4798      	blx	r3
   147ee:	1c07      	adds	r7, r0, #0
					printf("AJCFG_MessageProcessor status= %s\n",AJ_StatusText(status));
   147f0:	7830      	ldrb	r0, [r6, #0]
   147f2:	4bb9      	ldr	r3, [pc, #740]	; (14ad8 <main+0x848>)
   147f4:	4798      	blx	r3
   147f6:	1c01      	adds	r1, r0, #0
   147f8:	48b8      	ldr	r0, [pc, #736]	; (14adc <main+0x84c>)
   147fa:	4bac      	ldr	r3, [pc, #688]	; (14aac <main+0x81c>)
   147fc:	4798      	blx	r3
                    if (serv_status == AJSVC_SERVICE_STATUS_NOT_HANDLED) 
					{
                        serv_status = AJOBS_MessageProcessor(&Bus, &msg, &status);
                    }
#endif
                    if (serv_status == AJSVC_SERVICE_STATUS_NOT_HANDLED) 
   147fe:	2f01      	cmp	r7, #1
   14800:	d000      	beq.n	14804 <main+0x574>
   14802:	e1f0      	b.n	14be6 <main+0x956>
					{
                        // let the notification produer object attempt to handle this message
                        serv_status = AJNS_Producer_MessageProcessor(&Bus, &msg, &status);
   14804:	48ad      	ldr	r0, [pc, #692]	; (14abc <main+0x82c>)
   14806:	a931      	add	r1, sp, #196	; 0xc4
   14808:	2208      	movs	r2, #8
   1480a:	32ff      	adds	r2, #255	; 0xff
   1480c:	446a      	add	r2, sp
   1480e:	4bb4      	ldr	r3, [pc, #720]	; (14ae0 <main+0x850>)
   14810:	4798      	blx	r3
                    }

                    if (serv_status == AJSVC_SERVICE_STATUS_NOT_HANDLED) 
   14812:	2801      	cmp	r0, #1
   14814:	d000      	beq.n	14818 <main+0x588>
   14816:	e1e6      	b.n	14be6 <main+0x956>
	AJ_InfoPrintf(("%s\n", __func__));
	SendStateChanged = TRUE;
}
static AJSVC_ServiceStatus LAMP_HandleMessage(AJ_Message* msg, AJ_Status* status)
{
	printf("%s\n", __func__);
   14818:	48b2      	ldr	r0, [pc, #712]	; (14ae4 <main+0x854>)
   1481a:	4bb3      	ldr	r3, [pc, #716]	; (14ae8 <main+0x858>)
   1481c:	4798      	blx	r3
	AJSVC_ServiceStatus serv_status = AJSVC_SERVICE_STATUS_HANDLED;

	switch (msg->msgId) {
   1481e:	9b31      	ldr	r3, [sp, #196]	; 0xc4
   14820:	4ab2      	ldr	r2, [pc, #712]	; (14aec <main+0x85c>)
   14822:	4293      	cmp	r3, r2
   14824:	d028      	beq.n	14878 <main+0x5e8>
   14826:	d806      	bhi.n	14836 <main+0x5a6>
   14828:	3a02      	subs	r2, #2
   1482a:	4293      	cmp	r3, r2
   1482c:	d010      	beq.n	14850 <main+0x5c0>
   1482e:	4ab0      	ldr	r2, [pc, #704]	; (14af0 <main+0x860>)
   14830:	4293      	cmp	r3, r2
   14832:	d017      	beq.n	14864 <main+0x5d4>
   14834:	e1d0      	b.n	14bd8 <main+0x948>
   14836:	4aaf      	ldr	r2, [pc, #700]	; (14af4 <main+0x864>)
   14838:	4293      	cmp	r3, r2
   1483a:	d100      	bne.n	1483e <main+0x5ae>
   1483c:	e0c7      	b.n	149ce <main+0x73e>
   1483e:	4aae      	ldr	r2, [pc, #696]	; (14af8 <main+0x868>)
   14840:	4293      	cmp	r3, r2
   14842:	d100      	bne.n	14846 <main+0x5b6>
   14844:	e0fc      	b.n	14a40 <main+0x7b0>
   14846:	4aad      	ldr	r2, [pc, #692]	; (14afc <main+0x86c>)
   14848:	4293      	cmp	r3, r2
   1484a:	d000      	beq.n	1484e <main+0x5be>
   1484c:	e1c4      	b.n	14bd8 <main+0x948>
   1484e:	e0a0      	b.n	14992 <main+0x702>

		case APP_GET_PROP:
		*status = AJ_BusPropGet(msg, PropGetHandler, NULL);
   14850:	a831      	add	r0, sp, #196	; 0xc4
   14852:	49ab      	ldr	r1, [pc, #684]	; (14b00 <main+0x870>)
   14854:	2200      	movs	r2, #0
   14856:	4bab      	ldr	r3, [pc, #684]	; (14b04 <main+0x874>)
   14858:	4798      	blx	r3
   1485a:	2308      	movs	r3, #8
   1485c:	33ff      	adds	r3, #255	; 0xff
   1485e:	446b      	add	r3, sp
   14860:	7018      	strb	r0, [r3, #0]
   14862:	e1c0      	b.n	14be6 <main+0x956>
		break;

		case APP_SET_PROP:
		*status = AJ_BusPropSet(msg, PropSetHandler, NULL);
   14864:	a831      	add	r0, sp, #196	; 0xc4
   14866:	49a8      	ldr	r1, [pc, #672]	; (14b08 <main+0x878>)
   14868:	2200      	movs	r2, #0
   1486a:	4ba8      	ldr	r3, [pc, #672]	; (14b0c <main+0x87c>)
   1486c:	4798      	blx	r3
   1486e:	2308      	movs	r3, #8
   14870:	33ff      	adds	r3, #255	; 0xff
   14872:	446b      	add	r3, sp
   14874:	7018      	strb	r0, [r3, #0]
   14876:	e1b6      	b.n	14be6 <main+0x956>
{
	const char* iface;
	AJ_Message reply;
	AJ_Arg array1;

	AJ_UnmarshalArgs(msg, "s", &iface);
   14878:	a831      	add	r0, sp, #196	; 0xc4
   1487a:	49a5      	ldr	r1, [pc, #660]	; (14b10 <main+0x880>)
   1487c:	aa09      	add	r2, sp, #36	; 0x24
   1487e:	4b8e      	ldr	r3, [pc, #568]	; (14ab8 <main+0x828>)
   14880:	4798      	blx	r3
	printf("%s: Interface=%s\n", __func__, iface);
   14882:	48a4      	ldr	r0, [pc, #656]	; (14b14 <main+0x884>)
   14884:	49a4      	ldr	r1, [pc, #656]	; (14b18 <main+0x888>)
   14886:	9a09      	ldr	r2, [sp, #36]	; 0x24
   14888:	4b88      	ldr	r3, [pc, #544]	; (14aac <main+0x81c>)
   1488a:	4798      	blx	r3

	AJ_MarshalReplyMsg(msg, &reply);
   1488c:	a831      	add	r0, sp, #196	; 0xc4
   1488e:	a91b      	add	r1, sp, #108	; 0x6c
   14890:	4ba2      	ldr	r3, [pc, #648]	; (14b1c <main+0x88c>)
   14892:	4798      	blx	r3
	AJ_MarshalContainer(&reply, &array1, AJ_ARG_ARRAY);
   14894:	a81b      	add	r0, sp, #108	; 0x6c
   14896:	a90a      	add	r1, sp, #40	; 0x28
   14898:	2261      	movs	r2, #97	; 0x61
   1489a:	4ba1      	ldr	r3, [pc, #644]	; (14b20 <main+0x890>)
   1489c:	4798      	blx	r3

	if (0 == strcmp(iface, LSF_Interface_Name)) 
   1489e:	9e09      	ldr	r6, [sp, #36]	; 0x24
   148a0:	1c30      	adds	r0, r6, #0
   148a2:	49a0      	ldr	r1, [pc, #640]	; (14b24 <main+0x894>)
   148a4:	4ba0      	ldr	r3, [pc, #640]	; (14b28 <main+0x898>)
   148a6:	4798      	blx	r3
   148a8:	2800      	cmp	r0, #0
   148aa:	d129      	bne.n	14900 <main+0x670>
	{
		AJ_MarshalArgs(&reply, "{sv}", "Version", "u", LSF_Interface_Version);
   148ac:	2601      	movs	r6, #1
   148ae:	9600      	str	r6, [sp, #0]
   148b0:	a81b      	add	r0, sp, #108	; 0x6c
   148b2:	499e      	ldr	r1, [pc, #632]	; (14b2c <main+0x89c>)
   148b4:	4a9e      	ldr	r2, [pc, #632]	; (14b30 <main+0x8a0>)
   148b6:	4b9f      	ldr	r3, [pc, #636]	; (14b34 <main+0x8a4>)
   148b8:	4f9f      	ldr	r7, [pc, #636]	; (14b38 <main+0x8a8>)
   148ba:	47b8      	blx	r7
		AJ_MarshalArgs(&reply, "{sv}", "LampServiceVersion", "u", LAMP_GetServiceVersion());
   148bc:	9600      	str	r6, [sp, #0]
   148be:	a81b      	add	r0, sp, #108	; 0x6c
   148c0:	499a      	ldr	r1, [pc, #616]	; (14b2c <main+0x89c>)
   148c2:	4a9e      	ldr	r2, [pc, #632]	; (14b3c <main+0x8ac>)
   148c4:	4b9b      	ldr	r3, [pc, #620]	; (14b34 <main+0x8a4>)
   148c6:	47b8      	blx	r7

		// now add the lamp faults to the message
		{
			AJ_Arg array2, struct1;
			AJ_MarshalContainer(&reply, &struct1, AJ_ARG_DICT_ENTRY);
   148c8:	a81b      	add	r0, sp, #108	; 0x6c
   148ca:	a915      	add	r1, sp, #84	; 0x54
   148cc:	227b      	movs	r2, #123	; 0x7b
   148ce:	4e94      	ldr	r6, [pc, #592]	; (14b20 <main+0x890>)
   148d0:	47b0      	blx	r6
			AJ_MarshalArgs(&reply, "s", "LampFaults");
   148d2:	a81b      	add	r0, sp, #108	; 0x6c
   148d4:	498e      	ldr	r1, [pc, #568]	; (14b10 <main+0x880>)
   148d6:	4a9a      	ldr	r2, [pc, #616]	; (14b40 <main+0x8b0>)
   148d8:	47b8      	blx	r7

			AJ_MarshalVariant(&reply, "au");
   148da:	a81b      	add	r0, sp, #108	; 0x6c
   148dc:	4999      	ldr	r1, [pc, #612]	; (14b44 <main+0x8b4>)
   148de:	4b9a      	ldr	r3, [pc, #616]	; (14b48 <main+0x8b8>)
   148e0:	4798      	blx	r3

			AJ_MarshalContainer(&reply, &array2, AJ_ARG_ARRAY);
   148e2:	a81b      	add	r0, sp, #108	; 0x6c
   148e4:	a90e      	add	r1, sp, #56	; 0x38
   148e6:	2261      	movs	r2, #97	; 0x61
   148e8:	47b0      	blx	r6
			OEM_LS_PopulateFaults(&reply);
   148ea:	a81b      	add	r0, sp, #108	; 0x6c
   148ec:	4b97      	ldr	r3, [pc, #604]	; (14b4c <main+0x8bc>)
   148ee:	4798      	blx	r3
			AJ_MarshalCloseContainer(&reply, &array2);
   148f0:	a81b      	add	r0, sp, #108	; 0x6c
   148f2:	a90e      	add	r1, sp, #56	; 0x38
   148f4:	4e96      	ldr	r6, [pc, #600]	; (14b50 <main+0x8c0>)
   148f6:	47b0      	blx	r6
			AJ_MarshalCloseContainer(&reply, &struct1);
   148f8:	a81b      	add	r0, sp, #108	; 0x6c
   148fa:	a915      	add	r1, sp, #84	; 0x54
   148fc:	47b0      	blx	r6
   148fe:	e038      	b.n	14972 <main+0x6e2>
		}
	} 
	else if (0 == strcmp(iface, LSF_Parameters_Interface_Name)) 
   14900:	1c30      	adds	r0, r6, #0
   14902:	4994      	ldr	r1, [pc, #592]	; (14b54 <main+0x8c4>)
   14904:	4b88      	ldr	r3, [pc, #544]	; (14b28 <main+0x898>)
   14906:	4798      	blx	r3
   14908:	2800      	cmp	r0, #0
   1490a:	d10b      	bne.n	14924 <main+0x694>
	{
		AJ_MarshalArgs(&reply, "{sv}", "Version", "u", LSF_Parameters_Interface_Version);
   1490c:	2301      	movs	r3, #1
   1490e:	9300      	str	r3, [sp, #0]
   14910:	a81b      	add	r0, sp, #108	; 0x6c
   14912:	4986      	ldr	r1, [pc, #536]	; (14b2c <main+0x89c>)
   14914:	4a86      	ldr	r2, [pc, #536]	; (14b30 <main+0x8a0>)
   14916:	4b87      	ldr	r3, [pc, #540]	; (14b34 <main+0x8a4>)
   14918:	4e87      	ldr	r6, [pc, #540]	; (14b38 <main+0x8a8>)
   1491a:	47b0      	blx	r6
		OEM_LS_PopulateParameters(&reply);
   1491c:	a81b      	add	r0, sp, #108	; 0x6c
   1491e:	4b8e      	ldr	r3, [pc, #568]	; (14b58 <main+0x8c8>)
   14920:	4798      	blx	r3
   14922:	e026      	b.n	14972 <main+0x6e2>
	}
	else if (0 == strcmp(iface, LSF_Details_Interface_Name))
   14924:	1c30      	adds	r0, r6, #0
   14926:	498d      	ldr	r1, [pc, #564]	; (14b5c <main+0x8cc>)
   14928:	4b7f      	ldr	r3, [pc, #508]	; (14b28 <main+0x898>)
   1492a:	4798      	blx	r3
   1492c:	2800      	cmp	r0, #0
   1492e:	d10b      	bne.n	14948 <main+0x6b8>
	{
		AJ_MarshalArgs(&reply, "{sv}", "Version", "u", LSF_Details_Interface_Version);
   14930:	2301      	movs	r3, #1
   14932:	9300      	str	r3, [sp, #0]
   14934:	a81b      	add	r0, sp, #108	; 0x6c
   14936:	497d      	ldr	r1, [pc, #500]	; (14b2c <main+0x89c>)
   14938:	4a7d      	ldr	r2, [pc, #500]	; (14b30 <main+0x8a0>)
   1493a:	4b7e      	ldr	r3, [pc, #504]	; (14b34 <main+0x8a4>)
   1493c:	4e7e      	ldr	r6, [pc, #504]	; (14b38 <main+0x8a8>)
   1493e:	47b0      	blx	r6
		OEM_LS_PopulateDetails(&reply);
   14940:	a81b      	add	r0, sp, #108	; 0x6c
   14942:	4b87      	ldr	r3, [pc, #540]	; (14b60 <main+0x8d0>)
   14944:	4798      	blx	r3
   14946:	e014      	b.n	14972 <main+0x6e2>
	} 
	else if (0 == strcmp(iface, LSF_State_Interface_Name)) 
   14948:	1c30      	adds	r0, r6, #0
   1494a:	4986      	ldr	r1, [pc, #536]	; (14b64 <main+0x8d4>)
   1494c:	4b76      	ldr	r3, [pc, #472]	; (14b28 <main+0x898>)
   1494e:	4798      	blx	r3
   14950:	2800      	cmp	r0, #0
   14952:	d10e      	bne.n	14972 <main+0x6e2>
	{
		AJ_MarshalArgs(&reply, "{sv}", "Version", "u", LSF_State_Interface_Version);
   14954:	2301      	movs	r3, #1
   14956:	9300      	str	r3, [sp, #0]
   14958:	a81b      	add	r0, sp, #108	; 0x6c
   1495a:	4974      	ldr	r1, [pc, #464]	; (14b2c <main+0x89c>)
   1495c:	4a74      	ldr	r2, [pc, #464]	; (14b30 <main+0x8a0>)
   1495e:	4b75      	ldr	r3, [pc, #468]	; (14b34 <main+0x8a4>)
   14960:	4e75      	ldr	r6, [pc, #468]	; (14b38 <main+0x8a8>)
   14962:	47b0      	blx	r6
		LampState state;
		LAMP_GetState(&state);
   14964:	a815      	add	r0, sp, #84	; 0x54
   14966:	4b80      	ldr	r3, [pc, #512]	; (14b68 <main+0x8d8>)
   14968:	4798      	blx	r3
		LAMP_MarshalState(&state, &reply);
   1496a:	a815      	add	r0, sp, #84	; 0x54
   1496c:	a91b      	add	r1, sp, #108	; 0x6c
   1496e:	4b7f      	ldr	r3, [pc, #508]	; (14b6c <main+0x8dc>)
   14970:	4798      	blx	r3
	}

	AJ_MarshalCloseContainer(&reply, &array1);
   14972:	a81b      	add	r0, sp, #108	; 0x6c
   14974:	a90a      	add	r1, sp, #40	; 0x28
   14976:	4b76      	ldr	r3, [pc, #472]	; (14b50 <main+0x8c0>)
   14978:	4798      	blx	r3
	AJ_DeliverMsg(&reply);
   1497a:	a81b      	add	r0, sp, #108	; 0x6c
   1497c:	4b7c      	ldr	r3, [pc, #496]	; (14b70 <main+0x8e0>)
   1497e:	4798      	blx	r3
	AJ_CloseMsg(&reply);
   14980:	a81b      	add	r0, sp, #108	; 0x6c
   14982:	4b7c      	ldr	r3, [pc, #496]	; (14b74 <main+0x8e4>)
   14984:	4798      	blx	r3
		case APP_SET_PROP:
		*status = AJ_BusPropSet(msg, PropSetHandler, NULL);
		break;

		case APP_GET_PROP_ALL:
		*status = GetAllProps(msg);
   14986:	2200      	movs	r2, #0
   14988:	2308      	movs	r3, #8
   1498a:	33ff      	adds	r3, #255	; 0xff
   1498c:	446b      	add	r3, sp
   1498e:	701a      	strb	r2, [r3, #0]
   14990:	e129      	b.n	14be6 <main+0x956>
static AJ_Status ClearLampFault(AJ_Message* msg)
{
    LampResponseCode responseCode = LAMP_OK;
    uint32_t faultCode;
    AJ_Message reply;
    AJ_MarshalReplyMsg(msg, &reply);
   14992:	a831      	add	r0, sp, #196	; 0xc4
   14994:	a91b      	add	r1, sp, #108	; 0x6c
   14996:	4b61      	ldr	r3, [pc, #388]	; (14b1c <main+0x88c>)
   14998:	4798      	blx	r3

    AJ_UnmarshalArgs(msg, "u", &faultCode);
   1499a:	a831      	add	r0, sp, #196	; 0xc4
   1499c:	4965      	ldr	r1, [pc, #404]	; (14b34 <main+0x8a4>)
   1499e:	aa15      	add	r2, sp, #84	; 0x54
   149a0:	4b45      	ldr	r3, [pc, #276]	; (14ab8 <main+0x828>)
   149a2:	4798      	blx	r3
    responseCode = OEM_LS_ClearFault(faultCode);
   149a4:	9815      	ldr	r0, [sp, #84]	; 0x54
   149a6:	4b74      	ldr	r3, [pc, #464]	; (14b78 <main+0x8e8>)
   149a8:	4798      	blx	r3
   149aa:	1c02      	adds	r2, r0, #0

    AJ_MarshalArgs(&reply, "uu", (uint32_t) responseCode, (uint32_t) faultCode);
   149ac:	a81b      	add	r0, sp, #108	; 0x6c
   149ae:	4945      	ldr	r1, [pc, #276]	; (14ac4 <main+0x834>)
   149b0:	9b15      	ldr	r3, [sp, #84]	; 0x54
   149b2:	4e61      	ldr	r6, [pc, #388]	; (14b38 <main+0x8a8>)
   149b4:	47b0      	blx	r6
    AJ_DeliverMsg(&reply);
   149b6:	a81b      	add	r0, sp, #108	; 0x6c
   149b8:	4b6d      	ldr	r3, [pc, #436]	; (14b70 <main+0x8e0>)
   149ba:	4798      	blx	r3
    AJ_CloseMsg(&reply);
   149bc:	a81b      	add	r0, sp, #108	; 0x6c
   149be:	4b6d      	ldr	r3, [pc, #436]	; (14b74 <main+0x8e4>)
   149c0:	4798      	blx	r3
		case APP_GET_PROP_ALL:
		*status = GetAllProps(msg);
		break;

		case LSF_METHOD_CLEARLAMPFAULTS:
		*status = ClearLampFault(msg);
   149c2:	2200      	movs	r2, #0
   149c4:	2308      	movs	r3, #8
   149c6:	33ff      	adds	r3, #255	; 0xff
   149c8:	446b      	add	r3, sp
   149ca:	701a      	strb	r2, [r3, #0]
   149cc:	e10b      	b.n	14be6 <main+0x956>
    LampStateContainer newState;
    uint64_t timestamp;
    uint32_t TransitionPeriod;

    AJ_Message reply;
    AJ_MarshalReplyMsg(msg, &reply);
   149ce:	a831      	add	r0, sp, #196	; 0xc4
   149d0:	a91b      	add	r1, sp, #108	; 0x6c
   149d2:	4b52      	ldr	r3, [pc, #328]	; (14b1c <main+0x88c>)
   149d4:	4798      	blx	r3

    AJ_UnmarshalArgs(msg, "t", &timestamp);
   149d6:	a831      	add	r0, sp, #196	; 0xc4
   149d8:	4968      	ldr	r1, [pc, #416]	; (14b7c <main+0x8ec>)
   149da:	aa0e      	add	r2, sp, #56	; 0x38
   149dc:	4f36      	ldr	r7, [pc, #216]	; (14ab8 <main+0x828>)
   149de:	47b8      	blx	r7
    LAMP_UnmarshalState(&newState, msg);
   149e0:	ae15      	add	r6, sp, #84	; 0x54
   149e2:	1c30      	adds	r0, r6, #0
   149e4:	a931      	add	r1, sp, #196	; 0xc4
   149e6:	4b66      	ldr	r3, [pc, #408]	; (14b80 <main+0x8f0>)
   149e8:	4798      	blx	r3
    AJ_UnmarshalArgs(msg, "u", &TransitionPeriod);
   149ea:	a831      	add	r0, sp, #196	; 0xc4
   149ec:	4951      	ldr	r1, [pc, #324]	; (14b34 <main+0x8a4>)
   149ee:	aa0a      	add	r2, sp, #40	; 0x28
   149f0:	47b8      	blx	r7

    // apply the new state
    if (newState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR)
   149f2:	7d33      	ldrb	r3, [r6, #20]
   149f4:	2b1f      	cmp	r3, #31
   149f6:	d108      	bne.n	14a0a <main+0x77a>
	{
        responseCode = OEM_LS_TransitionState(&(newState.state), timestamp, TransitionPeriod);
   149f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   149fa:	9300      	str	r3, [sp, #0]
   149fc:	a815      	add	r0, sp, #84	; 0x54
   149fe:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   14a00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14a02:	4960      	ldr	r1, [pc, #384]	; (14b84 <main+0x8f4>)
   14a04:	4788      	blx	r1
   14a06:	1c02      	adds	r2, r0, #0
   14a08:	e00a      	b.n	14a20 <main+0x790>
	{
        responseCode = OEM_LS_TransitionStateFields(&newState, timestamp, TransitionPeriod);
    }
	else 
	{
        responseCode = LAMP_ERR_INVALID_ARGS;
   14a0a:	220c      	movs	r2, #12
    // apply the new state
    if (newState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR)
	{
        responseCode = OEM_LS_TransitionState(&(newState.state), timestamp, TransitionPeriod);
    } 
	else if (newState.stateFieldIndicators) 
   14a0c:	2b00      	cmp	r3, #0
   14a0e:	d007      	beq.n	14a20 <main+0x790>
	{
        responseCode = OEM_LS_TransitionStateFields(&newState, timestamp, TransitionPeriod);
   14a10:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14a12:	9300      	str	r3, [sp, #0]
   14a14:	a815      	add	r0, sp, #84	; 0x54
   14a16:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   14a18:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14a1a:	495b      	ldr	r1, [pc, #364]	; (14b88 <main+0x8f8>)
   14a1c:	4788      	blx	r1
   14a1e:	1c02      	adds	r2, r0, #0
	else 
	{
        responseCode = LAMP_ERR_INVALID_ARGS;
    }

    AJ_MarshalArgs(&reply, "u", (uint32_t) responseCode);
   14a20:	a81b      	add	r0, sp, #108	; 0x6c
   14a22:	4944      	ldr	r1, [pc, #272]	; (14b34 <main+0x8a4>)
   14a24:	4b44      	ldr	r3, [pc, #272]	; (14b38 <main+0x8a8>)
   14a26:	4798      	blx	r3
    AJ_DeliverMsg(&reply);
   14a28:	a81b      	add	r0, sp, #108	; 0x6c
   14a2a:	4b51      	ldr	r3, [pc, #324]	; (14b70 <main+0x8e0>)
   14a2c:	4798      	blx	r3
    AJ_CloseMsg(&reply);
   14a2e:	a81b      	add	r0, sp, #108	; 0x6c
   14a30:	4b50      	ldr	r3, [pc, #320]	; (14b74 <main+0x8e4>)
   14a32:	4798      	blx	r3
		case LSF_METHOD_CLEARLAMPFAULTS:
		*status = ClearLampFault(msg);
		break;

		case LSF_METHOD_STATE_SETSTATE:
		*status = TransitionLampState(msg);
   14a34:	2200      	movs	r2, #0
   14a36:	2308      	movs	r3, #8
   14a38:	33ff      	adds	r3, #255	; 0xff
   14a3a:	446b      	add	r3, sp
   14a3c:	701a      	strb	r2, [r3, #0]
   14a3e:	e0d2      	b.n	14be6 <main+0x956>
    uint32_t duration;
    uint32_t numPulses;
    uint64_t timestamp;

    AJ_Message reply;
    AJ_MarshalReplyMsg(msg, &reply);
   14a40:	a831      	add	r0, sp, #196	; 0xc4
   14a42:	a91b      	add	r1, sp, #108	; 0x6c
   14a44:	4b35      	ldr	r3, [pc, #212]	; (14b1c <main+0x88c>)
   14a46:	4798      	blx	r3

    LAMP_UnmarshalState(&FromState, msg);
   14a48:	ae0e      	add	r6, sp, #56	; 0x38
   14a4a:	1c30      	adds	r0, r6, #0
   14a4c:	a931      	add	r1, sp, #196	; 0xc4
   14a4e:	4f4c      	ldr	r7, [pc, #304]	; (14b80 <main+0x8f0>)
   14a50:	47b8      	blx	r7
    LAMP_UnmarshalState(&ToState, msg);
   14a52:	a815      	add	r0, sp, #84	; 0x54
   14a54:	a931      	add	r1, sp, #196	; 0xc4
   14a56:	47b8      	blx	r7
    AJ_UnmarshalArgs(msg, "uuut", &period, &duration, &numPulses, &timestamp);
   14a58:	ab09      	add	r3, sp, #36	; 0x24
   14a5a:	9300      	str	r3, [sp, #0]
   14a5c:	ab0a      	add	r3, sp, #40	; 0x28
   14a5e:	9301      	str	r3, [sp, #4]
   14a60:	a831      	add	r0, sp, #196	; 0xc4
   14a62:	494a      	ldr	r1, [pc, #296]	; (14b8c <main+0x8fc>)
   14a64:	aa07      	add	r2, sp, #28
   14a66:	ab08      	add	r3, sp, #32
   14a68:	4f13      	ldr	r7, [pc, #76]	; (14ab8 <main+0x828>)
   14a6a:	47b8      	blx	r7

    // apply the new state
    if ((FromState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR) && (ToState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR)) 
   14a6c:	7d33      	ldrb	r3, [r6, #20]
   14a6e:	2b1f      	cmp	r3, #31
   14a70:	d000      	beq.n	14a74 <main+0x7e4>
   14a72:	e08f      	b.n	14b94 <main+0x904>
   14a74:	ab15      	add	r3, sp, #84	; 0x54
   14a76:	7d1b      	ldrb	r3, [r3, #20]
   14a78:	2b1f      	cmp	r3, #31
   14a7a:	d000      	beq.n	14a7e <main+0x7ee>
   14a7c:	e08a      	b.n	14b94 <main+0x904>
	{
        responseCode = OEM_LS_ApplyPulseEffect(&(FromState.state), &(ToState.state), period, duration, numPulses, timestamp);
   14a7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14a80:	9300      	str	r3, [sp, #0]
   14a82:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14a84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   14a86:	9202      	str	r2, [sp, #8]
   14a88:	9303      	str	r3, [sp, #12]
   14a8a:	a80e      	add	r0, sp, #56	; 0x38
   14a8c:	a915      	add	r1, sp, #84	; 0x54
   14a8e:	9a07      	ldr	r2, [sp, #28]
   14a90:	9b08      	ldr	r3, [sp, #32]
   14a92:	4e3f      	ldr	r6, [pc, #252]	; (14b90 <main+0x900>)
   14a94:	47b0      	blx	r6
   14a96:	1c02      	adds	r2, r0, #0
   14a98:	e08e      	b.n	14bb8 <main+0x928>
   14a9a:	46c0      	nop			; (mov r8, r8)
   14a9c:	00002ba9 	.word	0x00002ba9
   14aa0:	20001344 	.word	0x20001344
   14aa4:	00021648 	.word	0x00021648
   14aa8:	00021318 	.word	0x00021318
   14aac:	00016e3d 	.word	0x00016e3d
   14ab0:	00021678 	.word	0x00021678
   14ab4:	000215e0 	.word	0x000215e0
   14ab8:	0000b5f5 	.word	0x0000b5f5
   14abc:	20002c58 	.word	0x20002c58
   14ac0:	00002a49 	.word	0x00002a49
   14ac4:	000200ac 	.word	0x000200ac
   14ac8:	000216b0 	.word	0x000216b0
   14acc:	000216c8 	.word	0x000216c8
   14ad0:	20002448 	.word	0x20002448
   14ad4:	0000df55 	.word	0x0000df55
   14ad8:	000063c5 	.word	0x000063c5
   14adc:	000216e4 	.word	0x000216e4
   14ae0:	0000eacd 	.word	0x0000eacd
   14ae4:	00021304 	.word	0x00021304
   14ae8:	00016f5d 	.word	0x00016f5d
   14aec:	01000002 	.word	0x01000002
   14af0:	01000001 	.word	0x01000001
   14af4:	01000401 	.word	0x01000401
   14af8:	01000402 	.word	0x01000402
   14afc:	01000102 	.word	0x01000102
   14b00:	00013eed 	.word	0x00013eed
   14b04:	000030d1 	.word	0x000030d1
   14b08:	00013e25 	.word	0x00013e25
   14b0c:	00003105 	.word	0x00003105
   14b10:	0001f054 	.word	0x0001f054
   14b14:	00021708 	.word	0x00021708
   14b18:	00021bfc 	.word	0x00021bfc
   14b1c:	0000bd45 	.word	0x0000bd45
   14b20:	0000b8a1 	.word	0x0000b8a1
   14b24:	00021bc0 	.word	0x00021bc0
   14b28:	00017137 	.word	0x00017137
   14b2c:	0001f938 	.word	0x0001f938
   14b30:	00019dd8 	.word	0x00019dd8
   14b34:	0002192c 	.word	0x0002192c
   14b38:	0000bc85 	.word	0x0000bc85
   14b3c:	0002171c 	.word	0x0002171c
   14b40:	00021730 	.word	0x00021730
   14b44:	00021b1c 	.word	0x00021b1c
   14b48:	0000b9fd 	.word	0x0000b9fd
   14b4c:	00000afd 	.word	0x00000afd
   14b50:	0000b8d1 	.word	0x0000b8d1
   14b54:	00021bdc 	.word	0x00021bdc
   14b58:	00000b5d 	.word	0x00000b5d
   14b5c:	00021320 	.word	0x00021320
   14b60:	00000bb5 	.word	0x00000bb5
   14b64:	00021b8c 	.word	0x00021b8c
   14b68:	00000525 	.word	0x00000525
   14b6c:	00000291 	.word	0x00000291
   14b70:	0000a539 	.word	0x0000a539
   14b74:	0000a77d 	.word	0x0000a77d
   14b78:	00000b41 	.word	0x00000b41
   14b7c:	0001c6f0 	.word	0x0001c6f0
   14b80:	0000033d 	.word	0x0000033d
   14b84:	00000955 	.word	0x00000955
   14b88:	00000999 	.word	0x00000999
   14b8c:	0002173c 	.word	0x0002173c
   14b90:	00000799 	.word	0x00000799
    } 
	else if (ToState.stateFieldIndicators)
   14b94:	ab15      	add	r3, sp, #84	; 0x54
   14b96:	7d1b      	ldrb	r3, [r3, #20]
	{
        responseCode = OEM_LS_ApplyPulseEffectOnStateFields(&FromState, &ToState, period, duration, numPulses, timestamp);
    } 
	else
	{
        responseCode = LAMP_ERR_INVALID_ARGS;
   14b98:	220c      	movs	r2, #12
    // apply the new state
    if ((FromState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR) && (ToState.stateFieldIndicators == LAMP_STATE_ALL_FIELDS_INDICATOR)) 
	{
        responseCode = OEM_LS_ApplyPulseEffect(&(FromState.state), &(ToState.state), period, duration, numPulses, timestamp);
    } 
	else if (ToState.stateFieldIndicators)
   14b9a:	2b00      	cmp	r3, #0
   14b9c:	d00c      	beq.n	14bb8 <main+0x928>
	{
        responseCode = OEM_LS_ApplyPulseEffectOnStateFields(&FromState, &ToState, period, duration, numPulses, timestamp);
   14b9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14ba0:	9300      	str	r3, [sp, #0]
   14ba2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14ba4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   14ba6:	9202      	str	r2, [sp, #8]
   14ba8:	9303      	str	r3, [sp, #12]
   14baa:	a80e      	add	r0, sp, #56	; 0x38
   14bac:	a915      	add	r1, sp, #84	; 0x54
   14bae:	9a07      	ldr	r2, [sp, #28]
   14bb0:	9b08      	ldr	r3, [sp, #32]
   14bb2:	4e8a      	ldr	r6, [pc, #552]	; (14ddc <main+0xb4c>)
   14bb4:	47b0      	blx	r6
   14bb6:	1c02      	adds	r2, r0, #0
	else
	{
        responseCode = LAMP_ERR_INVALID_ARGS;
    }

    AJ_MarshalArgs(&reply, "u", (uint32_t) responseCode);
   14bb8:	a81b      	add	r0, sp, #108	; 0x6c
   14bba:	4989      	ldr	r1, [pc, #548]	; (14de0 <main+0xb50>)
   14bbc:	4b89      	ldr	r3, [pc, #548]	; (14de4 <main+0xb54>)
   14bbe:	4798      	blx	r3
    AJ_DeliverMsg(&reply);
   14bc0:	a81b      	add	r0, sp, #108	; 0x6c
   14bc2:	4b89      	ldr	r3, [pc, #548]	; (14de8 <main+0xb58>)
   14bc4:	4798      	blx	r3
    AJ_CloseMsg(&reply);
   14bc6:	a81b      	add	r0, sp, #108	; 0x6c
   14bc8:	4b88      	ldr	r3, [pc, #544]	; (14dec <main+0xb5c>)
   14bca:	4798      	blx	r3
		case LSF_METHOD_STATE_SETSTATE:
		*status = TransitionLampState(msg);
		break;

		case LSF_METHOD_APPLY_PULSE:
		*status = ApplyPulseEffect(msg);
   14bcc:	2200      	movs	r2, #0
   14bce:	2308      	movs	r3, #8
   14bd0:	33ff      	adds	r3, #255	; 0xff
   14bd2:	446b      	add	r3, sp
   14bd4:	701a      	strb	r2, [r3, #0]
   14bd6:	e006      	b.n	14be6 <main+0x956>
					{
                        /*
                         * Pass to the built-in bus message handlers.
                         * This will also handle messages for the About object
                         */
                        status = AJ_BusHandleBusMessage(&msg);
   14bd8:	a831      	add	r0, sp, #196	; 0xc4
   14bda:	4b85      	ldr	r3, [pc, #532]	; (14df0 <main+0xb60>)
   14bdc:	4798      	blx	r3
   14bde:	2308      	movs	r3, #8
   14be0:	33ff      	adds	r3, #255	; 0xff
   14be2:	446b      	add	r3, sp
   14be4:	7018      	strb	r0, [r3, #0]
                    break;
                }
            } // end switch

            // Any received packets indicates the link is active, so call to reinforce the bus link state
            AJ_NotifyLinkActive();
   14be6:	4b83      	ldr	r3, [pc, #524]	; (14df4 <main+0xb64>)
   14be8:	4798      	blx	r3
        }

        // Unarshaled messages must be closed to free resources
        AJ_CloseMsg(&msg);
   14bea:	a831      	add	r0, sp, #196	; 0xc4
   14bec:	4b7f      	ldr	r3, [pc, #508]	; (14dec <main+0xb5c>)
   14bee:	4798      	blx	r3
static void CheckForFaults(void)
{
    static uint32_t FaultNotificationSerialNumber = 0;

    // if new faults have occured, send a notification
    if (PendingFaultNotification) 
   14bf0:	4b81      	ldr	r3, [pc, #516]	; (14df8 <main+0xb68>)
   14bf2:	781b      	ldrb	r3, [r3, #0]
   14bf4:	2b00      	cmp	r3, #0
   14bf6:	d027      	beq.n	14c48 <main+0x9b8>
	{
        // turn ON notification
        AJNS_NotificationContent NotificationContent;
        AJNS_DictionaryEntry NotificationTexts;
        uint16_t messageType = AJNS_NOTIFICATION_MESSAGE_TYPE_WARNING;
        uint32_t ttl = AJNS_NOTIFICATION_TTL_MAX;
   14bf8:	4b80      	ldr	r3, [pc, #512]	; (14dfc <main+0xb6c>)
   14bfa:	881f      	ldrh	r7, [r3, #0]
        const char* notif_text = OEM_LS_GetFaultsText();
   14bfc:	4b80      	ldr	r3, [pc, #512]	; (14e00 <main+0xb70>)
   14bfe:	4798      	blx	r3
        memset(&NotificationContent, 0, sizeof(AJNS_NotificationContent));
   14c00:	2300      	movs	r3, #0
   14c02:	931b      	str	r3, [sp, #108]	; 0x6c
   14c04:	931c      	str	r3, [sp, #112]	; 0x70
   14c06:	931d      	str	r3, [sp, #116]	; 0x74
   14c08:	931e      	str	r3, [sp, #120]	; 0x78
   14c0a:	931f      	str	r3, [sp, #124]	; 0x7c
   14c0c:	9320      	str	r3, [sp, #128]	; 0x80
   14c0e:	9321      	str	r3, [sp, #132]	; 0x84
   14c10:	9322      	str	r3, [sp, #136]	; 0x88
   14c12:	9323      	str	r3, [sp, #140]	; 0x8c
   14c14:	9324      	str	r3, [sp, #144]	; 0x90
   14c16:	9325      	str	r3, [sp, #148]	; 0x94

        if (notif_text != NULL) 
   14c18:	2800      	cmp	r0, #0
   14c1a:	d015      	beq.n	14c48 <main+0x9b8>
		{
            NotificationTexts.key = "LSF_FAULTS";
   14c1c:	ae15      	add	r6, sp, #84	; 0x54
   14c1e:	4b79      	ldr	r3, [pc, #484]	; (14e04 <main+0xb74>)
   14c20:	9315      	str	r3, [sp, #84]	; 0x54
            NotificationTexts.value = notif_text;
   14c22:	9016      	str	r0, [sp, #88]	; 0x58

            NotificationContent.originalSenderName = AJ_GetUniqueName(&Bus);
   14c24:	4878      	ldr	r0, [pc, #480]	; (14e08 <main+0xb78>)
   14c26:	4b79      	ldr	r3, [pc, #484]	; (14e0c <main+0xb7c>)
   14c28:	4798      	blx	r3
   14c2a:	a91b      	add	r1, sp, #108	; 0x6c
   14c2c:	6288      	str	r0, [r1, #40]	; 0x28
            NotificationContent.numTexts = 1;
   14c2e:	2301      	movs	r3, #1
   14c30:	720b      	strb	r3, [r1, #8]
            NotificationContent.texts = &NotificationTexts;
   14c32:	60ce      	str	r6, [r1, #12]

            // if we clear this now, the Notification will be pulled on the next
            // pass through the event loop
            PendingFaultNotification = FALSE;
   14c34:	2200      	movs	r2, #0
   14c36:	4b70      	ldr	r3, [pc, #448]	; (14df8 <main+0xb68>)
   14c38:	701a      	strb	r2, [r3, #0]
            AJNS_Producer_SendNotification(&Bus, &NotificationContent, messageType, ttl, &FaultNotificationSerialNumber);
   14c3a:	4b75      	ldr	r3, [pc, #468]	; (14e10 <main+0xb80>)
   14c3c:	9300      	str	r3, [sp, #0]
   14c3e:	4872      	ldr	r0, [pc, #456]	; (14e08 <main+0xb78>)
   14c40:	3201      	adds	r2, #1
   14c42:	1c3b      	adds	r3, r7, #0
   14c44:	4e73      	ldr	r6, [pc, #460]	; (14e14 <main+0xb84>)
   14c46:	47b0      	blx	r6
/*
 * We do this on the side, the same as checking for faults.
 */
static void CheckForStateChanged(void)
{
    if (ControllerSessionID != 0 && SendStateChanged == TRUE) 
   14c48:	4b73      	ldr	r3, [pc, #460]	; (14e18 <main+0xb88>)
   14c4a:	681b      	ldr	r3, [r3, #0]
   14c4c:	2b00      	cmp	r3, #0
   14c4e:	d01c      	beq.n	14c8a <main+0x9fa>
   14c50:	4a72      	ldr	r2, [pc, #456]	; (14e1c <main+0xb8c>)
   14c52:	7812      	ldrb	r2, [r2, #0]
   14c54:	2a01      	cmp	r2, #1
   14c56:	d118      	bne.n	14c8a <main+0x9fa>
	{
        AJ_InfoPrintf(("\n%s\n", __func__));
        AJ_Message sig_out;
        AJ_MarshalSignal(&Bus, &sig_out, LSF_SIGNAL_STATE_STATECHANGED, NULL, ControllerSessionID, 0, 0);
   14c58:	9300      	str	r3, [sp, #0]
   14c5a:	2600      	movs	r6, #0
   14c5c:	9601      	str	r6, [sp, #4]
   14c5e:	9602      	str	r6, [sp, #8]
   14c60:	4869      	ldr	r0, [pc, #420]	; (14e08 <main+0xb78>)
   14c62:	a91b      	add	r1, sp, #108	; 0x6c
   14c64:	4a6e      	ldr	r2, [pc, #440]	; (14e20 <main+0xb90>)
   14c66:	2300      	movs	r3, #0
   14c68:	4f6e      	ldr	r7, [pc, #440]	; (14e24 <main+0xb94>)
   14c6a:	47b8      	blx	r7
        AJ_MarshalArgs(&sig_out, "s", LAMP_GetID());
   14c6c:	4b6e      	ldr	r3, [pc, #440]	; (14e28 <main+0xb98>)
   14c6e:	4798      	blx	r3
   14c70:	1c02      	adds	r2, r0, #0
   14c72:	a81b      	add	r0, sp, #108	; 0x6c
   14c74:	496d      	ldr	r1, [pc, #436]	; (14e2c <main+0xb9c>)
   14c76:	4b5b      	ldr	r3, [pc, #364]	; (14de4 <main+0xb54>)
   14c78:	4798      	blx	r3
        AJ_DeliverMsg(&sig_out);
   14c7a:	a81b      	add	r0, sp, #108	; 0x6c
   14c7c:	4b5a      	ldr	r3, [pc, #360]	; (14de8 <main+0xb58>)
   14c7e:	4798      	blx	r3
        AJ_CloseMsg(&sig_out);
   14c80:	a81b      	add	r0, sp, #108	; 0x6c
   14c82:	4b5a      	ldr	r3, [pc, #360]	; (14dec <main+0xb5c>)
   14c84:	4798      	blx	r3

        // no need to send this again.
        SendStateChanged = FALSE;
   14c86:	4b65      	ldr	r3, [pc, #404]	; (14e1c <main+0xb8c>)
   14c88:	701e      	strb	r6, [r3, #0]
        // check for anything that must go out now
        CheckForFaults();
        CheckForStateChanged();

        // this will be called by AJ_BusHandleBusMessage, but on LSF method calls AJ_BusHandleBusMessage isn't called
        if (status == AJ_OK) 
   14c8a:	2308      	movs	r3, #8
   14c8c:	33ff      	adds	r3, #255	; 0xff
   14c8e:	446b      	add	r3, sp
   14c90:	781b      	ldrb	r3, [r3, #0]
   14c92:	2b00      	cmp	r3, #0
   14c94:	d102      	bne.n	14c9c <main+0xa0c>
		{
            AJ_AboutAnnounce(&Bus);
   14c96:	485c      	ldr	r0, [pc, #368]	; (14e08 <main+0xb78>)
   14c98:	4b65      	ldr	r3, [pc, #404]	; (14e30 <main+0xba0>)
   14c9a:	4798      	blx	r3
        }
        if (PendingRestartRequest == TRUE) 
   14c9c:	4b65      	ldr	r3, [pc, #404]	; (14e34 <main+0xba4>)
   14c9e:	781b      	ldrb	r3, [r3, #0]
   14ca0:	2b01      	cmp	r3, #1
   14ca2:	d10d      	bne.n	14cc0 <main+0xa30>
		{
            AJ_InfoPrintf(("%s: PendingRestartRequest == TRUE\n", __func__));
            PendingRestartRequest = FALSE;
   14ca4:	2200      	movs	r2, #0
   14ca6:	4b63      	ldr	r3, [pc, #396]	; (14e34 <main+0xba4>)
   14ca8:	701a      	strb	r2, [r3, #0]
            status = AJ_ERR_RESTART;
   14caa:	3214      	adds	r2, #20
   14cac:	2308      	movs	r3, #8
   14cae:	33ff      	adds	r3, #255	; 0xff
   14cb0:	446b      	add	r3, sp
   14cb2:	701a      	strb	r2, [r3, #0]
        }

        if (PendingFactoryResetRequest == TRUE) 
   14cb4:	4b60      	ldr	r3, [pc, #384]	; (14e38 <main+0xba8>)
   14cb6:	781b      	ldrb	r3, [r3, #0]
   14cb8:	2b01      	cmp	r3, #1
   14cba:	d005      	beq.n	14cc8 <main+0xa38>
            OEM_LS_DoFactoryReset();

            status = AJ_ERR_RESTART_APP;
        }

        if (status == AJ_ERR_READ || status == AJ_ERR_RESTART || status == AJ_ERR_RESTART_APP) 
   14cbc:	2014      	movs	r0, #20
   14cbe:	e023      	b.n	14d08 <main+0xa78>
            AJ_InfoPrintf(("%s: PendingRestartRequest == TRUE\n", __func__));
            PendingRestartRequest = FALSE;
            status = AJ_ERR_RESTART;
        }

        if (PendingFactoryResetRequest == TRUE) 
   14cc0:	4b5d      	ldr	r3, [pc, #372]	; (14e38 <main+0xba8>)
   14cc2:	781b      	ldrb	r3, [r3, #0]
   14cc4:	2b01      	cmp	r3, #1
   14cc6:	d115      	bne.n	14cf4 <main+0xa64>
		{
            printf("%s: PendingFactoryResetRequest == TRUE\n", __func__);
   14cc8:	485c      	ldr	r0, [pc, #368]	; (14e3c <main+0xbac>)
   14cca:	495d      	ldr	r1, [pc, #372]	; (14e40 <main+0xbb0>)
   14ccc:	4b5d      	ldr	r3, [pc, #372]	; (14e44 <main+0xbb4>)
   14cce:	4798      	blx	r3
            PendingFactoryResetRequest = FALSE;
   14cd0:	2200      	movs	r2, #0
   14cd2:	4b59      	ldr	r3, [pc, #356]	; (14e38 <main+0xba8>)
   14cd4:	701a      	strb	r2, [r3, #0]

            AJSVC_PropertyStore_ResetAll();
   14cd6:	4b5c      	ldr	r3, [pc, #368]	; (14e48 <main+0xbb8>)
   14cd8:	4798      	blx	r3
            SavePersistentDeviceId();
   14cda:	4b5c      	ldr	r3, [pc, #368]	; (14e4c <main+0xbbc>)
   14cdc:	4798      	blx	r3
            PropertyStore_Init();
   14cde:	4b5c      	ldr	r3, [pc, #368]	; (14e50 <main+0xbc0>)
   14ce0:	4798      	blx	r3

            OEM_LS_DoFactoryReset();
   14ce2:	4b5c      	ldr	r3, [pc, #368]	; (14e54 <main+0xbc4>)
   14ce4:	4798      	blx	r3

            status = AJ_ERR_RESTART_APP;
   14ce6:	221e      	movs	r2, #30
   14ce8:	2308      	movs	r3, #8
   14cea:	33ff      	adds	r3, #255	; 0xff
   14cec:	446b      	add	r3, sp
   14cee:	701a      	strb	r2, [r3, #0]
        }

        if (status == AJ_ERR_READ || status == AJ_ERR_RESTART || status == AJ_ERR_RESTART_APP) 
   14cf0:	201e      	movs	r0, #30
   14cf2:	e009      	b.n	14d08 <main+0xa78>
   14cf4:	2308      	movs	r3, #8
   14cf6:	33ff      	adds	r3, #255	; 0xff
   14cf8:	446b      	add	r3, sp
   14cfa:	7818      	ldrb	r0, [r3, #0]
   14cfc:	2805      	cmp	r0, #5
   14cfe:	d003      	beq.n	14d08 <main+0xa78>
   14d00:	2814      	cmp	r0, #20
   14d02:	d001      	beq.n	14d08 <main+0xa78>
   14d04:	281e      	cmp	r0, #30
   14d06:	d129      	bne.n	14d5c <main+0xacc>
		{
            printf(("%s: AllJoyn disconnect due to status %s\n", __func__, AJ_StatusText(status)));
   14d08:	4b53      	ldr	r3, [pc, #332]	; (14e58 <main+0xbc8>)
   14d0a:	4798      	blx	r3
   14d0c:	4e4d      	ldr	r6, [pc, #308]	; (14e44 <main+0xbb4>)
   14d0e:	47b0      	blx	r6
            printf(("%s: Disconnected from Daemon:%s\n", __func__, AJ_GetUniqueName(&Bus)));
   14d10:	483d      	ldr	r0, [pc, #244]	; (14e08 <main+0xb78>)
   14d12:	4b3e      	ldr	r3, [pc, #248]	; (14e0c <main+0xb7c>)
   14d14:	4798      	blx	r3
   14d16:	47b0      	blx	r6

            LSF_DisconnectHandler(status != AJ_ERR_READ);
   14d18:	2308      	movs	r3, #8
   14d1a:	33ff      	adds	r3, #255	; 0xff
   14d1c:	446b      	add	r3, sp
{
	return ms_ticks;
}
static void LSF_DisconnectHandler(uint8_t restart)
{
	if (restart) 
   14d1e:	781b      	ldrb	r3, [r3, #0]
   14d20:	2b05      	cmp	r3, #5
   14d22:	d003      	beq.n	14d2c <main+0xa9c>
	{
		AJ_BusUnbindSession(&Bus, LSF_ServicePort);
   14d24:	4838      	ldr	r0, [pc, #224]	; (14e08 <main+0xb78>)
   14d26:	212a      	movs	r1, #42	; 0x2a
   14d28:	4b4c      	ldr	r3, [pc, #304]	; (14e5c <main+0xbcc>)
   14d2a:	4798      	blx	r3
	}
	AJ_AboutSetShouldAnnounce();
   14d2c:	4b4c      	ldr	r3, [pc, #304]	; (14e60 <main+0xbd0>)
   14d2e:	4798      	blx	r3

	AJSVC_DisconnectHandler(&Bus);
   14d30:	4e35      	ldr	r6, [pc, #212]	; (14e08 <main+0xb78>)
   14d32:	1c30      	adds	r0, r6, #0
   14d34:	4b4b      	ldr	r3, [pc, #300]	; (14e64 <main+0xbd4>)
   14d36:	4798      	blx	r3
		{
            printf(("%s: AllJoyn disconnect due to status %s\n", __func__, AJ_StatusText(status)));
            printf(("%s: Disconnected from Daemon:%s\n", __func__, AJ_GetUniqueName(&Bus)));

            LSF_DisconnectHandler(status != AJ_ERR_READ);
            AJSVC_RoutingNodeDisconnect(&Bus, (status != AJ_ERR_READ), 2000, 3000, &connected);
   14d38:	2308      	movs	r3, #8
   14d3a:	33ff      	adds	r3, #255	; 0xff
   14d3c:	446b      	add	r3, sp
   14d3e:	7819      	ldrb	r1, [r3, #0]
   14d40:	3905      	subs	r1, #5
   14d42:	1e4b      	subs	r3, r1, #1
   14d44:	4199      	sbcs	r1, r3
   14d46:	b2c9      	uxtb	r1, r1
   14d48:	466b      	mov	r3, sp
   14d4a:	3307      	adds	r3, #7
   14d4c:	33ff      	adds	r3, #255	; 0xff
   14d4e:	9300      	str	r3, [sp, #0]
   14d50:	1c30      	adds	r0, r6, #0
   14d52:	22fa      	movs	r2, #250	; 0xfa
   14d54:	00d2      	lsls	r2, r2, #3
   14d56:	4b44      	ldr	r3, [pc, #272]	; (14e68 <main+0xbd8>)
   14d58:	4e44      	ldr	r6, [pc, #272]	; (14e6c <main+0xbdc>)
   14d5a:	47b0      	blx	r6
            if (status == AJ_ERR_RESTART_APP) 
			{
                AJ_Reboot();
            }
        }
		if (wifi_connected == M2M_WIFI_CONNECTED)
   14d5c:	4b44      	ldr	r3, [pc, #272]	; (14e70 <main+0xbe0>)
   14d5e:	781b      	ldrb	r3, [r3, #0]
   14d60:	2b01      	cmp	r3, #1
   14d62:	d001      	beq.n	14d68 <main+0xad8>
   14d64:	f7ff fafc 	bl	14360 <main+0xd0>
		{
			// Open client socket. 
			if (tcp_client_socket < 0) 
   14d68:	4b42      	ldr	r3, [pc, #264]	; (14e74 <main+0xbe4>)
   14d6a:	781b      	ldrb	r3, [r3, #0]
   14d6c:	2b7f      	cmp	r3, #127	; 0x7f
   14d6e:	d801      	bhi.n	14d74 <main+0xae4>
   14d70:	f7ff faf6 	bl	14360 <main+0xd0>
			{
				if ((tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
   14d74:	2002      	movs	r0, #2
   14d76:	2101      	movs	r1, #1
   14d78:	2200      	movs	r2, #0
   14d7a:	4b3f      	ldr	r3, [pc, #252]	; (14e78 <main+0xbe8>)
   14d7c:	4798      	blx	r3
   14d7e:	1e01      	subs	r1, r0, #0
   14d80:	4b3c      	ldr	r3, [pc, #240]	; (14e74 <main+0xbe4>)
   14d82:	7018      	strb	r0, [r3, #0]
   14d84:	da04      	bge.n	14d90 <main+0xb00>
				{
					printf("main: failed to create TCP client socket error!\r\n");
   14d86:	483d      	ldr	r0, [pc, #244]	; (14e7c <main+0xbec>)
   14d88:	4b3d      	ldr	r3, [pc, #244]	; (14e80 <main+0xbf0>)
   14d8a:	4798      	blx	r3
					continue;
   14d8c:	f7ff fae8 	bl	14360 <main+0xd0>
				}
				// Connect server				
			    printf("socket_number new connection: %d\r\n", tcp_client_socket);
   14d90:	483c      	ldr	r0, [pc, #240]	; (14e84 <main+0xbf4>)
   14d92:	4f2c      	ldr	r7, [pc, #176]	; (14e44 <main+0xbb4>)
   14d94:	47b8      	blx	r7
			    ret=connect(tcp_client_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
   14d96:	4b37      	ldr	r3, [pc, #220]	; (14e74 <main+0xbe4>)
   14d98:	2000      	movs	r0, #0
   14d9a:	5618      	ldrsb	r0, [r3, r0]
   14d9c:	493a      	ldr	r1, [pc, #232]	; (14e88 <main+0xbf8>)
   14d9e:	2210      	movs	r2, #16
   14da0:	4b3a      	ldr	r3, [pc, #232]	; (14e8c <main+0xbfc>)
   14da2:	4798      	blx	r3
   14da4:	1c06      	adds	r6, r0, #0
			    printf("ret value: %d\r\n", ret);
   14da6:	483a      	ldr	r0, [pc, #232]	; (14e90 <main+0xc00>)
   14da8:	1c31      	adds	r1, r6, #0
   14daa:	47b8      	blx	r7
                connected = FALSE;
   14dac:	2200      	movs	r2, #0
   14dae:	466b      	mov	r3, sp
   14db0:	3307      	adds	r3, #7
   14db2:	33ff      	adds	r3, #255	; 0xff
   14db4:	701a      	strb	r2, [r3, #0]
				if (ret < 0) 
   14db6:	2e00      	cmp	r6, #0
   14db8:	db01      	blt.n	14dbe <main+0xb2e>
   14dba:	f7ff fad1 	bl	14360 <main+0xd0>
				{
					close(tcp_client_socket);
   14dbe:	4e2d      	ldr	r6, [pc, #180]	; (14e74 <main+0xbe4>)
   14dc0:	2000      	movs	r0, #0
   14dc2:	5630      	ldrsb	r0, [r6, r0]
   14dc4:	4b33      	ldr	r3, [pc, #204]	; (14e94 <main+0xc04>)
   14dc6:	4798      	blx	r3
					tcp_client_socket = -1;
   14dc8:	23ff      	movs	r3, #255	; 0xff
   14dca:	7033      	strb	r3, [r6, #0]
   14dcc:	f7ff fac8 	bl	14360 <main+0xd0>
	nm_bsp_init();
    port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
	// Enable SysTick interrupt for non busy wait delay.
	if (SysTick_Config(system_cpu_clock_get_hz() / 1000))
	{
	   puts("main: SysTick configuration error!");
   14dd0:	4831      	ldr	r0, [pc, #196]	; (14e98 <main+0xc08>)
   14dd2:	4b2b      	ldr	r3, [pc, #172]	; (14e80 <main+0xbf0>)
   14dd4:	4798      	blx	r3
   14dd6:	f7ff faa9 	bl	1432c <main+0x9c>
   14dda:	46c0      	nop			; (mov r8, r8)
   14ddc:	000007f1 	.word	0x000007f1
   14de0:	0002192c 	.word	0x0002192c
   14de4:	0000bc85 	.word	0x0000bc85
   14de8:	0000a539 	.word	0x0000a539
   14dec:	0000a77d 	.word	0x0000a77d
   14df0:	00002bf1 	.word	0x00002bf1
   14df4:	000099c5 	.word	0x000099c5
   14df8:	20001904 	.word	0x20001904
   14dfc:	0001fb3a 	.word	0x0001fb3a
   14e00:	00000a85 	.word	0x00000a85
   14e04:	00021744 	.word	0x00021744
   14e08:	20002c58 	.word	0x20002c58
   14e0c:	000028e9 	.word	0x000028e9
   14e10:	2000190c 	.word	0x2000190c
   14e14:	0000e21d 	.word	0x0000e21d
   14e18:	20001344 	.word	0x20001344
   14e1c:	20002448 	.word	0x20002448
   14e20:	01000403 	.word	0x01000403
   14e24:	0000bcfd 	.word	0x0000bcfd
   14e28:	000001c5 	.word	0x000001c5
   14e2c:	0001f054 	.word	0x0001f054
   14e30:	0000172d 	.word	0x0000172d
   14e34:	20001910 	.word	0x20001910
   14e38:	20001905 	.word	0x20001905
   14e3c:	00021750 	.word	0x00021750
   14e40:	00021318 	.word	0x00021318
   14e44:	00016e3d 	.word	0x00016e3d
   14e48:	00001435 	.word	0x00001435
   14e4c:	00000fb9 	.word	0x00000fb9
   14e50:	00000fc1 	.word	0x00000fc1
   14e54:	00000ab1 	.word	0x00000ab1
   14e58:	000063c5 	.word	0x000063c5
   14e5c:	00002981 	.word	0x00002981
   14e60:	00001965 	.word	0x00001965
   14e64:	0000ed15 	.word	0x0000ed15
   14e68:	00000bb8 	.word	0x00000bb8
   14e6c:	0000ed31 	.word	0x0000ed31
   14e70:	20001340 	.word	0x20001340
   14e74:	20000272 	.word	0x20000272
   14e78:	00012cb1 	.word	0x00012cb1
   14e7c:	00021778 	.word	0x00021778
   14e80:	00016f5d 	.word	0x00016f5d
   14e84:	000217ac 	.word	0x000217ac
   14e88:	20002c48 	.word	0x20002c48
   14e8c:	00012ded 	.word	0x00012ded
   14e90:	000217d0 	.word	0x000217d0
   14e94:	00013085 	.word	0x00013085
   14e98:	000217e0 	.word	0x000217e0

00014e9c <__aeabi_uidiv>:
   14e9c:	2200      	movs	r2, #0
   14e9e:	0843      	lsrs	r3, r0, #1
   14ea0:	428b      	cmp	r3, r1
   14ea2:	d374      	bcc.n	14f8e <__aeabi_uidiv+0xf2>
   14ea4:	0903      	lsrs	r3, r0, #4
   14ea6:	428b      	cmp	r3, r1
   14ea8:	d35f      	bcc.n	14f6a <__aeabi_uidiv+0xce>
   14eaa:	0a03      	lsrs	r3, r0, #8
   14eac:	428b      	cmp	r3, r1
   14eae:	d344      	bcc.n	14f3a <__aeabi_uidiv+0x9e>
   14eb0:	0b03      	lsrs	r3, r0, #12
   14eb2:	428b      	cmp	r3, r1
   14eb4:	d328      	bcc.n	14f08 <__aeabi_uidiv+0x6c>
   14eb6:	0c03      	lsrs	r3, r0, #16
   14eb8:	428b      	cmp	r3, r1
   14eba:	d30d      	bcc.n	14ed8 <__aeabi_uidiv+0x3c>
   14ebc:	22ff      	movs	r2, #255	; 0xff
   14ebe:	0209      	lsls	r1, r1, #8
   14ec0:	ba12      	rev	r2, r2
   14ec2:	0c03      	lsrs	r3, r0, #16
   14ec4:	428b      	cmp	r3, r1
   14ec6:	d302      	bcc.n	14ece <__aeabi_uidiv+0x32>
   14ec8:	1212      	asrs	r2, r2, #8
   14eca:	0209      	lsls	r1, r1, #8
   14ecc:	d065      	beq.n	14f9a <__aeabi_uidiv+0xfe>
   14ece:	0b03      	lsrs	r3, r0, #12
   14ed0:	428b      	cmp	r3, r1
   14ed2:	d319      	bcc.n	14f08 <__aeabi_uidiv+0x6c>
   14ed4:	e000      	b.n	14ed8 <__aeabi_uidiv+0x3c>
   14ed6:	0a09      	lsrs	r1, r1, #8
   14ed8:	0bc3      	lsrs	r3, r0, #15
   14eda:	428b      	cmp	r3, r1
   14edc:	d301      	bcc.n	14ee2 <__aeabi_uidiv+0x46>
   14ede:	03cb      	lsls	r3, r1, #15
   14ee0:	1ac0      	subs	r0, r0, r3
   14ee2:	4152      	adcs	r2, r2
   14ee4:	0b83      	lsrs	r3, r0, #14
   14ee6:	428b      	cmp	r3, r1
   14ee8:	d301      	bcc.n	14eee <__aeabi_uidiv+0x52>
   14eea:	038b      	lsls	r3, r1, #14
   14eec:	1ac0      	subs	r0, r0, r3
   14eee:	4152      	adcs	r2, r2
   14ef0:	0b43      	lsrs	r3, r0, #13
   14ef2:	428b      	cmp	r3, r1
   14ef4:	d301      	bcc.n	14efa <__aeabi_uidiv+0x5e>
   14ef6:	034b      	lsls	r3, r1, #13
   14ef8:	1ac0      	subs	r0, r0, r3
   14efa:	4152      	adcs	r2, r2
   14efc:	0b03      	lsrs	r3, r0, #12
   14efe:	428b      	cmp	r3, r1
   14f00:	d301      	bcc.n	14f06 <__aeabi_uidiv+0x6a>
   14f02:	030b      	lsls	r3, r1, #12
   14f04:	1ac0      	subs	r0, r0, r3
   14f06:	4152      	adcs	r2, r2
   14f08:	0ac3      	lsrs	r3, r0, #11
   14f0a:	428b      	cmp	r3, r1
   14f0c:	d301      	bcc.n	14f12 <__aeabi_uidiv+0x76>
   14f0e:	02cb      	lsls	r3, r1, #11
   14f10:	1ac0      	subs	r0, r0, r3
   14f12:	4152      	adcs	r2, r2
   14f14:	0a83      	lsrs	r3, r0, #10
   14f16:	428b      	cmp	r3, r1
   14f18:	d301      	bcc.n	14f1e <__aeabi_uidiv+0x82>
   14f1a:	028b      	lsls	r3, r1, #10
   14f1c:	1ac0      	subs	r0, r0, r3
   14f1e:	4152      	adcs	r2, r2
   14f20:	0a43      	lsrs	r3, r0, #9
   14f22:	428b      	cmp	r3, r1
   14f24:	d301      	bcc.n	14f2a <__aeabi_uidiv+0x8e>
   14f26:	024b      	lsls	r3, r1, #9
   14f28:	1ac0      	subs	r0, r0, r3
   14f2a:	4152      	adcs	r2, r2
   14f2c:	0a03      	lsrs	r3, r0, #8
   14f2e:	428b      	cmp	r3, r1
   14f30:	d301      	bcc.n	14f36 <__aeabi_uidiv+0x9a>
   14f32:	020b      	lsls	r3, r1, #8
   14f34:	1ac0      	subs	r0, r0, r3
   14f36:	4152      	adcs	r2, r2
   14f38:	d2cd      	bcs.n	14ed6 <__aeabi_uidiv+0x3a>
   14f3a:	09c3      	lsrs	r3, r0, #7
   14f3c:	428b      	cmp	r3, r1
   14f3e:	d301      	bcc.n	14f44 <__aeabi_uidiv+0xa8>
   14f40:	01cb      	lsls	r3, r1, #7
   14f42:	1ac0      	subs	r0, r0, r3
   14f44:	4152      	adcs	r2, r2
   14f46:	0983      	lsrs	r3, r0, #6
   14f48:	428b      	cmp	r3, r1
   14f4a:	d301      	bcc.n	14f50 <__aeabi_uidiv+0xb4>
   14f4c:	018b      	lsls	r3, r1, #6
   14f4e:	1ac0      	subs	r0, r0, r3
   14f50:	4152      	adcs	r2, r2
   14f52:	0943      	lsrs	r3, r0, #5
   14f54:	428b      	cmp	r3, r1
   14f56:	d301      	bcc.n	14f5c <__aeabi_uidiv+0xc0>
   14f58:	014b      	lsls	r3, r1, #5
   14f5a:	1ac0      	subs	r0, r0, r3
   14f5c:	4152      	adcs	r2, r2
   14f5e:	0903      	lsrs	r3, r0, #4
   14f60:	428b      	cmp	r3, r1
   14f62:	d301      	bcc.n	14f68 <__aeabi_uidiv+0xcc>
   14f64:	010b      	lsls	r3, r1, #4
   14f66:	1ac0      	subs	r0, r0, r3
   14f68:	4152      	adcs	r2, r2
   14f6a:	08c3      	lsrs	r3, r0, #3
   14f6c:	428b      	cmp	r3, r1
   14f6e:	d301      	bcc.n	14f74 <__aeabi_uidiv+0xd8>
   14f70:	00cb      	lsls	r3, r1, #3
   14f72:	1ac0      	subs	r0, r0, r3
   14f74:	4152      	adcs	r2, r2
   14f76:	0883      	lsrs	r3, r0, #2
   14f78:	428b      	cmp	r3, r1
   14f7a:	d301      	bcc.n	14f80 <__aeabi_uidiv+0xe4>
   14f7c:	008b      	lsls	r3, r1, #2
   14f7e:	1ac0      	subs	r0, r0, r3
   14f80:	4152      	adcs	r2, r2
   14f82:	0843      	lsrs	r3, r0, #1
   14f84:	428b      	cmp	r3, r1
   14f86:	d301      	bcc.n	14f8c <__aeabi_uidiv+0xf0>
   14f88:	004b      	lsls	r3, r1, #1
   14f8a:	1ac0      	subs	r0, r0, r3
   14f8c:	4152      	adcs	r2, r2
   14f8e:	1a41      	subs	r1, r0, r1
   14f90:	d200      	bcs.n	14f94 <__aeabi_uidiv+0xf8>
   14f92:	4601      	mov	r1, r0
   14f94:	4152      	adcs	r2, r2
   14f96:	4610      	mov	r0, r2
   14f98:	4770      	bx	lr
   14f9a:	e7ff      	b.n	14f9c <__aeabi_uidiv+0x100>
   14f9c:	b501      	push	{r0, lr}
   14f9e:	2000      	movs	r0, #0
   14fa0:	f000 f8fc 	bl	1519c <__aeabi_idiv0>
   14fa4:	bd02      	pop	{r1, pc}
   14fa6:	46c0      	nop			; (mov r8, r8)

00014fa8 <__aeabi_uidivmod>:
   14fa8:	2900      	cmp	r1, #0
   14faa:	d0f7      	beq.n	14f9c <__aeabi_uidiv+0x100>
   14fac:	b503      	push	{r0, r1, lr}
   14fae:	f7ff ff75 	bl	14e9c <__aeabi_uidiv>
   14fb2:	bc0e      	pop	{r1, r2, r3}
   14fb4:	4342      	muls	r2, r0
   14fb6:	1a89      	subs	r1, r1, r2
   14fb8:	4718      	bx	r3
   14fba:	46c0      	nop			; (mov r8, r8)

00014fbc <__aeabi_idiv>:
   14fbc:	4603      	mov	r3, r0
   14fbe:	430b      	orrs	r3, r1
   14fc0:	d47f      	bmi.n	150c2 <__aeabi_idiv+0x106>
   14fc2:	2200      	movs	r2, #0
   14fc4:	0843      	lsrs	r3, r0, #1
   14fc6:	428b      	cmp	r3, r1
   14fc8:	d374      	bcc.n	150b4 <__aeabi_idiv+0xf8>
   14fca:	0903      	lsrs	r3, r0, #4
   14fcc:	428b      	cmp	r3, r1
   14fce:	d35f      	bcc.n	15090 <__aeabi_idiv+0xd4>
   14fd0:	0a03      	lsrs	r3, r0, #8
   14fd2:	428b      	cmp	r3, r1
   14fd4:	d344      	bcc.n	15060 <__aeabi_idiv+0xa4>
   14fd6:	0b03      	lsrs	r3, r0, #12
   14fd8:	428b      	cmp	r3, r1
   14fda:	d328      	bcc.n	1502e <__aeabi_idiv+0x72>
   14fdc:	0c03      	lsrs	r3, r0, #16
   14fde:	428b      	cmp	r3, r1
   14fe0:	d30d      	bcc.n	14ffe <__aeabi_idiv+0x42>
   14fe2:	22ff      	movs	r2, #255	; 0xff
   14fe4:	0209      	lsls	r1, r1, #8
   14fe6:	ba12      	rev	r2, r2
   14fe8:	0c03      	lsrs	r3, r0, #16
   14fea:	428b      	cmp	r3, r1
   14fec:	d302      	bcc.n	14ff4 <__aeabi_idiv+0x38>
   14fee:	1212      	asrs	r2, r2, #8
   14ff0:	0209      	lsls	r1, r1, #8
   14ff2:	d065      	beq.n	150c0 <__aeabi_idiv+0x104>
   14ff4:	0b03      	lsrs	r3, r0, #12
   14ff6:	428b      	cmp	r3, r1
   14ff8:	d319      	bcc.n	1502e <__aeabi_idiv+0x72>
   14ffa:	e000      	b.n	14ffe <__aeabi_idiv+0x42>
   14ffc:	0a09      	lsrs	r1, r1, #8
   14ffe:	0bc3      	lsrs	r3, r0, #15
   15000:	428b      	cmp	r3, r1
   15002:	d301      	bcc.n	15008 <__aeabi_idiv+0x4c>
   15004:	03cb      	lsls	r3, r1, #15
   15006:	1ac0      	subs	r0, r0, r3
   15008:	4152      	adcs	r2, r2
   1500a:	0b83      	lsrs	r3, r0, #14
   1500c:	428b      	cmp	r3, r1
   1500e:	d301      	bcc.n	15014 <__aeabi_idiv+0x58>
   15010:	038b      	lsls	r3, r1, #14
   15012:	1ac0      	subs	r0, r0, r3
   15014:	4152      	adcs	r2, r2
   15016:	0b43      	lsrs	r3, r0, #13
   15018:	428b      	cmp	r3, r1
   1501a:	d301      	bcc.n	15020 <__aeabi_idiv+0x64>
   1501c:	034b      	lsls	r3, r1, #13
   1501e:	1ac0      	subs	r0, r0, r3
   15020:	4152      	adcs	r2, r2
   15022:	0b03      	lsrs	r3, r0, #12
   15024:	428b      	cmp	r3, r1
   15026:	d301      	bcc.n	1502c <__aeabi_idiv+0x70>
   15028:	030b      	lsls	r3, r1, #12
   1502a:	1ac0      	subs	r0, r0, r3
   1502c:	4152      	adcs	r2, r2
   1502e:	0ac3      	lsrs	r3, r0, #11
   15030:	428b      	cmp	r3, r1
   15032:	d301      	bcc.n	15038 <__aeabi_idiv+0x7c>
   15034:	02cb      	lsls	r3, r1, #11
   15036:	1ac0      	subs	r0, r0, r3
   15038:	4152      	adcs	r2, r2
   1503a:	0a83      	lsrs	r3, r0, #10
   1503c:	428b      	cmp	r3, r1
   1503e:	d301      	bcc.n	15044 <__aeabi_idiv+0x88>
   15040:	028b      	lsls	r3, r1, #10
   15042:	1ac0      	subs	r0, r0, r3
   15044:	4152      	adcs	r2, r2
   15046:	0a43      	lsrs	r3, r0, #9
   15048:	428b      	cmp	r3, r1
   1504a:	d301      	bcc.n	15050 <__aeabi_idiv+0x94>
   1504c:	024b      	lsls	r3, r1, #9
   1504e:	1ac0      	subs	r0, r0, r3
   15050:	4152      	adcs	r2, r2
   15052:	0a03      	lsrs	r3, r0, #8
   15054:	428b      	cmp	r3, r1
   15056:	d301      	bcc.n	1505c <__aeabi_idiv+0xa0>
   15058:	020b      	lsls	r3, r1, #8
   1505a:	1ac0      	subs	r0, r0, r3
   1505c:	4152      	adcs	r2, r2
   1505e:	d2cd      	bcs.n	14ffc <__aeabi_idiv+0x40>
   15060:	09c3      	lsrs	r3, r0, #7
   15062:	428b      	cmp	r3, r1
   15064:	d301      	bcc.n	1506a <__aeabi_idiv+0xae>
   15066:	01cb      	lsls	r3, r1, #7
   15068:	1ac0      	subs	r0, r0, r3
   1506a:	4152      	adcs	r2, r2
   1506c:	0983      	lsrs	r3, r0, #6
   1506e:	428b      	cmp	r3, r1
   15070:	d301      	bcc.n	15076 <__aeabi_idiv+0xba>
   15072:	018b      	lsls	r3, r1, #6
   15074:	1ac0      	subs	r0, r0, r3
   15076:	4152      	adcs	r2, r2
   15078:	0943      	lsrs	r3, r0, #5
   1507a:	428b      	cmp	r3, r1
   1507c:	d301      	bcc.n	15082 <__aeabi_idiv+0xc6>
   1507e:	014b      	lsls	r3, r1, #5
   15080:	1ac0      	subs	r0, r0, r3
   15082:	4152      	adcs	r2, r2
   15084:	0903      	lsrs	r3, r0, #4
   15086:	428b      	cmp	r3, r1
   15088:	d301      	bcc.n	1508e <__aeabi_idiv+0xd2>
   1508a:	010b      	lsls	r3, r1, #4
   1508c:	1ac0      	subs	r0, r0, r3
   1508e:	4152      	adcs	r2, r2
   15090:	08c3      	lsrs	r3, r0, #3
   15092:	428b      	cmp	r3, r1
   15094:	d301      	bcc.n	1509a <__aeabi_idiv+0xde>
   15096:	00cb      	lsls	r3, r1, #3
   15098:	1ac0      	subs	r0, r0, r3
   1509a:	4152      	adcs	r2, r2
   1509c:	0883      	lsrs	r3, r0, #2
   1509e:	428b      	cmp	r3, r1
   150a0:	d301      	bcc.n	150a6 <__aeabi_idiv+0xea>
   150a2:	008b      	lsls	r3, r1, #2
   150a4:	1ac0      	subs	r0, r0, r3
   150a6:	4152      	adcs	r2, r2
   150a8:	0843      	lsrs	r3, r0, #1
   150aa:	428b      	cmp	r3, r1
   150ac:	d301      	bcc.n	150b2 <__aeabi_idiv+0xf6>
   150ae:	004b      	lsls	r3, r1, #1
   150b0:	1ac0      	subs	r0, r0, r3
   150b2:	4152      	adcs	r2, r2
   150b4:	1a41      	subs	r1, r0, r1
   150b6:	d200      	bcs.n	150ba <__aeabi_idiv+0xfe>
   150b8:	4601      	mov	r1, r0
   150ba:	4152      	adcs	r2, r2
   150bc:	4610      	mov	r0, r2
   150be:	4770      	bx	lr
   150c0:	e05d      	b.n	1517e <__aeabi_idiv+0x1c2>
   150c2:	0fca      	lsrs	r2, r1, #31
   150c4:	d000      	beq.n	150c8 <__aeabi_idiv+0x10c>
   150c6:	4249      	negs	r1, r1
   150c8:	1003      	asrs	r3, r0, #32
   150ca:	d300      	bcc.n	150ce <__aeabi_idiv+0x112>
   150cc:	4240      	negs	r0, r0
   150ce:	4053      	eors	r3, r2
   150d0:	2200      	movs	r2, #0
   150d2:	469c      	mov	ip, r3
   150d4:	0903      	lsrs	r3, r0, #4
   150d6:	428b      	cmp	r3, r1
   150d8:	d32d      	bcc.n	15136 <__aeabi_idiv+0x17a>
   150da:	0a03      	lsrs	r3, r0, #8
   150dc:	428b      	cmp	r3, r1
   150de:	d312      	bcc.n	15106 <__aeabi_idiv+0x14a>
   150e0:	22fc      	movs	r2, #252	; 0xfc
   150e2:	0189      	lsls	r1, r1, #6
   150e4:	ba12      	rev	r2, r2
   150e6:	0a03      	lsrs	r3, r0, #8
   150e8:	428b      	cmp	r3, r1
   150ea:	d30c      	bcc.n	15106 <__aeabi_idiv+0x14a>
   150ec:	0189      	lsls	r1, r1, #6
   150ee:	1192      	asrs	r2, r2, #6
   150f0:	428b      	cmp	r3, r1
   150f2:	d308      	bcc.n	15106 <__aeabi_idiv+0x14a>
   150f4:	0189      	lsls	r1, r1, #6
   150f6:	1192      	asrs	r2, r2, #6
   150f8:	428b      	cmp	r3, r1
   150fa:	d304      	bcc.n	15106 <__aeabi_idiv+0x14a>
   150fc:	0189      	lsls	r1, r1, #6
   150fe:	d03a      	beq.n	15176 <__aeabi_idiv+0x1ba>
   15100:	1192      	asrs	r2, r2, #6
   15102:	e000      	b.n	15106 <__aeabi_idiv+0x14a>
   15104:	0989      	lsrs	r1, r1, #6
   15106:	09c3      	lsrs	r3, r0, #7
   15108:	428b      	cmp	r3, r1
   1510a:	d301      	bcc.n	15110 <__aeabi_idiv+0x154>
   1510c:	01cb      	lsls	r3, r1, #7
   1510e:	1ac0      	subs	r0, r0, r3
   15110:	4152      	adcs	r2, r2
   15112:	0983      	lsrs	r3, r0, #6
   15114:	428b      	cmp	r3, r1
   15116:	d301      	bcc.n	1511c <__aeabi_idiv+0x160>
   15118:	018b      	lsls	r3, r1, #6
   1511a:	1ac0      	subs	r0, r0, r3
   1511c:	4152      	adcs	r2, r2
   1511e:	0943      	lsrs	r3, r0, #5
   15120:	428b      	cmp	r3, r1
   15122:	d301      	bcc.n	15128 <__aeabi_idiv+0x16c>
   15124:	014b      	lsls	r3, r1, #5
   15126:	1ac0      	subs	r0, r0, r3
   15128:	4152      	adcs	r2, r2
   1512a:	0903      	lsrs	r3, r0, #4
   1512c:	428b      	cmp	r3, r1
   1512e:	d301      	bcc.n	15134 <__aeabi_idiv+0x178>
   15130:	010b      	lsls	r3, r1, #4
   15132:	1ac0      	subs	r0, r0, r3
   15134:	4152      	adcs	r2, r2
   15136:	08c3      	lsrs	r3, r0, #3
   15138:	428b      	cmp	r3, r1
   1513a:	d301      	bcc.n	15140 <__aeabi_idiv+0x184>
   1513c:	00cb      	lsls	r3, r1, #3
   1513e:	1ac0      	subs	r0, r0, r3
   15140:	4152      	adcs	r2, r2
   15142:	0883      	lsrs	r3, r0, #2
   15144:	428b      	cmp	r3, r1
   15146:	d301      	bcc.n	1514c <__aeabi_idiv+0x190>
   15148:	008b      	lsls	r3, r1, #2
   1514a:	1ac0      	subs	r0, r0, r3
   1514c:	4152      	adcs	r2, r2
   1514e:	d2d9      	bcs.n	15104 <__aeabi_idiv+0x148>
   15150:	0843      	lsrs	r3, r0, #1
   15152:	428b      	cmp	r3, r1
   15154:	d301      	bcc.n	1515a <__aeabi_idiv+0x19e>
   15156:	004b      	lsls	r3, r1, #1
   15158:	1ac0      	subs	r0, r0, r3
   1515a:	4152      	adcs	r2, r2
   1515c:	1a41      	subs	r1, r0, r1
   1515e:	d200      	bcs.n	15162 <__aeabi_idiv+0x1a6>
   15160:	4601      	mov	r1, r0
   15162:	4663      	mov	r3, ip
   15164:	4152      	adcs	r2, r2
   15166:	105b      	asrs	r3, r3, #1
   15168:	4610      	mov	r0, r2
   1516a:	d301      	bcc.n	15170 <__aeabi_idiv+0x1b4>
   1516c:	4240      	negs	r0, r0
   1516e:	2b00      	cmp	r3, #0
   15170:	d500      	bpl.n	15174 <__aeabi_idiv+0x1b8>
   15172:	4249      	negs	r1, r1
   15174:	4770      	bx	lr
   15176:	4663      	mov	r3, ip
   15178:	105b      	asrs	r3, r3, #1
   1517a:	d300      	bcc.n	1517e <__aeabi_idiv+0x1c2>
   1517c:	4240      	negs	r0, r0
   1517e:	b501      	push	{r0, lr}
   15180:	2000      	movs	r0, #0
   15182:	f000 f80b 	bl	1519c <__aeabi_idiv0>
   15186:	bd02      	pop	{r1, pc}

00015188 <__aeabi_idivmod>:
   15188:	2900      	cmp	r1, #0
   1518a:	d0f8      	beq.n	1517e <__aeabi_idiv+0x1c2>
   1518c:	b503      	push	{r0, r1, lr}
   1518e:	f7ff ff15 	bl	14fbc <__aeabi_idiv>
   15192:	bc0e      	pop	{r1, r2, r3}
   15194:	4342      	muls	r2, r0
   15196:	1a89      	subs	r1, r1, r2
   15198:	4718      	bx	r3
   1519a:	46c0      	nop			; (mov r8, r8)

0001519c <__aeabi_idiv0>:
   1519c:	4770      	bx	lr
   1519e:	46c0      	nop			; (mov r8, r8)

000151a0 <__aeabi_lmul>:
   151a0:	b5f0      	push	{r4, r5, r6, r7, lr}
   151a2:	464f      	mov	r7, r9
   151a4:	4646      	mov	r6, r8
   151a6:	0405      	lsls	r5, r0, #16
   151a8:	0c2d      	lsrs	r5, r5, #16
   151aa:	1c2c      	adds	r4, r5, #0
   151ac:	b4c0      	push	{r6, r7}
   151ae:	0417      	lsls	r7, r2, #16
   151b0:	0c16      	lsrs	r6, r2, #16
   151b2:	0c3f      	lsrs	r7, r7, #16
   151b4:	4699      	mov	r9, r3
   151b6:	0c03      	lsrs	r3, r0, #16
   151b8:	437c      	muls	r4, r7
   151ba:	4375      	muls	r5, r6
   151bc:	435f      	muls	r7, r3
   151be:	4373      	muls	r3, r6
   151c0:	197d      	adds	r5, r7, r5
   151c2:	0c26      	lsrs	r6, r4, #16
   151c4:	19ad      	adds	r5, r5, r6
   151c6:	469c      	mov	ip, r3
   151c8:	42af      	cmp	r7, r5
   151ca:	d903      	bls.n	151d4 <__aeabi_lmul+0x34>
   151cc:	2380      	movs	r3, #128	; 0x80
   151ce:	025b      	lsls	r3, r3, #9
   151d0:	4698      	mov	r8, r3
   151d2:	44c4      	add	ip, r8
   151d4:	464b      	mov	r3, r9
   151d6:	4351      	muls	r1, r2
   151d8:	4343      	muls	r3, r0
   151da:	0424      	lsls	r4, r4, #16
   151dc:	0c2e      	lsrs	r6, r5, #16
   151de:	0c24      	lsrs	r4, r4, #16
   151e0:	042d      	lsls	r5, r5, #16
   151e2:	4466      	add	r6, ip
   151e4:	192c      	adds	r4, r5, r4
   151e6:	1859      	adds	r1, r3, r1
   151e8:	1989      	adds	r1, r1, r6
   151ea:	1c20      	adds	r0, r4, #0
   151ec:	bc0c      	pop	{r2, r3}
   151ee:	4690      	mov	r8, r2
   151f0:	4699      	mov	r9, r3
   151f2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000151f4 <__aeabi_dadd>:
   151f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   151f6:	4645      	mov	r5, r8
   151f8:	4657      	mov	r7, sl
   151fa:	464e      	mov	r6, r9
   151fc:	4694      	mov	ip, r2
   151fe:	004c      	lsls	r4, r1, #1
   15200:	030a      	lsls	r2, r1, #12
   15202:	0fc9      	lsrs	r1, r1, #31
   15204:	b4e0      	push	{r5, r6, r7}
   15206:	4688      	mov	r8, r1
   15208:	1c0e      	adds	r6, r1, #0
   1520a:	0319      	lsls	r1, r3, #12
   1520c:	0f47      	lsrs	r7, r0, #29
   1520e:	00c5      	lsls	r5, r0, #3
   15210:	0a48      	lsrs	r0, r1, #9
   15212:	4661      	mov	r1, ip
   15214:	0f49      	lsrs	r1, r1, #29
   15216:	4301      	orrs	r1, r0
   15218:	4660      	mov	r0, ip
   1521a:	0a52      	lsrs	r2, r2, #9
   1521c:	4317      	orrs	r7, r2
   1521e:	00c0      	lsls	r0, r0, #3
   15220:	005a      	lsls	r2, r3, #1
   15222:	0d64      	lsrs	r4, r4, #21
   15224:	0d52      	lsrs	r2, r2, #21
   15226:	0fdb      	lsrs	r3, r3, #31
   15228:	4684      	mov	ip, r0
   1522a:	4598      	cmp	r8, r3
   1522c:	d100      	bne.n	15230 <__aeabi_dadd+0x3c>
   1522e:	e0a7      	b.n	15380 <__aeabi_dadd+0x18c>
   15230:	1aa0      	subs	r0, r4, r2
   15232:	2800      	cmp	r0, #0
   15234:	dc00      	bgt.n	15238 <__aeabi_dadd+0x44>
   15236:	e101      	b.n	1543c <__aeabi_dadd+0x248>
   15238:	2a00      	cmp	r2, #0
   1523a:	d13d      	bne.n	152b8 <__aeabi_dadd+0xc4>
   1523c:	4663      	mov	r3, ip
   1523e:	430b      	orrs	r3, r1
   15240:	d000      	beq.n	15244 <__aeabi_dadd+0x50>
   15242:	e0d4      	b.n	153ee <__aeabi_dadd+0x1fa>
   15244:	076b      	lsls	r3, r5, #29
   15246:	d100      	bne.n	1524a <__aeabi_dadd+0x56>
   15248:	e088      	b.n	1535c <__aeabi_dadd+0x168>
   1524a:	230f      	movs	r3, #15
   1524c:	402b      	ands	r3, r5
   1524e:	2b04      	cmp	r3, #4
   15250:	d100      	bne.n	15254 <__aeabi_dadd+0x60>
   15252:	e083      	b.n	1535c <__aeabi_dadd+0x168>
   15254:	1d2a      	adds	r2, r5, #4
   15256:	42aa      	cmp	r2, r5
   15258:	41ad      	sbcs	r5, r5
   1525a:	2380      	movs	r3, #128	; 0x80
   1525c:	426d      	negs	r5, r5
   1525e:	197f      	adds	r7, r7, r5
   15260:	041b      	lsls	r3, r3, #16
   15262:	403b      	ands	r3, r7
   15264:	4646      	mov	r6, r8
   15266:	1c15      	adds	r5, r2, #0
   15268:	2b00      	cmp	r3, #0
   1526a:	d100      	bne.n	1526e <__aeabi_dadd+0x7a>
   1526c:	e07c      	b.n	15368 <__aeabi_dadd+0x174>
   1526e:	4bcc      	ldr	r3, [pc, #816]	; (155a0 <__aeabi_dadd+0x3ac>)
   15270:	3401      	adds	r4, #1
   15272:	429c      	cmp	r4, r3
   15274:	d100      	bne.n	15278 <__aeabi_dadd+0x84>
   15276:	e0fd      	b.n	15474 <__aeabi_dadd+0x280>
   15278:	1c3a      	adds	r2, r7, #0
   1527a:	4bca      	ldr	r3, [pc, #808]	; (155a4 <__aeabi_dadd+0x3b0>)
   1527c:	08ed      	lsrs	r5, r5, #3
   1527e:	401a      	ands	r2, r3
   15280:	0750      	lsls	r0, r2, #29
   15282:	0564      	lsls	r4, r4, #21
   15284:	0252      	lsls	r2, r2, #9
   15286:	4305      	orrs	r5, r0
   15288:	0b12      	lsrs	r2, r2, #12
   1528a:	0d64      	lsrs	r4, r4, #21
   1528c:	2100      	movs	r1, #0
   1528e:	0312      	lsls	r2, r2, #12
   15290:	0d0b      	lsrs	r3, r1, #20
   15292:	051b      	lsls	r3, r3, #20
   15294:	0564      	lsls	r4, r4, #21
   15296:	0b12      	lsrs	r2, r2, #12
   15298:	431a      	orrs	r2, r3
   1529a:	0863      	lsrs	r3, r4, #1
   1529c:	4cc2      	ldr	r4, [pc, #776]	; (155a8 <__aeabi_dadd+0x3b4>)
   1529e:	07f6      	lsls	r6, r6, #31
   152a0:	4014      	ands	r4, r2
   152a2:	431c      	orrs	r4, r3
   152a4:	0064      	lsls	r4, r4, #1
   152a6:	0864      	lsrs	r4, r4, #1
   152a8:	4334      	orrs	r4, r6
   152aa:	1c28      	adds	r0, r5, #0
   152ac:	1c21      	adds	r1, r4, #0
   152ae:	bc1c      	pop	{r2, r3, r4}
   152b0:	4690      	mov	r8, r2
   152b2:	4699      	mov	r9, r3
   152b4:	46a2      	mov	sl, r4
   152b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   152b8:	4bb9      	ldr	r3, [pc, #740]	; (155a0 <__aeabi_dadd+0x3ac>)
   152ba:	429c      	cmp	r4, r3
   152bc:	d0c2      	beq.n	15244 <__aeabi_dadd+0x50>
   152be:	2380      	movs	r3, #128	; 0x80
   152c0:	041b      	lsls	r3, r3, #16
   152c2:	4319      	orrs	r1, r3
   152c4:	2838      	cmp	r0, #56	; 0x38
   152c6:	dd00      	ble.n	152ca <__aeabi_dadd+0xd6>
   152c8:	e0ec      	b.n	154a4 <__aeabi_dadd+0x2b0>
   152ca:	281f      	cmp	r0, #31
   152cc:	dd00      	ble.n	152d0 <__aeabi_dadd+0xdc>
   152ce:	e121      	b.n	15514 <__aeabi_dadd+0x320>
   152d0:	2220      	movs	r2, #32
   152d2:	1c0e      	adds	r6, r1, #0
   152d4:	4663      	mov	r3, ip
   152d6:	1a12      	subs	r2, r2, r0
   152d8:	4096      	lsls	r6, r2
   152da:	40c3      	lsrs	r3, r0
   152dc:	4333      	orrs	r3, r6
   152de:	4666      	mov	r6, ip
   152e0:	4096      	lsls	r6, r2
   152e2:	1c32      	adds	r2, r6, #0
   152e4:	1e56      	subs	r6, r2, #1
   152e6:	41b2      	sbcs	r2, r6
   152e8:	4313      	orrs	r3, r2
   152ea:	1c0a      	adds	r2, r1, #0
   152ec:	40c2      	lsrs	r2, r0
   152ee:	1aeb      	subs	r3, r5, r3
   152f0:	429d      	cmp	r5, r3
   152f2:	41b6      	sbcs	r6, r6
   152f4:	1c1d      	adds	r5, r3, #0
   152f6:	1aba      	subs	r2, r7, r2
   152f8:	4276      	negs	r6, r6
   152fa:	1b97      	subs	r7, r2, r6
   152fc:	023b      	lsls	r3, r7, #8
   152fe:	d400      	bmi.n	15302 <__aeabi_dadd+0x10e>
   15300:	e097      	b.n	15432 <__aeabi_dadd+0x23e>
   15302:	027a      	lsls	r2, r7, #9
   15304:	0a56      	lsrs	r6, r2, #9
   15306:	2e00      	cmp	r6, #0
   15308:	d100      	bne.n	1530c <__aeabi_dadd+0x118>
   1530a:	e0b6      	b.n	1547a <__aeabi_dadd+0x286>
   1530c:	1c30      	adds	r0, r6, #0
   1530e:	f001 f96d 	bl	165ec <__clzsi2>
   15312:	1c03      	adds	r3, r0, #0
   15314:	3b08      	subs	r3, #8
   15316:	2b1f      	cmp	r3, #31
   15318:	dd00      	ble.n	1531c <__aeabi_dadd+0x128>
   1531a:	e0b7      	b.n	1548c <__aeabi_dadd+0x298>
   1531c:	409e      	lsls	r6, r3
   1531e:	1c37      	adds	r7, r6, #0
   15320:	2628      	movs	r6, #40	; 0x28
   15322:	1c2a      	adds	r2, r5, #0
   15324:	1a36      	subs	r6, r6, r0
   15326:	40f2      	lsrs	r2, r6
   15328:	1c16      	adds	r6, r2, #0
   1532a:	409d      	lsls	r5, r3
   1532c:	433e      	orrs	r6, r7
   1532e:	429c      	cmp	r4, r3
   15330:	dd00      	ble.n	15334 <__aeabi_dadd+0x140>
   15332:	e0b2      	b.n	1549a <__aeabi_dadd+0x2a6>
   15334:	1b1c      	subs	r4, r3, r4
   15336:	1c62      	adds	r2, r4, #1
   15338:	2a1f      	cmp	r2, #31
   1533a:	dd00      	ble.n	1533e <__aeabi_dadd+0x14a>
   1533c:	e0d8      	b.n	154f0 <__aeabi_dadd+0x2fc>
   1533e:	231f      	movs	r3, #31
   15340:	1c29      	adds	r1, r5, #0
   15342:	1b1c      	subs	r4, r3, r4
   15344:	1c33      	adds	r3, r6, #0
   15346:	40a5      	lsls	r5, r4
   15348:	40a3      	lsls	r3, r4
   1534a:	40d1      	lsrs	r1, r2
   1534c:	1e6c      	subs	r4, r5, #1
   1534e:	41a5      	sbcs	r5, r4
   15350:	40d6      	lsrs	r6, r2
   15352:	4319      	orrs	r1, r3
   15354:	430d      	orrs	r5, r1
   15356:	1c37      	adds	r7, r6, #0
   15358:	2400      	movs	r4, #0
   1535a:	e773      	b.n	15244 <__aeabi_dadd+0x50>
   1535c:	2380      	movs	r3, #128	; 0x80
   1535e:	041b      	lsls	r3, r3, #16
   15360:	403b      	ands	r3, r7
   15362:	4646      	mov	r6, r8
   15364:	d000      	beq.n	15368 <__aeabi_dadd+0x174>
   15366:	e782      	b.n	1526e <__aeabi_dadd+0x7a>
   15368:	4b8d      	ldr	r3, [pc, #564]	; (155a0 <__aeabi_dadd+0x3ac>)
   1536a:	08ed      	lsrs	r5, r5, #3
   1536c:	0778      	lsls	r0, r7, #29
   1536e:	4305      	orrs	r5, r0
   15370:	08fa      	lsrs	r2, r7, #3
   15372:	429c      	cmp	r4, r3
   15374:	d032      	beq.n	153dc <__aeabi_dadd+0x1e8>
   15376:	0312      	lsls	r2, r2, #12
   15378:	0564      	lsls	r4, r4, #21
   1537a:	0b12      	lsrs	r2, r2, #12
   1537c:	0d64      	lsrs	r4, r4, #21
   1537e:	e785      	b.n	1528c <__aeabi_dadd+0x98>
   15380:	1aa3      	subs	r3, r4, r2
   15382:	2b00      	cmp	r3, #0
   15384:	dc00      	bgt.n	15388 <__aeabi_dadd+0x194>
   15386:	e094      	b.n	154b2 <__aeabi_dadd+0x2be>
   15388:	2a00      	cmp	r2, #0
   1538a:	d03c      	beq.n	15406 <__aeabi_dadd+0x212>
   1538c:	4a84      	ldr	r2, [pc, #528]	; (155a0 <__aeabi_dadd+0x3ac>)
   1538e:	4294      	cmp	r4, r2
   15390:	d100      	bne.n	15394 <__aeabi_dadd+0x1a0>
   15392:	e757      	b.n	15244 <__aeabi_dadd+0x50>
   15394:	2280      	movs	r2, #128	; 0x80
   15396:	0412      	lsls	r2, r2, #16
   15398:	4311      	orrs	r1, r2
   1539a:	2b38      	cmp	r3, #56	; 0x38
   1539c:	dc00      	bgt.n	153a0 <__aeabi_dadd+0x1ac>
   1539e:	e105      	b.n	155ac <__aeabi_dadd+0x3b8>
   153a0:	4663      	mov	r3, ip
   153a2:	4319      	orrs	r1, r3
   153a4:	1e48      	subs	r0, r1, #1
   153a6:	4181      	sbcs	r1, r0
   153a8:	2200      	movs	r2, #0
   153aa:	b2c8      	uxtb	r0, r1
   153ac:	1940      	adds	r0, r0, r5
   153ae:	42a8      	cmp	r0, r5
   153b0:	419b      	sbcs	r3, r3
   153b2:	1c05      	adds	r5, r0, #0
   153b4:	19d2      	adds	r2, r2, r7
   153b6:	425b      	negs	r3, r3
   153b8:	18d7      	adds	r7, r2, r3
   153ba:	023b      	lsls	r3, r7, #8
   153bc:	d539      	bpl.n	15432 <__aeabi_dadd+0x23e>
   153be:	4b78      	ldr	r3, [pc, #480]	; (155a0 <__aeabi_dadd+0x3ac>)
   153c0:	3401      	adds	r4, #1
   153c2:	429c      	cmp	r4, r3
   153c4:	d100      	bne.n	153c8 <__aeabi_dadd+0x1d4>
   153c6:	e14c      	b.n	15662 <__aeabi_dadd+0x46e>
   153c8:	2001      	movs	r0, #1
   153ca:	4a76      	ldr	r2, [pc, #472]	; (155a4 <__aeabi_dadd+0x3b0>)
   153cc:	086b      	lsrs	r3, r5, #1
   153ce:	403a      	ands	r2, r7
   153d0:	4028      	ands	r0, r5
   153d2:	4318      	orrs	r0, r3
   153d4:	07d5      	lsls	r5, r2, #31
   153d6:	4305      	orrs	r5, r0
   153d8:	0857      	lsrs	r7, r2, #1
   153da:	e733      	b.n	15244 <__aeabi_dadd+0x50>
   153dc:	1c2b      	adds	r3, r5, #0
   153de:	4313      	orrs	r3, r2
   153e0:	d048      	beq.n	15474 <__aeabi_dadd+0x280>
   153e2:	2380      	movs	r3, #128	; 0x80
   153e4:	031b      	lsls	r3, r3, #12
   153e6:	431a      	orrs	r2, r3
   153e8:	0312      	lsls	r2, r2, #12
   153ea:	0b12      	lsrs	r2, r2, #12
   153ec:	e74e      	b.n	1528c <__aeabi_dadd+0x98>
   153ee:	3801      	subs	r0, #1
   153f0:	2800      	cmp	r0, #0
   153f2:	d178      	bne.n	154e6 <__aeabi_dadd+0x2f2>
   153f4:	4663      	mov	r3, ip
   153f6:	1aee      	subs	r6, r5, r3
   153f8:	42b5      	cmp	r5, r6
   153fa:	419b      	sbcs	r3, r3
   153fc:	1a7a      	subs	r2, r7, r1
   153fe:	425b      	negs	r3, r3
   15400:	1ad7      	subs	r7, r2, r3
   15402:	1c35      	adds	r5, r6, #0
   15404:	e77a      	b.n	152fc <__aeabi_dadd+0x108>
   15406:	1c02      	adds	r2, r0, #0
   15408:	430a      	orrs	r2, r1
   1540a:	d100      	bne.n	1540e <__aeabi_dadd+0x21a>
   1540c:	e71a      	b.n	15244 <__aeabi_dadd+0x50>
   1540e:	3b01      	subs	r3, #1
   15410:	2b00      	cmp	r3, #0
   15412:	d000      	beq.n	15416 <__aeabi_dadd+0x222>
   15414:	e0f2      	b.n	155fc <__aeabi_dadd+0x408>
   15416:	1940      	adds	r0, r0, r5
   15418:	42a8      	cmp	r0, r5
   1541a:	419b      	sbcs	r3, r3
   1541c:	19ca      	adds	r2, r1, r7
   1541e:	425b      	negs	r3, r3
   15420:	18d7      	adds	r7, r2, r3
   15422:	1c05      	adds	r5, r0, #0
   15424:	e7c9      	b.n	153ba <__aeabi_dadd+0x1c6>
   15426:	1c13      	adds	r3, r2, #0
   15428:	4333      	orrs	r3, r6
   1542a:	d100      	bne.n	1542e <__aeabi_dadd+0x23a>
   1542c:	e118      	b.n	15660 <__aeabi_dadd+0x46c>
   1542e:	1c17      	adds	r7, r2, #0
   15430:	1c35      	adds	r5, r6, #0
   15432:	4646      	mov	r6, r8
   15434:	076b      	lsls	r3, r5, #29
   15436:	d000      	beq.n	1543a <__aeabi_dadd+0x246>
   15438:	e707      	b.n	1524a <__aeabi_dadd+0x56>
   1543a:	e795      	b.n	15368 <__aeabi_dadd+0x174>
   1543c:	2800      	cmp	r0, #0
   1543e:	d17a      	bne.n	15536 <__aeabi_dadd+0x342>
   15440:	1c62      	adds	r2, r4, #1
   15442:	0552      	lsls	r2, r2, #21
   15444:	0d52      	lsrs	r2, r2, #21
   15446:	2a01      	cmp	r2, #1
   15448:	dc00      	bgt.n	1544c <__aeabi_dadd+0x258>
   1544a:	e0fb      	b.n	15644 <__aeabi_dadd+0x450>
   1544c:	4662      	mov	r2, ip
   1544e:	1aaa      	subs	r2, r5, r2
   15450:	4295      	cmp	r5, r2
   15452:	41b6      	sbcs	r6, r6
   15454:	4691      	mov	r9, r2
   15456:	1a78      	subs	r0, r7, r1
   15458:	4272      	negs	r2, r6
   1545a:	1a86      	subs	r6, r0, r2
   1545c:	0232      	lsls	r2, r6, #8
   1545e:	d400      	bmi.n	15462 <__aeabi_dadd+0x26e>
   15460:	e093      	b.n	1558a <__aeabi_dadd+0x396>
   15462:	4662      	mov	r2, ip
   15464:	1b55      	subs	r5, r2, r5
   15466:	45ac      	cmp	ip, r5
   15468:	4180      	sbcs	r0, r0
   1546a:	1bcf      	subs	r7, r1, r7
   1546c:	4240      	negs	r0, r0
   1546e:	1a3e      	subs	r6, r7, r0
   15470:	4698      	mov	r8, r3
   15472:	e748      	b.n	15306 <__aeabi_dadd+0x112>
   15474:	2200      	movs	r2, #0
   15476:	2500      	movs	r5, #0
   15478:	e708      	b.n	1528c <__aeabi_dadd+0x98>
   1547a:	1c28      	adds	r0, r5, #0
   1547c:	f001 f8b6 	bl	165ec <__clzsi2>
   15480:	3020      	adds	r0, #32
   15482:	1c03      	adds	r3, r0, #0
   15484:	3b08      	subs	r3, #8
   15486:	2b1f      	cmp	r3, #31
   15488:	dc00      	bgt.n	1548c <__aeabi_dadd+0x298>
   1548a:	e747      	b.n	1531c <__aeabi_dadd+0x128>
   1548c:	3828      	subs	r0, #40	; 0x28
   1548e:	4085      	lsls	r5, r0
   15490:	1c2e      	adds	r6, r5, #0
   15492:	2500      	movs	r5, #0
   15494:	429c      	cmp	r4, r3
   15496:	dc00      	bgt.n	1549a <__aeabi_dadd+0x2a6>
   15498:	e74c      	b.n	15334 <__aeabi_dadd+0x140>
   1549a:	4a42      	ldr	r2, [pc, #264]	; (155a4 <__aeabi_dadd+0x3b0>)
   1549c:	1ae4      	subs	r4, r4, r3
   1549e:	4016      	ands	r6, r2
   154a0:	1c37      	adds	r7, r6, #0
   154a2:	e6cf      	b.n	15244 <__aeabi_dadd+0x50>
   154a4:	4663      	mov	r3, ip
   154a6:	4319      	orrs	r1, r3
   154a8:	1e4b      	subs	r3, r1, #1
   154aa:	4199      	sbcs	r1, r3
   154ac:	2200      	movs	r2, #0
   154ae:	b2cb      	uxtb	r3, r1
   154b0:	e71d      	b.n	152ee <__aeabi_dadd+0xfa>
   154b2:	2b00      	cmp	r3, #0
   154b4:	d000      	beq.n	154b8 <__aeabi_dadd+0x2c4>
   154b6:	e0f2      	b.n	1569e <__aeabi_dadd+0x4aa>
   154b8:	1c60      	adds	r0, r4, #1
   154ba:	0543      	lsls	r3, r0, #21
   154bc:	0d5b      	lsrs	r3, r3, #21
   154be:	2b01      	cmp	r3, #1
   154c0:	dc00      	bgt.n	154c4 <__aeabi_dadd+0x2d0>
   154c2:	e0a4      	b.n	1560e <__aeabi_dadd+0x41a>
   154c4:	4b36      	ldr	r3, [pc, #216]	; (155a0 <__aeabi_dadd+0x3ac>)
   154c6:	4298      	cmp	r0, r3
   154c8:	d100      	bne.n	154cc <__aeabi_dadd+0x2d8>
   154ca:	e121      	b.n	15710 <__aeabi_dadd+0x51c>
   154cc:	4663      	mov	r3, ip
   154ce:	195c      	adds	r4, r3, r5
   154d0:	42ac      	cmp	r4, r5
   154d2:	419b      	sbcs	r3, r3
   154d4:	19cf      	adds	r7, r1, r7
   154d6:	425b      	negs	r3, r3
   154d8:	18fa      	adds	r2, r7, r3
   154da:	0864      	lsrs	r4, r4, #1
   154dc:	07d5      	lsls	r5, r2, #31
   154de:	4325      	orrs	r5, r4
   154e0:	0857      	lsrs	r7, r2, #1
   154e2:	1c04      	adds	r4, r0, #0
   154e4:	e6ae      	b.n	15244 <__aeabi_dadd+0x50>
   154e6:	4b2e      	ldr	r3, [pc, #184]	; (155a0 <__aeabi_dadd+0x3ac>)
   154e8:	429c      	cmp	r4, r3
   154ea:	d000      	beq.n	154ee <__aeabi_dadd+0x2fa>
   154ec:	e6ea      	b.n	152c4 <__aeabi_dadd+0xd0>
   154ee:	e6a9      	b.n	15244 <__aeabi_dadd+0x50>
   154f0:	1c21      	adds	r1, r4, #0
   154f2:	1c33      	adds	r3, r6, #0
   154f4:	391f      	subs	r1, #31
   154f6:	40cb      	lsrs	r3, r1
   154f8:	1c19      	adds	r1, r3, #0
   154fa:	2a20      	cmp	r2, #32
   154fc:	d100      	bne.n	15500 <__aeabi_dadd+0x30c>
   154fe:	e082      	b.n	15606 <__aeabi_dadd+0x412>
   15500:	233f      	movs	r3, #63	; 0x3f
   15502:	1b1c      	subs	r4, r3, r4
   15504:	40a6      	lsls	r6, r4
   15506:	4335      	orrs	r5, r6
   15508:	1e6e      	subs	r6, r5, #1
   1550a:	41b5      	sbcs	r5, r6
   1550c:	2700      	movs	r7, #0
   1550e:	430d      	orrs	r5, r1
   15510:	2400      	movs	r4, #0
   15512:	e78e      	b.n	15432 <__aeabi_dadd+0x23e>
   15514:	1c03      	adds	r3, r0, #0
   15516:	1c0e      	adds	r6, r1, #0
   15518:	3b20      	subs	r3, #32
   1551a:	40de      	lsrs	r6, r3
   1551c:	2820      	cmp	r0, #32
   1551e:	d074      	beq.n	1560a <__aeabi_dadd+0x416>
   15520:	2340      	movs	r3, #64	; 0x40
   15522:	1a1b      	subs	r3, r3, r0
   15524:	4099      	lsls	r1, r3
   15526:	1c0b      	adds	r3, r1, #0
   15528:	4662      	mov	r2, ip
   1552a:	4313      	orrs	r3, r2
   1552c:	1e59      	subs	r1, r3, #1
   1552e:	418b      	sbcs	r3, r1
   15530:	2200      	movs	r2, #0
   15532:	4333      	orrs	r3, r6
   15534:	e6db      	b.n	152ee <__aeabi_dadd+0xfa>
   15536:	2c00      	cmp	r4, #0
   15538:	d050      	beq.n	155dc <__aeabi_dadd+0x3e8>
   1553a:	4c19      	ldr	r4, [pc, #100]	; (155a0 <__aeabi_dadd+0x3ac>)
   1553c:	42a2      	cmp	r2, r4
   1553e:	d100      	bne.n	15542 <__aeabi_dadd+0x34e>
   15540:	e0a8      	b.n	15694 <__aeabi_dadd+0x4a0>
   15542:	2480      	movs	r4, #128	; 0x80
   15544:	0424      	lsls	r4, r4, #16
   15546:	4240      	negs	r0, r0
   15548:	4327      	orrs	r7, r4
   1554a:	2838      	cmp	r0, #56	; 0x38
   1554c:	dd00      	ble.n	15550 <__aeabi_dadd+0x35c>
   1554e:	e0d9      	b.n	15704 <__aeabi_dadd+0x510>
   15550:	281f      	cmp	r0, #31
   15552:	dd00      	ble.n	15556 <__aeabi_dadd+0x362>
   15554:	e139      	b.n	157ca <__aeabi_dadd+0x5d6>
   15556:	2420      	movs	r4, #32
   15558:	1c3e      	adds	r6, r7, #0
   1555a:	1a24      	subs	r4, r4, r0
   1555c:	40a6      	lsls	r6, r4
   1555e:	46b0      	mov	r8, r6
   15560:	1c2e      	adds	r6, r5, #0
   15562:	46a1      	mov	r9, r4
   15564:	40c6      	lsrs	r6, r0
   15566:	4644      	mov	r4, r8
   15568:	4326      	orrs	r6, r4
   1556a:	464c      	mov	r4, r9
   1556c:	40a5      	lsls	r5, r4
   1556e:	1e6c      	subs	r4, r5, #1
   15570:	41a5      	sbcs	r5, r4
   15572:	40c7      	lsrs	r7, r0
   15574:	4335      	orrs	r5, r6
   15576:	4660      	mov	r0, ip
   15578:	1b45      	subs	r5, r0, r5
   1557a:	1bcf      	subs	r7, r1, r7
   1557c:	45ac      	cmp	ip, r5
   1557e:	4189      	sbcs	r1, r1
   15580:	4249      	negs	r1, r1
   15582:	1a7f      	subs	r7, r7, r1
   15584:	1c14      	adds	r4, r2, #0
   15586:	4698      	mov	r8, r3
   15588:	e6b8      	b.n	152fc <__aeabi_dadd+0x108>
   1558a:	464b      	mov	r3, r9
   1558c:	464d      	mov	r5, r9
   1558e:	4333      	orrs	r3, r6
   15590:	d000      	beq.n	15594 <__aeabi_dadd+0x3a0>
   15592:	e6b8      	b.n	15306 <__aeabi_dadd+0x112>
   15594:	2600      	movs	r6, #0
   15596:	2700      	movs	r7, #0
   15598:	2400      	movs	r4, #0
   1559a:	2500      	movs	r5, #0
   1559c:	e6e4      	b.n	15368 <__aeabi_dadd+0x174>
   1559e:	46c0      	nop			; (mov r8, r8)
   155a0:	000007ff 	.word	0x000007ff
   155a4:	ff7fffff 	.word	0xff7fffff
   155a8:	800fffff 	.word	0x800fffff
   155ac:	2b1f      	cmp	r3, #31
   155ae:	dc5b      	bgt.n	15668 <__aeabi_dadd+0x474>
   155b0:	2220      	movs	r2, #32
   155b2:	1c08      	adds	r0, r1, #0
   155b4:	1ad2      	subs	r2, r2, r3
   155b6:	4090      	lsls	r0, r2
   155b8:	4681      	mov	r9, r0
   155ba:	4660      	mov	r0, ip
   155bc:	4692      	mov	sl, r2
   155be:	40d8      	lsrs	r0, r3
   155c0:	464a      	mov	r2, r9
   155c2:	4310      	orrs	r0, r2
   155c4:	4681      	mov	r9, r0
   155c6:	4652      	mov	r2, sl
   155c8:	4660      	mov	r0, ip
   155ca:	4090      	lsls	r0, r2
   155cc:	1c02      	adds	r2, r0, #0
   155ce:	1e50      	subs	r0, r2, #1
   155d0:	4182      	sbcs	r2, r0
   155d2:	4648      	mov	r0, r9
   155d4:	4310      	orrs	r0, r2
   155d6:	1c0a      	adds	r2, r1, #0
   155d8:	40da      	lsrs	r2, r3
   155da:	e6e7      	b.n	153ac <__aeabi_dadd+0x1b8>
   155dc:	1c3c      	adds	r4, r7, #0
   155de:	432c      	orrs	r4, r5
   155e0:	d058      	beq.n	15694 <__aeabi_dadd+0x4a0>
   155e2:	43c0      	mvns	r0, r0
   155e4:	2800      	cmp	r0, #0
   155e6:	d151      	bne.n	1568c <__aeabi_dadd+0x498>
   155e8:	4660      	mov	r0, ip
   155ea:	1b45      	subs	r5, r0, r5
   155ec:	45ac      	cmp	ip, r5
   155ee:	4180      	sbcs	r0, r0
   155f0:	1bcf      	subs	r7, r1, r7
   155f2:	4240      	negs	r0, r0
   155f4:	1a3f      	subs	r7, r7, r0
   155f6:	1c14      	adds	r4, r2, #0
   155f8:	4698      	mov	r8, r3
   155fa:	e67f      	b.n	152fc <__aeabi_dadd+0x108>
   155fc:	4a8f      	ldr	r2, [pc, #572]	; (1583c <__aeabi_dadd+0x648>)
   155fe:	4294      	cmp	r4, r2
   15600:	d000      	beq.n	15604 <__aeabi_dadd+0x410>
   15602:	e6ca      	b.n	1539a <__aeabi_dadd+0x1a6>
   15604:	e61e      	b.n	15244 <__aeabi_dadd+0x50>
   15606:	2600      	movs	r6, #0
   15608:	e77d      	b.n	15506 <__aeabi_dadd+0x312>
   1560a:	2300      	movs	r3, #0
   1560c:	e78c      	b.n	15528 <__aeabi_dadd+0x334>
   1560e:	1c3b      	adds	r3, r7, #0
   15610:	432b      	orrs	r3, r5
   15612:	2c00      	cmp	r4, #0
   15614:	d000      	beq.n	15618 <__aeabi_dadd+0x424>
   15616:	e0bd      	b.n	15794 <__aeabi_dadd+0x5a0>
   15618:	2b00      	cmp	r3, #0
   1561a:	d100      	bne.n	1561e <__aeabi_dadd+0x42a>
   1561c:	e0f5      	b.n	1580a <__aeabi_dadd+0x616>
   1561e:	4663      	mov	r3, ip
   15620:	430b      	orrs	r3, r1
   15622:	d100      	bne.n	15626 <__aeabi_dadd+0x432>
   15624:	e60e      	b.n	15244 <__aeabi_dadd+0x50>
   15626:	4663      	mov	r3, ip
   15628:	195b      	adds	r3, r3, r5
   1562a:	42ab      	cmp	r3, r5
   1562c:	4180      	sbcs	r0, r0
   1562e:	19ca      	adds	r2, r1, r7
   15630:	4240      	negs	r0, r0
   15632:	1817      	adds	r7, r2, r0
   15634:	023a      	lsls	r2, r7, #8
   15636:	d400      	bmi.n	1563a <__aeabi_dadd+0x446>
   15638:	e0fc      	b.n	15834 <__aeabi_dadd+0x640>
   1563a:	4a81      	ldr	r2, [pc, #516]	; (15840 <__aeabi_dadd+0x64c>)
   1563c:	1c1d      	adds	r5, r3, #0
   1563e:	4017      	ands	r7, r2
   15640:	3401      	adds	r4, #1
   15642:	e5ff      	b.n	15244 <__aeabi_dadd+0x50>
   15644:	1c3a      	adds	r2, r7, #0
   15646:	432a      	orrs	r2, r5
   15648:	2c00      	cmp	r4, #0
   1564a:	d151      	bne.n	156f0 <__aeabi_dadd+0x4fc>
   1564c:	2a00      	cmp	r2, #0
   1564e:	d000      	beq.n	15652 <__aeabi_dadd+0x45e>
   15650:	e085      	b.n	1575e <__aeabi_dadd+0x56a>
   15652:	4662      	mov	r2, ip
   15654:	430a      	orrs	r2, r1
   15656:	d003      	beq.n	15660 <__aeabi_dadd+0x46c>
   15658:	1c0f      	adds	r7, r1, #0
   1565a:	4665      	mov	r5, ip
   1565c:	4698      	mov	r8, r3
   1565e:	e5f1      	b.n	15244 <__aeabi_dadd+0x50>
   15660:	2600      	movs	r6, #0
   15662:	2700      	movs	r7, #0
   15664:	2500      	movs	r5, #0
   15666:	e67f      	b.n	15368 <__aeabi_dadd+0x174>
   15668:	1c18      	adds	r0, r3, #0
   1566a:	1c0a      	adds	r2, r1, #0
   1566c:	3820      	subs	r0, #32
   1566e:	40c2      	lsrs	r2, r0
   15670:	2b20      	cmp	r3, #32
   15672:	d100      	bne.n	15676 <__aeabi_dadd+0x482>
   15674:	e0a7      	b.n	157c6 <__aeabi_dadd+0x5d2>
   15676:	2040      	movs	r0, #64	; 0x40
   15678:	1ac0      	subs	r0, r0, r3
   1567a:	4081      	lsls	r1, r0
   1567c:	1c08      	adds	r0, r1, #0
   1567e:	4663      	mov	r3, ip
   15680:	4318      	orrs	r0, r3
   15682:	1e41      	subs	r1, r0, #1
   15684:	4188      	sbcs	r0, r1
   15686:	4310      	orrs	r0, r2
   15688:	2200      	movs	r2, #0
   1568a:	e68f      	b.n	153ac <__aeabi_dadd+0x1b8>
   1568c:	4c6b      	ldr	r4, [pc, #428]	; (1583c <__aeabi_dadd+0x648>)
   1568e:	42a2      	cmp	r2, r4
   15690:	d000      	beq.n	15694 <__aeabi_dadd+0x4a0>
   15692:	e75a      	b.n	1554a <__aeabi_dadd+0x356>
   15694:	1c0f      	adds	r7, r1, #0
   15696:	4665      	mov	r5, ip
   15698:	1c14      	adds	r4, r2, #0
   1569a:	4698      	mov	r8, r3
   1569c:	e5d2      	b.n	15244 <__aeabi_dadd+0x50>
   1569e:	2c00      	cmp	r4, #0
   156a0:	d13a      	bne.n	15718 <__aeabi_dadd+0x524>
   156a2:	1c38      	adds	r0, r7, #0
   156a4:	4328      	orrs	r0, r5
   156a6:	d071      	beq.n	1578c <__aeabi_dadd+0x598>
   156a8:	43db      	mvns	r3, r3
   156aa:	2b00      	cmp	r3, #0
   156ac:	d018      	beq.n	156e0 <__aeabi_dadd+0x4ec>
   156ae:	4863      	ldr	r0, [pc, #396]	; (1583c <__aeabi_dadd+0x648>)
   156b0:	4282      	cmp	r2, r0
   156b2:	d06b      	beq.n	1578c <__aeabi_dadd+0x598>
   156b4:	2b38      	cmp	r3, #56	; 0x38
   156b6:	dd00      	ble.n	156ba <__aeabi_dadd+0x4c6>
   156b8:	e09d      	b.n	157f6 <__aeabi_dadd+0x602>
   156ba:	2b1f      	cmp	r3, #31
   156bc:	dd00      	ble.n	156c0 <__aeabi_dadd+0x4cc>
   156be:	e0a7      	b.n	15810 <__aeabi_dadd+0x61c>
   156c0:	2020      	movs	r0, #32
   156c2:	1c3c      	adds	r4, r7, #0
   156c4:	1ac0      	subs	r0, r0, r3
   156c6:	4084      	lsls	r4, r0
   156c8:	46a1      	mov	r9, r4
   156ca:	1c2c      	adds	r4, r5, #0
   156cc:	4682      	mov	sl, r0
   156ce:	40dc      	lsrs	r4, r3
   156d0:	4648      	mov	r0, r9
   156d2:	4304      	orrs	r4, r0
   156d4:	4650      	mov	r0, sl
   156d6:	4085      	lsls	r5, r0
   156d8:	1e68      	subs	r0, r5, #1
   156da:	4185      	sbcs	r5, r0
   156dc:	40df      	lsrs	r7, r3
   156de:	4325      	orrs	r5, r4
   156e0:	4465      	add	r5, ip
   156e2:	4565      	cmp	r5, ip
   156e4:	419b      	sbcs	r3, r3
   156e6:	187f      	adds	r7, r7, r1
   156e8:	425b      	negs	r3, r3
   156ea:	18ff      	adds	r7, r7, r3
   156ec:	1c14      	adds	r4, r2, #0
   156ee:	e664      	b.n	153ba <__aeabi_dadd+0x1c6>
   156f0:	2a00      	cmp	r2, #0
   156f2:	d119      	bne.n	15728 <__aeabi_dadd+0x534>
   156f4:	4662      	mov	r2, ip
   156f6:	430a      	orrs	r2, r1
   156f8:	d077      	beq.n	157ea <__aeabi_dadd+0x5f6>
   156fa:	1c0f      	adds	r7, r1, #0
   156fc:	4665      	mov	r5, ip
   156fe:	4698      	mov	r8, r3
   15700:	4c4e      	ldr	r4, [pc, #312]	; (1583c <__aeabi_dadd+0x648>)
   15702:	e59f      	b.n	15244 <__aeabi_dadd+0x50>
   15704:	433d      	orrs	r5, r7
   15706:	1e6f      	subs	r7, r5, #1
   15708:	41bd      	sbcs	r5, r7
   1570a:	2700      	movs	r7, #0
   1570c:	b2ed      	uxtb	r5, r5
   1570e:	e732      	b.n	15576 <__aeabi_dadd+0x382>
   15710:	1c04      	adds	r4, r0, #0
   15712:	2700      	movs	r7, #0
   15714:	2500      	movs	r5, #0
   15716:	e627      	b.n	15368 <__aeabi_dadd+0x174>
   15718:	4848      	ldr	r0, [pc, #288]	; (1583c <__aeabi_dadd+0x648>)
   1571a:	4282      	cmp	r2, r0
   1571c:	d036      	beq.n	1578c <__aeabi_dadd+0x598>
   1571e:	2080      	movs	r0, #128	; 0x80
   15720:	0400      	lsls	r0, r0, #16
   15722:	425b      	negs	r3, r3
   15724:	4307      	orrs	r7, r0
   15726:	e7c5      	b.n	156b4 <__aeabi_dadd+0x4c0>
   15728:	4662      	mov	r2, ip
   1572a:	430a      	orrs	r2, r1
   1572c:	d049      	beq.n	157c2 <__aeabi_dadd+0x5ce>
   1572e:	2480      	movs	r4, #128	; 0x80
   15730:	08ed      	lsrs	r5, r5, #3
   15732:	0778      	lsls	r0, r7, #29
   15734:	08fa      	lsrs	r2, r7, #3
   15736:	0324      	lsls	r4, r4, #12
   15738:	4328      	orrs	r0, r5
   1573a:	4222      	tst	r2, r4
   1573c:	d009      	beq.n	15752 <__aeabi_dadd+0x55e>
   1573e:	08ce      	lsrs	r6, r1, #3
   15740:	4226      	tst	r6, r4
   15742:	d106      	bne.n	15752 <__aeabi_dadd+0x55e>
   15744:	4662      	mov	r2, ip
   15746:	074f      	lsls	r7, r1, #29
   15748:	1c38      	adds	r0, r7, #0
   1574a:	08d2      	lsrs	r2, r2, #3
   1574c:	4310      	orrs	r0, r2
   1574e:	4698      	mov	r8, r3
   15750:	1c32      	adds	r2, r6, #0
   15752:	00d2      	lsls	r2, r2, #3
   15754:	0f47      	lsrs	r7, r0, #29
   15756:	4317      	orrs	r7, r2
   15758:	00c5      	lsls	r5, r0, #3
   1575a:	4c38      	ldr	r4, [pc, #224]	; (1583c <__aeabi_dadd+0x648>)
   1575c:	e572      	b.n	15244 <__aeabi_dadd+0x50>
   1575e:	4662      	mov	r2, ip
   15760:	430a      	orrs	r2, r1
   15762:	d100      	bne.n	15766 <__aeabi_dadd+0x572>
   15764:	e56e      	b.n	15244 <__aeabi_dadd+0x50>
   15766:	4662      	mov	r2, ip
   15768:	1aae      	subs	r6, r5, r2
   1576a:	42b5      	cmp	r5, r6
   1576c:	4192      	sbcs	r2, r2
   1576e:	1a78      	subs	r0, r7, r1
   15770:	4252      	negs	r2, r2
   15772:	1a82      	subs	r2, r0, r2
   15774:	0210      	lsls	r0, r2, #8
   15776:	d400      	bmi.n	1577a <__aeabi_dadd+0x586>
   15778:	e655      	b.n	15426 <__aeabi_dadd+0x232>
   1577a:	4662      	mov	r2, ip
   1577c:	1b55      	subs	r5, r2, r5
   1577e:	45ac      	cmp	ip, r5
   15780:	4180      	sbcs	r0, r0
   15782:	1bca      	subs	r2, r1, r7
   15784:	4240      	negs	r0, r0
   15786:	1a17      	subs	r7, r2, r0
   15788:	4698      	mov	r8, r3
   1578a:	e55b      	b.n	15244 <__aeabi_dadd+0x50>
   1578c:	1c0f      	adds	r7, r1, #0
   1578e:	4665      	mov	r5, ip
   15790:	1c14      	adds	r4, r2, #0
   15792:	e557      	b.n	15244 <__aeabi_dadd+0x50>
   15794:	2b00      	cmp	r3, #0
   15796:	d034      	beq.n	15802 <__aeabi_dadd+0x60e>
   15798:	4663      	mov	r3, ip
   1579a:	430b      	orrs	r3, r1
   1579c:	d011      	beq.n	157c2 <__aeabi_dadd+0x5ce>
   1579e:	2480      	movs	r4, #128	; 0x80
   157a0:	08ed      	lsrs	r5, r5, #3
   157a2:	0778      	lsls	r0, r7, #29
   157a4:	08fa      	lsrs	r2, r7, #3
   157a6:	0324      	lsls	r4, r4, #12
   157a8:	4328      	orrs	r0, r5
   157aa:	4222      	tst	r2, r4
   157ac:	d0d1      	beq.n	15752 <__aeabi_dadd+0x55e>
   157ae:	08cb      	lsrs	r3, r1, #3
   157b0:	4223      	tst	r3, r4
   157b2:	d1ce      	bne.n	15752 <__aeabi_dadd+0x55e>
   157b4:	4662      	mov	r2, ip
   157b6:	074f      	lsls	r7, r1, #29
   157b8:	1c38      	adds	r0, r7, #0
   157ba:	08d2      	lsrs	r2, r2, #3
   157bc:	4310      	orrs	r0, r2
   157be:	1c1a      	adds	r2, r3, #0
   157c0:	e7c7      	b.n	15752 <__aeabi_dadd+0x55e>
   157c2:	4c1e      	ldr	r4, [pc, #120]	; (1583c <__aeabi_dadd+0x648>)
   157c4:	e53e      	b.n	15244 <__aeabi_dadd+0x50>
   157c6:	2000      	movs	r0, #0
   157c8:	e759      	b.n	1567e <__aeabi_dadd+0x48a>
   157ca:	1c04      	adds	r4, r0, #0
   157cc:	1c3e      	adds	r6, r7, #0
   157ce:	3c20      	subs	r4, #32
   157d0:	40e6      	lsrs	r6, r4
   157d2:	1c34      	adds	r4, r6, #0
   157d4:	2820      	cmp	r0, #32
   157d6:	d02b      	beq.n	15830 <__aeabi_dadd+0x63c>
   157d8:	2640      	movs	r6, #64	; 0x40
   157da:	1a30      	subs	r0, r6, r0
   157dc:	4087      	lsls	r7, r0
   157de:	433d      	orrs	r5, r7
   157e0:	1e6f      	subs	r7, r5, #1
   157e2:	41bd      	sbcs	r5, r7
   157e4:	2700      	movs	r7, #0
   157e6:	4325      	orrs	r5, r4
   157e8:	e6c5      	b.n	15576 <__aeabi_dadd+0x382>
   157ea:	2780      	movs	r7, #128	; 0x80
   157ec:	2600      	movs	r6, #0
   157ee:	03ff      	lsls	r7, r7, #15
   157f0:	4c12      	ldr	r4, [pc, #72]	; (1583c <__aeabi_dadd+0x648>)
   157f2:	2500      	movs	r5, #0
   157f4:	e5b8      	b.n	15368 <__aeabi_dadd+0x174>
   157f6:	433d      	orrs	r5, r7
   157f8:	1e6f      	subs	r7, r5, #1
   157fa:	41bd      	sbcs	r5, r7
   157fc:	2700      	movs	r7, #0
   157fe:	b2ed      	uxtb	r5, r5
   15800:	e76e      	b.n	156e0 <__aeabi_dadd+0x4ec>
   15802:	1c0f      	adds	r7, r1, #0
   15804:	4665      	mov	r5, ip
   15806:	4c0d      	ldr	r4, [pc, #52]	; (1583c <__aeabi_dadd+0x648>)
   15808:	e51c      	b.n	15244 <__aeabi_dadd+0x50>
   1580a:	1c0f      	adds	r7, r1, #0
   1580c:	4665      	mov	r5, ip
   1580e:	e519      	b.n	15244 <__aeabi_dadd+0x50>
   15810:	1c1c      	adds	r4, r3, #0
   15812:	1c38      	adds	r0, r7, #0
   15814:	3c20      	subs	r4, #32
   15816:	40e0      	lsrs	r0, r4
   15818:	1c04      	adds	r4, r0, #0
   1581a:	2b20      	cmp	r3, #32
   1581c:	d00c      	beq.n	15838 <__aeabi_dadd+0x644>
   1581e:	2040      	movs	r0, #64	; 0x40
   15820:	1ac3      	subs	r3, r0, r3
   15822:	409f      	lsls	r7, r3
   15824:	433d      	orrs	r5, r7
   15826:	1e6f      	subs	r7, r5, #1
   15828:	41bd      	sbcs	r5, r7
   1582a:	2700      	movs	r7, #0
   1582c:	4325      	orrs	r5, r4
   1582e:	e757      	b.n	156e0 <__aeabi_dadd+0x4ec>
   15830:	2700      	movs	r7, #0
   15832:	e7d4      	b.n	157de <__aeabi_dadd+0x5ea>
   15834:	1c1d      	adds	r5, r3, #0
   15836:	e5fc      	b.n	15432 <__aeabi_dadd+0x23e>
   15838:	2700      	movs	r7, #0
   1583a:	e7f3      	b.n	15824 <__aeabi_dadd+0x630>
   1583c:	000007ff 	.word	0x000007ff
   15840:	ff7fffff 	.word	0xff7fffff

00015844 <__aeabi_ddiv>:
   15844:	b5f0      	push	{r4, r5, r6, r7, lr}
   15846:	465f      	mov	r7, fp
   15848:	4656      	mov	r6, sl
   1584a:	464d      	mov	r5, r9
   1584c:	4644      	mov	r4, r8
   1584e:	b4f0      	push	{r4, r5, r6, r7}
   15850:	030f      	lsls	r7, r1, #12
   15852:	b087      	sub	sp, #28
   15854:	4698      	mov	r8, r3
   15856:	004d      	lsls	r5, r1, #1
   15858:	0b3b      	lsrs	r3, r7, #12
   1585a:	0fcc      	lsrs	r4, r1, #31
   1585c:	1c06      	adds	r6, r0, #0
   1585e:	4692      	mov	sl, r2
   15860:	4681      	mov	r9, r0
   15862:	469b      	mov	fp, r3
   15864:	0d6d      	lsrs	r5, r5, #21
   15866:	9401      	str	r4, [sp, #4]
   15868:	d06b      	beq.n	15942 <__aeabi_ddiv+0xfe>
   1586a:	4b66      	ldr	r3, [pc, #408]	; (15a04 <__aeabi_ddiv+0x1c0>)
   1586c:	429d      	cmp	r5, r3
   1586e:	d035      	beq.n	158dc <__aeabi_ddiv+0x98>
   15870:	2780      	movs	r7, #128	; 0x80
   15872:	465b      	mov	r3, fp
   15874:	037f      	lsls	r7, r7, #13
   15876:	431f      	orrs	r7, r3
   15878:	00f3      	lsls	r3, r6, #3
   1587a:	4699      	mov	r9, r3
   1587c:	4b62      	ldr	r3, [pc, #392]	; (15a08 <__aeabi_ddiv+0x1c4>)
   1587e:	00ff      	lsls	r7, r7, #3
   15880:	0f40      	lsrs	r0, r0, #29
   15882:	469c      	mov	ip, r3
   15884:	4307      	orrs	r7, r0
   15886:	2300      	movs	r3, #0
   15888:	46bb      	mov	fp, r7
   1588a:	2600      	movs	r6, #0
   1588c:	4465      	add	r5, ip
   1588e:	9300      	str	r3, [sp, #0]
   15890:	4642      	mov	r2, r8
   15892:	0317      	lsls	r7, r2, #12
   15894:	0050      	lsls	r0, r2, #1
   15896:	0fd2      	lsrs	r2, r2, #31
   15898:	4653      	mov	r3, sl
   1589a:	0b3f      	lsrs	r7, r7, #12
   1589c:	0d40      	lsrs	r0, r0, #21
   1589e:	4690      	mov	r8, r2
   158a0:	d100      	bne.n	158a4 <__aeabi_ddiv+0x60>
   158a2:	e072      	b.n	1598a <__aeabi_ddiv+0x146>
   158a4:	4a57      	ldr	r2, [pc, #348]	; (15a04 <__aeabi_ddiv+0x1c0>)
   158a6:	4290      	cmp	r0, r2
   158a8:	d067      	beq.n	1597a <__aeabi_ddiv+0x136>
   158aa:	2380      	movs	r3, #128	; 0x80
   158ac:	035b      	lsls	r3, r3, #13
   158ae:	431f      	orrs	r7, r3
   158b0:	4653      	mov	r3, sl
   158b2:	4a55      	ldr	r2, [pc, #340]	; (15a08 <__aeabi_ddiv+0x1c4>)
   158b4:	0f5b      	lsrs	r3, r3, #29
   158b6:	00ff      	lsls	r7, r7, #3
   158b8:	431f      	orrs	r7, r3
   158ba:	4694      	mov	ip, r2
   158bc:	4653      	mov	r3, sl
   158be:	2100      	movs	r1, #0
   158c0:	00db      	lsls	r3, r3, #3
   158c2:	4460      	add	r0, ip
   158c4:	4642      	mov	r2, r8
   158c6:	4062      	eors	r2, r4
   158c8:	4692      	mov	sl, r2
   158ca:	1a2d      	subs	r5, r5, r0
   158cc:	430e      	orrs	r6, r1
   158ce:	2e0f      	cmp	r6, #15
   158d0:	d900      	bls.n	158d4 <__aeabi_ddiv+0x90>
   158d2:	e0a1      	b.n	15a18 <__aeabi_ddiv+0x1d4>
   158d4:	484d      	ldr	r0, [pc, #308]	; (15a0c <__aeabi_ddiv+0x1c8>)
   158d6:	00b6      	lsls	r6, r6, #2
   158d8:	5980      	ldr	r0, [r0, r6]
   158da:	4687      	mov	pc, r0
   158dc:	465b      	mov	r3, fp
   158de:	431e      	orrs	r6, r3
   158e0:	d000      	beq.n	158e4 <__aeabi_ddiv+0xa0>
   158e2:	e076      	b.n	159d2 <__aeabi_ddiv+0x18e>
   158e4:	2300      	movs	r3, #0
   158e6:	469b      	mov	fp, r3
   158e8:	4699      	mov	r9, r3
   158ea:	3302      	adds	r3, #2
   158ec:	2608      	movs	r6, #8
   158ee:	9300      	str	r3, [sp, #0]
   158f0:	e7ce      	b.n	15890 <__aeabi_ddiv+0x4c>
   158f2:	4699      	mov	r9, r3
   158f4:	4643      	mov	r3, r8
   158f6:	46bb      	mov	fp, r7
   158f8:	9301      	str	r3, [sp, #4]
   158fa:	9100      	str	r1, [sp, #0]
   158fc:	9b00      	ldr	r3, [sp, #0]
   158fe:	2b02      	cmp	r3, #2
   15900:	d16b      	bne.n	159da <__aeabi_ddiv+0x196>
   15902:	9b01      	ldr	r3, [sp, #4]
   15904:	469a      	mov	sl, r3
   15906:	2100      	movs	r1, #0
   15908:	4653      	mov	r3, sl
   1590a:	2201      	movs	r2, #1
   1590c:	2700      	movs	r7, #0
   1590e:	4689      	mov	r9, r1
   15910:	401a      	ands	r2, r3
   15912:	4b3c      	ldr	r3, [pc, #240]	; (15a04 <__aeabi_ddiv+0x1c0>)
   15914:	2100      	movs	r1, #0
   15916:	033f      	lsls	r7, r7, #12
   15918:	0d0c      	lsrs	r4, r1, #20
   1591a:	0524      	lsls	r4, r4, #20
   1591c:	0b3f      	lsrs	r7, r7, #12
   1591e:	4327      	orrs	r7, r4
   15920:	4c3b      	ldr	r4, [pc, #236]	; (15a10 <__aeabi_ddiv+0x1cc>)
   15922:	051b      	lsls	r3, r3, #20
   15924:	4027      	ands	r7, r4
   15926:	431f      	orrs	r7, r3
   15928:	007f      	lsls	r7, r7, #1
   1592a:	07d2      	lsls	r2, r2, #31
   1592c:	087f      	lsrs	r7, r7, #1
   1592e:	4317      	orrs	r7, r2
   15930:	4648      	mov	r0, r9
   15932:	1c39      	adds	r1, r7, #0
   15934:	b007      	add	sp, #28
   15936:	bc3c      	pop	{r2, r3, r4, r5}
   15938:	4690      	mov	r8, r2
   1593a:	4699      	mov	r9, r3
   1593c:	46a2      	mov	sl, r4
   1593e:	46ab      	mov	fp, r5
   15940:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15942:	4303      	orrs	r3, r0
   15944:	d03e      	beq.n	159c4 <__aeabi_ddiv+0x180>
   15946:	465b      	mov	r3, fp
   15948:	2b00      	cmp	r3, #0
   1594a:	d100      	bne.n	1594e <__aeabi_ddiv+0x10a>
   1594c:	e19c      	b.n	15c88 <__aeabi_ddiv+0x444>
   1594e:	4658      	mov	r0, fp
   15950:	f000 fe4c 	bl	165ec <__clzsi2>
   15954:	2328      	movs	r3, #40	; 0x28
   15956:	1c31      	adds	r1, r6, #0
   15958:	1a1b      	subs	r3, r3, r0
   1595a:	1c02      	adds	r2, r0, #0
   1595c:	465f      	mov	r7, fp
   1595e:	40d9      	lsrs	r1, r3
   15960:	3a08      	subs	r2, #8
   15962:	4097      	lsls	r7, r2
   15964:	1c0b      	adds	r3, r1, #0
   15966:	4096      	lsls	r6, r2
   15968:	433b      	orrs	r3, r7
   1596a:	469b      	mov	fp, r3
   1596c:	46b1      	mov	r9, r6
   1596e:	2300      	movs	r3, #0
   15970:	4d28      	ldr	r5, [pc, #160]	; (15a14 <__aeabi_ddiv+0x1d0>)
   15972:	2600      	movs	r6, #0
   15974:	1a2d      	subs	r5, r5, r0
   15976:	9300      	str	r3, [sp, #0]
   15978:	e78a      	b.n	15890 <__aeabi_ddiv+0x4c>
   1597a:	4652      	mov	r2, sl
   1597c:	2103      	movs	r1, #3
   1597e:	433a      	orrs	r2, r7
   15980:	d1a0      	bne.n	158c4 <__aeabi_ddiv+0x80>
   15982:	2700      	movs	r7, #0
   15984:	2300      	movs	r3, #0
   15986:	2102      	movs	r1, #2
   15988:	e79c      	b.n	158c4 <__aeabi_ddiv+0x80>
   1598a:	4652      	mov	r2, sl
   1598c:	433a      	orrs	r2, r7
   1598e:	d015      	beq.n	159bc <__aeabi_ddiv+0x178>
   15990:	2f00      	cmp	r7, #0
   15992:	d100      	bne.n	15996 <__aeabi_ddiv+0x152>
   15994:	e185      	b.n	15ca2 <__aeabi_ddiv+0x45e>
   15996:	1c38      	adds	r0, r7, #0
   15998:	f000 fe28 	bl	165ec <__clzsi2>
   1599c:	1c02      	adds	r2, r0, #0
   1599e:	2128      	movs	r1, #40	; 0x28
   159a0:	4650      	mov	r0, sl
   159a2:	1a89      	subs	r1, r1, r2
   159a4:	1c13      	adds	r3, r2, #0
   159a6:	40c8      	lsrs	r0, r1
   159a8:	4651      	mov	r1, sl
   159aa:	3b08      	subs	r3, #8
   159ac:	4099      	lsls	r1, r3
   159ae:	409f      	lsls	r7, r3
   159b0:	1c0b      	adds	r3, r1, #0
   159b2:	4307      	orrs	r7, r0
   159b4:	4817      	ldr	r0, [pc, #92]	; (15a14 <__aeabi_ddiv+0x1d0>)
   159b6:	2100      	movs	r1, #0
   159b8:	1a80      	subs	r0, r0, r2
   159ba:	e783      	b.n	158c4 <__aeabi_ddiv+0x80>
   159bc:	2700      	movs	r7, #0
   159be:	2300      	movs	r3, #0
   159c0:	2101      	movs	r1, #1
   159c2:	e77f      	b.n	158c4 <__aeabi_ddiv+0x80>
   159c4:	2300      	movs	r3, #0
   159c6:	469b      	mov	fp, r3
   159c8:	4699      	mov	r9, r3
   159ca:	3301      	adds	r3, #1
   159cc:	2604      	movs	r6, #4
   159ce:	9300      	str	r3, [sp, #0]
   159d0:	e75e      	b.n	15890 <__aeabi_ddiv+0x4c>
   159d2:	2303      	movs	r3, #3
   159d4:	260c      	movs	r6, #12
   159d6:	9300      	str	r3, [sp, #0]
   159d8:	e75a      	b.n	15890 <__aeabi_ddiv+0x4c>
   159da:	2b03      	cmp	r3, #3
   159dc:	d100      	bne.n	159e0 <__aeabi_ddiv+0x19c>
   159de:	e23c      	b.n	15e5a <__aeabi_ddiv+0x616>
   159e0:	2b01      	cmp	r3, #1
   159e2:	d000      	beq.n	159e6 <__aeabi_ddiv+0x1a2>
   159e4:	e1bf      	b.n	15d66 <__aeabi_ddiv+0x522>
   159e6:	1c1a      	adds	r2, r3, #0
   159e8:	9b01      	ldr	r3, [sp, #4]
   159ea:	401a      	ands	r2, r3
   159ec:	2100      	movs	r1, #0
   159ee:	2300      	movs	r3, #0
   159f0:	2700      	movs	r7, #0
   159f2:	4689      	mov	r9, r1
   159f4:	e78e      	b.n	15914 <__aeabi_ddiv+0xd0>
   159f6:	2300      	movs	r3, #0
   159f8:	2780      	movs	r7, #128	; 0x80
   159fa:	4699      	mov	r9, r3
   159fc:	2200      	movs	r2, #0
   159fe:	033f      	lsls	r7, r7, #12
   15a00:	4b00      	ldr	r3, [pc, #0]	; (15a04 <__aeabi_ddiv+0x1c0>)
   15a02:	e787      	b.n	15914 <__aeabi_ddiv+0xd0>
   15a04:	000007ff 	.word	0x000007ff
   15a08:	fffffc01 	.word	0xfffffc01
   15a0c:	00021c08 	.word	0x00021c08
   15a10:	800fffff 	.word	0x800fffff
   15a14:	fffffc0d 	.word	0xfffffc0d
   15a18:	45bb      	cmp	fp, r7
   15a1a:	d900      	bls.n	15a1e <__aeabi_ddiv+0x1da>
   15a1c:	e151      	b.n	15cc2 <__aeabi_ddiv+0x47e>
   15a1e:	d100      	bne.n	15a22 <__aeabi_ddiv+0x1de>
   15a20:	e14c      	b.n	15cbc <__aeabi_ddiv+0x478>
   15a22:	464a      	mov	r2, r9
   15a24:	9203      	str	r2, [sp, #12]
   15a26:	2200      	movs	r2, #0
   15a28:	465c      	mov	r4, fp
   15a2a:	4690      	mov	r8, r2
   15a2c:	3d01      	subs	r5, #1
   15a2e:	0e18      	lsrs	r0, r3, #24
   15a30:	023f      	lsls	r7, r7, #8
   15a32:	4338      	orrs	r0, r7
   15a34:	021b      	lsls	r3, r3, #8
   15a36:	9301      	str	r3, [sp, #4]
   15a38:	0c03      	lsrs	r3, r0, #16
   15a3a:	4699      	mov	r9, r3
   15a3c:	0403      	lsls	r3, r0, #16
   15a3e:	0c1b      	lsrs	r3, r3, #16
   15a40:	4649      	mov	r1, r9
   15a42:	1c06      	adds	r6, r0, #0
   15a44:	1c20      	adds	r0, r4, #0
   15a46:	1c1f      	adds	r7, r3, #0
   15a48:	9300      	str	r3, [sp, #0]
   15a4a:	f7ff fa27 	bl	14e9c <__aeabi_uidiv>
   15a4e:	1c02      	adds	r2, r0, #0
   15a50:	437a      	muls	r2, r7
   15a52:	9002      	str	r0, [sp, #8]
   15a54:	4649      	mov	r1, r9
   15a56:	1c20      	adds	r0, r4, #0
   15a58:	1c17      	adds	r7, r2, #0
   15a5a:	f7ff faa5 	bl	14fa8 <__aeabi_uidivmod>
   15a5e:	9b03      	ldr	r3, [sp, #12]
   15a60:	0409      	lsls	r1, r1, #16
   15a62:	0c1b      	lsrs	r3, r3, #16
   15a64:	4319      	orrs	r1, r3
   15a66:	428f      	cmp	r7, r1
   15a68:	d90c      	bls.n	15a84 <__aeabi_ddiv+0x240>
   15a6a:	9b02      	ldr	r3, [sp, #8]
   15a6c:	1989      	adds	r1, r1, r6
   15a6e:	3b01      	subs	r3, #1
   15a70:	428e      	cmp	r6, r1
   15a72:	d900      	bls.n	15a76 <__aeabi_ddiv+0x232>
   15a74:	e152      	b.n	15d1c <__aeabi_ddiv+0x4d8>
   15a76:	428f      	cmp	r7, r1
   15a78:	d800      	bhi.n	15a7c <__aeabi_ddiv+0x238>
   15a7a:	e14f      	b.n	15d1c <__aeabi_ddiv+0x4d8>
   15a7c:	9b02      	ldr	r3, [sp, #8]
   15a7e:	1989      	adds	r1, r1, r6
   15a80:	3b02      	subs	r3, #2
   15a82:	9302      	str	r3, [sp, #8]
   15a84:	1bcc      	subs	r4, r1, r7
   15a86:	1c20      	adds	r0, r4, #0
   15a88:	4649      	mov	r1, r9
   15a8a:	f7ff fa07 	bl	14e9c <__aeabi_uidiv>
   15a8e:	9f00      	ldr	r7, [sp, #0]
   15a90:	4683      	mov	fp, r0
   15a92:	4347      	muls	r7, r0
   15a94:	4649      	mov	r1, r9
   15a96:	1c20      	adds	r0, r4, #0
   15a98:	f7ff fa86 	bl	14fa8 <__aeabi_uidivmod>
   15a9c:	9a03      	ldr	r2, [sp, #12]
   15a9e:	040b      	lsls	r3, r1, #16
   15aa0:	0414      	lsls	r4, r2, #16
   15aa2:	0c24      	lsrs	r4, r4, #16
   15aa4:	4323      	orrs	r3, r4
   15aa6:	429f      	cmp	r7, r3
   15aa8:	d90d      	bls.n	15ac6 <__aeabi_ddiv+0x282>
   15aaa:	465a      	mov	r2, fp
   15aac:	199b      	adds	r3, r3, r6
   15aae:	3a01      	subs	r2, #1
   15ab0:	429e      	cmp	r6, r3
   15ab2:	d900      	bls.n	15ab6 <__aeabi_ddiv+0x272>
   15ab4:	e130      	b.n	15d18 <__aeabi_ddiv+0x4d4>
   15ab6:	429f      	cmp	r7, r3
   15ab8:	d800      	bhi.n	15abc <__aeabi_ddiv+0x278>
   15aba:	e12d      	b.n	15d18 <__aeabi_ddiv+0x4d4>
   15abc:	2202      	movs	r2, #2
   15abe:	4252      	negs	r2, r2
   15ac0:	4694      	mov	ip, r2
   15ac2:	199b      	adds	r3, r3, r6
   15ac4:	44e3      	add	fp, ip
   15ac6:	9a02      	ldr	r2, [sp, #8]
   15ac8:	1bdb      	subs	r3, r3, r7
   15aca:	0417      	lsls	r7, r2, #16
   15acc:	465a      	mov	r2, fp
   15ace:	433a      	orrs	r2, r7
   15ad0:	4693      	mov	fp, r2
   15ad2:	9c01      	ldr	r4, [sp, #4]
   15ad4:	0c17      	lsrs	r7, r2, #16
   15ad6:	0c22      	lsrs	r2, r4, #16
   15ad8:	1c10      	adds	r0, r2, #0
   15ada:	9204      	str	r2, [sp, #16]
   15adc:	465a      	mov	r2, fp
   15ade:	0411      	lsls	r1, r2, #16
   15ae0:	0422      	lsls	r2, r4, #16
   15ae2:	0c12      	lsrs	r2, r2, #16
   15ae4:	1c14      	adds	r4, r2, #0
   15ae6:	0c09      	lsrs	r1, r1, #16
   15ae8:	437c      	muls	r4, r7
   15aea:	9205      	str	r2, [sp, #20]
   15aec:	434a      	muls	r2, r1
   15aee:	4341      	muls	r1, r0
   15af0:	4347      	muls	r7, r0
   15af2:	1861      	adds	r1, r4, r1
   15af4:	0c10      	lsrs	r0, r2, #16
   15af6:	1809      	adds	r1, r1, r0
   15af8:	428c      	cmp	r4, r1
   15afa:	d903      	bls.n	15b04 <__aeabi_ddiv+0x2c0>
   15afc:	2080      	movs	r0, #128	; 0x80
   15afe:	0240      	lsls	r0, r0, #9
   15b00:	4684      	mov	ip, r0
   15b02:	4467      	add	r7, ip
   15b04:	0c0c      	lsrs	r4, r1, #16
   15b06:	0412      	lsls	r2, r2, #16
   15b08:	0408      	lsls	r0, r1, #16
   15b0a:	0c12      	lsrs	r2, r2, #16
   15b0c:	193c      	adds	r4, r7, r4
   15b0e:	1881      	adds	r1, r0, r2
   15b10:	42a3      	cmp	r3, r4
   15b12:	d200      	bcs.n	15b16 <__aeabi_ddiv+0x2d2>
   15b14:	e0e5      	b.n	15ce2 <__aeabi_ddiv+0x49e>
   15b16:	d100      	bne.n	15b1a <__aeabi_ddiv+0x2d6>
   15b18:	e0df      	b.n	15cda <__aeabi_ddiv+0x496>
   15b1a:	1b1f      	subs	r7, r3, r4
   15b1c:	4643      	mov	r3, r8
   15b1e:	1a5c      	subs	r4, r3, r1
   15b20:	45a0      	cmp	r8, r4
   15b22:	4192      	sbcs	r2, r2
   15b24:	4252      	negs	r2, r2
   15b26:	1abf      	subs	r7, r7, r2
   15b28:	42b7      	cmp	r7, r6
   15b2a:	d100      	bne.n	15b2e <__aeabi_ddiv+0x2ea>
   15b2c:	e10e      	b.n	15d4c <__aeabi_ddiv+0x508>
   15b2e:	1c38      	adds	r0, r7, #0
   15b30:	4649      	mov	r1, r9
   15b32:	f7ff f9b3 	bl	14e9c <__aeabi_uidiv>
   15b36:	9b00      	ldr	r3, [sp, #0]
   15b38:	9002      	str	r0, [sp, #8]
   15b3a:	4343      	muls	r3, r0
   15b3c:	4649      	mov	r1, r9
   15b3e:	1c38      	adds	r0, r7, #0
   15b40:	4698      	mov	r8, r3
   15b42:	f7ff fa31 	bl	14fa8 <__aeabi_uidivmod>
   15b46:	0c23      	lsrs	r3, r4, #16
   15b48:	040f      	lsls	r7, r1, #16
   15b4a:	431f      	orrs	r7, r3
   15b4c:	45b8      	cmp	r8, r7
   15b4e:	d90c      	bls.n	15b6a <__aeabi_ddiv+0x326>
   15b50:	9b02      	ldr	r3, [sp, #8]
   15b52:	19bf      	adds	r7, r7, r6
   15b54:	3b01      	subs	r3, #1
   15b56:	42be      	cmp	r6, r7
   15b58:	d900      	bls.n	15b5c <__aeabi_ddiv+0x318>
   15b5a:	e0fb      	b.n	15d54 <__aeabi_ddiv+0x510>
   15b5c:	45b8      	cmp	r8, r7
   15b5e:	d800      	bhi.n	15b62 <__aeabi_ddiv+0x31e>
   15b60:	e0f8      	b.n	15d54 <__aeabi_ddiv+0x510>
   15b62:	9b02      	ldr	r3, [sp, #8]
   15b64:	19bf      	adds	r7, r7, r6
   15b66:	3b02      	subs	r3, #2
   15b68:	9302      	str	r3, [sp, #8]
   15b6a:	4643      	mov	r3, r8
   15b6c:	1aff      	subs	r7, r7, r3
   15b6e:	4649      	mov	r1, r9
   15b70:	1c38      	adds	r0, r7, #0
   15b72:	f7ff f993 	bl	14e9c <__aeabi_uidiv>
   15b76:	9b00      	ldr	r3, [sp, #0]
   15b78:	9003      	str	r0, [sp, #12]
   15b7a:	4343      	muls	r3, r0
   15b7c:	4649      	mov	r1, r9
   15b7e:	1c38      	adds	r0, r7, #0
   15b80:	4698      	mov	r8, r3
   15b82:	f7ff fa11 	bl	14fa8 <__aeabi_uidivmod>
   15b86:	0424      	lsls	r4, r4, #16
   15b88:	0409      	lsls	r1, r1, #16
   15b8a:	0c24      	lsrs	r4, r4, #16
   15b8c:	4321      	orrs	r1, r4
   15b8e:	4588      	cmp	r8, r1
   15b90:	d90c      	bls.n	15bac <__aeabi_ddiv+0x368>
   15b92:	9b03      	ldr	r3, [sp, #12]
   15b94:	1989      	adds	r1, r1, r6
   15b96:	3b01      	subs	r3, #1
   15b98:	428e      	cmp	r6, r1
   15b9a:	d900      	bls.n	15b9e <__aeabi_ddiv+0x35a>
   15b9c:	e0dc      	b.n	15d58 <__aeabi_ddiv+0x514>
   15b9e:	4588      	cmp	r8, r1
   15ba0:	d800      	bhi.n	15ba4 <__aeabi_ddiv+0x360>
   15ba2:	e0d9      	b.n	15d58 <__aeabi_ddiv+0x514>
   15ba4:	9b03      	ldr	r3, [sp, #12]
   15ba6:	1989      	adds	r1, r1, r6
   15ba8:	3b02      	subs	r3, #2
   15baa:	9303      	str	r3, [sp, #12]
   15bac:	4643      	mov	r3, r8
   15bae:	1ac9      	subs	r1, r1, r3
   15bb0:	9b02      	ldr	r3, [sp, #8]
   15bb2:	9a03      	ldr	r2, [sp, #12]
   15bb4:	041b      	lsls	r3, r3, #16
   15bb6:	9c05      	ldr	r4, [sp, #20]
   15bb8:	431a      	orrs	r2, r3
   15bba:	0c10      	lsrs	r0, r2, #16
   15bbc:	0413      	lsls	r3, r2, #16
   15bbe:	4691      	mov	r9, r2
   15bc0:	1c22      	adds	r2, r4, #0
   15bc2:	9f04      	ldr	r7, [sp, #16]
   15bc4:	0c1b      	lsrs	r3, r3, #16
   15bc6:	435a      	muls	r2, r3
   15bc8:	4344      	muls	r4, r0
   15bca:	437b      	muls	r3, r7
   15bcc:	4378      	muls	r0, r7
   15bce:	18e3      	adds	r3, r4, r3
   15bd0:	0c17      	lsrs	r7, r2, #16
   15bd2:	19db      	adds	r3, r3, r7
   15bd4:	429c      	cmp	r4, r3
   15bd6:	d903      	bls.n	15be0 <__aeabi_ddiv+0x39c>
   15bd8:	2480      	movs	r4, #128	; 0x80
   15bda:	0264      	lsls	r4, r4, #9
   15bdc:	46a4      	mov	ip, r4
   15bde:	4460      	add	r0, ip
   15be0:	0c1c      	lsrs	r4, r3, #16
   15be2:	0412      	lsls	r2, r2, #16
   15be4:	041b      	lsls	r3, r3, #16
   15be6:	0c12      	lsrs	r2, r2, #16
   15be8:	1900      	adds	r0, r0, r4
   15bea:	189b      	adds	r3, r3, r2
   15bec:	4281      	cmp	r1, r0
   15bee:	d200      	bcs.n	15bf2 <__aeabi_ddiv+0x3ae>
   15bf0:	e096      	b.n	15d20 <__aeabi_ddiv+0x4dc>
   15bf2:	d100      	bne.n	15bf6 <__aeabi_ddiv+0x3b2>
   15bf4:	e0fc      	b.n	15df0 <__aeabi_ddiv+0x5ac>
   15bf6:	464a      	mov	r2, r9
   15bf8:	2301      	movs	r3, #1
   15bfa:	431a      	orrs	r2, r3
   15bfc:	4691      	mov	r9, r2
   15bfe:	4b9b      	ldr	r3, [pc, #620]	; (15e6c <__aeabi_ddiv+0x628>)
   15c00:	18eb      	adds	r3, r5, r3
   15c02:	2b00      	cmp	r3, #0
   15c04:	dc00      	bgt.n	15c08 <__aeabi_ddiv+0x3c4>
   15c06:	e099      	b.n	15d3c <__aeabi_ddiv+0x4f8>
   15c08:	464a      	mov	r2, r9
   15c0a:	0752      	lsls	r2, r2, #29
   15c0c:	d00a      	beq.n	15c24 <__aeabi_ddiv+0x3e0>
   15c0e:	220f      	movs	r2, #15
   15c10:	4649      	mov	r1, r9
   15c12:	400a      	ands	r2, r1
   15c14:	2a04      	cmp	r2, #4
   15c16:	d005      	beq.n	15c24 <__aeabi_ddiv+0x3e0>
   15c18:	3104      	adds	r1, #4
   15c1a:	4549      	cmp	r1, r9
   15c1c:	4192      	sbcs	r2, r2
   15c1e:	4689      	mov	r9, r1
   15c20:	4252      	negs	r2, r2
   15c22:	4493      	add	fp, r2
   15c24:	465a      	mov	r2, fp
   15c26:	01d2      	lsls	r2, r2, #7
   15c28:	d506      	bpl.n	15c38 <__aeabi_ddiv+0x3f4>
   15c2a:	465a      	mov	r2, fp
   15c2c:	4b90      	ldr	r3, [pc, #576]	; (15e70 <__aeabi_ddiv+0x62c>)
   15c2e:	401a      	ands	r2, r3
   15c30:	2380      	movs	r3, #128	; 0x80
   15c32:	4693      	mov	fp, r2
   15c34:	00db      	lsls	r3, r3, #3
   15c36:	18eb      	adds	r3, r5, r3
   15c38:	4a8e      	ldr	r2, [pc, #568]	; (15e74 <__aeabi_ddiv+0x630>)
   15c3a:	4293      	cmp	r3, r2
   15c3c:	dd00      	ble.n	15c40 <__aeabi_ddiv+0x3fc>
   15c3e:	e662      	b.n	15906 <__aeabi_ddiv+0xc2>
   15c40:	464a      	mov	r2, r9
   15c42:	4659      	mov	r1, fp
   15c44:	08d2      	lsrs	r2, r2, #3
   15c46:	0749      	lsls	r1, r1, #29
   15c48:	4311      	orrs	r1, r2
   15c4a:	465a      	mov	r2, fp
   15c4c:	4689      	mov	r9, r1
   15c4e:	0257      	lsls	r7, r2, #9
   15c50:	4651      	mov	r1, sl
   15c52:	2201      	movs	r2, #1
   15c54:	055b      	lsls	r3, r3, #21
   15c56:	0b3f      	lsrs	r7, r7, #12
   15c58:	0d5b      	lsrs	r3, r3, #21
   15c5a:	400a      	ands	r2, r1
   15c5c:	e65a      	b.n	15914 <__aeabi_ddiv+0xd0>
   15c5e:	2080      	movs	r0, #128	; 0x80
   15c60:	465a      	mov	r2, fp
   15c62:	0300      	lsls	r0, r0, #12
   15c64:	4202      	tst	r2, r0
   15c66:	d008      	beq.n	15c7a <__aeabi_ddiv+0x436>
   15c68:	4207      	tst	r7, r0
   15c6a:	d106      	bne.n	15c7a <__aeabi_ddiv+0x436>
   15c6c:	4307      	orrs	r7, r0
   15c6e:	033f      	lsls	r7, r7, #12
   15c70:	4699      	mov	r9, r3
   15c72:	0b3f      	lsrs	r7, r7, #12
   15c74:	4642      	mov	r2, r8
   15c76:	4b80      	ldr	r3, [pc, #512]	; (15e78 <__aeabi_ddiv+0x634>)
   15c78:	e64c      	b.n	15914 <__aeabi_ddiv+0xd0>
   15c7a:	465f      	mov	r7, fp
   15c7c:	4307      	orrs	r7, r0
   15c7e:	033f      	lsls	r7, r7, #12
   15c80:	0b3f      	lsrs	r7, r7, #12
   15c82:	1c22      	adds	r2, r4, #0
   15c84:	4b7c      	ldr	r3, [pc, #496]	; (15e78 <__aeabi_ddiv+0x634>)
   15c86:	e645      	b.n	15914 <__aeabi_ddiv+0xd0>
   15c88:	f000 fcb0 	bl	165ec <__clzsi2>
   15c8c:	1c03      	adds	r3, r0, #0
   15c8e:	3020      	adds	r0, #32
   15c90:	2827      	cmp	r0, #39	; 0x27
   15c92:	dc00      	bgt.n	15c96 <__aeabi_ddiv+0x452>
   15c94:	e65e      	b.n	15954 <__aeabi_ddiv+0x110>
   15c96:	3b08      	subs	r3, #8
   15c98:	409e      	lsls	r6, r3
   15c9a:	2300      	movs	r3, #0
   15c9c:	46b3      	mov	fp, r6
   15c9e:	4699      	mov	r9, r3
   15ca0:	e665      	b.n	1596e <__aeabi_ddiv+0x12a>
   15ca2:	4650      	mov	r0, sl
   15ca4:	f000 fca2 	bl	165ec <__clzsi2>
   15ca8:	1c02      	adds	r2, r0, #0
   15caa:	3220      	adds	r2, #32
   15cac:	2a27      	cmp	r2, #39	; 0x27
   15cae:	dc00      	bgt.n	15cb2 <__aeabi_ddiv+0x46e>
   15cb0:	e675      	b.n	1599e <__aeabi_ddiv+0x15a>
   15cb2:	4657      	mov	r7, sl
   15cb4:	3808      	subs	r0, #8
   15cb6:	4087      	lsls	r7, r0
   15cb8:	2300      	movs	r3, #0
   15cba:	e67b      	b.n	159b4 <__aeabi_ddiv+0x170>
   15cbc:	4599      	cmp	r9, r3
   15cbe:	d200      	bcs.n	15cc2 <__aeabi_ddiv+0x47e>
   15cc0:	e6af      	b.n	15a22 <__aeabi_ddiv+0x1de>
   15cc2:	465a      	mov	r2, fp
   15cc4:	4659      	mov	r1, fp
   15cc6:	0854      	lsrs	r4, r2, #1
   15cc8:	464a      	mov	r2, r9
   15cca:	07c8      	lsls	r0, r1, #31
   15ccc:	0852      	lsrs	r2, r2, #1
   15cce:	4302      	orrs	r2, r0
   15cd0:	9203      	str	r2, [sp, #12]
   15cd2:	464a      	mov	r2, r9
   15cd4:	07d2      	lsls	r2, r2, #31
   15cd6:	4690      	mov	r8, r2
   15cd8:	e6a9      	b.n	15a2e <__aeabi_ddiv+0x1ea>
   15cda:	2700      	movs	r7, #0
   15cdc:	4588      	cmp	r8, r1
   15cde:	d300      	bcc.n	15ce2 <__aeabi_ddiv+0x49e>
   15ce0:	e71c      	b.n	15b1c <__aeabi_ddiv+0x2d8>
   15ce2:	9f01      	ldr	r7, [sp, #4]
   15ce4:	465a      	mov	r2, fp
   15ce6:	46bc      	mov	ip, r7
   15ce8:	44e0      	add	r8, ip
   15cea:	45b8      	cmp	r8, r7
   15cec:	41bf      	sbcs	r7, r7
   15cee:	427f      	negs	r7, r7
   15cf0:	19bf      	adds	r7, r7, r6
   15cf2:	18ff      	adds	r7, r7, r3
   15cf4:	3a01      	subs	r2, #1
   15cf6:	42be      	cmp	r6, r7
   15cf8:	d206      	bcs.n	15d08 <__aeabi_ddiv+0x4c4>
   15cfa:	42bc      	cmp	r4, r7
   15cfc:	d85f      	bhi.n	15dbe <__aeabi_ddiv+0x57a>
   15cfe:	d100      	bne.n	15d02 <__aeabi_ddiv+0x4be>
   15d00:	e09f      	b.n	15e42 <__aeabi_ddiv+0x5fe>
   15d02:	1b3f      	subs	r7, r7, r4
   15d04:	4693      	mov	fp, r2
   15d06:	e709      	b.n	15b1c <__aeabi_ddiv+0x2d8>
   15d08:	42b7      	cmp	r7, r6
   15d0a:	d1fa      	bne.n	15d02 <__aeabi_ddiv+0x4be>
   15d0c:	9b01      	ldr	r3, [sp, #4]
   15d0e:	4543      	cmp	r3, r8
   15d10:	d9f3      	bls.n	15cfa <__aeabi_ddiv+0x4b6>
   15d12:	1b37      	subs	r7, r6, r4
   15d14:	4693      	mov	fp, r2
   15d16:	e701      	b.n	15b1c <__aeabi_ddiv+0x2d8>
   15d18:	4693      	mov	fp, r2
   15d1a:	e6d4      	b.n	15ac6 <__aeabi_ddiv+0x282>
   15d1c:	9302      	str	r3, [sp, #8]
   15d1e:	e6b1      	b.n	15a84 <__aeabi_ddiv+0x240>
   15d20:	464a      	mov	r2, r9
   15d22:	1989      	adds	r1, r1, r6
   15d24:	3a01      	subs	r2, #1
   15d26:	428e      	cmp	r6, r1
   15d28:	d918      	bls.n	15d5c <__aeabi_ddiv+0x518>
   15d2a:	4691      	mov	r9, r2
   15d2c:	4281      	cmp	r1, r0
   15d2e:	d000      	beq.n	15d32 <__aeabi_ddiv+0x4ee>
   15d30:	e761      	b.n	15bf6 <__aeabi_ddiv+0x3b2>
   15d32:	9a01      	ldr	r2, [sp, #4]
   15d34:	429a      	cmp	r2, r3
   15d36:	d000      	beq.n	15d3a <__aeabi_ddiv+0x4f6>
   15d38:	e75d      	b.n	15bf6 <__aeabi_ddiv+0x3b2>
   15d3a:	e760      	b.n	15bfe <__aeabi_ddiv+0x3ba>
   15d3c:	4f4f      	ldr	r7, [pc, #316]	; (15e7c <__aeabi_ddiv+0x638>)
   15d3e:	1b7f      	subs	r7, r7, r5
   15d40:	2f38      	cmp	r7, #56	; 0x38
   15d42:	dd13      	ble.n	15d6c <__aeabi_ddiv+0x528>
   15d44:	2201      	movs	r2, #1
   15d46:	4653      	mov	r3, sl
   15d48:	401a      	ands	r2, r3
   15d4a:	e64f      	b.n	159ec <__aeabi_ddiv+0x1a8>
   15d4c:	2301      	movs	r3, #1
   15d4e:	425b      	negs	r3, r3
   15d50:	4699      	mov	r9, r3
   15d52:	e754      	b.n	15bfe <__aeabi_ddiv+0x3ba>
   15d54:	9302      	str	r3, [sp, #8]
   15d56:	e708      	b.n	15b6a <__aeabi_ddiv+0x326>
   15d58:	9303      	str	r3, [sp, #12]
   15d5a:	e727      	b.n	15bac <__aeabi_ddiv+0x368>
   15d5c:	4288      	cmp	r0, r1
   15d5e:	d83c      	bhi.n	15dda <__aeabi_ddiv+0x596>
   15d60:	d074      	beq.n	15e4c <__aeabi_ddiv+0x608>
   15d62:	4691      	mov	r9, r2
   15d64:	e747      	b.n	15bf6 <__aeabi_ddiv+0x3b2>
   15d66:	9b01      	ldr	r3, [sp, #4]
   15d68:	469a      	mov	sl, r3
   15d6a:	e748      	b.n	15bfe <__aeabi_ddiv+0x3ba>
   15d6c:	2f1f      	cmp	r7, #31
   15d6e:	dc44      	bgt.n	15dfa <__aeabi_ddiv+0x5b6>
   15d70:	4b43      	ldr	r3, [pc, #268]	; (15e80 <__aeabi_ddiv+0x63c>)
   15d72:	464a      	mov	r2, r9
   15d74:	469c      	mov	ip, r3
   15d76:	465b      	mov	r3, fp
   15d78:	4465      	add	r5, ip
   15d7a:	40fa      	lsrs	r2, r7
   15d7c:	40ab      	lsls	r3, r5
   15d7e:	4313      	orrs	r3, r2
   15d80:	464a      	mov	r2, r9
   15d82:	40aa      	lsls	r2, r5
   15d84:	1c15      	adds	r5, r2, #0
   15d86:	1e6a      	subs	r2, r5, #1
   15d88:	4195      	sbcs	r5, r2
   15d8a:	465a      	mov	r2, fp
   15d8c:	40fa      	lsrs	r2, r7
   15d8e:	432b      	orrs	r3, r5
   15d90:	1c17      	adds	r7, r2, #0
   15d92:	075a      	lsls	r2, r3, #29
   15d94:	d009      	beq.n	15daa <__aeabi_ddiv+0x566>
   15d96:	220f      	movs	r2, #15
   15d98:	401a      	ands	r2, r3
   15d9a:	2a04      	cmp	r2, #4
   15d9c:	d005      	beq.n	15daa <__aeabi_ddiv+0x566>
   15d9e:	1d1a      	adds	r2, r3, #4
   15da0:	429a      	cmp	r2, r3
   15da2:	419b      	sbcs	r3, r3
   15da4:	425b      	negs	r3, r3
   15da6:	18ff      	adds	r7, r7, r3
   15da8:	1c13      	adds	r3, r2, #0
   15daa:	023a      	lsls	r2, r7, #8
   15dac:	d53e      	bpl.n	15e2c <__aeabi_ddiv+0x5e8>
   15dae:	4653      	mov	r3, sl
   15db0:	2201      	movs	r2, #1
   15db2:	2100      	movs	r1, #0
   15db4:	401a      	ands	r2, r3
   15db6:	2700      	movs	r7, #0
   15db8:	2301      	movs	r3, #1
   15dba:	4689      	mov	r9, r1
   15dbc:	e5aa      	b.n	15914 <__aeabi_ddiv+0xd0>
   15dbe:	2302      	movs	r3, #2
   15dc0:	425b      	negs	r3, r3
   15dc2:	469c      	mov	ip, r3
   15dc4:	9a01      	ldr	r2, [sp, #4]
   15dc6:	44e3      	add	fp, ip
   15dc8:	4694      	mov	ip, r2
   15dca:	44e0      	add	r8, ip
   15dcc:	4590      	cmp	r8, r2
   15dce:	419b      	sbcs	r3, r3
   15dd0:	425b      	negs	r3, r3
   15dd2:	199b      	adds	r3, r3, r6
   15dd4:	19df      	adds	r7, r3, r7
   15dd6:	1b3f      	subs	r7, r7, r4
   15dd8:	e6a0      	b.n	15b1c <__aeabi_ddiv+0x2d8>
   15dda:	9f01      	ldr	r7, [sp, #4]
   15ddc:	464a      	mov	r2, r9
   15dde:	007c      	lsls	r4, r7, #1
   15de0:	42bc      	cmp	r4, r7
   15de2:	41bf      	sbcs	r7, r7
   15de4:	427f      	negs	r7, r7
   15de6:	19bf      	adds	r7, r7, r6
   15de8:	3a02      	subs	r2, #2
   15dea:	19c9      	adds	r1, r1, r7
   15dec:	9401      	str	r4, [sp, #4]
   15dee:	e79c      	b.n	15d2a <__aeabi_ddiv+0x4e6>
   15df0:	2b00      	cmp	r3, #0
   15df2:	d195      	bne.n	15d20 <__aeabi_ddiv+0x4dc>
   15df4:	2200      	movs	r2, #0
   15df6:	9201      	str	r2, [sp, #4]
   15df8:	e79b      	b.n	15d32 <__aeabi_ddiv+0x4ee>
   15dfa:	465a      	mov	r2, fp
   15dfc:	4b21      	ldr	r3, [pc, #132]	; (15e84 <__aeabi_ddiv+0x640>)
   15dfe:	1b5b      	subs	r3, r3, r5
   15e00:	40da      	lsrs	r2, r3
   15e02:	2f20      	cmp	r7, #32
   15e04:	d027      	beq.n	15e56 <__aeabi_ddiv+0x612>
   15e06:	4b20      	ldr	r3, [pc, #128]	; (15e88 <__aeabi_ddiv+0x644>)
   15e08:	469c      	mov	ip, r3
   15e0a:	465b      	mov	r3, fp
   15e0c:	4465      	add	r5, ip
   15e0e:	40ab      	lsls	r3, r5
   15e10:	4649      	mov	r1, r9
   15e12:	430b      	orrs	r3, r1
   15e14:	1e59      	subs	r1, r3, #1
   15e16:	418b      	sbcs	r3, r1
   15e18:	4313      	orrs	r3, r2
   15e1a:	2207      	movs	r2, #7
   15e1c:	2700      	movs	r7, #0
   15e1e:	401a      	ands	r2, r3
   15e20:	d007      	beq.n	15e32 <__aeabi_ddiv+0x5ee>
   15e22:	220f      	movs	r2, #15
   15e24:	2700      	movs	r7, #0
   15e26:	401a      	ands	r2, r3
   15e28:	2a04      	cmp	r2, #4
   15e2a:	d1b8      	bne.n	15d9e <__aeabi_ddiv+0x55a>
   15e2c:	077a      	lsls	r2, r7, #29
   15e2e:	027f      	lsls	r7, r7, #9
   15e30:	0b3f      	lsrs	r7, r7, #12
   15e32:	08db      	lsrs	r3, r3, #3
   15e34:	4313      	orrs	r3, r2
   15e36:	4699      	mov	r9, r3
   15e38:	2201      	movs	r2, #1
   15e3a:	4653      	mov	r3, sl
   15e3c:	401a      	ands	r2, r3
   15e3e:	2300      	movs	r3, #0
   15e40:	e568      	b.n	15914 <__aeabi_ddiv+0xd0>
   15e42:	4541      	cmp	r1, r8
   15e44:	d8bb      	bhi.n	15dbe <__aeabi_ddiv+0x57a>
   15e46:	4693      	mov	fp, r2
   15e48:	2700      	movs	r7, #0
   15e4a:	e667      	b.n	15b1c <__aeabi_ddiv+0x2d8>
   15e4c:	9c01      	ldr	r4, [sp, #4]
   15e4e:	429c      	cmp	r4, r3
   15e50:	d3c3      	bcc.n	15dda <__aeabi_ddiv+0x596>
   15e52:	4691      	mov	r9, r2
   15e54:	e76d      	b.n	15d32 <__aeabi_ddiv+0x4ee>
   15e56:	2300      	movs	r3, #0
   15e58:	e7da      	b.n	15e10 <__aeabi_ddiv+0x5cc>
   15e5a:	2780      	movs	r7, #128	; 0x80
   15e5c:	465b      	mov	r3, fp
   15e5e:	033f      	lsls	r7, r7, #12
   15e60:	431f      	orrs	r7, r3
   15e62:	033f      	lsls	r7, r7, #12
   15e64:	0b3f      	lsrs	r7, r7, #12
   15e66:	9a01      	ldr	r2, [sp, #4]
   15e68:	4b03      	ldr	r3, [pc, #12]	; (15e78 <__aeabi_ddiv+0x634>)
   15e6a:	e553      	b.n	15914 <__aeabi_ddiv+0xd0>
   15e6c:	000003ff 	.word	0x000003ff
   15e70:	feffffff 	.word	0xfeffffff
   15e74:	000007fe 	.word	0x000007fe
   15e78:	000007ff 	.word	0x000007ff
   15e7c:	fffffc02 	.word	0xfffffc02
   15e80:	0000041e 	.word	0x0000041e
   15e84:	fffffbe2 	.word	0xfffffbe2
   15e88:	0000043e 	.word	0x0000043e

00015e8c <__aeabi_dmul>:
   15e8c:	b5f0      	push	{r4, r5, r6, r7, lr}
   15e8e:	465f      	mov	r7, fp
   15e90:	4656      	mov	r6, sl
   15e92:	464d      	mov	r5, r9
   15e94:	4644      	mov	r4, r8
   15e96:	b4f0      	push	{r4, r5, r6, r7}
   15e98:	1c05      	adds	r5, r0, #0
   15e9a:	1c06      	adds	r6, r0, #0
   15e9c:	0308      	lsls	r0, r1, #12
   15e9e:	b087      	sub	sp, #28
   15ea0:	4699      	mov	r9, r3
   15ea2:	004f      	lsls	r7, r1, #1
   15ea4:	0b03      	lsrs	r3, r0, #12
   15ea6:	0fcc      	lsrs	r4, r1, #31
   15ea8:	4692      	mov	sl, r2
   15eaa:	469b      	mov	fp, r3
   15eac:	0d7f      	lsrs	r7, r7, #21
   15eae:	9401      	str	r4, [sp, #4]
   15eb0:	d067      	beq.n	15f82 <__aeabi_dmul+0xf6>
   15eb2:	4b6c      	ldr	r3, [pc, #432]	; (16064 <__aeabi_dmul+0x1d8>)
   15eb4:	429f      	cmp	r7, r3
   15eb6:	d036      	beq.n	15f26 <__aeabi_dmul+0x9a>
   15eb8:	2080      	movs	r0, #128	; 0x80
   15eba:	465b      	mov	r3, fp
   15ebc:	0340      	lsls	r0, r0, #13
   15ebe:	4318      	orrs	r0, r3
   15ec0:	00c0      	lsls	r0, r0, #3
   15ec2:	0f6b      	lsrs	r3, r5, #29
   15ec4:	4318      	orrs	r0, r3
   15ec6:	4b68      	ldr	r3, [pc, #416]	; (16068 <__aeabi_dmul+0x1dc>)
   15ec8:	4683      	mov	fp, r0
   15eca:	469c      	mov	ip, r3
   15ecc:	2300      	movs	r3, #0
   15ece:	4698      	mov	r8, r3
   15ed0:	00ee      	lsls	r6, r5, #3
   15ed2:	4467      	add	r7, ip
   15ed4:	9300      	str	r3, [sp, #0]
   15ed6:	464b      	mov	r3, r9
   15ed8:	4649      	mov	r1, r9
   15eda:	031d      	lsls	r5, r3, #12
   15edc:	0fc9      	lsrs	r1, r1, #31
   15ede:	005b      	lsls	r3, r3, #1
   15ee0:	4652      	mov	r2, sl
   15ee2:	0b2d      	lsrs	r5, r5, #12
   15ee4:	0d5b      	lsrs	r3, r3, #21
   15ee6:	4689      	mov	r9, r1
   15ee8:	d100      	bne.n	15eec <__aeabi_dmul+0x60>
   15eea:	e06e      	b.n	15fca <__aeabi_dmul+0x13e>
   15eec:	495d      	ldr	r1, [pc, #372]	; (16064 <__aeabi_dmul+0x1d8>)
   15eee:	428b      	cmp	r3, r1
   15ef0:	d064      	beq.n	15fbc <__aeabi_dmul+0x130>
   15ef2:	2080      	movs	r0, #128	; 0x80
   15ef4:	495c      	ldr	r1, [pc, #368]	; (16068 <__aeabi_dmul+0x1dc>)
   15ef6:	0340      	lsls	r0, r0, #13
   15ef8:	468c      	mov	ip, r1
   15efa:	2100      	movs	r1, #0
   15efc:	4305      	orrs	r5, r0
   15efe:	00ed      	lsls	r5, r5, #3
   15f00:	0f50      	lsrs	r0, r2, #29
   15f02:	4305      	orrs	r5, r0
   15f04:	00d2      	lsls	r2, r2, #3
   15f06:	4463      	add	r3, ip
   15f08:	4648      	mov	r0, r9
   15f0a:	18ff      	adds	r7, r7, r3
   15f0c:	1c7b      	adds	r3, r7, #1
   15f0e:	469a      	mov	sl, r3
   15f10:	9b00      	ldr	r3, [sp, #0]
   15f12:	4060      	eors	r0, r4
   15f14:	9002      	str	r0, [sp, #8]
   15f16:	430b      	orrs	r3, r1
   15f18:	2b0f      	cmp	r3, #15
   15f1a:	d900      	bls.n	15f1e <__aeabi_dmul+0x92>
   15f1c:	e0ac      	b.n	16078 <__aeabi_dmul+0x1ec>
   15f1e:	4853      	ldr	r0, [pc, #332]	; (1606c <__aeabi_dmul+0x1e0>)
   15f20:	009b      	lsls	r3, r3, #2
   15f22:	58c3      	ldr	r3, [r0, r3]
   15f24:	469f      	mov	pc, r3
   15f26:	465b      	mov	r3, fp
   15f28:	431d      	orrs	r5, r3
   15f2a:	d000      	beq.n	15f2e <__aeabi_dmul+0xa2>
   15f2c:	e082      	b.n	16034 <__aeabi_dmul+0x1a8>
   15f2e:	2308      	movs	r3, #8
   15f30:	9300      	str	r3, [sp, #0]
   15f32:	2300      	movs	r3, #0
   15f34:	469b      	mov	fp, r3
   15f36:	3302      	adds	r3, #2
   15f38:	2600      	movs	r6, #0
   15f3a:	4698      	mov	r8, r3
   15f3c:	e7cb      	b.n	15ed6 <__aeabi_dmul+0x4a>
   15f3e:	9b02      	ldr	r3, [sp, #8]
   15f40:	9301      	str	r3, [sp, #4]
   15f42:	4643      	mov	r3, r8
   15f44:	2b02      	cmp	r3, #2
   15f46:	d159      	bne.n	15ffc <__aeabi_dmul+0x170>
   15f48:	2401      	movs	r4, #1
   15f4a:	2500      	movs	r5, #0
   15f4c:	2600      	movs	r6, #0
   15f4e:	9b01      	ldr	r3, [sp, #4]
   15f50:	401c      	ands	r4, r3
   15f52:	4b44      	ldr	r3, [pc, #272]	; (16064 <__aeabi_dmul+0x1d8>)
   15f54:	2100      	movs	r1, #0
   15f56:	032d      	lsls	r5, r5, #12
   15f58:	0d0a      	lsrs	r2, r1, #20
   15f5a:	0512      	lsls	r2, r2, #20
   15f5c:	0b2d      	lsrs	r5, r5, #12
   15f5e:	4315      	orrs	r5, r2
   15f60:	4a43      	ldr	r2, [pc, #268]	; (16070 <__aeabi_dmul+0x1e4>)
   15f62:	051b      	lsls	r3, r3, #20
   15f64:	4015      	ands	r5, r2
   15f66:	431d      	orrs	r5, r3
   15f68:	006d      	lsls	r5, r5, #1
   15f6a:	07e4      	lsls	r4, r4, #31
   15f6c:	086d      	lsrs	r5, r5, #1
   15f6e:	4325      	orrs	r5, r4
   15f70:	1c30      	adds	r0, r6, #0
   15f72:	1c29      	adds	r1, r5, #0
   15f74:	b007      	add	sp, #28
   15f76:	bc3c      	pop	{r2, r3, r4, r5}
   15f78:	4690      	mov	r8, r2
   15f7a:	4699      	mov	r9, r3
   15f7c:	46a2      	mov	sl, r4
   15f7e:	46ab      	mov	fp, r5
   15f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15f82:	432b      	orrs	r3, r5
   15f84:	d04e      	beq.n	16024 <__aeabi_dmul+0x198>
   15f86:	465b      	mov	r3, fp
   15f88:	2b00      	cmp	r3, #0
   15f8a:	d100      	bne.n	15f8e <__aeabi_dmul+0x102>
   15f8c:	e185      	b.n	1629a <__aeabi_dmul+0x40e>
   15f8e:	4658      	mov	r0, fp
   15f90:	f000 fb2c 	bl	165ec <__clzsi2>
   15f94:	1c02      	adds	r2, r0, #0
   15f96:	2328      	movs	r3, #40	; 0x28
   15f98:	1c29      	adds	r1, r5, #0
   15f9a:	1a9b      	subs	r3, r3, r2
   15f9c:	1c16      	adds	r6, r2, #0
   15f9e:	4658      	mov	r0, fp
   15fa0:	40d9      	lsrs	r1, r3
   15fa2:	3e08      	subs	r6, #8
   15fa4:	40b0      	lsls	r0, r6
   15fa6:	1c0b      	adds	r3, r1, #0
   15fa8:	40b5      	lsls	r5, r6
   15faa:	4303      	orrs	r3, r0
   15fac:	469b      	mov	fp, r3
   15fae:	1c2e      	adds	r6, r5, #0
   15fb0:	2300      	movs	r3, #0
   15fb2:	4f30      	ldr	r7, [pc, #192]	; (16074 <__aeabi_dmul+0x1e8>)
   15fb4:	9300      	str	r3, [sp, #0]
   15fb6:	1abf      	subs	r7, r7, r2
   15fb8:	4698      	mov	r8, r3
   15fba:	e78c      	b.n	15ed6 <__aeabi_dmul+0x4a>
   15fbc:	4651      	mov	r1, sl
   15fbe:	4329      	orrs	r1, r5
   15fc0:	d12e      	bne.n	16020 <__aeabi_dmul+0x194>
   15fc2:	2500      	movs	r5, #0
   15fc4:	2200      	movs	r2, #0
   15fc6:	2102      	movs	r1, #2
   15fc8:	e79e      	b.n	15f08 <__aeabi_dmul+0x7c>
   15fca:	4651      	mov	r1, sl
   15fcc:	4329      	orrs	r1, r5
   15fce:	d023      	beq.n	16018 <__aeabi_dmul+0x18c>
   15fd0:	2d00      	cmp	r5, #0
   15fd2:	d100      	bne.n	15fd6 <__aeabi_dmul+0x14a>
   15fd4:	e154      	b.n	16280 <__aeabi_dmul+0x3f4>
   15fd6:	1c28      	adds	r0, r5, #0
   15fd8:	f000 fb08 	bl	165ec <__clzsi2>
   15fdc:	1c03      	adds	r3, r0, #0
   15fde:	2128      	movs	r1, #40	; 0x28
   15fe0:	4650      	mov	r0, sl
   15fe2:	1ac9      	subs	r1, r1, r3
   15fe4:	1c1a      	adds	r2, r3, #0
   15fe6:	40c8      	lsrs	r0, r1
   15fe8:	4651      	mov	r1, sl
   15fea:	3a08      	subs	r2, #8
   15fec:	4091      	lsls	r1, r2
   15fee:	4095      	lsls	r5, r2
   15ff0:	1c0a      	adds	r2, r1, #0
   15ff2:	4305      	orrs	r5, r0
   15ff4:	481f      	ldr	r0, [pc, #124]	; (16074 <__aeabi_dmul+0x1e8>)
   15ff6:	2100      	movs	r1, #0
   15ff8:	1ac3      	subs	r3, r0, r3
   15ffa:	e785      	b.n	15f08 <__aeabi_dmul+0x7c>
   15ffc:	2b03      	cmp	r3, #3
   15ffe:	d100      	bne.n	16002 <__aeabi_dmul+0x176>
   16000:	e1c2      	b.n	16388 <__aeabi_dmul+0x4fc>
   16002:	2b01      	cmp	r3, #1
   16004:	d000      	beq.n	16008 <__aeabi_dmul+0x17c>
   16006:	e16d      	b.n	162e4 <__aeabi_dmul+0x458>
   16008:	4644      	mov	r4, r8
   1600a:	9b01      	ldr	r3, [sp, #4]
   1600c:	2500      	movs	r5, #0
   1600e:	401c      	ands	r4, r3
   16010:	b2e4      	uxtb	r4, r4
   16012:	2300      	movs	r3, #0
   16014:	2600      	movs	r6, #0
   16016:	e79d      	b.n	15f54 <__aeabi_dmul+0xc8>
   16018:	2500      	movs	r5, #0
   1601a:	2200      	movs	r2, #0
   1601c:	2101      	movs	r1, #1
   1601e:	e773      	b.n	15f08 <__aeabi_dmul+0x7c>
   16020:	2103      	movs	r1, #3
   16022:	e771      	b.n	15f08 <__aeabi_dmul+0x7c>
   16024:	2304      	movs	r3, #4
   16026:	9300      	str	r3, [sp, #0]
   16028:	2300      	movs	r3, #0
   1602a:	469b      	mov	fp, r3
   1602c:	3301      	adds	r3, #1
   1602e:	2600      	movs	r6, #0
   16030:	4698      	mov	r8, r3
   16032:	e750      	b.n	15ed6 <__aeabi_dmul+0x4a>
   16034:	230c      	movs	r3, #12
   16036:	9300      	str	r3, [sp, #0]
   16038:	3b09      	subs	r3, #9
   1603a:	4698      	mov	r8, r3
   1603c:	e74b      	b.n	15ed6 <__aeabi_dmul+0x4a>
   1603e:	2580      	movs	r5, #128	; 0x80
   16040:	2400      	movs	r4, #0
   16042:	032d      	lsls	r5, r5, #12
   16044:	2600      	movs	r6, #0
   16046:	4b07      	ldr	r3, [pc, #28]	; (16064 <__aeabi_dmul+0x1d8>)
   16048:	e784      	b.n	15f54 <__aeabi_dmul+0xc8>
   1604a:	464b      	mov	r3, r9
   1604c:	46ab      	mov	fp, r5
   1604e:	1c16      	adds	r6, r2, #0
   16050:	9301      	str	r3, [sp, #4]
   16052:	4688      	mov	r8, r1
   16054:	e775      	b.n	15f42 <__aeabi_dmul+0xb6>
   16056:	9b02      	ldr	r3, [sp, #8]
   16058:	46ab      	mov	fp, r5
   1605a:	1c16      	adds	r6, r2, #0
   1605c:	9301      	str	r3, [sp, #4]
   1605e:	4688      	mov	r8, r1
   16060:	e76f      	b.n	15f42 <__aeabi_dmul+0xb6>
   16062:	46c0      	nop			; (mov r8, r8)
   16064:	000007ff 	.word	0x000007ff
   16068:	fffffc01 	.word	0xfffffc01
   1606c:	00021c48 	.word	0x00021c48
   16070:	800fffff 	.word	0x800fffff
   16074:	fffffc0d 	.word	0xfffffc0d
   16078:	0c33      	lsrs	r3, r6, #16
   1607a:	0436      	lsls	r6, r6, #16
   1607c:	0c36      	lsrs	r6, r6, #16
   1607e:	469c      	mov	ip, r3
   16080:	1c33      	adds	r3, r6, #0
   16082:	0c14      	lsrs	r4, r2, #16
   16084:	0412      	lsls	r2, r2, #16
   16086:	0c12      	lsrs	r2, r2, #16
   16088:	4353      	muls	r3, r2
   1608a:	4698      	mov	r8, r3
   1608c:	4663      	mov	r3, ip
   1608e:	4353      	muls	r3, r2
   16090:	4699      	mov	r9, r3
   16092:	4663      	mov	r3, ip
   16094:	4363      	muls	r3, r4
   16096:	9301      	str	r3, [sp, #4]
   16098:	1c33      	adds	r3, r6, #0
   1609a:	4641      	mov	r1, r8
   1609c:	4363      	muls	r3, r4
   1609e:	0c09      	lsrs	r1, r1, #16
   160a0:	444b      	add	r3, r9
   160a2:	185b      	adds	r3, r3, r1
   160a4:	4599      	cmp	r9, r3
   160a6:	d905      	bls.n	160b4 <__aeabi_dmul+0x228>
   160a8:	2080      	movs	r0, #128	; 0x80
   160aa:	0240      	lsls	r0, r0, #9
   160ac:	4681      	mov	r9, r0
   160ae:	9901      	ldr	r1, [sp, #4]
   160b0:	4449      	add	r1, r9
   160b2:	9101      	str	r1, [sp, #4]
   160b4:	0c19      	lsrs	r1, r3, #16
   160b6:	9103      	str	r1, [sp, #12]
   160b8:	4641      	mov	r1, r8
   160ba:	0409      	lsls	r1, r1, #16
   160bc:	0c09      	lsrs	r1, r1, #16
   160be:	041b      	lsls	r3, r3, #16
   160c0:	185b      	adds	r3, r3, r1
   160c2:	9304      	str	r3, [sp, #16]
   160c4:	0c2b      	lsrs	r3, r5, #16
   160c6:	4698      	mov	r8, r3
   160c8:	1c33      	adds	r3, r6, #0
   160ca:	042d      	lsls	r5, r5, #16
   160cc:	0c29      	lsrs	r1, r5, #16
   160ce:	434b      	muls	r3, r1
   160d0:	4660      	mov	r0, ip
   160d2:	9300      	str	r3, [sp, #0]
   160d4:	4643      	mov	r3, r8
   160d6:	4665      	mov	r5, ip
   160d8:	4358      	muls	r0, r3
   160da:	435e      	muls	r6, r3
   160dc:	9b00      	ldr	r3, [sp, #0]
   160de:	434d      	muls	r5, r1
   160e0:	0c1b      	lsrs	r3, r3, #16
   160e2:	4699      	mov	r9, r3
   160e4:	19ae      	adds	r6, r5, r6
   160e6:	444e      	add	r6, r9
   160e8:	4684      	mov	ip, r0
   160ea:	42b5      	cmp	r5, r6
   160ec:	d903      	bls.n	160f6 <__aeabi_dmul+0x26a>
   160ee:	2380      	movs	r3, #128	; 0x80
   160f0:	025b      	lsls	r3, r3, #9
   160f2:	4699      	mov	r9, r3
   160f4:	44cc      	add	ip, r9
   160f6:	0c35      	lsrs	r5, r6, #16
   160f8:	1c2b      	adds	r3, r5, #0
   160fa:	9803      	ldr	r0, [sp, #12]
   160fc:	4463      	add	r3, ip
   160fe:	4684      	mov	ip, r0
   16100:	9305      	str	r3, [sp, #20]
   16102:	9b00      	ldr	r3, [sp, #0]
   16104:	0436      	lsls	r6, r6, #16
   16106:	041b      	lsls	r3, r3, #16
   16108:	0c1b      	lsrs	r3, r3, #16
   1610a:	18f3      	adds	r3, r6, r3
   1610c:	449c      	add	ip, r3
   1610e:	4660      	mov	r0, ip
   16110:	9003      	str	r0, [sp, #12]
   16112:	4658      	mov	r0, fp
   16114:	0405      	lsls	r5, r0, #16
   16116:	0c06      	lsrs	r6, r0, #16
   16118:	0c28      	lsrs	r0, r5, #16
   1611a:	4684      	mov	ip, r0
   1611c:	4350      	muls	r0, r2
   1611e:	1c35      	adds	r5, r6, #0
   16120:	4681      	mov	r9, r0
   16122:	4660      	mov	r0, ip
   16124:	4365      	muls	r5, r4
   16126:	4344      	muls	r4, r0
   16128:	4648      	mov	r0, r9
   1612a:	0c00      	lsrs	r0, r0, #16
   1612c:	4683      	mov	fp, r0
   1612e:	4372      	muls	r2, r6
   16130:	1914      	adds	r4, r2, r4
   16132:	445c      	add	r4, fp
   16134:	42a2      	cmp	r2, r4
   16136:	d903      	bls.n	16140 <__aeabi_dmul+0x2b4>
   16138:	2280      	movs	r2, #128	; 0x80
   1613a:	0252      	lsls	r2, r2, #9
   1613c:	4693      	mov	fp, r2
   1613e:	445d      	add	r5, fp
   16140:	0c22      	lsrs	r2, r4, #16
   16142:	18ad      	adds	r5, r5, r2
   16144:	464a      	mov	r2, r9
   16146:	0412      	lsls	r2, r2, #16
   16148:	0c12      	lsrs	r2, r2, #16
   1614a:	0424      	lsls	r4, r4, #16
   1614c:	4640      	mov	r0, r8
   1614e:	18a4      	adds	r4, r4, r2
   16150:	4662      	mov	r2, ip
   16152:	434a      	muls	r2, r1
   16154:	4371      	muls	r1, r6
   16156:	4346      	muls	r6, r0
   16158:	4660      	mov	r0, ip
   1615a:	9600      	str	r6, [sp, #0]
   1615c:	4646      	mov	r6, r8
   1615e:	4370      	muls	r0, r6
   16160:	4680      	mov	r8, r0
   16162:	0c10      	lsrs	r0, r2, #16
   16164:	4684      	mov	ip, r0
   16166:	4488      	add	r8, r1
   16168:	44e0      	add	r8, ip
   1616a:	4541      	cmp	r1, r8
   1616c:	d905      	bls.n	1617a <__aeabi_dmul+0x2ee>
   1616e:	2180      	movs	r1, #128	; 0x80
   16170:	0249      	lsls	r1, r1, #9
   16172:	468c      	mov	ip, r1
   16174:	9900      	ldr	r1, [sp, #0]
   16176:	4461      	add	r1, ip
   16178:	9100      	str	r1, [sp, #0]
   1617a:	9801      	ldr	r0, [sp, #4]
   1617c:	9903      	ldr	r1, [sp, #12]
   1617e:	4684      	mov	ip, r0
   16180:	4461      	add	r1, ip
   16182:	4299      	cmp	r1, r3
   16184:	419b      	sbcs	r3, r3
   16186:	425b      	negs	r3, r3
   16188:	4699      	mov	r9, r3
   1618a:	9805      	ldr	r0, [sp, #20]
   1618c:	4643      	mov	r3, r8
   1618e:	4684      	mov	ip, r0
   16190:	0412      	lsls	r2, r2, #16
   16192:	0c12      	lsrs	r2, r2, #16
   16194:	041b      	lsls	r3, r3, #16
   16196:	189b      	adds	r3, r3, r2
   16198:	4463      	add	r3, ip
   1619a:	469c      	mov	ip, r3
   1619c:	46ab      	mov	fp, r5
   1619e:	4283      	cmp	r3, r0
   161a0:	419b      	sbcs	r3, r3
   161a2:	4640      	mov	r0, r8
   161a4:	190a      	adds	r2, r1, r4
   161a6:	44cc      	add	ip, r9
   161a8:	42a2      	cmp	r2, r4
   161aa:	4189      	sbcs	r1, r1
   161ac:	44e3      	add	fp, ip
   161ae:	45cc      	cmp	ip, r9
   161b0:	41b6      	sbcs	r6, r6
   161b2:	465c      	mov	r4, fp
   161b4:	0c00      	lsrs	r0, r0, #16
   161b6:	4680      	mov	r8, r0
   161b8:	4249      	negs	r1, r1
   161ba:	4276      	negs	r6, r6
   161bc:	425b      	negs	r3, r3
   161be:	1864      	adds	r4, r4, r1
   161c0:	4333      	orrs	r3, r6
   161c2:	4498      	add	r8, r3
   161c4:	428c      	cmp	r4, r1
   161c6:	4189      	sbcs	r1, r1
   161c8:	45ab      	cmp	fp, r5
   161ca:	419b      	sbcs	r3, r3
   161cc:	4249      	negs	r1, r1
   161ce:	425b      	negs	r3, r3
   161d0:	4319      	orrs	r1, r3
   161d2:	1c0d      	adds	r5, r1, #0
   161d4:	9b00      	ldr	r3, [sp, #0]
   161d6:	4445      	add	r5, r8
   161d8:	18ee      	adds	r6, r5, r3
   161da:	0276      	lsls	r6, r6, #9
   161dc:	0de5      	lsrs	r5, r4, #23
   161de:	432e      	orrs	r6, r5
   161e0:	46b3      	mov	fp, r6
   161e2:	9b04      	ldr	r3, [sp, #16]
   161e4:	0256      	lsls	r6, r2, #9
   161e6:	431e      	orrs	r6, r3
   161e8:	1e73      	subs	r3, r6, #1
   161ea:	419e      	sbcs	r6, r3
   161ec:	465b      	mov	r3, fp
   161ee:	0dd2      	lsrs	r2, r2, #23
   161f0:	4332      	orrs	r2, r6
   161f2:	0266      	lsls	r6, r4, #9
   161f4:	4316      	orrs	r6, r2
   161f6:	01db      	lsls	r3, r3, #7
   161f8:	d50a      	bpl.n	16210 <__aeabi_dmul+0x384>
   161fa:	2301      	movs	r3, #1
   161fc:	4033      	ands	r3, r6
   161fe:	0876      	lsrs	r6, r6, #1
   16200:	431e      	orrs	r6, r3
   16202:	465b      	mov	r3, fp
   16204:	07db      	lsls	r3, r3, #31
   16206:	431e      	orrs	r6, r3
   16208:	465b      	mov	r3, fp
   1620a:	085b      	lsrs	r3, r3, #1
   1620c:	469b      	mov	fp, r3
   1620e:	4657      	mov	r7, sl
   16210:	4b63      	ldr	r3, [pc, #396]	; (163a0 <__aeabi_dmul+0x514>)
   16212:	18fb      	adds	r3, r7, r3
   16214:	2b00      	cmp	r3, #0
   16216:	dd5a      	ble.n	162ce <__aeabi_dmul+0x442>
   16218:	0772      	lsls	r2, r6, #29
   1621a:	d009      	beq.n	16230 <__aeabi_dmul+0x3a4>
   1621c:	220f      	movs	r2, #15
   1621e:	4032      	ands	r2, r6
   16220:	2a04      	cmp	r2, #4
   16222:	d005      	beq.n	16230 <__aeabi_dmul+0x3a4>
   16224:	1d32      	adds	r2, r6, #4
   16226:	42b2      	cmp	r2, r6
   16228:	41b6      	sbcs	r6, r6
   1622a:	4276      	negs	r6, r6
   1622c:	44b3      	add	fp, r6
   1622e:	1c16      	adds	r6, r2, #0
   16230:	465a      	mov	r2, fp
   16232:	01d2      	lsls	r2, r2, #7
   16234:	d506      	bpl.n	16244 <__aeabi_dmul+0x3b8>
   16236:	465a      	mov	r2, fp
   16238:	4b5a      	ldr	r3, [pc, #360]	; (163a4 <__aeabi_dmul+0x518>)
   1623a:	401a      	ands	r2, r3
   1623c:	2380      	movs	r3, #128	; 0x80
   1623e:	4693      	mov	fp, r2
   16240:	00db      	lsls	r3, r3, #3
   16242:	18fb      	adds	r3, r7, r3
   16244:	4a58      	ldr	r2, [pc, #352]	; (163a8 <__aeabi_dmul+0x51c>)
   16246:	4293      	cmp	r3, r2
   16248:	dd34      	ble.n	162b4 <__aeabi_dmul+0x428>
   1624a:	2401      	movs	r4, #1
   1624c:	9b02      	ldr	r3, [sp, #8]
   1624e:	2500      	movs	r5, #0
   16250:	401c      	ands	r4, r3
   16252:	2600      	movs	r6, #0
   16254:	4b55      	ldr	r3, [pc, #340]	; (163ac <__aeabi_dmul+0x520>)
   16256:	e67d      	b.n	15f54 <__aeabi_dmul+0xc8>
   16258:	2080      	movs	r0, #128	; 0x80
   1625a:	465b      	mov	r3, fp
   1625c:	0300      	lsls	r0, r0, #12
   1625e:	4203      	tst	r3, r0
   16260:	d008      	beq.n	16274 <__aeabi_dmul+0x3e8>
   16262:	4205      	tst	r5, r0
   16264:	d106      	bne.n	16274 <__aeabi_dmul+0x3e8>
   16266:	4305      	orrs	r5, r0
   16268:	032d      	lsls	r5, r5, #12
   1626a:	0b2d      	lsrs	r5, r5, #12
   1626c:	464c      	mov	r4, r9
   1626e:	1c16      	adds	r6, r2, #0
   16270:	4b4e      	ldr	r3, [pc, #312]	; (163ac <__aeabi_dmul+0x520>)
   16272:	e66f      	b.n	15f54 <__aeabi_dmul+0xc8>
   16274:	465d      	mov	r5, fp
   16276:	4305      	orrs	r5, r0
   16278:	032d      	lsls	r5, r5, #12
   1627a:	0b2d      	lsrs	r5, r5, #12
   1627c:	4b4b      	ldr	r3, [pc, #300]	; (163ac <__aeabi_dmul+0x520>)
   1627e:	e669      	b.n	15f54 <__aeabi_dmul+0xc8>
   16280:	4650      	mov	r0, sl
   16282:	f000 f9b3 	bl	165ec <__clzsi2>
   16286:	1c03      	adds	r3, r0, #0
   16288:	3320      	adds	r3, #32
   1628a:	2b27      	cmp	r3, #39	; 0x27
   1628c:	dc00      	bgt.n	16290 <__aeabi_dmul+0x404>
   1628e:	e6a6      	b.n	15fde <__aeabi_dmul+0x152>
   16290:	4655      	mov	r5, sl
   16292:	3808      	subs	r0, #8
   16294:	4085      	lsls	r5, r0
   16296:	2200      	movs	r2, #0
   16298:	e6ac      	b.n	15ff4 <__aeabi_dmul+0x168>
   1629a:	1c28      	adds	r0, r5, #0
   1629c:	f000 f9a6 	bl	165ec <__clzsi2>
   162a0:	1c02      	adds	r2, r0, #0
   162a2:	3220      	adds	r2, #32
   162a4:	2a27      	cmp	r2, #39	; 0x27
   162a6:	dc00      	bgt.n	162aa <__aeabi_dmul+0x41e>
   162a8:	e675      	b.n	15f96 <__aeabi_dmul+0x10a>
   162aa:	3808      	subs	r0, #8
   162ac:	4085      	lsls	r5, r0
   162ae:	2600      	movs	r6, #0
   162b0:	46ab      	mov	fp, r5
   162b2:	e67d      	b.n	15fb0 <__aeabi_dmul+0x124>
   162b4:	465a      	mov	r2, fp
   162b6:	08f6      	lsrs	r6, r6, #3
   162b8:	0752      	lsls	r2, r2, #29
   162ba:	4316      	orrs	r6, r2
   162bc:	465a      	mov	r2, fp
   162be:	2401      	movs	r4, #1
   162c0:	0255      	lsls	r5, r2, #9
   162c2:	9a02      	ldr	r2, [sp, #8]
   162c4:	055b      	lsls	r3, r3, #21
   162c6:	0b2d      	lsrs	r5, r5, #12
   162c8:	0d5b      	lsrs	r3, r3, #21
   162ca:	4014      	ands	r4, r2
   162cc:	e642      	b.n	15f54 <__aeabi_dmul+0xc8>
   162ce:	4d38      	ldr	r5, [pc, #224]	; (163b0 <__aeabi_dmul+0x524>)
   162d0:	1bed      	subs	r5, r5, r7
   162d2:	2d38      	cmp	r5, #56	; 0x38
   162d4:	dd0a      	ble.n	162ec <__aeabi_dmul+0x460>
   162d6:	2401      	movs	r4, #1
   162d8:	9b02      	ldr	r3, [sp, #8]
   162da:	2500      	movs	r5, #0
   162dc:	401c      	ands	r4, r3
   162de:	2600      	movs	r6, #0
   162e0:	2300      	movs	r3, #0
   162e2:	e637      	b.n	15f54 <__aeabi_dmul+0xc8>
   162e4:	9b01      	ldr	r3, [sp, #4]
   162e6:	4657      	mov	r7, sl
   162e8:	9302      	str	r3, [sp, #8]
   162ea:	e791      	b.n	16210 <__aeabi_dmul+0x384>
   162ec:	2d1f      	cmp	r5, #31
   162ee:	dc25      	bgt.n	1633c <__aeabi_dmul+0x4b0>
   162f0:	4b30      	ldr	r3, [pc, #192]	; (163b4 <__aeabi_dmul+0x528>)
   162f2:	1c32      	adds	r2, r6, #0
   162f4:	469c      	mov	ip, r3
   162f6:	4467      	add	r7, ip
   162f8:	40be      	lsls	r6, r7
   162fa:	465b      	mov	r3, fp
   162fc:	40bb      	lsls	r3, r7
   162fe:	1c37      	adds	r7, r6, #0
   16300:	40ea      	lsrs	r2, r5
   16302:	1e7e      	subs	r6, r7, #1
   16304:	41b7      	sbcs	r7, r6
   16306:	4313      	orrs	r3, r2
   16308:	433b      	orrs	r3, r7
   1630a:	1c1e      	adds	r6, r3, #0
   1630c:	465b      	mov	r3, fp
   1630e:	40eb      	lsrs	r3, r5
   16310:	1c1d      	adds	r5, r3, #0
   16312:	0773      	lsls	r3, r6, #29
   16314:	d009      	beq.n	1632a <__aeabi_dmul+0x49e>
   16316:	230f      	movs	r3, #15
   16318:	4033      	ands	r3, r6
   1631a:	2b04      	cmp	r3, #4
   1631c:	d005      	beq.n	1632a <__aeabi_dmul+0x49e>
   1631e:	1d33      	adds	r3, r6, #4
   16320:	42b3      	cmp	r3, r6
   16322:	41b6      	sbcs	r6, r6
   16324:	4276      	negs	r6, r6
   16326:	19ad      	adds	r5, r5, r6
   16328:	1c1e      	adds	r6, r3, #0
   1632a:	022b      	lsls	r3, r5, #8
   1632c:	d520      	bpl.n	16370 <__aeabi_dmul+0x4e4>
   1632e:	2401      	movs	r4, #1
   16330:	9b02      	ldr	r3, [sp, #8]
   16332:	2500      	movs	r5, #0
   16334:	401c      	ands	r4, r3
   16336:	2600      	movs	r6, #0
   16338:	2301      	movs	r3, #1
   1633a:	e60b      	b.n	15f54 <__aeabi_dmul+0xc8>
   1633c:	465a      	mov	r2, fp
   1633e:	4b1e      	ldr	r3, [pc, #120]	; (163b8 <__aeabi_dmul+0x52c>)
   16340:	1bdb      	subs	r3, r3, r7
   16342:	40da      	lsrs	r2, r3
   16344:	1c13      	adds	r3, r2, #0
   16346:	2d20      	cmp	r5, #32
   16348:	d01c      	beq.n	16384 <__aeabi_dmul+0x4f8>
   1634a:	4a1c      	ldr	r2, [pc, #112]	; (163bc <__aeabi_dmul+0x530>)
   1634c:	4694      	mov	ip, r2
   1634e:	465a      	mov	r2, fp
   16350:	4467      	add	r7, ip
   16352:	40ba      	lsls	r2, r7
   16354:	1c17      	adds	r7, r2, #0
   16356:	433e      	orrs	r6, r7
   16358:	1e72      	subs	r2, r6, #1
   1635a:	4196      	sbcs	r6, r2
   1635c:	431e      	orrs	r6, r3
   1635e:	2307      	movs	r3, #7
   16360:	2500      	movs	r5, #0
   16362:	4033      	ands	r3, r6
   16364:	d007      	beq.n	16376 <__aeabi_dmul+0x4ea>
   16366:	230f      	movs	r3, #15
   16368:	2500      	movs	r5, #0
   1636a:	4033      	ands	r3, r6
   1636c:	2b04      	cmp	r3, #4
   1636e:	d1d6      	bne.n	1631e <__aeabi_dmul+0x492>
   16370:	076b      	lsls	r3, r5, #29
   16372:	026d      	lsls	r5, r5, #9
   16374:	0b2d      	lsrs	r5, r5, #12
   16376:	2401      	movs	r4, #1
   16378:	08f6      	lsrs	r6, r6, #3
   1637a:	431e      	orrs	r6, r3
   1637c:	9b02      	ldr	r3, [sp, #8]
   1637e:	401c      	ands	r4, r3
   16380:	2300      	movs	r3, #0
   16382:	e5e7      	b.n	15f54 <__aeabi_dmul+0xc8>
   16384:	2700      	movs	r7, #0
   16386:	e7e6      	b.n	16356 <__aeabi_dmul+0x4ca>
   16388:	2580      	movs	r5, #128	; 0x80
   1638a:	465b      	mov	r3, fp
   1638c:	2401      	movs	r4, #1
   1638e:	032d      	lsls	r5, r5, #12
   16390:	431d      	orrs	r5, r3
   16392:	9b01      	ldr	r3, [sp, #4]
   16394:	032d      	lsls	r5, r5, #12
   16396:	4023      	ands	r3, r4
   16398:	1c1c      	adds	r4, r3, #0
   1639a:	0b2d      	lsrs	r5, r5, #12
   1639c:	4b03      	ldr	r3, [pc, #12]	; (163ac <__aeabi_dmul+0x520>)
   1639e:	e5d9      	b.n	15f54 <__aeabi_dmul+0xc8>
   163a0:	000003ff 	.word	0x000003ff
   163a4:	feffffff 	.word	0xfeffffff
   163a8:	000007fe 	.word	0x000007fe
   163ac:	000007ff 	.word	0x000007ff
   163b0:	fffffc02 	.word	0xfffffc02
   163b4:	0000041e 	.word	0x0000041e
   163b8:	fffffbe2 	.word	0xfffffbe2
   163bc:	0000043e 	.word	0x0000043e

000163c0 <__aeabi_ui2d>:
   163c0:	b510      	push	{r4, lr}
   163c2:	1e04      	subs	r4, r0, #0
   163c4:	d010      	beq.n	163e8 <__aeabi_ui2d+0x28>
   163c6:	f000 f911 	bl	165ec <__clzsi2>
   163ca:	4a14      	ldr	r2, [pc, #80]	; (1641c <__aeabi_ui2d+0x5c>)
   163cc:	1a12      	subs	r2, r2, r0
   163ce:	280a      	cmp	r0, #10
   163d0:	dc1a      	bgt.n	16408 <__aeabi_ui2d+0x48>
   163d2:	230b      	movs	r3, #11
   163d4:	1c21      	adds	r1, r4, #0
   163d6:	1a1b      	subs	r3, r3, r0
   163d8:	40d9      	lsrs	r1, r3
   163da:	3015      	adds	r0, #21
   163dc:	030b      	lsls	r3, r1, #12
   163de:	0552      	lsls	r2, r2, #21
   163e0:	4084      	lsls	r4, r0
   163e2:	0b1b      	lsrs	r3, r3, #12
   163e4:	0d52      	lsrs	r2, r2, #21
   163e6:	e001      	b.n	163ec <__aeabi_ui2d+0x2c>
   163e8:	2200      	movs	r2, #0
   163ea:	2300      	movs	r3, #0
   163ec:	2100      	movs	r1, #0
   163ee:	031b      	lsls	r3, r3, #12
   163f0:	1c20      	adds	r0, r4, #0
   163f2:	0b1c      	lsrs	r4, r3, #12
   163f4:	0d0b      	lsrs	r3, r1, #20
   163f6:	051b      	lsls	r3, r3, #20
   163f8:	4323      	orrs	r3, r4
   163fa:	4c09      	ldr	r4, [pc, #36]	; (16420 <__aeabi_ui2d+0x60>)
   163fc:	0512      	lsls	r2, r2, #20
   163fe:	4023      	ands	r3, r4
   16400:	4313      	orrs	r3, r2
   16402:	005b      	lsls	r3, r3, #1
   16404:	0859      	lsrs	r1, r3, #1
   16406:	bd10      	pop	{r4, pc}
   16408:	1c03      	adds	r3, r0, #0
   1640a:	3b0b      	subs	r3, #11
   1640c:	409c      	lsls	r4, r3
   1640e:	0552      	lsls	r2, r2, #21
   16410:	0323      	lsls	r3, r4, #12
   16412:	0b1b      	lsrs	r3, r3, #12
   16414:	0d52      	lsrs	r2, r2, #21
   16416:	2400      	movs	r4, #0
   16418:	e7e8      	b.n	163ec <__aeabi_ui2d+0x2c>
   1641a:	46c0      	nop			; (mov r8, r8)
   1641c:	0000041e 	.word	0x0000041e
   16420:	800fffff 	.word	0x800fffff

00016424 <__aeabi_f2d>:
   16424:	0042      	lsls	r2, r0, #1
   16426:	0e12      	lsrs	r2, r2, #24
   16428:	1c51      	adds	r1, r2, #1
   1642a:	b538      	push	{r3, r4, r5, lr}
   1642c:	b2c9      	uxtb	r1, r1
   1642e:	0243      	lsls	r3, r0, #9
   16430:	0a5d      	lsrs	r5, r3, #9
   16432:	0fc4      	lsrs	r4, r0, #31
   16434:	2901      	cmp	r1, #1
   16436:	dd15      	ble.n	16464 <__aeabi_f2d+0x40>
   16438:	21e0      	movs	r1, #224	; 0xe0
   1643a:	0089      	lsls	r1, r1, #2
   1643c:	468c      	mov	ip, r1
   1643e:	076d      	lsls	r5, r5, #29
   16440:	0b1b      	lsrs	r3, r3, #12
   16442:	4462      	add	r2, ip
   16444:	2100      	movs	r1, #0
   16446:	1c28      	adds	r0, r5, #0
   16448:	0d0d      	lsrs	r5, r1, #20
   1644a:	052d      	lsls	r5, r5, #20
   1644c:	432b      	orrs	r3, r5
   1644e:	4d1c      	ldr	r5, [pc, #112]	; (164c0 <__aeabi_f2d+0x9c>)
   16450:	0552      	lsls	r2, r2, #21
   16452:	402b      	ands	r3, r5
   16454:	0852      	lsrs	r2, r2, #1
   16456:	4313      	orrs	r3, r2
   16458:	005b      	lsls	r3, r3, #1
   1645a:	07e4      	lsls	r4, r4, #31
   1645c:	085b      	lsrs	r3, r3, #1
   1645e:	4323      	orrs	r3, r4
   16460:	1c19      	adds	r1, r3, #0
   16462:	bd38      	pop	{r3, r4, r5, pc}
   16464:	2a00      	cmp	r2, #0
   16466:	d115      	bne.n	16494 <__aeabi_f2d+0x70>
   16468:	2d00      	cmp	r5, #0
   1646a:	d01f      	beq.n	164ac <__aeabi_f2d+0x88>
   1646c:	1c28      	adds	r0, r5, #0
   1646e:	f000 f8bd 	bl	165ec <__clzsi2>
   16472:	280a      	cmp	r0, #10
   16474:	dc1d      	bgt.n	164b2 <__aeabi_f2d+0x8e>
   16476:	230b      	movs	r3, #11
   16478:	1c2a      	adds	r2, r5, #0
   1647a:	1a1b      	subs	r3, r3, r0
   1647c:	40da      	lsrs	r2, r3
   1647e:	1c13      	adds	r3, r2, #0
   16480:	1c02      	adds	r2, r0, #0
   16482:	3215      	adds	r2, #21
   16484:	4095      	lsls	r5, r2
   16486:	4a0f      	ldr	r2, [pc, #60]	; (164c4 <__aeabi_f2d+0xa0>)
   16488:	031b      	lsls	r3, r3, #12
   1648a:	1a12      	subs	r2, r2, r0
   1648c:	0552      	lsls	r2, r2, #21
   1648e:	0b1b      	lsrs	r3, r3, #12
   16490:	0d52      	lsrs	r2, r2, #21
   16492:	e7d7      	b.n	16444 <__aeabi_f2d+0x20>
   16494:	2d00      	cmp	r5, #0
   16496:	d006      	beq.n	164a6 <__aeabi_f2d+0x82>
   16498:	2280      	movs	r2, #128	; 0x80
   1649a:	0b1b      	lsrs	r3, r3, #12
   1649c:	0312      	lsls	r2, r2, #12
   1649e:	4313      	orrs	r3, r2
   164a0:	076d      	lsls	r5, r5, #29
   164a2:	4a09      	ldr	r2, [pc, #36]	; (164c8 <__aeabi_f2d+0xa4>)
   164a4:	e7ce      	b.n	16444 <__aeabi_f2d+0x20>
   164a6:	4a08      	ldr	r2, [pc, #32]	; (164c8 <__aeabi_f2d+0xa4>)
   164a8:	2300      	movs	r3, #0
   164aa:	e7cb      	b.n	16444 <__aeabi_f2d+0x20>
   164ac:	2200      	movs	r2, #0
   164ae:	2300      	movs	r3, #0
   164b0:	e7c8      	b.n	16444 <__aeabi_f2d+0x20>
   164b2:	1c03      	adds	r3, r0, #0
   164b4:	3b0b      	subs	r3, #11
   164b6:	409d      	lsls	r5, r3
   164b8:	1c2b      	adds	r3, r5, #0
   164ba:	2500      	movs	r5, #0
   164bc:	e7e3      	b.n	16486 <__aeabi_f2d+0x62>
   164be:	46c0      	nop			; (mov r8, r8)
   164c0:	800fffff 	.word	0x800fffff
   164c4:	00000389 	.word	0x00000389
   164c8:	000007ff 	.word	0x000007ff

000164cc <__aeabi_d2f>:
   164cc:	b570      	push	{r4, r5, r6, lr}
   164ce:	030b      	lsls	r3, r1, #12
   164d0:	004d      	lsls	r5, r1, #1
   164d2:	0f44      	lsrs	r4, r0, #29
   164d4:	0d6d      	lsrs	r5, r5, #21
   164d6:	0a5b      	lsrs	r3, r3, #9
   164d8:	4323      	orrs	r3, r4
   164da:	1c6c      	adds	r4, r5, #1
   164dc:	0564      	lsls	r4, r4, #21
   164de:	0fc9      	lsrs	r1, r1, #31
   164e0:	00c2      	lsls	r2, r0, #3
   164e2:	0d64      	lsrs	r4, r4, #21
   164e4:	2c01      	cmp	r4, #1
   164e6:	dd2a      	ble.n	1653e <__aeabi_d2f+0x72>
   164e8:	4c3b      	ldr	r4, [pc, #236]	; (165d8 <__aeabi_d2f+0x10c>)
   164ea:	192c      	adds	r4, r5, r4
   164ec:	2cfe      	cmp	r4, #254	; 0xfe
   164ee:	dc1a      	bgt.n	16526 <__aeabi_d2f+0x5a>
   164f0:	2c00      	cmp	r4, #0
   164f2:	dd35      	ble.n	16560 <__aeabi_d2f+0x94>
   164f4:	0180      	lsls	r0, r0, #6
   164f6:	1e45      	subs	r5, r0, #1
   164f8:	41a8      	sbcs	r0, r5
   164fa:	00db      	lsls	r3, r3, #3
   164fc:	4303      	orrs	r3, r0
   164fe:	0f52      	lsrs	r2, r2, #29
   16500:	4313      	orrs	r3, r2
   16502:	075a      	lsls	r2, r3, #29
   16504:	d004      	beq.n	16510 <__aeabi_d2f+0x44>
   16506:	220f      	movs	r2, #15
   16508:	401a      	ands	r2, r3
   1650a:	2a04      	cmp	r2, #4
   1650c:	d000      	beq.n	16510 <__aeabi_d2f+0x44>
   1650e:	3304      	adds	r3, #4
   16510:	2280      	movs	r2, #128	; 0x80
   16512:	04d2      	lsls	r2, r2, #19
   16514:	401a      	ands	r2, r3
   16516:	d027      	beq.n	16568 <__aeabi_d2f+0x9c>
   16518:	3401      	adds	r4, #1
   1651a:	2cff      	cmp	r4, #255	; 0xff
   1651c:	d003      	beq.n	16526 <__aeabi_d2f+0x5a>
   1651e:	019b      	lsls	r3, r3, #6
   16520:	0a5b      	lsrs	r3, r3, #9
   16522:	b2e4      	uxtb	r4, r4
   16524:	e001      	b.n	1652a <__aeabi_d2f+0x5e>
   16526:	24ff      	movs	r4, #255	; 0xff
   16528:	2300      	movs	r3, #0
   1652a:	025b      	lsls	r3, r3, #9
   1652c:	05e4      	lsls	r4, r4, #23
   1652e:	0a5b      	lsrs	r3, r3, #9
   16530:	4323      	orrs	r3, r4
   16532:	005b      	lsls	r3, r3, #1
   16534:	07c9      	lsls	r1, r1, #31
   16536:	085b      	lsrs	r3, r3, #1
   16538:	430b      	orrs	r3, r1
   1653a:	1c18      	adds	r0, r3, #0
   1653c:	bd70      	pop	{r4, r5, r6, pc}
   1653e:	2d00      	cmp	r5, #0
   16540:	d106      	bne.n	16550 <__aeabi_d2f+0x84>
   16542:	4313      	orrs	r3, r2
   16544:	d10e      	bne.n	16564 <__aeabi_d2f+0x98>
   16546:	2400      	movs	r4, #0
   16548:	025b      	lsls	r3, r3, #9
   1654a:	0a5b      	lsrs	r3, r3, #9
   1654c:	b2e4      	uxtb	r4, r4
   1654e:	e7ec      	b.n	1652a <__aeabi_d2f+0x5e>
   16550:	431a      	orrs	r2, r3
   16552:	d0e8      	beq.n	16526 <__aeabi_d2f+0x5a>
   16554:	2080      	movs	r0, #128	; 0x80
   16556:	00db      	lsls	r3, r3, #3
   16558:	0480      	lsls	r0, r0, #18
   1655a:	4303      	orrs	r3, r0
   1655c:	24ff      	movs	r4, #255	; 0xff
   1655e:	e7d0      	b.n	16502 <__aeabi_d2f+0x36>
   16560:	3417      	adds	r4, #23
   16562:	da0c      	bge.n	1657e <__aeabi_d2f+0xb2>
   16564:	2305      	movs	r3, #5
   16566:	2400      	movs	r4, #0
   16568:	08db      	lsrs	r3, r3, #3
   1656a:	2cff      	cmp	r4, #255	; 0xff
   1656c:	d1ec      	bne.n	16548 <__aeabi_d2f+0x7c>
   1656e:	2b00      	cmp	r3, #0
   16570:	d02d      	beq.n	165ce <__aeabi_d2f+0x102>
   16572:	2280      	movs	r2, #128	; 0x80
   16574:	03d2      	lsls	r2, r2, #15
   16576:	4313      	orrs	r3, r2
   16578:	025b      	lsls	r3, r3, #9
   1657a:	0a5b      	lsrs	r3, r3, #9
   1657c:	e7d5      	b.n	1652a <__aeabi_d2f+0x5e>
   1657e:	2480      	movs	r4, #128	; 0x80
   16580:	4816      	ldr	r0, [pc, #88]	; (165dc <__aeabi_d2f+0x110>)
   16582:	0424      	lsls	r4, r4, #16
   16584:	4323      	orrs	r3, r4
   16586:	1b40      	subs	r0, r0, r5
   16588:	281f      	cmp	r0, #31
   1658a:	dc0d      	bgt.n	165a8 <__aeabi_d2f+0xdc>
   1658c:	4c14      	ldr	r4, [pc, #80]	; (165e0 <__aeabi_d2f+0x114>)
   1658e:	46a4      	mov	ip, r4
   16590:	4465      	add	r5, ip
   16592:	40ab      	lsls	r3, r5
   16594:	1c1c      	adds	r4, r3, #0
   16596:	1c13      	adds	r3, r2, #0
   16598:	40ab      	lsls	r3, r5
   1659a:	1e5d      	subs	r5, r3, #1
   1659c:	41ab      	sbcs	r3, r5
   1659e:	40c2      	lsrs	r2, r0
   165a0:	4323      	orrs	r3, r4
   165a2:	4313      	orrs	r3, r2
   165a4:	2400      	movs	r4, #0
   165a6:	e7ac      	b.n	16502 <__aeabi_d2f+0x36>
   165a8:	1c1e      	adds	r6, r3, #0
   165aa:	4c0e      	ldr	r4, [pc, #56]	; (165e4 <__aeabi_d2f+0x118>)
   165ac:	1b64      	subs	r4, r4, r5
   165ae:	40e6      	lsrs	r6, r4
   165b0:	1c34      	adds	r4, r6, #0
   165b2:	2820      	cmp	r0, #32
   165b4:	d00d      	beq.n	165d2 <__aeabi_d2f+0x106>
   165b6:	480c      	ldr	r0, [pc, #48]	; (165e8 <__aeabi_d2f+0x11c>)
   165b8:	4684      	mov	ip, r0
   165ba:	4465      	add	r5, ip
   165bc:	40ab      	lsls	r3, r5
   165be:	1c1d      	adds	r5, r3, #0
   165c0:	432a      	orrs	r2, r5
   165c2:	1e53      	subs	r3, r2, #1
   165c4:	419a      	sbcs	r2, r3
   165c6:	1c13      	adds	r3, r2, #0
   165c8:	4323      	orrs	r3, r4
   165ca:	2400      	movs	r4, #0
   165cc:	e799      	b.n	16502 <__aeabi_d2f+0x36>
   165ce:	2300      	movs	r3, #0
   165d0:	e7ab      	b.n	1652a <__aeabi_d2f+0x5e>
   165d2:	2500      	movs	r5, #0
   165d4:	e7f4      	b.n	165c0 <__aeabi_d2f+0xf4>
   165d6:	46c0      	nop			; (mov r8, r8)
   165d8:	fffffc80 	.word	0xfffffc80
   165dc:	0000039e 	.word	0x0000039e
   165e0:	fffffc82 	.word	0xfffffc82
   165e4:	0000037e 	.word	0x0000037e
   165e8:	fffffca2 	.word	0xfffffca2

000165ec <__clzsi2>:
   165ec:	211c      	movs	r1, #28
   165ee:	2301      	movs	r3, #1
   165f0:	041b      	lsls	r3, r3, #16
   165f2:	4298      	cmp	r0, r3
   165f4:	d301      	bcc.n	165fa <__clzsi2+0xe>
   165f6:	0c00      	lsrs	r0, r0, #16
   165f8:	3910      	subs	r1, #16
   165fa:	0a1b      	lsrs	r3, r3, #8
   165fc:	4298      	cmp	r0, r3
   165fe:	d301      	bcc.n	16604 <__clzsi2+0x18>
   16600:	0a00      	lsrs	r0, r0, #8
   16602:	3908      	subs	r1, #8
   16604:	091b      	lsrs	r3, r3, #4
   16606:	4298      	cmp	r0, r3
   16608:	d301      	bcc.n	1660e <__clzsi2+0x22>
   1660a:	0900      	lsrs	r0, r0, #4
   1660c:	3904      	subs	r1, #4
   1660e:	a202      	add	r2, pc, #8	; (adr r2, 16618 <__clzsi2+0x2c>)
   16610:	5c10      	ldrb	r0, [r2, r0]
   16612:	1840      	adds	r0, r0, r1
   16614:	4770      	bx	lr
   16616:	46c0      	nop			; (mov r8, r8)
   16618:	02020304 	.word	0x02020304
   1661c:	01010101 	.word	0x01010101
	...

00016628 <__assert_func>:
   16628:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   1662a:	1c06      	adds	r6, r0, #0
   1662c:	4809      	ldr	r0, [pc, #36]	; (16654 <__assert_func+0x2c>)
   1662e:	6800      	ldr	r0, [r0, #0]
   16630:	68c0      	ldr	r0, [r0, #12]
   16632:	2a00      	cmp	r2, #0
   16634:	d102      	bne.n	1663c <__assert_func+0x14>
   16636:	4d08      	ldr	r5, [pc, #32]	; (16658 <__assert_func+0x30>)
   16638:	1c2c      	adds	r4, r5, #0
   1663a:	e001      	b.n	16640 <__assert_func+0x18>
   1663c:	1c14      	adds	r4, r2, #0
   1663e:	4d07      	ldr	r5, [pc, #28]	; (1665c <__assert_func+0x34>)
   16640:	1c1a      	adds	r2, r3, #0
   16642:	9100      	str	r1, [sp, #0]
   16644:	1c33      	adds	r3, r6, #0
   16646:	4906      	ldr	r1, [pc, #24]	; (16660 <__assert_func+0x38>)
   16648:	9501      	str	r5, [sp, #4]
   1664a:	9402      	str	r4, [sp, #8]
   1664c:	f000 f810 	bl	16670 <fiprintf>
   16650:	f001 fa0a 	bl	17a68 <abort>
   16654:	200002f4 	.word	0x200002f4
   16658:	00021cc3 	.word	0x00021cc3
   1665c:	00021c88 	.word	0x00021c88
   16660:	00021c95 	.word	0x00021c95

00016664 <atoi>:
   16664:	b508      	push	{r3, lr}
   16666:	2100      	movs	r1, #0
   16668:	220a      	movs	r2, #10
   1666a:	f001 f915 	bl	17898 <strtol>
   1666e:	bd08      	pop	{r3, pc}

00016670 <fiprintf>:
   16670:	b40e      	push	{r1, r2, r3}
   16672:	b503      	push	{r0, r1, lr}
   16674:	1c01      	adds	r1, r0, #0
   16676:	ab03      	add	r3, sp, #12
   16678:	4804      	ldr	r0, [pc, #16]	; (1668c <fiprintf+0x1c>)
   1667a:	cb04      	ldmia	r3!, {r2}
   1667c:	6800      	ldr	r0, [r0, #0]
   1667e:	9301      	str	r3, [sp, #4]
   16680:	f000 f946 	bl	16910 <_vfiprintf_r>
   16684:	b002      	add	sp, #8
   16686:	bc08      	pop	{r3}
   16688:	b003      	add	sp, #12
   1668a:	4718      	bx	r3
   1668c:	200002f4 	.word	0x200002f4

00016690 <__libc_init_array>:
   16690:	4b0e      	ldr	r3, [pc, #56]	; (166cc <__libc_init_array+0x3c>)
   16692:	b570      	push	{r4, r5, r6, lr}
   16694:	2500      	movs	r5, #0
   16696:	1c1e      	adds	r6, r3, #0
   16698:	4c0d      	ldr	r4, [pc, #52]	; (166d0 <__libc_init_array+0x40>)
   1669a:	1ae4      	subs	r4, r4, r3
   1669c:	10a4      	asrs	r4, r4, #2
   1669e:	42a5      	cmp	r5, r4
   166a0:	d004      	beq.n	166ac <__libc_init_array+0x1c>
   166a2:	00ab      	lsls	r3, r5, #2
   166a4:	58f3      	ldr	r3, [r6, r3]
   166a6:	4798      	blx	r3
   166a8:	3501      	adds	r5, #1
   166aa:	e7f8      	b.n	1669e <__libc_init_array+0xe>
   166ac:	f00b fd0e 	bl	220cc <_init>
   166b0:	4b08      	ldr	r3, [pc, #32]	; (166d4 <__libc_init_array+0x44>)
   166b2:	2500      	movs	r5, #0
   166b4:	1c1e      	adds	r6, r3, #0
   166b6:	4c08      	ldr	r4, [pc, #32]	; (166d8 <__libc_init_array+0x48>)
   166b8:	1ae4      	subs	r4, r4, r3
   166ba:	10a4      	asrs	r4, r4, #2
   166bc:	42a5      	cmp	r5, r4
   166be:	d004      	beq.n	166ca <__libc_init_array+0x3a>
   166c0:	00ab      	lsls	r3, r5, #2
   166c2:	58f3      	ldr	r3, [r6, r3]
   166c4:	4798      	blx	r3
   166c6:	3501      	adds	r5, #1
   166c8:	e7f8      	b.n	166bc <__libc_init_array+0x2c>
   166ca:	bd70      	pop	{r4, r5, r6, pc}
   166cc:	000220d8 	.word	0x000220d8
   166d0:	000220d8 	.word	0x000220d8
   166d4:	000220d8 	.word	0x000220d8
   166d8:	000220dc 	.word	0x000220dc

000166dc <malloc>:
   166dc:	b508      	push	{r3, lr}
   166de:	4b03      	ldr	r3, [pc, #12]	; (166ec <malloc+0x10>)
   166e0:	1c01      	adds	r1, r0, #0
   166e2:	6818      	ldr	r0, [r3, #0]
   166e4:	f000 f894 	bl	16810 <_malloc_r>
   166e8:	bd08      	pop	{r3, pc}
   166ea:	46c0      	nop			; (mov r8, r8)
   166ec:	200002f4 	.word	0x200002f4

000166f0 <free>:
   166f0:	b508      	push	{r3, lr}
   166f2:	4b03      	ldr	r3, [pc, #12]	; (16700 <free+0x10>)
   166f4:	1c01      	adds	r1, r0, #0
   166f6:	6818      	ldr	r0, [r3, #0]
   166f8:	f000 f844 	bl	16784 <_free_r>
   166fc:	bd08      	pop	{r3, pc}
   166fe:	46c0      	nop			; (mov r8, r8)
   16700:	200002f4 	.word	0x200002f4

00016704 <memchr>:
   16704:	b2c9      	uxtb	r1, r1
   16706:	1882      	adds	r2, r0, r2
   16708:	4290      	cmp	r0, r2
   1670a:	d004      	beq.n	16716 <memchr+0x12>
   1670c:	7803      	ldrb	r3, [r0, #0]
   1670e:	428b      	cmp	r3, r1
   16710:	d002      	beq.n	16718 <memchr+0x14>
   16712:	3001      	adds	r0, #1
   16714:	e7f8      	b.n	16708 <memchr+0x4>
   16716:	2000      	movs	r0, #0
   16718:	4770      	bx	lr

0001671a <memcmp>:
   1671a:	b530      	push	{r4, r5, lr}
   1671c:	2400      	movs	r4, #0
   1671e:	4294      	cmp	r4, r2
   16720:	d008      	beq.n	16734 <memcmp+0x1a>
   16722:	5d03      	ldrb	r3, [r0, r4]
   16724:	1c65      	adds	r5, r4, #1
   16726:	5d0c      	ldrb	r4, [r1, r4]
   16728:	42a3      	cmp	r3, r4
   1672a:	d001      	beq.n	16730 <memcmp+0x16>
   1672c:	1b18      	subs	r0, r3, r4
   1672e:	e002      	b.n	16736 <memcmp+0x1c>
   16730:	1c2c      	adds	r4, r5, #0
   16732:	e7f4      	b.n	1671e <memcmp+0x4>
   16734:	2000      	movs	r0, #0
   16736:	bd30      	pop	{r4, r5, pc}

00016738 <memcpy>:
   16738:	2300      	movs	r3, #0
   1673a:	b510      	push	{r4, lr}
   1673c:	4293      	cmp	r3, r2
   1673e:	d003      	beq.n	16748 <memcpy+0x10>
   16740:	5ccc      	ldrb	r4, [r1, r3]
   16742:	54c4      	strb	r4, [r0, r3]
   16744:	3301      	adds	r3, #1
   16746:	e7f9      	b.n	1673c <memcpy+0x4>
   16748:	bd10      	pop	{r4, pc}

0001674a <memmove>:
   1674a:	b510      	push	{r4, lr}
   1674c:	4281      	cmp	r1, r0
   1674e:	d208      	bcs.n	16762 <memmove+0x18>
   16750:	188b      	adds	r3, r1, r2
   16752:	4298      	cmp	r0, r3
   16754:	d205      	bcs.n	16762 <memmove+0x18>
   16756:	1a9b      	subs	r3, r3, r2
   16758:	3a01      	subs	r2, #1
   1675a:	d309      	bcc.n	16770 <memmove+0x26>
   1675c:	5c99      	ldrb	r1, [r3, r2]
   1675e:	5481      	strb	r1, [r0, r2]
   16760:	e7fa      	b.n	16758 <memmove+0xe>
   16762:	2300      	movs	r3, #0
   16764:	4293      	cmp	r3, r2
   16766:	d003      	beq.n	16770 <memmove+0x26>
   16768:	5ccc      	ldrb	r4, [r1, r3]
   1676a:	54c4      	strb	r4, [r0, r3]
   1676c:	3301      	adds	r3, #1
   1676e:	e7f9      	b.n	16764 <memmove+0x1a>
   16770:	bd10      	pop	{r4, pc}

00016772 <memset>:
   16772:	1c03      	adds	r3, r0, #0
   16774:	1882      	adds	r2, r0, r2
   16776:	4293      	cmp	r3, r2
   16778:	d002      	beq.n	16780 <memset+0xe>
   1677a:	7019      	strb	r1, [r3, #0]
   1677c:	3301      	adds	r3, #1
   1677e:	e7fa      	b.n	16776 <memset+0x4>
   16780:	4770      	bx	lr
	...

00016784 <_free_r>:
   16784:	b530      	push	{r4, r5, lr}
   16786:	2900      	cmp	r1, #0
   16788:	d03e      	beq.n	16808 <_free_r+0x84>
   1678a:	3904      	subs	r1, #4
   1678c:	680b      	ldr	r3, [r1, #0]
   1678e:	2b00      	cmp	r3, #0
   16790:	da00      	bge.n	16794 <_free_r+0x10>
   16792:	18c9      	adds	r1, r1, r3
   16794:	4a1d      	ldr	r2, [pc, #116]	; (1680c <_free_r+0x88>)
   16796:	6813      	ldr	r3, [r2, #0]
   16798:	1c14      	adds	r4, r2, #0
   1679a:	2b00      	cmp	r3, #0
   1679c:	d102      	bne.n	167a4 <_free_r+0x20>
   1679e:	604b      	str	r3, [r1, #4]
   167a0:	6011      	str	r1, [r2, #0]
   167a2:	e031      	b.n	16808 <_free_r+0x84>
   167a4:	4299      	cmp	r1, r3
   167a6:	d20d      	bcs.n	167c4 <_free_r+0x40>
   167a8:	6808      	ldr	r0, [r1, #0]
   167aa:	180a      	adds	r2, r1, r0
   167ac:	429a      	cmp	r2, r3
   167ae:	d103      	bne.n	167b8 <_free_r+0x34>
   167b0:	6813      	ldr	r3, [r2, #0]
   167b2:	18c3      	adds	r3, r0, r3
   167b4:	600b      	str	r3, [r1, #0]
   167b6:	6853      	ldr	r3, [r2, #4]
   167b8:	604b      	str	r3, [r1, #4]
   167ba:	6021      	str	r1, [r4, #0]
   167bc:	e024      	b.n	16808 <_free_r+0x84>
   167be:	428a      	cmp	r2, r1
   167c0:	d803      	bhi.n	167ca <_free_r+0x46>
   167c2:	1c13      	adds	r3, r2, #0
   167c4:	685a      	ldr	r2, [r3, #4]
   167c6:	2a00      	cmp	r2, #0
   167c8:	d1f9      	bne.n	167be <_free_r+0x3a>
   167ca:	681d      	ldr	r5, [r3, #0]
   167cc:	195c      	adds	r4, r3, r5
   167ce:	428c      	cmp	r4, r1
   167d0:	d10b      	bne.n	167ea <_free_r+0x66>
   167d2:	6809      	ldr	r1, [r1, #0]
   167d4:	1869      	adds	r1, r5, r1
   167d6:	1858      	adds	r0, r3, r1
   167d8:	6019      	str	r1, [r3, #0]
   167da:	4290      	cmp	r0, r2
   167dc:	d114      	bne.n	16808 <_free_r+0x84>
   167de:	6810      	ldr	r0, [r2, #0]
   167e0:	6852      	ldr	r2, [r2, #4]
   167e2:	1809      	adds	r1, r1, r0
   167e4:	6019      	str	r1, [r3, #0]
   167e6:	605a      	str	r2, [r3, #4]
   167e8:	e00e      	b.n	16808 <_free_r+0x84>
   167ea:	428c      	cmp	r4, r1
   167ec:	d902      	bls.n	167f4 <_free_r+0x70>
   167ee:	230c      	movs	r3, #12
   167f0:	6003      	str	r3, [r0, #0]
   167f2:	e009      	b.n	16808 <_free_r+0x84>
   167f4:	6808      	ldr	r0, [r1, #0]
   167f6:	180c      	adds	r4, r1, r0
   167f8:	4294      	cmp	r4, r2
   167fa:	d103      	bne.n	16804 <_free_r+0x80>
   167fc:	6814      	ldr	r4, [r2, #0]
   167fe:	6852      	ldr	r2, [r2, #4]
   16800:	1900      	adds	r0, r0, r4
   16802:	6008      	str	r0, [r1, #0]
   16804:	604a      	str	r2, [r1, #4]
   16806:	6059      	str	r1, [r3, #4]
   16808:	bd30      	pop	{r4, r5, pc}
   1680a:	46c0      	nop			; (mov r8, r8)
   1680c:	200029c8 	.word	0x200029c8

00016810 <_malloc_r>:
   16810:	2303      	movs	r3, #3
   16812:	b570      	push	{r4, r5, r6, lr}
   16814:	1ccc      	adds	r4, r1, #3
   16816:	439c      	bics	r4, r3
   16818:	3408      	adds	r4, #8
   1681a:	1c05      	adds	r5, r0, #0
   1681c:	2c0c      	cmp	r4, #12
   1681e:	d201      	bcs.n	16824 <_malloc_r+0x14>
   16820:	240c      	movs	r4, #12
   16822:	e005      	b.n	16830 <_malloc_r+0x20>
   16824:	2c00      	cmp	r4, #0
   16826:	da03      	bge.n	16830 <_malloc_r+0x20>
   16828:	230c      	movs	r3, #12
   1682a:	2000      	movs	r0, #0
   1682c:	602b      	str	r3, [r5, #0]
   1682e:	e042      	b.n	168b6 <_malloc_r+0xa6>
   16830:	428c      	cmp	r4, r1
   16832:	d3f9      	bcc.n	16828 <_malloc_r+0x18>
   16834:	4a20      	ldr	r2, [pc, #128]	; (168b8 <_malloc_r+0xa8>)
   16836:	6813      	ldr	r3, [r2, #0]
   16838:	1c10      	adds	r0, r2, #0
   1683a:	1c19      	adds	r1, r3, #0
   1683c:	2900      	cmp	r1, #0
   1683e:	d013      	beq.n	16868 <_malloc_r+0x58>
   16840:	680a      	ldr	r2, [r1, #0]
   16842:	1b12      	subs	r2, r2, r4
   16844:	d40d      	bmi.n	16862 <_malloc_r+0x52>
   16846:	2a0b      	cmp	r2, #11
   16848:	d902      	bls.n	16850 <_malloc_r+0x40>
   1684a:	600a      	str	r2, [r1, #0]
   1684c:	188b      	adds	r3, r1, r2
   1684e:	e01f      	b.n	16890 <_malloc_r+0x80>
   16850:	428b      	cmp	r3, r1
   16852:	d102      	bne.n	1685a <_malloc_r+0x4a>
   16854:	685a      	ldr	r2, [r3, #4]
   16856:	6002      	str	r2, [r0, #0]
   16858:	e01b      	b.n	16892 <_malloc_r+0x82>
   1685a:	684a      	ldr	r2, [r1, #4]
   1685c:	605a      	str	r2, [r3, #4]
   1685e:	1c0b      	adds	r3, r1, #0
   16860:	e017      	b.n	16892 <_malloc_r+0x82>
   16862:	1c0b      	adds	r3, r1, #0
   16864:	6849      	ldr	r1, [r1, #4]
   16866:	e7e9      	b.n	1683c <_malloc_r+0x2c>
   16868:	4e14      	ldr	r6, [pc, #80]	; (168bc <_malloc_r+0xac>)
   1686a:	6833      	ldr	r3, [r6, #0]
   1686c:	2b00      	cmp	r3, #0
   1686e:	d103      	bne.n	16878 <_malloc_r+0x68>
   16870:	1c28      	adds	r0, r5, #0
   16872:	f000 fb7d 	bl	16f70 <_sbrk_r>
   16876:	6030      	str	r0, [r6, #0]
   16878:	1c28      	adds	r0, r5, #0
   1687a:	1c21      	adds	r1, r4, #0
   1687c:	f000 fb78 	bl	16f70 <_sbrk_r>
   16880:	1c03      	adds	r3, r0, #0
   16882:	1c42      	adds	r2, r0, #1
   16884:	d0d0      	beq.n	16828 <_malloc_r+0x18>
   16886:	2203      	movs	r2, #3
   16888:	1cc6      	adds	r6, r0, #3
   1688a:	4396      	bics	r6, r2
   1688c:	4286      	cmp	r6, r0
   1688e:	d10a      	bne.n	168a6 <_malloc_r+0x96>
   16890:	601c      	str	r4, [r3, #0]
   16892:	1c18      	adds	r0, r3, #0
   16894:	2107      	movs	r1, #7
   16896:	300b      	adds	r0, #11
   16898:	1d1a      	adds	r2, r3, #4
   1689a:	4388      	bics	r0, r1
   1689c:	1a82      	subs	r2, r0, r2
   1689e:	d00a      	beq.n	168b6 <_malloc_r+0xa6>
   168a0:	4251      	negs	r1, r2
   168a2:	5099      	str	r1, [r3, r2]
   168a4:	e007      	b.n	168b6 <_malloc_r+0xa6>
   168a6:	1a31      	subs	r1, r6, r0
   168a8:	1c28      	adds	r0, r5, #0
   168aa:	f000 fb61 	bl	16f70 <_sbrk_r>
   168ae:	1c43      	adds	r3, r0, #1
   168b0:	d0ba      	beq.n	16828 <_malloc_r+0x18>
   168b2:	1c33      	adds	r3, r6, #0
   168b4:	e7ec      	b.n	16890 <_malloc_r+0x80>
   168b6:	bd70      	pop	{r4, r5, r6, pc}
   168b8:	200029c8 	.word	0x200029c8
   168bc:	200029c4 	.word	0x200029c4

000168c0 <__sfputc_r>:
   168c0:	6893      	ldr	r3, [r2, #8]
   168c2:	b510      	push	{r4, lr}
   168c4:	3b01      	subs	r3, #1
   168c6:	6093      	str	r3, [r2, #8]
   168c8:	2b00      	cmp	r3, #0
   168ca:	da05      	bge.n	168d8 <__sfputc_r+0x18>
   168cc:	6994      	ldr	r4, [r2, #24]
   168ce:	42a3      	cmp	r3, r4
   168d0:	db08      	blt.n	168e4 <__sfputc_r+0x24>
   168d2:	b2cb      	uxtb	r3, r1
   168d4:	2b0a      	cmp	r3, #10
   168d6:	d005      	beq.n	168e4 <__sfputc_r+0x24>
   168d8:	6813      	ldr	r3, [r2, #0]
   168da:	1c58      	adds	r0, r3, #1
   168dc:	6010      	str	r0, [r2, #0]
   168de:	7019      	strb	r1, [r3, #0]
   168e0:	b2c8      	uxtb	r0, r1
   168e2:	e001      	b.n	168e8 <__sfputc_r+0x28>
   168e4:	f000 fff4 	bl	178d0 <__swbuf_r>
   168e8:	bd10      	pop	{r4, pc}

000168ea <__sfputs_r>:
   168ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   168ec:	1c06      	adds	r6, r0, #0
   168ee:	1c0f      	adds	r7, r1, #0
   168f0:	1c14      	adds	r4, r2, #0
   168f2:	18d5      	adds	r5, r2, r3
   168f4:	42ac      	cmp	r4, r5
   168f6:	d008      	beq.n	1690a <__sfputs_r+0x20>
   168f8:	7821      	ldrb	r1, [r4, #0]
   168fa:	1c30      	adds	r0, r6, #0
   168fc:	1c3a      	adds	r2, r7, #0
   168fe:	f7ff ffdf 	bl	168c0 <__sfputc_r>
   16902:	3401      	adds	r4, #1
   16904:	1c43      	adds	r3, r0, #1
   16906:	d1f5      	bne.n	168f4 <__sfputs_r+0xa>
   16908:	e000      	b.n	1690c <__sfputs_r+0x22>
   1690a:	2000      	movs	r0, #0
   1690c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00016910 <_vfiprintf_r>:
   16910:	b5f0      	push	{r4, r5, r6, r7, lr}
   16912:	b09f      	sub	sp, #124	; 0x7c
   16914:	1c06      	adds	r6, r0, #0
   16916:	1c0f      	adds	r7, r1, #0
   16918:	9202      	str	r2, [sp, #8]
   1691a:	9305      	str	r3, [sp, #20]
   1691c:	2800      	cmp	r0, #0
   1691e:	d004      	beq.n	1692a <_vfiprintf_r+0x1a>
   16920:	6983      	ldr	r3, [r0, #24]
   16922:	2b00      	cmp	r3, #0
   16924:	d101      	bne.n	1692a <_vfiprintf_r+0x1a>
   16926:	f001 f99d 	bl	17c64 <__sinit>
   1692a:	4b79      	ldr	r3, [pc, #484]	; (16b10 <_vfiprintf_r+0x200>)
   1692c:	429f      	cmp	r7, r3
   1692e:	d101      	bne.n	16934 <_vfiprintf_r+0x24>
   16930:	6877      	ldr	r7, [r6, #4]
   16932:	e008      	b.n	16946 <_vfiprintf_r+0x36>
   16934:	4b77      	ldr	r3, [pc, #476]	; (16b14 <_vfiprintf_r+0x204>)
   16936:	429f      	cmp	r7, r3
   16938:	d101      	bne.n	1693e <_vfiprintf_r+0x2e>
   1693a:	68b7      	ldr	r7, [r6, #8]
   1693c:	e003      	b.n	16946 <_vfiprintf_r+0x36>
   1693e:	4b76      	ldr	r3, [pc, #472]	; (16b18 <_vfiprintf_r+0x208>)
   16940:	429f      	cmp	r7, r3
   16942:	d100      	bne.n	16946 <_vfiprintf_r+0x36>
   16944:	68f7      	ldr	r7, [r6, #12]
   16946:	89bb      	ldrh	r3, [r7, #12]
   16948:	071b      	lsls	r3, r3, #28
   1694a:	d50a      	bpl.n	16962 <_vfiprintf_r+0x52>
   1694c:	693b      	ldr	r3, [r7, #16]
   1694e:	2b00      	cmp	r3, #0
   16950:	d007      	beq.n	16962 <_vfiprintf_r+0x52>
   16952:	2300      	movs	r3, #0
   16954:	ad06      	add	r5, sp, #24
   16956:	616b      	str	r3, [r5, #20]
   16958:	3320      	adds	r3, #32
   1695a:	766b      	strb	r3, [r5, #25]
   1695c:	3310      	adds	r3, #16
   1695e:	76ab      	strb	r3, [r5, #26]
   16960:	e03d      	b.n	169de <_vfiprintf_r+0xce>
   16962:	1c30      	adds	r0, r6, #0
   16964:	1c39      	adds	r1, r7, #0
   16966:	f001 f80b 	bl	17980 <__swsetup_r>
   1696a:	2800      	cmp	r0, #0
   1696c:	d0f1      	beq.n	16952 <_vfiprintf_r+0x42>
   1696e:	2001      	movs	r0, #1
   16970:	4240      	negs	r0, r0
   16972:	e0ca      	b.n	16b0a <_vfiprintf_r+0x1fa>
   16974:	9a05      	ldr	r2, [sp, #20]
   16976:	1d11      	adds	r1, r2, #4
   16978:	6812      	ldr	r2, [r2, #0]
   1697a:	9105      	str	r1, [sp, #20]
   1697c:	2a00      	cmp	r2, #0
   1697e:	db7e      	blt.n	16a7e <_vfiprintf_r+0x16e>
   16980:	9209      	str	r2, [sp, #36]	; 0x24
   16982:	3401      	adds	r4, #1
   16984:	7823      	ldrb	r3, [r4, #0]
   16986:	2b2e      	cmp	r3, #46	; 0x2e
   16988:	d100      	bne.n	1698c <_vfiprintf_r+0x7c>
   1698a:	e089      	b.n	16aa0 <_vfiprintf_r+0x190>
   1698c:	7821      	ldrb	r1, [r4, #0]
   1698e:	4863      	ldr	r0, [pc, #396]	; (16b1c <_vfiprintf_r+0x20c>)
   16990:	2203      	movs	r2, #3
   16992:	f7ff feb7 	bl	16704 <memchr>
   16996:	2800      	cmp	r0, #0
   16998:	d008      	beq.n	169ac <_vfiprintf_r+0x9c>
   1699a:	4b60      	ldr	r3, [pc, #384]	; (16b1c <_vfiprintf_r+0x20c>)
   1699c:	3401      	adds	r4, #1
   1699e:	1ac0      	subs	r0, r0, r3
   169a0:	2340      	movs	r3, #64	; 0x40
   169a2:	4083      	lsls	r3, r0
   169a4:	1c18      	adds	r0, r3, #0
   169a6:	682b      	ldr	r3, [r5, #0]
   169a8:	4318      	orrs	r0, r3
   169aa:	6028      	str	r0, [r5, #0]
   169ac:	7821      	ldrb	r1, [r4, #0]
   169ae:	1c63      	adds	r3, r4, #1
   169b0:	485b      	ldr	r0, [pc, #364]	; (16b20 <_vfiprintf_r+0x210>)
   169b2:	2206      	movs	r2, #6
   169b4:	9302      	str	r3, [sp, #8]
   169b6:	7629      	strb	r1, [r5, #24]
   169b8:	f7ff fea4 	bl	16704 <memchr>
   169bc:	2800      	cmp	r0, #0
   169be:	d100      	bne.n	169c2 <_vfiprintf_r+0xb2>
   169c0:	e091      	b.n	16ae6 <_vfiprintf_r+0x1d6>
   169c2:	4b58      	ldr	r3, [pc, #352]	; (16b24 <_vfiprintf_r+0x214>)
   169c4:	2b00      	cmp	r3, #0
   169c6:	d000      	beq.n	169ca <_vfiprintf_r+0xba>
   169c8:	e084      	b.n	16ad4 <_vfiprintf_r+0x1c4>
   169ca:	2207      	movs	r2, #7
   169cc:	9b05      	ldr	r3, [sp, #20]
   169ce:	3307      	adds	r3, #7
   169d0:	4393      	bics	r3, r2
   169d2:	3308      	adds	r3, #8
   169d4:	9305      	str	r3, [sp, #20]
   169d6:	696b      	ldr	r3, [r5, #20]
   169d8:	9a03      	ldr	r2, [sp, #12]
   169da:	189b      	adds	r3, r3, r2
   169dc:	616b      	str	r3, [r5, #20]
   169de:	9c02      	ldr	r4, [sp, #8]
   169e0:	7823      	ldrb	r3, [r4, #0]
   169e2:	2b00      	cmp	r3, #0
   169e4:	d104      	bne.n	169f0 <_vfiprintf_r+0xe0>
   169e6:	9b02      	ldr	r3, [sp, #8]
   169e8:	1ae3      	subs	r3, r4, r3
   169ea:	9304      	str	r3, [sp, #16]
   169ec:	d011      	beq.n	16a12 <_vfiprintf_r+0x102>
   169ee:	e003      	b.n	169f8 <_vfiprintf_r+0xe8>
   169f0:	2b25      	cmp	r3, #37	; 0x25
   169f2:	d0f8      	beq.n	169e6 <_vfiprintf_r+0xd6>
   169f4:	3401      	adds	r4, #1
   169f6:	e7f3      	b.n	169e0 <_vfiprintf_r+0xd0>
   169f8:	9b04      	ldr	r3, [sp, #16]
   169fa:	1c30      	adds	r0, r6, #0
   169fc:	1c39      	adds	r1, r7, #0
   169fe:	9a02      	ldr	r2, [sp, #8]
   16a00:	f7ff ff73 	bl	168ea <__sfputs_r>
   16a04:	1c43      	adds	r3, r0, #1
   16a06:	d07b      	beq.n	16b00 <_vfiprintf_r+0x1f0>
   16a08:	696a      	ldr	r2, [r5, #20]
   16a0a:	9b04      	ldr	r3, [sp, #16]
   16a0c:	4694      	mov	ip, r2
   16a0e:	4463      	add	r3, ip
   16a10:	616b      	str	r3, [r5, #20]
   16a12:	7823      	ldrb	r3, [r4, #0]
   16a14:	2b00      	cmp	r3, #0
   16a16:	d073      	beq.n	16b00 <_vfiprintf_r+0x1f0>
   16a18:	2201      	movs	r2, #1
   16a1a:	2300      	movs	r3, #0
   16a1c:	4252      	negs	r2, r2
   16a1e:	606a      	str	r2, [r5, #4]
   16a20:	a902      	add	r1, sp, #8
   16a22:	3254      	adds	r2, #84	; 0x54
   16a24:	1852      	adds	r2, r2, r1
   16a26:	3401      	adds	r4, #1
   16a28:	602b      	str	r3, [r5, #0]
   16a2a:	60eb      	str	r3, [r5, #12]
   16a2c:	60ab      	str	r3, [r5, #8]
   16a2e:	7013      	strb	r3, [r2, #0]
   16a30:	65ab      	str	r3, [r5, #88]	; 0x58
   16a32:	7821      	ldrb	r1, [r4, #0]
   16a34:	483c      	ldr	r0, [pc, #240]	; (16b28 <_vfiprintf_r+0x218>)
   16a36:	2205      	movs	r2, #5
   16a38:	f7ff fe64 	bl	16704 <memchr>
   16a3c:	2800      	cmp	r0, #0
   16a3e:	d009      	beq.n	16a54 <_vfiprintf_r+0x144>
   16a40:	4b39      	ldr	r3, [pc, #228]	; (16b28 <_vfiprintf_r+0x218>)
   16a42:	3401      	adds	r4, #1
   16a44:	1ac0      	subs	r0, r0, r3
   16a46:	2301      	movs	r3, #1
   16a48:	4083      	lsls	r3, r0
   16a4a:	1c18      	adds	r0, r3, #0
   16a4c:	682b      	ldr	r3, [r5, #0]
   16a4e:	4318      	orrs	r0, r3
   16a50:	6028      	str	r0, [r5, #0]
   16a52:	e7ee      	b.n	16a32 <_vfiprintf_r+0x122>
   16a54:	682b      	ldr	r3, [r5, #0]
   16a56:	06da      	lsls	r2, r3, #27
   16a58:	d504      	bpl.n	16a64 <_vfiprintf_r+0x154>
   16a5a:	2253      	movs	r2, #83	; 0x53
   16a5c:	2120      	movs	r1, #32
   16a5e:	a802      	add	r0, sp, #8
   16a60:	1812      	adds	r2, r2, r0
   16a62:	7011      	strb	r1, [r2, #0]
   16a64:	071a      	lsls	r2, r3, #28
   16a66:	d504      	bpl.n	16a72 <_vfiprintf_r+0x162>
   16a68:	2253      	movs	r2, #83	; 0x53
   16a6a:	212b      	movs	r1, #43	; 0x2b
   16a6c:	a802      	add	r0, sp, #8
   16a6e:	1812      	adds	r2, r2, r0
   16a70:	7011      	strb	r1, [r2, #0]
   16a72:	7822      	ldrb	r2, [r4, #0]
   16a74:	2a2a      	cmp	r2, #42	; 0x2a
   16a76:	d100      	bne.n	16a7a <_vfiprintf_r+0x16a>
   16a78:	e77c      	b.n	16974 <_vfiprintf_r+0x64>
   16a7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16a7c:	e005      	b.n	16a8a <_vfiprintf_r+0x17a>
   16a7e:	4252      	negs	r2, r2
   16a80:	60ea      	str	r2, [r5, #12]
   16a82:	2202      	movs	r2, #2
   16a84:	4313      	orrs	r3, r2
   16a86:	602b      	str	r3, [r5, #0]
   16a88:	e77b      	b.n	16982 <_vfiprintf_r+0x72>
   16a8a:	7822      	ldrb	r2, [r4, #0]
   16a8c:	3a30      	subs	r2, #48	; 0x30
   16a8e:	2a09      	cmp	r2, #9
   16a90:	d804      	bhi.n	16a9c <_vfiprintf_r+0x18c>
   16a92:	210a      	movs	r1, #10
   16a94:	434b      	muls	r3, r1
   16a96:	3401      	adds	r4, #1
   16a98:	189b      	adds	r3, r3, r2
   16a9a:	e7f6      	b.n	16a8a <_vfiprintf_r+0x17a>
   16a9c:	9309      	str	r3, [sp, #36]	; 0x24
   16a9e:	e771      	b.n	16984 <_vfiprintf_r+0x74>
   16aa0:	7863      	ldrb	r3, [r4, #1]
   16aa2:	2b2a      	cmp	r3, #42	; 0x2a
   16aa4:	d109      	bne.n	16aba <_vfiprintf_r+0x1aa>
   16aa6:	9b05      	ldr	r3, [sp, #20]
   16aa8:	3402      	adds	r4, #2
   16aaa:	1d1a      	adds	r2, r3, #4
   16aac:	681b      	ldr	r3, [r3, #0]
   16aae:	9205      	str	r2, [sp, #20]
   16ab0:	2b00      	cmp	r3, #0
   16ab2:	da0d      	bge.n	16ad0 <_vfiprintf_r+0x1c0>
   16ab4:	2301      	movs	r3, #1
   16ab6:	425b      	negs	r3, r3
   16ab8:	e00a      	b.n	16ad0 <_vfiprintf_r+0x1c0>
   16aba:	2300      	movs	r3, #0
   16abc:	3401      	adds	r4, #1
   16abe:	7822      	ldrb	r2, [r4, #0]
   16ac0:	3a30      	subs	r2, #48	; 0x30
   16ac2:	2a09      	cmp	r2, #9
   16ac4:	d804      	bhi.n	16ad0 <_vfiprintf_r+0x1c0>
   16ac6:	210a      	movs	r1, #10
   16ac8:	434b      	muls	r3, r1
   16aca:	3401      	adds	r4, #1
   16acc:	189b      	adds	r3, r3, r2
   16ace:	e7f6      	b.n	16abe <_vfiprintf_r+0x1ae>
   16ad0:	9307      	str	r3, [sp, #28]
   16ad2:	e75b      	b.n	1698c <_vfiprintf_r+0x7c>
   16ad4:	ab05      	add	r3, sp, #20
   16ad6:	9300      	str	r3, [sp, #0]
   16ad8:	1c30      	adds	r0, r6, #0
   16ada:	1c29      	adds	r1, r5, #0
   16adc:	1c3a      	adds	r2, r7, #0
   16ade:	4b13      	ldr	r3, [pc, #76]	; (16b2c <_vfiprintf_r+0x21c>)
   16ae0:	e000      	b.n	16ae4 <_vfiprintf_r+0x1d4>
   16ae2:	bf00      	nop
   16ae4:	e007      	b.n	16af6 <_vfiprintf_r+0x1e6>
   16ae6:	ab05      	add	r3, sp, #20
   16ae8:	9300      	str	r3, [sp, #0]
   16aea:	1c30      	adds	r0, r6, #0
   16aec:	1c29      	adds	r1, r5, #0
   16aee:	1c3a      	adds	r2, r7, #0
   16af0:	4b0e      	ldr	r3, [pc, #56]	; (16b2c <_vfiprintf_r+0x21c>)
   16af2:	f000 f88b 	bl	16c0c <_printf_i>
   16af6:	9003      	str	r0, [sp, #12]
   16af8:	9b03      	ldr	r3, [sp, #12]
   16afa:	3301      	adds	r3, #1
   16afc:	d000      	beq.n	16b00 <_vfiprintf_r+0x1f0>
   16afe:	e76a      	b.n	169d6 <_vfiprintf_r+0xc6>
   16b00:	89bb      	ldrh	r3, [r7, #12]
   16b02:	065b      	lsls	r3, r3, #25
   16b04:	d500      	bpl.n	16b08 <_vfiprintf_r+0x1f8>
   16b06:	e732      	b.n	1696e <_vfiprintf_r+0x5e>
   16b08:	980b      	ldr	r0, [sp, #44]	; 0x2c
   16b0a:	b01f      	add	sp, #124	; 0x7c
   16b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16b0e:	46c0      	nop			; (mov r8, r8)
   16b10:	0002206c 	.word	0x0002206c
   16b14:	0002208c 	.word	0x0002208c
   16b18:	000220ac 	.word	0x000220ac
   16b1c:	00021cd2 	.word	0x00021cd2
   16b20:	00021cd6 	.word	0x00021cd6
   16b24:	00000000 	.word	0x00000000
   16b28:	00021ccc 	.word	0x00021ccc
   16b2c:	000168eb 	.word	0x000168eb

00016b30 <_printf_common>:
   16b30:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16b32:	1c17      	adds	r7, r2, #0
   16b34:	9301      	str	r3, [sp, #4]
   16b36:	690a      	ldr	r2, [r1, #16]
   16b38:	688b      	ldr	r3, [r1, #8]
   16b3a:	9000      	str	r0, [sp, #0]
   16b3c:	1c0c      	adds	r4, r1, #0
   16b3e:	4293      	cmp	r3, r2
   16b40:	da00      	bge.n	16b44 <_printf_common+0x14>
   16b42:	1c13      	adds	r3, r2, #0
   16b44:	1c22      	adds	r2, r4, #0
   16b46:	603b      	str	r3, [r7, #0]
   16b48:	3243      	adds	r2, #67	; 0x43
   16b4a:	7812      	ldrb	r2, [r2, #0]
   16b4c:	2a00      	cmp	r2, #0
   16b4e:	d001      	beq.n	16b54 <_printf_common+0x24>
   16b50:	3301      	adds	r3, #1
   16b52:	603b      	str	r3, [r7, #0]
   16b54:	6823      	ldr	r3, [r4, #0]
   16b56:	069b      	lsls	r3, r3, #26
   16b58:	d502      	bpl.n	16b60 <_printf_common+0x30>
   16b5a:	683b      	ldr	r3, [r7, #0]
   16b5c:	3302      	adds	r3, #2
   16b5e:	603b      	str	r3, [r7, #0]
   16b60:	2506      	movs	r5, #6
   16b62:	6823      	ldr	r3, [r4, #0]
   16b64:	401d      	ands	r5, r3
   16b66:	d01e      	beq.n	16ba6 <_printf_common+0x76>
   16b68:	1c23      	adds	r3, r4, #0
   16b6a:	3343      	adds	r3, #67	; 0x43
   16b6c:	781b      	ldrb	r3, [r3, #0]
   16b6e:	1e5a      	subs	r2, r3, #1
   16b70:	4193      	sbcs	r3, r2
   16b72:	6822      	ldr	r2, [r4, #0]
   16b74:	0692      	lsls	r2, r2, #26
   16b76:	d51c      	bpl.n	16bb2 <_printf_common+0x82>
   16b78:	2030      	movs	r0, #48	; 0x30
   16b7a:	18e1      	adds	r1, r4, r3
   16b7c:	3140      	adds	r1, #64	; 0x40
   16b7e:	70c8      	strb	r0, [r1, #3]
   16b80:	1c21      	adds	r1, r4, #0
   16b82:	1c5a      	adds	r2, r3, #1
   16b84:	3145      	adds	r1, #69	; 0x45
   16b86:	7809      	ldrb	r1, [r1, #0]
   16b88:	18a2      	adds	r2, r4, r2
   16b8a:	3240      	adds	r2, #64	; 0x40
   16b8c:	3302      	adds	r3, #2
   16b8e:	70d1      	strb	r1, [r2, #3]
   16b90:	e00f      	b.n	16bb2 <_printf_common+0x82>
   16b92:	1c22      	adds	r2, r4, #0
   16b94:	2301      	movs	r3, #1
   16b96:	9800      	ldr	r0, [sp, #0]
   16b98:	9901      	ldr	r1, [sp, #4]
   16b9a:	3219      	adds	r2, #25
   16b9c:	9e08      	ldr	r6, [sp, #32]
   16b9e:	47b0      	blx	r6
   16ba0:	1c43      	adds	r3, r0, #1
   16ba2:	d00e      	beq.n	16bc2 <_printf_common+0x92>
   16ba4:	3501      	adds	r5, #1
   16ba6:	68e3      	ldr	r3, [r4, #12]
   16ba8:	683a      	ldr	r2, [r7, #0]
   16baa:	1a9b      	subs	r3, r3, r2
   16bac:	429d      	cmp	r5, r3
   16bae:	dbf0      	blt.n	16b92 <_printf_common+0x62>
   16bb0:	e7da      	b.n	16b68 <_printf_common+0x38>
   16bb2:	1c22      	adds	r2, r4, #0
   16bb4:	9800      	ldr	r0, [sp, #0]
   16bb6:	9901      	ldr	r1, [sp, #4]
   16bb8:	3243      	adds	r2, #67	; 0x43
   16bba:	9d08      	ldr	r5, [sp, #32]
   16bbc:	47a8      	blx	r5
   16bbe:	1c43      	adds	r3, r0, #1
   16bc0:	d102      	bne.n	16bc8 <_printf_common+0x98>
   16bc2:	2001      	movs	r0, #1
   16bc4:	4240      	negs	r0, r0
   16bc6:	e020      	b.n	16c0a <_printf_common+0xda>
   16bc8:	2306      	movs	r3, #6
   16bca:	6820      	ldr	r0, [r4, #0]
   16bcc:	68e1      	ldr	r1, [r4, #12]
   16bce:	683a      	ldr	r2, [r7, #0]
   16bd0:	4003      	ands	r3, r0
   16bd2:	2500      	movs	r5, #0
   16bd4:	2b04      	cmp	r3, #4
   16bd6:	d103      	bne.n	16be0 <_printf_common+0xb0>
   16bd8:	1a8d      	subs	r5, r1, r2
   16bda:	43eb      	mvns	r3, r5
   16bdc:	17db      	asrs	r3, r3, #31
   16bde:	401d      	ands	r5, r3
   16be0:	68a3      	ldr	r3, [r4, #8]
   16be2:	6922      	ldr	r2, [r4, #16]
   16be4:	4293      	cmp	r3, r2
   16be6:	dd01      	ble.n	16bec <_printf_common+0xbc>
   16be8:	1a9b      	subs	r3, r3, r2
   16bea:	18ed      	adds	r5, r5, r3
   16bec:	2700      	movs	r7, #0
   16bee:	42af      	cmp	r7, r5
   16bf0:	da0a      	bge.n	16c08 <_printf_common+0xd8>
   16bf2:	1c22      	adds	r2, r4, #0
   16bf4:	2301      	movs	r3, #1
   16bf6:	9800      	ldr	r0, [sp, #0]
   16bf8:	9901      	ldr	r1, [sp, #4]
   16bfa:	321a      	adds	r2, #26
   16bfc:	9e08      	ldr	r6, [sp, #32]
   16bfe:	47b0      	blx	r6
   16c00:	1c43      	adds	r3, r0, #1
   16c02:	d0de      	beq.n	16bc2 <_printf_common+0x92>
   16c04:	3701      	adds	r7, #1
   16c06:	e7f2      	b.n	16bee <_printf_common+0xbe>
   16c08:	2000      	movs	r0, #0
   16c0a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00016c0c <_printf_i>:
   16c0c:	b5f0      	push	{r4, r5, r6, r7, lr}
   16c0e:	b08b      	sub	sp, #44	; 0x2c
   16c10:	9206      	str	r2, [sp, #24]
   16c12:	1c0a      	adds	r2, r1, #0
   16c14:	3243      	adds	r2, #67	; 0x43
   16c16:	9307      	str	r3, [sp, #28]
   16c18:	9005      	str	r0, [sp, #20]
   16c1a:	9204      	str	r2, [sp, #16]
   16c1c:	7e0a      	ldrb	r2, [r1, #24]
   16c1e:	1c0c      	adds	r4, r1, #0
   16c20:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16c22:	2a6e      	cmp	r2, #110	; 0x6e
   16c24:	d100      	bne.n	16c28 <_printf_i+0x1c>
   16c26:	e0a8      	b.n	16d7a <_printf_i+0x16e>
   16c28:	d811      	bhi.n	16c4e <_printf_i+0x42>
   16c2a:	2a63      	cmp	r2, #99	; 0x63
   16c2c:	d022      	beq.n	16c74 <_printf_i+0x68>
   16c2e:	d809      	bhi.n	16c44 <_printf_i+0x38>
   16c30:	2a00      	cmp	r2, #0
   16c32:	d100      	bne.n	16c36 <_printf_i+0x2a>
   16c34:	e0b2      	b.n	16d9c <_printf_i+0x190>
   16c36:	2a58      	cmp	r2, #88	; 0x58
   16c38:	d000      	beq.n	16c3c <_printf_i+0x30>
   16c3a:	e0c2      	b.n	16dc2 <_printf_i+0x1b6>
   16c3c:	3145      	adds	r1, #69	; 0x45
   16c3e:	700a      	strb	r2, [r1, #0]
   16c40:	4a7c      	ldr	r2, [pc, #496]	; (16e34 <_printf_i+0x228>)
   16c42:	e04f      	b.n	16ce4 <_printf_i+0xd8>
   16c44:	2a64      	cmp	r2, #100	; 0x64
   16c46:	d01d      	beq.n	16c84 <_printf_i+0x78>
   16c48:	2a69      	cmp	r2, #105	; 0x69
   16c4a:	d01b      	beq.n	16c84 <_printf_i+0x78>
   16c4c:	e0b9      	b.n	16dc2 <_printf_i+0x1b6>
   16c4e:	2a73      	cmp	r2, #115	; 0x73
   16c50:	d100      	bne.n	16c54 <_printf_i+0x48>
   16c52:	e0a7      	b.n	16da4 <_printf_i+0x198>
   16c54:	d809      	bhi.n	16c6a <_printf_i+0x5e>
   16c56:	2a6f      	cmp	r2, #111	; 0x6f
   16c58:	d029      	beq.n	16cae <_printf_i+0xa2>
   16c5a:	2a70      	cmp	r2, #112	; 0x70
   16c5c:	d000      	beq.n	16c60 <_printf_i+0x54>
   16c5e:	e0b0      	b.n	16dc2 <_printf_i+0x1b6>
   16c60:	2220      	movs	r2, #32
   16c62:	6809      	ldr	r1, [r1, #0]
   16c64:	430a      	orrs	r2, r1
   16c66:	6022      	str	r2, [r4, #0]
   16c68:	e037      	b.n	16cda <_printf_i+0xce>
   16c6a:	2a75      	cmp	r2, #117	; 0x75
   16c6c:	d01f      	beq.n	16cae <_printf_i+0xa2>
   16c6e:	2a78      	cmp	r2, #120	; 0x78
   16c70:	d033      	beq.n	16cda <_printf_i+0xce>
   16c72:	e0a6      	b.n	16dc2 <_printf_i+0x1b6>
   16c74:	1c0e      	adds	r6, r1, #0
   16c76:	681a      	ldr	r2, [r3, #0]
   16c78:	3642      	adds	r6, #66	; 0x42
   16c7a:	1d11      	adds	r1, r2, #4
   16c7c:	6019      	str	r1, [r3, #0]
   16c7e:	6813      	ldr	r3, [r2, #0]
   16c80:	7033      	strb	r3, [r6, #0]
   16c82:	e0a1      	b.n	16dc8 <_printf_i+0x1bc>
   16c84:	6821      	ldr	r1, [r4, #0]
   16c86:	681a      	ldr	r2, [r3, #0]
   16c88:	0608      	lsls	r0, r1, #24
   16c8a:	d406      	bmi.n	16c9a <_printf_i+0x8e>
   16c8c:	0649      	lsls	r1, r1, #25
   16c8e:	d504      	bpl.n	16c9a <_printf_i+0x8e>
   16c90:	1d11      	adds	r1, r2, #4
   16c92:	6019      	str	r1, [r3, #0]
   16c94:	2300      	movs	r3, #0
   16c96:	5ed5      	ldrsh	r5, [r2, r3]
   16c98:	e002      	b.n	16ca0 <_printf_i+0x94>
   16c9a:	1d11      	adds	r1, r2, #4
   16c9c:	6019      	str	r1, [r3, #0]
   16c9e:	6815      	ldr	r5, [r2, #0]
   16ca0:	2d00      	cmp	r5, #0
   16ca2:	da3b      	bge.n	16d1c <_printf_i+0x110>
   16ca4:	232d      	movs	r3, #45	; 0x2d
   16ca6:	9a04      	ldr	r2, [sp, #16]
   16ca8:	426d      	negs	r5, r5
   16caa:	7013      	strb	r3, [r2, #0]
   16cac:	e036      	b.n	16d1c <_printf_i+0x110>
   16cae:	6821      	ldr	r1, [r4, #0]
   16cb0:	681a      	ldr	r2, [r3, #0]
   16cb2:	0608      	lsls	r0, r1, #24
   16cb4:	d406      	bmi.n	16cc4 <_printf_i+0xb8>
   16cb6:	0649      	lsls	r1, r1, #25
   16cb8:	d504      	bpl.n	16cc4 <_printf_i+0xb8>
   16cba:	6815      	ldr	r5, [r2, #0]
   16cbc:	1d11      	adds	r1, r2, #4
   16cbe:	6019      	str	r1, [r3, #0]
   16cc0:	b2ad      	uxth	r5, r5
   16cc2:	e002      	b.n	16cca <_printf_i+0xbe>
   16cc4:	1d11      	adds	r1, r2, #4
   16cc6:	6019      	str	r1, [r3, #0]
   16cc8:	6815      	ldr	r5, [r2, #0]
   16cca:	4b5a      	ldr	r3, [pc, #360]	; (16e34 <_printf_i+0x228>)
   16ccc:	7e22      	ldrb	r2, [r4, #24]
   16cce:	9303      	str	r3, [sp, #12]
   16cd0:	270a      	movs	r7, #10
   16cd2:	2a6f      	cmp	r2, #111	; 0x6f
   16cd4:	d11d      	bne.n	16d12 <_printf_i+0x106>
   16cd6:	2708      	movs	r7, #8
   16cd8:	e01b      	b.n	16d12 <_printf_i+0x106>
   16cda:	1c22      	adds	r2, r4, #0
   16cdc:	2178      	movs	r1, #120	; 0x78
   16cde:	3245      	adds	r2, #69	; 0x45
   16ce0:	7011      	strb	r1, [r2, #0]
   16ce2:	4a55      	ldr	r2, [pc, #340]	; (16e38 <_printf_i+0x22c>)
   16ce4:	6819      	ldr	r1, [r3, #0]
   16ce6:	9203      	str	r2, [sp, #12]
   16ce8:	1d08      	adds	r0, r1, #4
   16cea:	6822      	ldr	r2, [r4, #0]
   16cec:	6018      	str	r0, [r3, #0]
   16cee:	680d      	ldr	r5, [r1, #0]
   16cf0:	0610      	lsls	r0, r2, #24
   16cf2:	d402      	bmi.n	16cfa <_printf_i+0xee>
   16cf4:	0650      	lsls	r0, r2, #25
   16cf6:	d500      	bpl.n	16cfa <_printf_i+0xee>
   16cf8:	b2ad      	uxth	r5, r5
   16cfa:	07d3      	lsls	r3, r2, #31
   16cfc:	d502      	bpl.n	16d04 <_printf_i+0xf8>
   16cfe:	2320      	movs	r3, #32
   16d00:	431a      	orrs	r2, r3
   16d02:	6022      	str	r2, [r4, #0]
   16d04:	2710      	movs	r7, #16
   16d06:	2d00      	cmp	r5, #0
   16d08:	d103      	bne.n	16d12 <_printf_i+0x106>
   16d0a:	2320      	movs	r3, #32
   16d0c:	6822      	ldr	r2, [r4, #0]
   16d0e:	439a      	bics	r2, r3
   16d10:	6022      	str	r2, [r4, #0]
   16d12:	1c23      	adds	r3, r4, #0
   16d14:	2200      	movs	r2, #0
   16d16:	3343      	adds	r3, #67	; 0x43
   16d18:	701a      	strb	r2, [r3, #0]
   16d1a:	e002      	b.n	16d22 <_printf_i+0x116>
   16d1c:	270a      	movs	r7, #10
   16d1e:	4b45      	ldr	r3, [pc, #276]	; (16e34 <_printf_i+0x228>)
   16d20:	9303      	str	r3, [sp, #12]
   16d22:	6863      	ldr	r3, [r4, #4]
   16d24:	60a3      	str	r3, [r4, #8]
   16d26:	2b00      	cmp	r3, #0
   16d28:	db03      	blt.n	16d32 <_printf_i+0x126>
   16d2a:	2204      	movs	r2, #4
   16d2c:	6821      	ldr	r1, [r4, #0]
   16d2e:	4391      	bics	r1, r2
   16d30:	6021      	str	r1, [r4, #0]
   16d32:	2d00      	cmp	r5, #0
   16d34:	d102      	bne.n	16d3c <_printf_i+0x130>
   16d36:	9e04      	ldr	r6, [sp, #16]
   16d38:	2b00      	cmp	r3, #0
   16d3a:	d00e      	beq.n	16d5a <_printf_i+0x14e>
   16d3c:	9e04      	ldr	r6, [sp, #16]
   16d3e:	1c28      	adds	r0, r5, #0
   16d40:	1c39      	adds	r1, r7, #0
   16d42:	f7fe f931 	bl	14fa8 <__aeabi_uidivmod>
   16d46:	9b03      	ldr	r3, [sp, #12]
   16d48:	3e01      	subs	r6, #1
   16d4a:	5c5b      	ldrb	r3, [r3, r1]
   16d4c:	1c28      	adds	r0, r5, #0
   16d4e:	7033      	strb	r3, [r6, #0]
   16d50:	1c39      	adds	r1, r7, #0
   16d52:	f7fe f8a3 	bl	14e9c <__aeabi_uidiv>
   16d56:	1e05      	subs	r5, r0, #0
   16d58:	d1f1      	bne.n	16d3e <_printf_i+0x132>
   16d5a:	2f08      	cmp	r7, #8
   16d5c:	d109      	bne.n	16d72 <_printf_i+0x166>
   16d5e:	6823      	ldr	r3, [r4, #0]
   16d60:	07db      	lsls	r3, r3, #31
   16d62:	d506      	bpl.n	16d72 <_printf_i+0x166>
   16d64:	6863      	ldr	r3, [r4, #4]
   16d66:	6922      	ldr	r2, [r4, #16]
   16d68:	4293      	cmp	r3, r2
   16d6a:	dc02      	bgt.n	16d72 <_printf_i+0x166>
   16d6c:	2330      	movs	r3, #48	; 0x30
   16d6e:	3e01      	subs	r6, #1
   16d70:	7033      	strb	r3, [r6, #0]
   16d72:	9b04      	ldr	r3, [sp, #16]
   16d74:	1b9b      	subs	r3, r3, r6
   16d76:	6123      	str	r3, [r4, #16]
   16d78:	e02b      	b.n	16dd2 <_printf_i+0x1c6>
   16d7a:	6809      	ldr	r1, [r1, #0]
   16d7c:	681a      	ldr	r2, [r3, #0]
   16d7e:	0608      	lsls	r0, r1, #24
   16d80:	d407      	bmi.n	16d92 <_printf_i+0x186>
   16d82:	0649      	lsls	r1, r1, #25
   16d84:	d505      	bpl.n	16d92 <_printf_i+0x186>
   16d86:	1d11      	adds	r1, r2, #4
   16d88:	6019      	str	r1, [r3, #0]
   16d8a:	6813      	ldr	r3, [r2, #0]
   16d8c:	8aa2      	ldrh	r2, [r4, #20]
   16d8e:	801a      	strh	r2, [r3, #0]
   16d90:	e004      	b.n	16d9c <_printf_i+0x190>
   16d92:	1d11      	adds	r1, r2, #4
   16d94:	6019      	str	r1, [r3, #0]
   16d96:	6813      	ldr	r3, [r2, #0]
   16d98:	6962      	ldr	r2, [r4, #20]
   16d9a:	601a      	str	r2, [r3, #0]
   16d9c:	2300      	movs	r3, #0
   16d9e:	9e04      	ldr	r6, [sp, #16]
   16da0:	6123      	str	r3, [r4, #16]
   16da2:	e016      	b.n	16dd2 <_printf_i+0x1c6>
   16da4:	681a      	ldr	r2, [r3, #0]
   16da6:	1d11      	adds	r1, r2, #4
   16da8:	6019      	str	r1, [r3, #0]
   16daa:	6816      	ldr	r6, [r2, #0]
   16dac:	2100      	movs	r1, #0
   16dae:	1c30      	adds	r0, r6, #0
   16db0:	6862      	ldr	r2, [r4, #4]
   16db2:	f7ff fca7 	bl	16704 <memchr>
   16db6:	2800      	cmp	r0, #0
   16db8:	d001      	beq.n	16dbe <_printf_i+0x1b2>
   16dba:	1b80      	subs	r0, r0, r6
   16dbc:	6060      	str	r0, [r4, #4]
   16dbe:	6863      	ldr	r3, [r4, #4]
   16dc0:	e003      	b.n	16dca <_printf_i+0x1be>
   16dc2:	1c26      	adds	r6, r4, #0
   16dc4:	3642      	adds	r6, #66	; 0x42
   16dc6:	7032      	strb	r2, [r6, #0]
   16dc8:	2301      	movs	r3, #1
   16dca:	6123      	str	r3, [r4, #16]
   16dcc:	2300      	movs	r3, #0
   16dce:	9a04      	ldr	r2, [sp, #16]
   16dd0:	7013      	strb	r3, [r2, #0]
   16dd2:	9b07      	ldr	r3, [sp, #28]
   16dd4:	9805      	ldr	r0, [sp, #20]
   16dd6:	9300      	str	r3, [sp, #0]
   16dd8:	1c21      	adds	r1, r4, #0
   16dda:	9b06      	ldr	r3, [sp, #24]
   16ddc:	aa09      	add	r2, sp, #36	; 0x24
   16dde:	f7ff fea7 	bl	16b30 <_printf_common>
   16de2:	1c43      	adds	r3, r0, #1
   16de4:	d102      	bne.n	16dec <_printf_i+0x1e0>
   16de6:	2001      	movs	r0, #1
   16de8:	4240      	negs	r0, r0
   16dea:	e021      	b.n	16e30 <_printf_i+0x224>
   16dec:	6923      	ldr	r3, [r4, #16]
   16dee:	9805      	ldr	r0, [sp, #20]
   16df0:	9906      	ldr	r1, [sp, #24]
   16df2:	1c32      	adds	r2, r6, #0
   16df4:	9d07      	ldr	r5, [sp, #28]
   16df6:	47a8      	blx	r5
   16df8:	1c43      	adds	r3, r0, #1
   16dfa:	d0f4      	beq.n	16de6 <_printf_i+0x1da>
   16dfc:	6823      	ldr	r3, [r4, #0]
   16dfe:	079b      	lsls	r3, r3, #30
   16e00:	d405      	bmi.n	16e0e <_printf_i+0x202>
   16e02:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16e04:	68e0      	ldr	r0, [r4, #12]
   16e06:	4298      	cmp	r0, r3
   16e08:	da12      	bge.n	16e30 <_printf_i+0x224>
   16e0a:	1c18      	adds	r0, r3, #0
   16e0c:	e010      	b.n	16e30 <_printf_i+0x224>
   16e0e:	2500      	movs	r5, #0
   16e10:	68e3      	ldr	r3, [r4, #12]
   16e12:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16e14:	1a9b      	subs	r3, r3, r2
   16e16:	429d      	cmp	r5, r3
   16e18:	daf3      	bge.n	16e02 <_printf_i+0x1f6>
   16e1a:	1c22      	adds	r2, r4, #0
   16e1c:	2301      	movs	r3, #1
   16e1e:	9805      	ldr	r0, [sp, #20]
   16e20:	9906      	ldr	r1, [sp, #24]
   16e22:	3219      	adds	r2, #25
   16e24:	9e07      	ldr	r6, [sp, #28]
   16e26:	47b0      	blx	r6
   16e28:	1c43      	adds	r3, r0, #1
   16e2a:	d0dc      	beq.n	16de6 <_printf_i+0x1da>
   16e2c:	3501      	adds	r5, #1
   16e2e:	e7ef      	b.n	16e10 <_printf_i+0x204>
   16e30:	b00b      	add	sp, #44	; 0x2c
   16e32:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16e34:	00021cdd 	.word	0x00021cdd
   16e38:	00021cee 	.word	0x00021cee

00016e3c <iprintf>:
   16e3c:	b40f      	push	{r0, r1, r2, r3}
   16e3e:	4b0b      	ldr	r3, [pc, #44]	; (16e6c <iprintf+0x30>)
   16e40:	b513      	push	{r0, r1, r4, lr}
   16e42:	681c      	ldr	r4, [r3, #0]
   16e44:	2c00      	cmp	r4, #0
   16e46:	d005      	beq.n	16e54 <iprintf+0x18>
   16e48:	69a3      	ldr	r3, [r4, #24]
   16e4a:	2b00      	cmp	r3, #0
   16e4c:	d102      	bne.n	16e54 <iprintf+0x18>
   16e4e:	1c20      	adds	r0, r4, #0
   16e50:	f000 ff08 	bl	17c64 <__sinit>
   16e54:	ab05      	add	r3, sp, #20
   16e56:	1c20      	adds	r0, r4, #0
   16e58:	68a1      	ldr	r1, [r4, #8]
   16e5a:	9a04      	ldr	r2, [sp, #16]
   16e5c:	9301      	str	r3, [sp, #4]
   16e5e:	f7ff fd57 	bl	16910 <_vfiprintf_r>
   16e62:	bc16      	pop	{r1, r2, r4}
   16e64:	bc08      	pop	{r3}
   16e66:	b004      	add	sp, #16
   16e68:	4718      	bx	r3
   16e6a:	46c0      	nop			; (mov r8, r8)
   16e6c:	200002f4 	.word	0x200002f4

00016e70 <putchar>:
   16e70:	b538      	push	{r3, r4, r5, lr}
   16e72:	4b08      	ldr	r3, [pc, #32]	; (16e94 <putchar+0x24>)
   16e74:	1c05      	adds	r5, r0, #0
   16e76:	681c      	ldr	r4, [r3, #0]
   16e78:	2c00      	cmp	r4, #0
   16e7a:	d005      	beq.n	16e88 <putchar+0x18>
   16e7c:	69a3      	ldr	r3, [r4, #24]
   16e7e:	2b00      	cmp	r3, #0
   16e80:	d102      	bne.n	16e88 <putchar+0x18>
   16e82:	1c20      	adds	r0, r4, #0
   16e84:	f000 feee 	bl	17c64 <__sinit>
   16e88:	1c29      	adds	r1, r5, #0
   16e8a:	1c20      	adds	r0, r4, #0
   16e8c:	68a2      	ldr	r2, [r4, #8]
   16e8e:	f001 f94f 	bl	18130 <_putc_r>
   16e92:	bd38      	pop	{r3, r4, r5, pc}
   16e94:	200002f4 	.word	0x200002f4

00016e98 <_puts_r>:
   16e98:	b570      	push	{r4, r5, r6, lr}
   16e9a:	1c05      	adds	r5, r0, #0
   16e9c:	1c0e      	adds	r6, r1, #0
   16e9e:	2800      	cmp	r0, #0
   16ea0:	d004      	beq.n	16eac <_puts_r+0x14>
   16ea2:	6983      	ldr	r3, [r0, #24]
   16ea4:	2b00      	cmp	r3, #0
   16ea6:	d101      	bne.n	16eac <_puts_r+0x14>
   16ea8:	f000 fedc 	bl	17c64 <__sinit>
   16eac:	68ac      	ldr	r4, [r5, #8]
   16eae:	89a3      	ldrh	r3, [r4, #12]
   16eb0:	071b      	lsls	r3, r3, #28
   16eb2:	d502      	bpl.n	16eba <_puts_r+0x22>
   16eb4:	6923      	ldr	r3, [r4, #16]
   16eb6:	2b00      	cmp	r3, #0
   16eb8:	d119      	bne.n	16eee <_puts_r+0x56>
   16eba:	1c28      	adds	r0, r5, #0
   16ebc:	1c21      	adds	r1, r4, #0
   16ebe:	f000 fd5f 	bl	17980 <__swsetup_r>
   16ec2:	2800      	cmp	r0, #0
   16ec4:	d013      	beq.n	16eee <_puts_r+0x56>
   16ec6:	2001      	movs	r0, #1
   16ec8:	4240      	negs	r0, r0
   16eca:	e045      	b.n	16f58 <_puts_r+0xc0>
   16ecc:	7831      	ldrb	r1, [r6, #0]
   16ece:	2b00      	cmp	r3, #0
   16ed0:	da1b      	bge.n	16f0a <_puts_r+0x72>
   16ed2:	69a2      	ldr	r2, [r4, #24]
   16ed4:	4293      	cmp	r3, r2
   16ed6:	da11      	bge.n	16efc <_puts_r+0x64>
   16ed8:	1c22      	adds	r2, r4, #0
   16eda:	1c28      	adds	r0, r5, #0
   16edc:	f000 fcf8 	bl	178d0 <__swbuf_r>
   16ee0:	3001      	adds	r0, #1
   16ee2:	4242      	negs	r2, r0
   16ee4:	4142      	adcs	r2, r0
   16ee6:	b2d0      	uxtb	r0, r2
   16ee8:	2800      	cmp	r0, #0
   16eea:	d1ec      	bne.n	16ec6 <_puts_r+0x2e>
   16eec:	3601      	adds	r6, #1
   16eee:	68a3      	ldr	r3, [r4, #8]
   16ef0:	7832      	ldrb	r2, [r6, #0]
   16ef2:	3b01      	subs	r3, #1
   16ef4:	60a3      	str	r3, [r4, #8]
   16ef6:	2a00      	cmp	r2, #0
   16ef8:	d1e8      	bne.n	16ecc <_puts_r+0x34>
   16efa:	e00c      	b.n	16f16 <_puts_r+0x7e>
   16efc:	6823      	ldr	r3, [r4, #0]
   16efe:	7019      	strb	r1, [r3, #0]
   16f00:	6823      	ldr	r3, [r4, #0]
   16f02:	7819      	ldrb	r1, [r3, #0]
   16f04:	290a      	cmp	r1, #10
   16f06:	d103      	bne.n	16f10 <_puts_r+0x78>
   16f08:	e7e6      	b.n	16ed8 <_puts_r+0x40>
   16f0a:	6823      	ldr	r3, [r4, #0]
   16f0c:	7019      	strb	r1, [r3, #0]
   16f0e:	6823      	ldr	r3, [r4, #0]
   16f10:	3301      	adds	r3, #1
   16f12:	6023      	str	r3, [r4, #0]
   16f14:	e7ea      	b.n	16eec <_puts_r+0x54>
   16f16:	2b00      	cmp	r3, #0
   16f18:	da17      	bge.n	16f4a <_puts_r+0xb2>
   16f1a:	69a2      	ldr	r2, [r4, #24]
   16f1c:	4293      	cmp	r3, r2
   16f1e:	db08      	blt.n	16f32 <_puts_r+0x9a>
   16f20:	230a      	movs	r3, #10
   16f22:	6822      	ldr	r2, [r4, #0]
   16f24:	7013      	strb	r3, [r2, #0]
   16f26:	6823      	ldr	r3, [r4, #0]
   16f28:	7819      	ldrb	r1, [r3, #0]
   16f2a:	290a      	cmp	r1, #10
   16f2c:	d111      	bne.n	16f52 <_puts_r+0xba>
   16f2e:	1c28      	adds	r0, r5, #0
   16f30:	e001      	b.n	16f36 <_puts_r+0x9e>
   16f32:	1c28      	adds	r0, r5, #0
   16f34:	210a      	movs	r1, #10
   16f36:	1c22      	adds	r2, r4, #0
   16f38:	f000 fcca 	bl	178d0 <__swbuf_r>
   16f3c:	3001      	adds	r0, #1
   16f3e:	4242      	negs	r2, r0
   16f40:	4142      	adcs	r2, r0
   16f42:	b2d0      	uxtb	r0, r2
   16f44:	2800      	cmp	r0, #0
   16f46:	d006      	beq.n	16f56 <_puts_r+0xbe>
   16f48:	e7bd      	b.n	16ec6 <_puts_r+0x2e>
   16f4a:	230a      	movs	r3, #10
   16f4c:	6822      	ldr	r2, [r4, #0]
   16f4e:	7013      	strb	r3, [r2, #0]
   16f50:	6823      	ldr	r3, [r4, #0]
   16f52:	3301      	adds	r3, #1
   16f54:	6023      	str	r3, [r4, #0]
   16f56:	200a      	movs	r0, #10
   16f58:	bd70      	pop	{r4, r5, r6, pc}
	...

00016f5c <puts>:
   16f5c:	b508      	push	{r3, lr}
   16f5e:	4b03      	ldr	r3, [pc, #12]	; (16f6c <puts+0x10>)
   16f60:	1c01      	adds	r1, r0, #0
   16f62:	6818      	ldr	r0, [r3, #0]
   16f64:	f7ff ff98 	bl	16e98 <_puts_r>
   16f68:	bd08      	pop	{r3, pc}
   16f6a:	46c0      	nop			; (mov r8, r8)
   16f6c:	200002f4 	.word	0x200002f4

00016f70 <_sbrk_r>:
   16f70:	b538      	push	{r3, r4, r5, lr}
   16f72:	2300      	movs	r3, #0
   16f74:	4c06      	ldr	r4, [pc, #24]	; (16f90 <_sbrk_r+0x20>)
   16f76:	1c05      	adds	r5, r0, #0
   16f78:	1c08      	adds	r0, r1, #0
   16f7a:	6023      	str	r3, [r4, #0]
   16f7c:	f7fc fe00 	bl	13b80 <_sbrk>
   16f80:	1c43      	adds	r3, r0, #1
   16f82:	d103      	bne.n	16f8c <_sbrk_r+0x1c>
   16f84:	6823      	ldr	r3, [r4, #0]
   16f86:	2b00      	cmp	r3, #0
   16f88:	d000      	beq.n	16f8c <_sbrk_r+0x1c>
   16f8a:	602b      	str	r3, [r5, #0]
   16f8c:	bd38      	pop	{r3, r4, r5, pc}
   16f8e:	46c0      	nop			; (mov r8, r8)
   16f90:	20002cbc 	.word	0x20002cbc

00016f94 <setbuf>:
   16f94:	b508      	push	{r3, lr}
   16f96:	424a      	negs	r2, r1
   16f98:	414a      	adcs	r2, r1
   16f9a:	2380      	movs	r3, #128	; 0x80
   16f9c:	0052      	lsls	r2, r2, #1
   16f9e:	00db      	lsls	r3, r3, #3
   16fa0:	f000 f802 	bl	16fa8 <setvbuf>
   16fa4:	bd08      	pop	{r3, pc}
	...

00016fa8 <setvbuf>:
   16fa8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16faa:	1c1e      	adds	r6, r3, #0
   16fac:	4b3c      	ldr	r3, [pc, #240]	; (170a0 <setvbuf+0xf8>)
   16fae:	1c04      	adds	r4, r0, #0
   16fb0:	681d      	ldr	r5, [r3, #0]
   16fb2:	1c0f      	adds	r7, r1, #0
   16fb4:	9201      	str	r2, [sp, #4]
   16fb6:	2d00      	cmp	r5, #0
   16fb8:	d005      	beq.n	16fc6 <setvbuf+0x1e>
   16fba:	69ab      	ldr	r3, [r5, #24]
   16fbc:	2b00      	cmp	r3, #0
   16fbe:	d102      	bne.n	16fc6 <setvbuf+0x1e>
   16fc0:	1c28      	adds	r0, r5, #0
   16fc2:	f000 fe4f 	bl	17c64 <__sinit>
   16fc6:	4b37      	ldr	r3, [pc, #220]	; (170a4 <setvbuf+0xfc>)
   16fc8:	429c      	cmp	r4, r3
   16fca:	d101      	bne.n	16fd0 <setvbuf+0x28>
   16fcc:	686c      	ldr	r4, [r5, #4]
   16fce:	e008      	b.n	16fe2 <setvbuf+0x3a>
   16fd0:	4b35      	ldr	r3, [pc, #212]	; (170a8 <setvbuf+0x100>)
   16fd2:	429c      	cmp	r4, r3
   16fd4:	d101      	bne.n	16fda <setvbuf+0x32>
   16fd6:	68ac      	ldr	r4, [r5, #8]
   16fd8:	e003      	b.n	16fe2 <setvbuf+0x3a>
   16fda:	4b34      	ldr	r3, [pc, #208]	; (170ac <setvbuf+0x104>)
   16fdc:	429c      	cmp	r4, r3
   16fde:	d100      	bne.n	16fe2 <setvbuf+0x3a>
   16fe0:	68ec      	ldr	r4, [r5, #12]
   16fe2:	9b01      	ldr	r3, [sp, #4]
   16fe4:	2b02      	cmp	r3, #2
   16fe6:	d858      	bhi.n	1709a <setvbuf+0xf2>
   16fe8:	2e00      	cmp	r6, #0
   16fea:	db56      	blt.n	1709a <setvbuf+0xf2>
   16fec:	1c28      	adds	r0, r5, #0
   16fee:	1c21      	adds	r1, r4, #0
   16ff0:	f000 fdca 	bl	17b88 <_fflush_r>
   16ff4:	2300      	movs	r3, #0
   16ff6:	6063      	str	r3, [r4, #4]
   16ff8:	61a3      	str	r3, [r4, #24]
   16ffa:	89a3      	ldrh	r3, [r4, #12]
   16ffc:	061b      	lsls	r3, r3, #24
   16ffe:	d503      	bpl.n	17008 <setvbuf+0x60>
   17000:	1c28      	adds	r0, r5, #0
   17002:	6921      	ldr	r1, [r4, #16]
   17004:	f7ff fbbe 	bl	16784 <_free_r>
   17008:	2283      	movs	r2, #131	; 0x83
   1700a:	89a3      	ldrh	r3, [r4, #12]
   1700c:	4393      	bics	r3, r2
   1700e:	81a3      	strh	r3, [r4, #12]
   17010:	9b01      	ldr	r3, [sp, #4]
   17012:	2b02      	cmp	r3, #2
   17014:	d013      	beq.n	1703e <setvbuf+0x96>
   17016:	2f00      	cmp	r7, #0
   17018:	d125      	bne.n	17066 <setvbuf+0xbe>
   1701a:	2e00      	cmp	r6, #0
   1701c:	d101      	bne.n	17022 <setvbuf+0x7a>
   1701e:	2680      	movs	r6, #128	; 0x80
   17020:	00f6      	lsls	r6, r6, #3
   17022:	1c30      	adds	r0, r6, #0
   17024:	f7ff fb5a 	bl	166dc <malloc>
   17028:	1e07      	subs	r7, r0, #0
   1702a:	d118      	bne.n	1705e <setvbuf+0xb6>
   1702c:	2080      	movs	r0, #128	; 0x80
   1702e:	00c0      	lsls	r0, r0, #3
   17030:	f7ff fb54 	bl	166dc <malloc>
   17034:	1e07      	subs	r7, r0, #0
   17036:	d110      	bne.n	1705a <setvbuf+0xb2>
   17038:	2001      	movs	r0, #1
   1703a:	4240      	negs	r0, r0
   1703c:	e000      	b.n	17040 <setvbuf+0x98>
   1703e:	2000      	movs	r0, #0
   17040:	2202      	movs	r2, #2
   17042:	89a3      	ldrh	r3, [r4, #12]
   17044:	4313      	orrs	r3, r2
   17046:	81a3      	strh	r3, [r4, #12]
   17048:	2300      	movs	r3, #0
   1704a:	60a3      	str	r3, [r4, #8]
   1704c:	1c23      	adds	r3, r4, #0
   1704e:	3347      	adds	r3, #71	; 0x47
   17050:	6023      	str	r3, [r4, #0]
   17052:	6123      	str	r3, [r4, #16]
   17054:	2301      	movs	r3, #1
   17056:	6163      	str	r3, [r4, #20]
   17058:	e021      	b.n	1709e <setvbuf+0xf6>
   1705a:	2680      	movs	r6, #128	; 0x80
   1705c:	00f6      	lsls	r6, r6, #3
   1705e:	2280      	movs	r2, #128	; 0x80
   17060:	89a3      	ldrh	r3, [r4, #12]
   17062:	4313      	orrs	r3, r2
   17064:	81a3      	strh	r3, [r4, #12]
   17066:	9b01      	ldr	r3, [sp, #4]
   17068:	2b01      	cmp	r3, #1
   1706a:	d105      	bne.n	17078 <setvbuf+0xd0>
   1706c:	89a3      	ldrh	r3, [r4, #12]
   1706e:	9a01      	ldr	r2, [sp, #4]
   17070:	431a      	orrs	r2, r3
   17072:	4273      	negs	r3, r6
   17074:	81a2      	strh	r2, [r4, #12]
   17076:	61a3      	str	r3, [r4, #24]
   17078:	4b0d      	ldr	r3, [pc, #52]	; (170b0 <setvbuf+0x108>)
   1707a:	2000      	movs	r0, #0
   1707c:	62ab      	str	r3, [r5, #40]	; 0x28
   1707e:	89a2      	ldrh	r2, [r4, #12]
   17080:	6027      	str	r7, [r4, #0]
   17082:	6127      	str	r7, [r4, #16]
   17084:	6166      	str	r6, [r4, #20]
   17086:	0713      	lsls	r3, r2, #28
   17088:	d509      	bpl.n	1709e <setvbuf+0xf6>
   1708a:	2303      	movs	r3, #3
   1708c:	401a      	ands	r2, r3
   1708e:	4253      	negs	r3, r2
   17090:	4153      	adcs	r3, r2
   17092:	425b      	negs	r3, r3
   17094:	401e      	ands	r6, r3
   17096:	60a6      	str	r6, [r4, #8]
   17098:	e001      	b.n	1709e <setvbuf+0xf6>
   1709a:	2001      	movs	r0, #1
   1709c:	4240      	negs	r0, r0
   1709e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   170a0:	200002f4 	.word	0x200002f4
   170a4:	0002206c 	.word	0x0002206c
   170a8:	0002208c 	.word	0x0002208c
   170ac:	000220ac 	.word	0x000220ac
   170b0:	00017be1 	.word	0x00017be1

000170b4 <sniprintf>:
   170b4:	b40c      	push	{r2, r3}
   170b6:	b530      	push	{r4, r5, lr}
   170b8:	4b17      	ldr	r3, [pc, #92]	; (17118 <sniprintf+0x64>)
   170ba:	b09d      	sub	sp, #116	; 0x74
   170bc:	681d      	ldr	r5, [r3, #0]
   170be:	2900      	cmp	r1, #0
   170c0:	da04      	bge.n	170cc <sniprintf+0x18>
   170c2:	238b      	movs	r3, #139	; 0x8b
   170c4:	2001      	movs	r0, #1
   170c6:	602b      	str	r3, [r5, #0]
   170c8:	4240      	negs	r0, r0
   170ca:	e01f      	b.n	1710c <sniprintf+0x58>
   170cc:	2382      	movs	r3, #130	; 0x82
   170ce:	aa02      	add	r2, sp, #8
   170d0:	009b      	lsls	r3, r3, #2
   170d2:	8193      	strh	r3, [r2, #12]
   170d4:	2300      	movs	r3, #0
   170d6:	9002      	str	r0, [sp, #8]
   170d8:	6110      	str	r0, [r2, #16]
   170da:	4299      	cmp	r1, r3
   170dc:	d000      	beq.n	170e0 <sniprintf+0x2c>
   170de:	1e4b      	subs	r3, r1, #1
   170e0:	6093      	str	r3, [r2, #8]
   170e2:	6153      	str	r3, [r2, #20]
   170e4:	2301      	movs	r3, #1
   170e6:	425b      	negs	r3, r3
   170e8:	81d3      	strh	r3, [r2, #14]
   170ea:	1c0c      	adds	r4, r1, #0
   170ec:	ab21      	add	r3, sp, #132	; 0x84
   170ee:	1c11      	adds	r1, r2, #0
   170f0:	1c28      	adds	r0, r5, #0
   170f2:	9a20      	ldr	r2, [sp, #128]	; 0x80
   170f4:	9301      	str	r3, [sp, #4]
   170f6:	f000 ff25 	bl	17f44 <_svfiprintf_r>
   170fa:	1c43      	adds	r3, r0, #1
   170fc:	da01      	bge.n	17102 <sniprintf+0x4e>
   170fe:	238b      	movs	r3, #139	; 0x8b
   17100:	602b      	str	r3, [r5, #0]
   17102:	2c00      	cmp	r4, #0
   17104:	d002      	beq.n	1710c <sniprintf+0x58>
   17106:	2300      	movs	r3, #0
   17108:	9a02      	ldr	r2, [sp, #8]
   1710a:	7013      	strb	r3, [r2, #0]
   1710c:	b01d      	add	sp, #116	; 0x74
   1710e:	bc30      	pop	{r4, r5}
   17110:	bc08      	pop	{r3}
   17112:	b002      	add	sp, #8
   17114:	4718      	bx	r3
   17116:	46c0      	nop			; (mov r8, r8)
   17118:	200002f4 	.word	0x200002f4

0001711c <strcat>:
   1711c:	1c02      	adds	r2, r0, #0
   1711e:	b510      	push	{r4, lr}
   17120:	7813      	ldrb	r3, [r2, #0]
   17122:	2b00      	cmp	r3, #0
   17124:	d001      	beq.n	1712a <strcat+0xe>
   17126:	3201      	adds	r2, #1
   17128:	e7fa      	b.n	17120 <strcat+0x4>
   1712a:	5ccc      	ldrb	r4, [r1, r3]
   1712c:	54d4      	strb	r4, [r2, r3]
   1712e:	3301      	adds	r3, #1
   17130:	2c00      	cmp	r4, #0
   17132:	d1fa      	bne.n	1712a <strcat+0xe>
   17134:	bd10      	pop	{r4, pc}

00017136 <strcmp>:
   17136:	7802      	ldrb	r2, [r0, #0]
   17138:	780b      	ldrb	r3, [r1, #0]
   1713a:	2a00      	cmp	r2, #0
   1713c:	d003      	beq.n	17146 <strcmp+0x10>
   1713e:	3001      	adds	r0, #1
   17140:	3101      	adds	r1, #1
   17142:	429a      	cmp	r2, r3
   17144:	d0f7      	beq.n	17136 <strcmp>
   17146:	1ad0      	subs	r0, r2, r3
   17148:	4770      	bx	lr

0001714a <strcpy>:
   1714a:	1c03      	adds	r3, r0, #0
   1714c:	780a      	ldrb	r2, [r1, #0]
   1714e:	3101      	adds	r1, #1
   17150:	701a      	strb	r2, [r3, #0]
   17152:	3301      	adds	r3, #1
   17154:	2a00      	cmp	r2, #0
   17156:	d1f9      	bne.n	1714c <strcpy+0x2>
   17158:	4770      	bx	lr

0001715a <strlen>:
   1715a:	2300      	movs	r3, #0
   1715c:	5cc2      	ldrb	r2, [r0, r3]
   1715e:	3301      	adds	r3, #1
   17160:	2a00      	cmp	r2, #0
   17162:	d1fb      	bne.n	1715c <strlen+0x2>
   17164:	1e58      	subs	r0, r3, #1
   17166:	4770      	bx	lr

00017168 <strncmp>:
   17168:	2300      	movs	r3, #0
   1716a:	b530      	push	{r4, r5, lr}
   1716c:	429a      	cmp	r2, r3
   1716e:	d00d      	beq.n	1718c <strncmp+0x24>
   17170:	3a01      	subs	r2, #1
   17172:	5cc4      	ldrb	r4, [r0, r3]
   17174:	5ccd      	ldrb	r5, [r1, r3]
   17176:	42ac      	cmp	r4, r5
   17178:	d102      	bne.n	17180 <strncmp+0x18>
   1717a:	4293      	cmp	r3, r2
   1717c:	d102      	bne.n	17184 <strncmp+0x1c>
   1717e:	1c25      	adds	r5, r4, #0
   17180:	1b63      	subs	r3, r4, r5
   17182:	e003      	b.n	1718c <strncmp+0x24>
   17184:	3301      	adds	r3, #1
   17186:	2c00      	cmp	r4, #0
   17188:	d1f3      	bne.n	17172 <strncmp+0xa>
   1718a:	e7f8      	b.n	1717e <strncmp+0x16>
   1718c:	1c18      	adds	r0, r3, #0
   1718e:	bd30      	pop	{r4, r5, pc}

00017190 <strncpy>:
   17190:	1c03      	adds	r3, r0, #0
   17192:	b530      	push	{r4, r5, lr}
   17194:	2a00      	cmp	r2, #0
   17196:	d007      	beq.n	171a8 <strncpy+0x18>
   17198:	780c      	ldrb	r4, [r1, #0]
   1719a:	3301      	adds	r3, #1
   1719c:	1e5d      	subs	r5, r3, #1
   1719e:	3a01      	subs	r2, #1
   171a0:	702c      	strb	r4, [r5, #0]
   171a2:	3101      	adds	r1, #1
   171a4:	2c00      	cmp	r4, #0
   171a6:	d1f5      	bne.n	17194 <strncpy+0x4>
   171a8:	189a      	adds	r2, r3, r2
   171aa:	4293      	cmp	r3, r2
   171ac:	d003      	beq.n	171b6 <strncpy+0x26>
   171ae:	2100      	movs	r1, #0
   171b0:	7019      	strb	r1, [r3, #0]
   171b2:	3301      	adds	r3, #1
   171b4:	e7f9      	b.n	171aa <strncpy+0x1a>
   171b6:	bd30      	pop	{r4, r5, pc}

000171b8 <is_leap_year>:
   171b8:	b510      	push	{r4, lr}
   171ba:	2300      	movs	r3, #0
   171bc:	0782      	lsls	r2, r0, #30
   171be:	d10d      	bne.n	171dc <is_leap_year+0x24>
   171c0:	2164      	movs	r1, #100	; 0x64
   171c2:	1c04      	adds	r4, r0, #0
   171c4:	f7fd ffe0 	bl	15188 <__aeabi_idivmod>
   171c8:	2301      	movs	r3, #1
   171ca:	2900      	cmp	r1, #0
   171cc:	d106      	bne.n	171dc <is_leap_year+0x24>
   171ce:	3191      	adds	r1, #145	; 0x91
   171d0:	1c20      	adds	r0, r4, #0
   171d2:	31ff      	adds	r1, #255	; 0xff
   171d4:	f7fd ffd8 	bl	15188 <__aeabi_idivmod>
   171d8:	424b      	negs	r3, r1
   171da:	414b      	adcs	r3, r1
   171dc:	1c18      	adds	r0, r3, #0
   171de:	bd10      	pop	{r4, pc}

000171e0 <first_day>:
   171e0:	b538      	push	{r3, r4, r5, lr}
   171e2:	1c05      	adds	r5, r0, #0
   171e4:	2404      	movs	r4, #4
   171e6:	4b08      	ldr	r3, [pc, #32]	; (17208 <first_day+0x28>)
   171e8:	3d01      	subs	r5, #1
   171ea:	429d      	cmp	r5, r3
   171ec:	dd0a      	ble.n	17204 <first_day+0x24>
   171ee:	1c28      	adds	r0, r5, #0
   171f0:	f7ff ffe2 	bl	171b8 <is_leap_year>
   171f4:	346e      	adds	r4, #110	; 0x6e
   171f6:	34ff      	adds	r4, #255	; 0xff
   171f8:	1820      	adds	r0, r4, r0
   171fa:	2107      	movs	r1, #7
   171fc:	f7fd ffc4 	bl	15188 <__aeabi_idivmod>
   17200:	1c0c      	adds	r4, r1, #0
   17202:	e7f0      	b.n	171e6 <first_day+0x6>
   17204:	1c20      	adds	r0, r4, #0
   17206:	bd38      	pop	{r3, r4, r5, pc}
   17208:	000007b1 	.word	0x000007b1

0001720c <match_string>:
   1720c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1720e:	1c06      	adds	r6, r0, #0
   17210:	1c0f      	adds	r7, r1, #0
   17212:	2400      	movs	r4, #0
   17214:	6838      	ldr	r0, [r7, #0]
   17216:	2800      	cmp	r0, #0
   17218:	d010      	beq.n	1723c <match_string+0x30>
   1721a:	f7ff ff9e 	bl	1715a <strlen>
   1721e:	1c05      	adds	r5, r0, #0
   17220:	cf02      	ldmia	r7!, {r1}
   17222:	6830      	ldr	r0, [r6, #0]
   17224:	1c2a      	adds	r2, r5, #0
   17226:	f001 f855 	bl	182d4 <strncasecmp>
   1722a:	2800      	cmp	r0, #0
   1722c:	d104      	bne.n	17238 <match_string+0x2c>
   1722e:	6833      	ldr	r3, [r6, #0]
   17230:	1c20      	adds	r0, r4, #0
   17232:	195d      	adds	r5, r3, r5
   17234:	6035      	str	r5, [r6, #0]
   17236:	e002      	b.n	1723e <match_string+0x32>
   17238:	3401      	adds	r4, #1
   1723a:	e7eb      	b.n	17214 <match_string+0x8>
   1723c:	3801      	subs	r0, #1
   1723e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00017240 <strptime>:
   17240:	b5f0      	push	{r4, r5, r6, r7, lr}
   17242:	b087      	sub	sp, #28
   17244:	9003      	str	r0, [sp, #12]
   17246:	1c0e      	adds	r6, r1, #0
   17248:	1c14      	adds	r4, r2, #0
   1724a:	f000 fb33 	bl	178b4 <__get_current_time_locale>
   1724e:	2500      	movs	r5, #0
   17250:	9000      	str	r0, [sp, #0]
   17252:	7832      	ldrb	r2, [r6, #0]
   17254:	2a00      	cmp	r2, #0
   17256:	d100      	bne.n	1725a <strptime+0x1a>
   17258:	e22a      	b.n	176b0 <strptime+0x470>
   1725a:	4bb6      	ldr	r3, [pc, #728]	; (17534 <strptime+0x2f4>)
   1725c:	6819      	ldr	r1, [r3, #0]
   1725e:	188b      	adds	r3, r1, r2
   17260:	785b      	ldrb	r3, [r3, #1]
   17262:	071b      	lsls	r3, r3, #28
   17264:	d509      	bpl.n	1727a <strptime+0x3a>
   17266:	9b03      	ldr	r3, [sp, #12]
   17268:	781a      	ldrb	r2, [r3, #0]
   1726a:	188a      	adds	r2, r1, r2
   1726c:	7852      	ldrb	r2, [r2, #1]
   1726e:	0712      	lsls	r2, r2, #28
   17270:	d400      	bmi.n	17274 <strptime+0x34>
   17272:	e219      	b.n	176a8 <strptime+0x468>
   17274:	3301      	adds	r3, #1
   17276:	9303      	str	r3, [sp, #12]
   17278:	e7f5      	b.n	17266 <strptime+0x26>
   1727a:	2a25      	cmp	r2, #37	; 0x25
   1727c:	d000      	beq.n	17280 <strptime+0x40>
   1727e:	e20d      	b.n	1769c <strptime+0x45c>
   17280:	7873      	ldrb	r3, [r6, #1]
   17282:	2b00      	cmp	r3, #0
   17284:	d100      	bne.n	17288 <strptime+0x48>
   17286:	e209      	b.n	1769c <strptime+0x45c>
   17288:	2b45      	cmp	r3, #69	; 0x45
   1728a:	d003      	beq.n	17294 <strptime+0x54>
   1728c:	2b4f      	cmp	r3, #79	; 0x4f
   1728e:	d001      	beq.n	17294 <strptime+0x54>
   17290:	3601      	adds	r6, #1
   17292:	e001      	b.n	17298 <strptime+0x58>
   17294:	78b3      	ldrb	r3, [r6, #2]
   17296:	3602      	adds	r6, #2
   17298:	2b5a      	cmp	r3, #90	; 0x5a
   1729a:	d100      	bne.n	1729e <strptime+0x5e>
   1729c:	e204      	b.n	176a8 <strptime+0x468>
   1729e:	d837      	bhi.n	17310 <strptime+0xd0>
   172a0:	2b4d      	cmp	r3, #77	; 0x4d
   172a2:	d100      	bne.n	172a6 <strptime+0x66>
   172a4:	e0ed      	b.n	17482 <strptime+0x242>
   172a6:	d818      	bhi.n	172da <strptime+0x9a>
   172a8:	2b42      	cmp	r3, #66	; 0x42
   172aa:	d100      	bne.n	172ae <strptime+0x6e>
   172ac:	e075      	b.n	1739a <strptime+0x15a>
   172ae:	d809      	bhi.n	172c4 <strptime+0x84>
   172b0:	2b25      	cmp	r3, #37	; 0x25
   172b2:	d100      	bne.n	172b6 <strptime+0x76>
   172b4:	e1e1      	b.n	1767a <strptime+0x43a>
   172b6:	2b41      	cmp	r3, #65	; 0x41
   172b8:	d065      	beq.n	17386 <strptime+0x146>
   172ba:	2b00      	cmp	r3, #0
   172bc:	d000      	beq.n	172c0 <strptime+0x80>
   172be:	e1e1      	b.n	17684 <strptime+0x444>
   172c0:	3e01      	subs	r6, #1
   172c2:	e1da      	b.n	1767a <strptime+0x43a>
   172c4:	2b44      	cmp	r3, #68	; 0x44
   172c6:	d100      	bne.n	172ca <strptime+0x8a>
   172c8:	e093      	b.n	173f2 <strptime+0x1b2>
   172ca:	d373      	bcc.n	173b4 <strptime+0x174>
   172cc:	2b48      	cmp	r3, #72	; 0x48
   172ce:	d100      	bne.n	172d2 <strptime+0x92>
   172d0:	e0a0      	b.n	17414 <strptime+0x1d4>
   172d2:	2b49      	cmp	r3, #73	; 0x49
   172d4:	d100      	bne.n	172d8 <strptime+0x98>
   172d6:	e0a7      	b.n	17428 <strptime+0x1e8>
   172d8:	e1d4      	b.n	17684 <strptime+0x444>
   172da:	2b55      	cmp	r3, #85	; 0x55
   172dc:	d100      	bne.n	172e0 <strptime+0xa0>
   172de:	e133      	b.n	17548 <strptime+0x308>
   172e0:	d80a      	bhi.n	172f8 <strptime+0xb8>
   172e2:	2b53      	cmp	r3, #83	; 0x53
   172e4:	d100      	bne.n	172e8 <strptime+0xa8>
   172e6:	e0fa      	b.n	174de <strptime+0x29e>
   172e8:	d900      	bls.n	172ec <strptime+0xac>
   172ea:	e0ed      	b.n	174c8 <strptime+0x288>
   172ec:	2b52      	cmp	r3, #82	; 0x52
   172ee:	d000      	beq.n	172f2 <strptime+0xb2>
   172f0:	e1c8      	b.n	17684 <strptime+0x444>
   172f2:	9803      	ldr	r0, [sp, #12]
   172f4:	4990      	ldr	r1, [pc, #576]	; (17538 <strptime+0x2f8>)
   172f6:	e0e9      	b.n	174cc <strptime+0x28c>
   172f8:	2b57      	cmp	r3, #87	; 0x57
   172fa:	d100      	bne.n	172fe <strptime+0xbe>
   172fc:	e161      	b.n	175c2 <strptime+0x382>
   172fe:	d200      	bcs.n	17302 <strptime+0xc2>
   17300:	e13c      	b.n	1757c <strptime+0x33c>
   17302:	2b58      	cmp	r3, #88	; 0x58
   17304:	d100      	bne.n	17308 <strptime+0xc8>
   17306:	e196      	b.n	17636 <strptime+0x3f6>
   17308:	2b59      	cmp	r3, #89	; 0x59
   1730a:	d100      	bne.n	1730e <strptime+0xce>
   1730c:	e1a5      	b.n	1765a <strptime+0x41a>
   1730e:	e1b9      	b.n	17684 <strptime+0x444>
   17310:	2b6c      	cmp	r3, #108	; 0x6c
   17312:	d100      	bne.n	17316 <strptime+0xd6>
   17314:	e088      	b.n	17428 <strptime+0x1e8>
   17316:	d814      	bhi.n	17342 <strptime+0x102>
   17318:	2b65      	cmp	r3, #101	; 0x65
   1731a:	d80b      	bhi.n	17334 <strptime+0xf4>
   1731c:	2b64      	cmp	r3, #100	; 0x64
   1731e:	d26b      	bcs.n	173f8 <strptime+0x1b8>
   17320:	2b62      	cmp	r3, #98	; 0x62
   17322:	d03e      	beq.n	173a2 <strptime+0x162>
   17324:	d857      	bhi.n	173d6 <strptime+0x196>
   17326:	2b61      	cmp	r3, #97	; 0x61
   17328:	d000      	beq.n	1732c <strptime+0xec>
   1732a:	e1ab      	b.n	17684 <strptime+0x444>
   1732c:	9900      	ldr	r1, [sp, #0]
   1732e:	a803      	add	r0, sp, #12
   17330:	3160      	adds	r1, #96	; 0x60
   17332:	e02b      	b.n	1738c <strptime+0x14c>
   17334:	2b6a      	cmp	r3, #106	; 0x6a
   17336:	d100      	bne.n	1733a <strptime+0xfa>
   17338:	e087      	b.n	1744a <strptime+0x20a>
   1733a:	d86b      	bhi.n	17414 <strptime+0x1d4>
   1733c:	2b68      	cmp	r3, #104	; 0x68
   1733e:	d030      	beq.n	173a2 <strptime+0x162>
   17340:	e1a0      	b.n	17684 <strptime+0x444>
   17342:	2b74      	cmp	r3, #116	; 0x74
   17344:	d100      	bne.n	17348 <strptime+0x108>
   17346:	e0d6      	b.n	174f6 <strptime+0x2b6>
   17348:	d80e      	bhi.n	17368 <strptime+0x128>
   1734a:	2b6e      	cmp	r3, #110	; 0x6e
   1734c:	d100      	bne.n	17350 <strptime+0x110>
   1734e:	e0a4      	b.n	1749a <strptime+0x25a>
   17350:	d200      	bcs.n	17354 <strptime+0x114>
   17352:	e087      	b.n	17464 <strptime+0x224>
   17354:	2b70      	cmp	r3, #112	; 0x70
   17356:	d100      	bne.n	1735a <strptime+0x11a>
   17358:	e0a5      	b.n	174a6 <strptime+0x266>
   1735a:	2b72      	cmp	r3, #114	; 0x72
   1735c:	d000      	beq.n	17360 <strptime+0x120>
   1735e:	e191      	b.n	17684 <strptime+0x444>
   17360:	9b00      	ldr	r3, [sp, #0]
   17362:	9803      	ldr	r0, [sp, #12]
   17364:	33e4      	adds	r3, #228	; 0xe4
   17366:	e169      	b.n	1763c <strptime+0x3fc>
   17368:	2b77      	cmp	r3, #119	; 0x77
   1736a:	d100      	bne.n	1736e <strptime+0x12e>
   1736c:	e0d8      	b.n	17520 <strptime+0x2e0>
   1736e:	d803      	bhi.n	17378 <strptime+0x138>
   17370:	2b75      	cmp	r3, #117	; 0x75
   17372:	d100      	bne.n	17376 <strptime+0x136>
   17374:	e0c5      	b.n	17502 <strptime+0x2c2>
   17376:	e185      	b.n	17684 <strptime+0x444>
   17378:	2b78      	cmp	r3, #120	; 0x78
   1737a:	d100      	bne.n	1737e <strptime+0x13e>
   1737c:	e14e      	b.n	1761c <strptime+0x3dc>
   1737e:	2b79      	cmp	r3, #121	; 0x79
   17380:	d100      	bne.n	17384 <strptime+0x144>
   17382:	e15d      	b.n	17640 <strptime+0x400>
   17384:	e17e      	b.n	17684 <strptime+0x444>
   17386:	9900      	ldr	r1, [sp, #0]
   17388:	a803      	add	r0, sp, #12
   1738a:	317c      	adds	r1, #124	; 0x7c
   1738c:	f7ff ff3e 	bl	1720c <match_string>
   17390:	2800      	cmp	r0, #0
   17392:	da00      	bge.n	17396 <strptime+0x156>
   17394:	e18a      	b.n	176ac <strptime+0x46c>
   17396:	61a0      	str	r0, [r4, #24]
   17398:	e0c0      	b.n	1751c <strptime+0x2dc>
   1739a:	9900      	ldr	r1, [sp, #0]
   1739c:	a803      	add	r0, sp, #12
   1739e:	3130      	adds	r1, #48	; 0x30
   173a0:	e001      	b.n	173a6 <strptime+0x166>
   173a2:	9900      	ldr	r1, [sp, #0]
   173a4:	a803      	add	r0, sp, #12
   173a6:	f7ff ff31 	bl	1720c <match_string>
   173aa:	2800      	cmp	r0, #0
   173ac:	da00      	bge.n	173b0 <strptime+0x170>
   173ae:	e17d      	b.n	176ac <strptime+0x46c>
   173b0:	6120      	str	r0, [r4, #16]
   173b2:	e064      	b.n	1747e <strptime+0x23e>
   173b4:	220a      	movs	r2, #10
   173b6:	9803      	ldr	r0, [sp, #12]
   173b8:	a905      	add	r1, sp, #20
   173ba:	f000 fa6d 	bl	17898 <strtol>
   173be:	9a05      	ldr	r2, [sp, #20]
   173c0:	9b03      	ldr	r3, [sp, #12]
   173c2:	429a      	cmp	r2, r3
   173c4:	d100      	bne.n	173c8 <strptime+0x188>
   173c6:	e171      	b.n	176ac <strptime+0x46c>
   173c8:	2364      	movs	r3, #100	; 0x64
   173ca:	4358      	muls	r0, r3
   173cc:	4b5b      	ldr	r3, [pc, #364]	; (1753c <strptime+0x2fc>)
   173ce:	9203      	str	r2, [sp, #12]
   173d0:	18c0      	adds	r0, r0, r3
   173d2:	6160      	str	r0, [r4, #20]
   173d4:	e14e      	b.n	17674 <strptime+0x434>
   173d6:	9b00      	ldr	r3, [sp, #0]
   173d8:	9803      	ldr	r0, [sp, #12]
   173da:	33a0      	adds	r3, #160	; 0xa0
   173dc:	6819      	ldr	r1, [r3, #0]
   173de:	1c22      	adds	r2, r4, #0
   173e0:	f7ff ff2e 	bl	17240 <strptime>
   173e4:	9005      	str	r0, [sp, #20]
   173e6:	2800      	cmp	r0, #0
   173e8:	d100      	bne.n	173ec <strptime+0x1ac>
   173ea:	e15f      	b.n	176ac <strptime+0x46c>
   173ec:	9003      	str	r0, [sp, #12]
   173ee:	230f      	movs	r3, #15
   173f0:	e141      	b.n	17676 <strptime+0x436>
   173f2:	9803      	ldr	r0, [sp, #12]
   173f4:	4952      	ldr	r1, [pc, #328]	; (17540 <strptime+0x300>)
   173f6:	e115      	b.n	17624 <strptime+0x3e4>
   173f8:	220a      	movs	r2, #10
   173fa:	9803      	ldr	r0, [sp, #12]
   173fc:	a905      	add	r1, sp, #20
   173fe:	f000 fa4b 	bl	17898 <strtol>
   17402:	9b05      	ldr	r3, [sp, #20]
   17404:	9a03      	ldr	r2, [sp, #12]
   17406:	4293      	cmp	r3, r2
   17408:	d100      	bne.n	1740c <strptime+0x1cc>
   1740a:	e14f      	b.n	176ac <strptime+0x46c>
   1740c:	9303      	str	r3, [sp, #12]
   1740e:	60e0      	str	r0, [r4, #12]
   17410:	2301      	movs	r3, #1
   17412:	e130      	b.n	17676 <strptime+0x436>
   17414:	220a      	movs	r2, #10
   17416:	9803      	ldr	r0, [sp, #12]
   17418:	a905      	add	r1, sp, #20
   1741a:	f000 fa3d 	bl	17898 <strtol>
   1741e:	9b05      	ldr	r3, [sp, #20]
   17420:	9a03      	ldr	r2, [sp, #12]
   17422:	4293      	cmp	r3, r2
   17424:	d10f      	bne.n	17446 <strptime+0x206>
   17426:	e141      	b.n	176ac <strptime+0x46c>
   17428:	220a      	movs	r2, #10
   1742a:	9803      	ldr	r0, [sp, #12]
   1742c:	a905      	add	r1, sp, #20
   1742e:	f000 fa33 	bl	17898 <strtol>
   17432:	9b05      	ldr	r3, [sp, #20]
   17434:	9a03      	ldr	r2, [sp, #12]
   17436:	4293      	cmp	r3, r2
   17438:	d100      	bne.n	1743c <strptime+0x1fc>
   1743a:	e137      	b.n	176ac <strptime+0x46c>
   1743c:	280c      	cmp	r0, #12
   1743e:	d102      	bne.n	17446 <strptime+0x206>
   17440:	2200      	movs	r2, #0
   17442:	60a2      	str	r2, [r4, #8]
   17444:	e12f      	b.n	176a6 <strptime+0x466>
   17446:	60a0      	str	r0, [r4, #8]
   17448:	e12d      	b.n	176a6 <strptime+0x466>
   1744a:	220a      	movs	r2, #10
   1744c:	9803      	ldr	r0, [sp, #12]
   1744e:	a905      	add	r1, sp, #20
   17450:	f000 fa22 	bl	17898 <strtol>
   17454:	9b05      	ldr	r3, [sp, #20]
   17456:	9a03      	ldr	r2, [sp, #12]
   17458:	4293      	cmp	r3, r2
   1745a:	d100      	bne.n	1745e <strptime+0x21e>
   1745c:	e126      	b.n	176ac <strptime+0x46c>
   1745e:	3801      	subs	r0, #1
   17460:	61e0      	str	r0, [r4, #28]
   17462:	e0d8      	b.n	17616 <strptime+0x3d6>
   17464:	220a      	movs	r2, #10
   17466:	9803      	ldr	r0, [sp, #12]
   17468:	a905      	add	r1, sp, #20
   1746a:	f000 fa15 	bl	17898 <strtol>
   1746e:	9b05      	ldr	r3, [sp, #20]
   17470:	9a03      	ldr	r2, [sp, #12]
   17472:	4293      	cmp	r3, r2
   17474:	d100      	bne.n	17478 <strptime+0x238>
   17476:	e119      	b.n	176ac <strptime+0x46c>
   17478:	3801      	subs	r0, #1
   1747a:	6120      	str	r0, [r4, #16]
   1747c:	9303      	str	r3, [sp, #12]
   1747e:	2302      	movs	r3, #2
   17480:	e0f9      	b.n	17676 <strptime+0x436>
   17482:	220a      	movs	r2, #10
   17484:	9803      	ldr	r0, [sp, #12]
   17486:	a905      	add	r1, sp, #20
   17488:	f000 fa06 	bl	17898 <strtol>
   1748c:	9b05      	ldr	r3, [sp, #20]
   1748e:	9a03      	ldr	r2, [sp, #12]
   17490:	4293      	cmp	r3, r2
   17492:	d100      	bne.n	17496 <strptime+0x256>
   17494:	e10a      	b.n	176ac <strptime+0x46c>
   17496:	6060      	str	r0, [r4, #4]
   17498:	e105      	b.n	176a6 <strptime+0x466>
   1749a:	9b03      	ldr	r3, [sp, #12]
   1749c:	781a      	ldrb	r2, [r3, #0]
   1749e:	2a0a      	cmp	r2, #10
   174a0:	d100      	bne.n	174a4 <strptime+0x264>
   174a2:	e0ff      	b.n	176a4 <strptime+0x464>
   174a4:	e102      	b.n	176ac <strptime+0x46c>
   174a6:	9900      	ldr	r1, [sp, #0]
   174a8:	a803      	add	r0, sp, #12
   174aa:	31a4      	adds	r1, #164	; 0xa4
   174ac:	f7ff feae 	bl	1720c <match_string>
   174b0:	2800      	cmp	r0, #0
   174b2:	da00      	bge.n	174b6 <strptime+0x276>
   174b4:	e0fa      	b.n	176ac <strptime+0x46c>
   174b6:	68a3      	ldr	r3, [r4, #8]
   174b8:	2b00      	cmp	r3, #0
   174ba:	d102      	bne.n	174c2 <strptime+0x282>
   174bc:	2801      	cmp	r0, #1
   174be:	d000      	beq.n	174c2 <strptime+0x282>
   174c0:	e0f2      	b.n	176a8 <strptime+0x468>
   174c2:	330c      	adds	r3, #12
   174c4:	60a3      	str	r3, [r4, #8]
   174c6:	e0ef      	b.n	176a8 <strptime+0x468>
   174c8:	9803      	ldr	r0, [sp, #12]
   174ca:	491e      	ldr	r1, [pc, #120]	; (17544 <strptime+0x304>)
   174cc:	1c22      	adds	r2, r4, #0
   174ce:	f7ff feb7 	bl	17240 <strptime>
   174d2:	9005      	str	r0, [sp, #20]
   174d4:	2800      	cmp	r0, #0
   174d6:	d100      	bne.n	174da <strptime+0x29a>
   174d8:	e0e8      	b.n	176ac <strptime+0x46c>
   174da:	9003      	str	r0, [sp, #12]
   174dc:	e0e4      	b.n	176a8 <strptime+0x468>
   174de:	220a      	movs	r2, #10
   174e0:	9803      	ldr	r0, [sp, #12]
   174e2:	a905      	add	r1, sp, #20
   174e4:	f000 f9d8 	bl	17898 <strtol>
   174e8:	9b05      	ldr	r3, [sp, #20]
   174ea:	9a03      	ldr	r2, [sp, #12]
   174ec:	4293      	cmp	r3, r2
   174ee:	d100      	bne.n	174f2 <strptime+0x2b2>
   174f0:	e0dc      	b.n	176ac <strptime+0x46c>
   174f2:	6020      	str	r0, [r4, #0]
   174f4:	e0d7      	b.n	176a6 <strptime+0x466>
   174f6:	9b03      	ldr	r3, [sp, #12]
   174f8:	781a      	ldrb	r2, [r3, #0]
   174fa:	2a09      	cmp	r2, #9
   174fc:	d100      	bne.n	17500 <strptime+0x2c0>
   174fe:	e0d1      	b.n	176a4 <strptime+0x464>
   17500:	e0d4      	b.n	176ac <strptime+0x46c>
   17502:	220a      	movs	r2, #10
   17504:	9803      	ldr	r0, [sp, #12]
   17506:	a905      	add	r1, sp, #20
   17508:	f000 f9c6 	bl	17898 <strtol>
   1750c:	9b05      	ldr	r3, [sp, #20]
   1750e:	9a03      	ldr	r2, [sp, #12]
   17510:	4293      	cmp	r3, r2
   17512:	d100      	bne.n	17516 <strptime+0x2d6>
   17514:	e0ca      	b.n	176ac <strptime+0x46c>
   17516:	3801      	subs	r0, #1
   17518:	61a0      	str	r0, [r4, #24]
   1751a:	9303      	str	r3, [sp, #12]
   1751c:	2308      	movs	r3, #8
   1751e:	e0aa      	b.n	17676 <strptime+0x436>
   17520:	220a      	movs	r2, #10
   17522:	9803      	ldr	r0, [sp, #12]
   17524:	a905      	add	r1, sp, #20
   17526:	f000 f9b7 	bl	17898 <strtol>
   1752a:	9b05      	ldr	r3, [sp, #20]
   1752c:	9a03      	ldr	r2, [sp, #12]
   1752e:	4293      	cmp	r3, r2
   17530:	d1f2      	bne.n	17518 <strptime+0x2d8>
   17532:	e0bb      	b.n	176ac <strptime+0x46c>
   17534:	200002f8 	.word	0x200002f8
   17538:	00021d39 	.word	0x00021d39
   1753c:	fffff894 	.word	0xfffff894
   17540:	00021d30 	.word	0x00021d30
   17544:	00021d3f 	.word	0x00021d3f
   17548:	220a      	movs	r2, #10
   1754a:	9803      	ldr	r0, [sp, #12]
   1754c:	a905      	add	r1, sp, #20
   1754e:	f000 f9a3 	bl	17898 <strtol>
   17552:	9b05      	ldr	r3, [sp, #20]
   17554:	9a03      	ldr	r2, [sp, #12]
   17556:	1c07      	adds	r7, r0, #0
   17558:	9301      	str	r3, [sp, #4]
   1755a:	4293      	cmp	r3, r2
   1755c:	d100      	bne.n	17560 <strptime+0x320>
   1755e:	e0a5      	b.n	176ac <strptime+0x46c>
   17560:	6963      	ldr	r3, [r4, #20]
   17562:	4a82      	ldr	r2, [pc, #520]	; (1776c <strptime+0x52c>)
   17564:	1898      	adds	r0, r3, r2
   17566:	f7ff fe3b 	bl	171e0 <first_day>
   1756a:	2307      	movs	r3, #7
   1756c:	435f      	muls	r7, r3
   1756e:	69a3      	ldr	r3, [r4, #24]
   17570:	18ff      	adds	r7, r7, r3
   17572:	1a3f      	subs	r7, r7, r0
   17574:	61e7      	str	r7, [r4, #28]
   17576:	d54d      	bpl.n	17614 <strptime+0x3d4>
   17578:	61a0      	str	r0, [r4, #24]
   1757a:	e049      	b.n	17610 <strptime+0x3d0>
   1757c:	220a      	movs	r2, #10
   1757e:	9803      	ldr	r0, [sp, #12]
   17580:	a905      	add	r1, sp, #20
   17582:	f000 f989 	bl	17898 <strtol>
   17586:	9b05      	ldr	r3, [sp, #20]
   17588:	9a03      	ldr	r2, [sp, #12]
   1758a:	1c07      	adds	r7, r0, #0
   1758c:	9301      	str	r3, [sp, #4]
   1758e:	4293      	cmp	r3, r2
   17590:	d100      	bne.n	17594 <strptime+0x354>
   17592:	e08b      	b.n	176ac <strptime+0x46c>
   17594:	4a75      	ldr	r2, [pc, #468]	; (1776c <strptime+0x52c>)
   17596:	6963      	ldr	r3, [r4, #20]
   17598:	1898      	adds	r0, r3, r2
   1759a:	f7ff fe21 	bl	171e0 <first_day>
   1759e:	2107      	movs	r1, #7
   175a0:	3006      	adds	r0, #6
   175a2:	f7fd fdf1 	bl	15188 <__aeabi_idivmod>
   175a6:	2200      	movs	r2, #0
   175a8:	2903      	cmp	r1, #3
   175aa:	dc00      	bgt.n	175ae <strptime+0x36e>
   175ac:	3207      	adds	r2, #7
   175ae:	2307      	movs	r3, #7
   175b0:	3f01      	subs	r7, #1
   175b2:	435f      	muls	r7, r3
   175b4:	69a3      	ldr	r3, [r4, #24]
   175b6:	19d7      	adds	r7, r2, r7
   175b8:	18ff      	adds	r7, r7, r3
   175ba:	1a7f      	subs	r7, r7, r1
   175bc:	61e7      	str	r7, [r4, #28]
   175be:	d529      	bpl.n	17614 <strptime+0x3d4>
   175c0:	e025      	b.n	1760e <strptime+0x3ce>
   175c2:	220a      	movs	r2, #10
   175c4:	9803      	ldr	r0, [sp, #12]
   175c6:	a905      	add	r1, sp, #20
   175c8:	f000 f966 	bl	17898 <strtol>
   175cc:	9b05      	ldr	r3, [sp, #20]
   175ce:	9a03      	ldr	r2, [sp, #12]
   175d0:	1c07      	adds	r7, r0, #0
   175d2:	9301      	str	r3, [sp, #4]
   175d4:	4293      	cmp	r3, r2
   175d6:	d069      	beq.n	176ac <strptime+0x46c>
   175d8:	6963      	ldr	r3, [r4, #20]
   175da:	4a64      	ldr	r2, [pc, #400]	; (1776c <strptime+0x52c>)
   175dc:	1898      	adds	r0, r3, r2
   175de:	f7ff fdff 	bl	171e0 <first_day>
   175e2:	2107      	movs	r1, #7
   175e4:	3006      	adds	r0, #6
   175e6:	f7fd fdcf 	bl	15188 <__aeabi_idivmod>
   175ea:	2307      	movs	r3, #7
   175ec:	435f      	muls	r7, r3
   175ee:	69a3      	ldr	r3, [r4, #24]
   175f0:	9102      	str	r1, [sp, #8]
   175f2:	1d98      	adds	r0, r3, #6
   175f4:	2107      	movs	r1, #7
   175f6:	f7fd fdc7 	bl	15188 <__aeabi_idivmod>
   175fa:	9b02      	ldr	r3, [sp, #8]
   175fc:	187f      	adds	r7, r7, r1
   175fe:	1aff      	subs	r7, r7, r3
   17600:	61e7      	str	r7, [r4, #28]
   17602:	d507      	bpl.n	17614 <strptime+0x3d4>
   17604:	1c18      	adds	r0, r3, #0
   17606:	2107      	movs	r1, #7
   17608:	3001      	adds	r0, #1
   1760a:	f7fd fdbd 	bl	15188 <__aeabi_idivmod>
   1760e:	61a1      	str	r1, [r4, #24]
   17610:	2300      	movs	r3, #0
   17612:	61e3      	str	r3, [r4, #28]
   17614:	9b01      	ldr	r3, [sp, #4]
   17616:	9303      	str	r3, [sp, #12]
   17618:	2310      	movs	r3, #16
   1761a:	e02c      	b.n	17676 <strptime+0x436>
   1761c:	9b00      	ldr	r3, [sp, #0]
   1761e:	9803      	ldr	r0, [sp, #12]
   17620:	339c      	adds	r3, #156	; 0x9c
   17622:	6819      	ldr	r1, [r3, #0]
   17624:	1c22      	adds	r2, r4, #0
   17626:	f7ff fe0b 	bl	17240 <strptime>
   1762a:	9005      	str	r0, [sp, #20]
   1762c:	2800      	cmp	r0, #0
   1762e:	d03d      	beq.n	176ac <strptime+0x46c>
   17630:	9003      	str	r0, [sp, #12]
   17632:	2307      	movs	r3, #7
   17634:	e01f      	b.n	17676 <strptime+0x436>
   17636:	9b00      	ldr	r3, [sp, #0]
   17638:	9803      	ldr	r0, [sp, #12]
   1763a:	3398      	adds	r3, #152	; 0x98
   1763c:	6819      	ldr	r1, [r3, #0]
   1763e:	e745      	b.n	174cc <strptime+0x28c>
   17640:	220a      	movs	r2, #10
   17642:	9803      	ldr	r0, [sp, #12]
   17644:	a905      	add	r1, sp, #20
   17646:	f000 f927 	bl	17898 <strtol>
   1764a:	9b05      	ldr	r3, [sp, #20]
   1764c:	9a03      	ldr	r2, [sp, #12]
   1764e:	4293      	cmp	r3, r2
   17650:	d02c      	beq.n	176ac <strptime+0x46c>
   17652:	2845      	cmp	r0, #69	; 0x45
   17654:	dc0c      	bgt.n	17670 <strptime+0x430>
   17656:	3064      	adds	r0, #100	; 0x64
   17658:	e00a      	b.n	17670 <strptime+0x430>
   1765a:	220a      	movs	r2, #10
   1765c:	9803      	ldr	r0, [sp, #12]
   1765e:	a905      	add	r1, sp, #20
   17660:	f000 f91a 	bl	17898 <strtol>
   17664:	9b05      	ldr	r3, [sp, #20]
   17666:	9a03      	ldr	r2, [sp, #12]
   17668:	4293      	cmp	r3, r2
   1766a:	d01f      	beq.n	176ac <strptime+0x46c>
   1766c:	4a40      	ldr	r2, [pc, #256]	; (17770 <strptime+0x530>)
   1766e:	1880      	adds	r0, r0, r2
   17670:	6160      	str	r0, [r4, #20]
   17672:	9303      	str	r3, [sp, #12]
   17674:	2304      	movs	r3, #4
   17676:	431d      	orrs	r5, r3
   17678:	e016      	b.n	176a8 <strptime+0x468>
   1767a:	9b03      	ldr	r3, [sp, #12]
   1767c:	781a      	ldrb	r2, [r3, #0]
   1767e:	2a25      	cmp	r2, #37	; 0x25
   17680:	d010      	beq.n	176a4 <strptime+0x464>
   17682:	e013      	b.n	176ac <strptime+0x46c>
   17684:	9a03      	ldr	r2, [sp, #12]
   17686:	7811      	ldrb	r1, [r2, #0]
   17688:	2925      	cmp	r1, #37	; 0x25
   1768a:	d101      	bne.n	17690 <strptime+0x450>
   1768c:	9b03      	ldr	r3, [sp, #12]
   1768e:	e009      	b.n	176a4 <strptime+0x464>
   17690:	1c51      	adds	r1, r2, #1
   17692:	9103      	str	r1, [sp, #12]
   17694:	7852      	ldrb	r2, [r2, #1]
   17696:	429a      	cmp	r2, r3
   17698:	d0f8      	beq.n	1768c <strptime+0x44c>
   1769a:	e007      	b.n	176ac <strptime+0x46c>
   1769c:	9b03      	ldr	r3, [sp, #12]
   1769e:	7819      	ldrb	r1, [r3, #0]
   176a0:	4291      	cmp	r1, r2
   176a2:	d103      	bne.n	176ac <strptime+0x46c>
   176a4:	3301      	adds	r3, #1
   176a6:	9303      	str	r3, [sp, #12]
   176a8:	3601      	adds	r6, #1
   176aa:	e5d2      	b.n	17252 <strptime+0x12>
   176ac:	2000      	movs	r0, #0
   176ae:	e05a      	b.n	17766 <strptime+0x526>
   176b0:	2307      	movs	r3, #7
   176b2:	402b      	ands	r3, r5
   176b4:	2b07      	cmp	r3, #7
   176b6:	d116      	bne.n	176e6 <strptime+0x4a6>
   176b8:	06eb      	lsls	r3, r5, #27
   176ba:	d444      	bmi.n	17746 <strptime+0x506>
   176bc:	6927      	ldr	r7, [r4, #16]
   176be:	4b2d      	ldr	r3, [pc, #180]	; (17774 <strptime+0x534>)
   176c0:	00ba      	lsls	r2, r7, #2
   176c2:	58d6      	ldr	r6, [r2, r3]
   176c4:	68e3      	ldr	r3, [r4, #12]
   176c6:	4a29      	ldr	r2, [pc, #164]	; (1776c <strptime+0x52c>)
   176c8:	18f6      	adds	r6, r6, r3
   176ca:	6963      	ldr	r3, [r4, #20]
   176cc:	61e6      	str	r6, [r4, #28]
   176ce:	1898      	adds	r0, r3, r2
   176d0:	f7ff fd72 	bl	171b8 <is_leap_year>
   176d4:	2800      	cmp	r0, #0
   176d6:	d001      	beq.n	176dc <strptime+0x49c>
   176d8:	2f01      	cmp	r7, #1
   176da:	dc01      	bgt.n	176e0 <strptime+0x4a0>
   176dc:	3e01      	subs	r6, #1
   176de:	61e6      	str	r6, [r4, #28]
   176e0:	2310      	movs	r3, #16
   176e2:	431d      	orrs	r5, r3
   176e4:	e02f      	b.n	17746 <strptime+0x506>
   176e6:	2314      	movs	r3, #20
   176e8:	402b      	ands	r3, r5
   176ea:	2b14      	cmp	r3, #20
   176ec:	d12b      	bne.n	17746 <strptime+0x506>
   176ee:	2702      	movs	r7, #2
   176f0:	1c2b      	adds	r3, r5, #0
   176f2:	403b      	ands	r3, r7
   176f4:	d113      	bne.n	1771e <strptime+0x4de>
   176f6:	69e6      	ldr	r6, [r4, #28]
   176f8:	2e1e      	cmp	r6, #30
   176fa:	dd0f      	ble.n	1771c <strptime+0x4dc>
   176fc:	6963      	ldr	r3, [r4, #20]
   176fe:	4a1b      	ldr	r2, [pc, #108]	; (1776c <strptime+0x52c>)
   17700:	1898      	adds	r0, r3, r2
   17702:	f7ff fd59 	bl	171b8 <is_leap_year>
   17706:	1c3b      	adds	r3, r7, #0
   17708:	4a1a      	ldr	r2, [pc, #104]	; (17774 <strptime+0x534>)
   1770a:	0099      	lsls	r1, r3, #2
   1770c:	588a      	ldr	r2, [r1, r2]
   1770e:	1882      	adds	r2, r0, r2
   17710:	4296      	cmp	r6, r2
   17712:	db02      	blt.n	1771a <strptime+0x4da>
   17714:	3301      	adds	r3, #1
   17716:	2b0c      	cmp	r3, #12
   17718:	d1f6      	bne.n	17708 <strptime+0x4c8>
   1771a:	3b01      	subs	r3, #1
   1771c:	6123      	str	r3, [r4, #16]
   1771e:	07eb      	lsls	r3, r5, #31
   17720:	d411      	bmi.n	17746 <strptime+0x506>
   17722:	6927      	ldr	r7, [r4, #16]
   17724:	4b13      	ldr	r3, [pc, #76]	; (17774 <strptime+0x534>)
   17726:	00ba      	lsls	r2, r7, #2
   17728:	58d6      	ldr	r6, [r2, r3]
   1772a:	69e3      	ldr	r3, [r4, #28]
   1772c:	4a0f      	ldr	r2, [pc, #60]	; (1776c <strptime+0x52c>)
   1772e:	1b9e      	subs	r6, r3, r6
   17730:	6963      	ldr	r3, [r4, #20]
   17732:	60e6      	str	r6, [r4, #12]
   17734:	1898      	adds	r0, r3, r2
   17736:	f7ff fd3f 	bl	171b8 <is_leap_year>
   1773a:	2800      	cmp	r0, #0
   1773c:	d001      	beq.n	17742 <strptime+0x502>
   1773e:	2f01      	cmp	r7, #1
   17740:	dc01      	bgt.n	17746 <strptime+0x506>
   17742:	3601      	adds	r6, #1
   17744:	60e6      	str	r6, [r4, #12]
   17746:	231c      	movs	r3, #28
   17748:	401d      	ands	r5, r3
   1774a:	2d14      	cmp	r5, #20
   1774c:	d10a      	bne.n	17764 <strptime+0x524>
   1774e:	6963      	ldr	r3, [r4, #20]
   17750:	4a06      	ldr	r2, [pc, #24]	; (1776c <strptime+0x52c>)
   17752:	1898      	adds	r0, r3, r2
   17754:	f7ff fd44 	bl	171e0 <first_day>
   17758:	69e3      	ldr	r3, [r4, #28]
   1775a:	2107      	movs	r1, #7
   1775c:	18c0      	adds	r0, r0, r3
   1775e:	f7fd fd13 	bl	15188 <__aeabi_idivmod>
   17762:	61a1      	str	r1, [r4, #24]
   17764:	9803      	ldr	r0, [sp, #12]
   17766:	b007      	add	sp, #28
   17768:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1776a:	46c0      	nop			; (mov r8, r8)
   1776c:	0000076c 	.word	0x0000076c
   17770:	fffff894 	.word	0xfffff894
   17774:	00021d00 	.word	0x00021d00

00017778 <_strtol_r>:
   17778:	b5f0      	push	{r4, r5, r6, r7, lr}
   1777a:	1c1e      	adds	r6, r3, #0
   1777c:	4b44      	ldr	r3, [pc, #272]	; (17890 <_strtol_r+0x118>)
   1777e:	b087      	sub	sp, #28
   17780:	681b      	ldr	r3, [r3, #0]
   17782:	9005      	str	r0, [sp, #20]
   17784:	9302      	str	r3, [sp, #8]
   17786:	1c0b      	adds	r3, r1, #0
   17788:	9103      	str	r1, [sp, #12]
   1778a:	9201      	str	r2, [sp, #4]
   1778c:	781c      	ldrb	r4, [r3, #0]
   1778e:	9a02      	ldr	r2, [sp, #8]
   17790:	1c5d      	adds	r5, r3, #1
   17792:	1912      	adds	r2, r2, r4
   17794:	7850      	ldrb	r0, [r2, #1]
   17796:	2208      	movs	r2, #8
   17798:	4010      	ands	r0, r2
   1779a:	d001      	beq.n	177a0 <_strtol_r+0x28>
   1779c:	1c2b      	adds	r3, r5, #0
   1779e:	e7f5      	b.n	1778c <_strtol_r+0x14>
   177a0:	2c2d      	cmp	r4, #45	; 0x2d
   177a2:	d104      	bne.n	177ae <_strtol_r+0x36>
   177a4:	1c9d      	adds	r5, r3, #2
   177a6:	785c      	ldrb	r4, [r3, #1]
   177a8:	2301      	movs	r3, #1
   177aa:	9300      	str	r3, [sp, #0]
   177ac:	e004      	b.n	177b8 <_strtol_r+0x40>
   177ae:	9000      	str	r0, [sp, #0]
   177b0:	2c2b      	cmp	r4, #43	; 0x2b
   177b2:	d101      	bne.n	177b8 <_strtol_r+0x40>
   177b4:	785c      	ldrb	r4, [r3, #1]
   177b6:	1c9d      	adds	r5, r3, #2
   177b8:	2e00      	cmp	r6, #0
   177ba:	d002      	beq.n	177c2 <_strtol_r+0x4a>
   177bc:	2e10      	cmp	r6, #16
   177be:	d10a      	bne.n	177d6 <_strtol_r+0x5e>
   177c0:	e060      	b.n	17884 <_strtol_r+0x10c>
   177c2:	2c30      	cmp	r4, #48	; 0x30
   177c4:	d15c      	bne.n	17880 <_strtol_r+0x108>
   177c6:	2220      	movs	r2, #32
   177c8:	782b      	ldrb	r3, [r5, #0]
   177ca:	4393      	bics	r3, r2
   177cc:	2b58      	cmp	r3, #88	; 0x58
   177ce:	d152      	bne.n	17876 <_strtol_r+0xfe>
   177d0:	2610      	movs	r6, #16
   177d2:	786c      	ldrb	r4, [r5, #1]
   177d4:	3502      	adds	r5, #2
   177d6:	9f00      	ldr	r7, [sp, #0]
   177d8:	1c31      	adds	r1, r6, #0
   177da:	1e7b      	subs	r3, r7, #1
   177dc:	419f      	sbcs	r7, r3
   177de:	4b2d      	ldr	r3, [pc, #180]	; (17894 <_strtol_r+0x11c>)
   177e0:	18ff      	adds	r7, r7, r3
   177e2:	1c38      	adds	r0, r7, #0
   177e4:	f7fd fbe0 	bl	14fa8 <__aeabi_uidivmod>
   177e8:	1c38      	adds	r0, r7, #0
   177ea:	9104      	str	r1, [sp, #16]
   177ec:	1c31      	adds	r1, r6, #0
   177ee:	f7fd fb55 	bl	14e9c <__aeabi_uidiv>
   177f2:	2200      	movs	r2, #0
   177f4:	1c07      	adds	r7, r0, #0
   177f6:	1c13      	adds	r3, r2, #0
   177f8:	9902      	ldr	r1, [sp, #8]
   177fa:	1909      	adds	r1, r1, r4
   177fc:	7849      	ldrb	r1, [r1, #1]
   177fe:	0748      	lsls	r0, r1, #29
   17800:	d501      	bpl.n	17806 <_strtol_r+0x8e>
   17802:	3c30      	subs	r4, #48	; 0x30
   17804:	e007      	b.n	17816 <_strtol_r+0x9e>
   17806:	2003      	movs	r0, #3
   17808:	4008      	ands	r0, r1
   1780a:	d017      	beq.n	1783c <_strtol_r+0xc4>
   1780c:	2137      	movs	r1, #55	; 0x37
   1780e:	2801      	cmp	r0, #1
   17810:	d000      	beq.n	17814 <_strtol_r+0x9c>
   17812:	3120      	adds	r1, #32
   17814:	1a64      	subs	r4, r4, r1
   17816:	42b4      	cmp	r4, r6
   17818:	da10      	bge.n	1783c <_strtol_r+0xc4>
   1781a:	1c51      	adds	r1, r2, #1
   1781c:	d00b      	beq.n	17836 <_strtol_r+0xbe>
   1781e:	42bb      	cmp	r3, r7
   17820:	d807      	bhi.n	17832 <_strtol_r+0xba>
   17822:	d102      	bne.n	1782a <_strtol_r+0xb2>
   17824:	9a04      	ldr	r2, [sp, #16]
   17826:	4294      	cmp	r4, r2
   17828:	dc03      	bgt.n	17832 <_strtol_r+0xba>
   1782a:	4373      	muls	r3, r6
   1782c:	2201      	movs	r2, #1
   1782e:	18e3      	adds	r3, r4, r3
   17830:	e001      	b.n	17836 <_strtol_r+0xbe>
   17832:	2201      	movs	r2, #1
   17834:	4252      	negs	r2, r2
   17836:	782c      	ldrb	r4, [r5, #0]
   17838:	3501      	adds	r5, #1
   1783a:	e7dd      	b.n	177f8 <_strtol_r+0x80>
   1783c:	1c18      	adds	r0, r3, #0
   1783e:	1c51      	adds	r1, r2, #1
   17840:	d10b      	bne.n	1785a <_strtol_r+0xe2>
   17842:	9800      	ldr	r0, [sp, #0]
   17844:	9a05      	ldr	r2, [sp, #20]
   17846:	1e43      	subs	r3, r0, #1
   17848:	4198      	sbcs	r0, r3
   1784a:	4b12      	ldr	r3, [pc, #72]	; (17894 <_strtol_r+0x11c>)
   1784c:	18c0      	adds	r0, r0, r3
   1784e:	2322      	movs	r3, #34	; 0x22
   17850:	6013      	str	r3, [r2, #0]
   17852:	9b01      	ldr	r3, [sp, #4]
   17854:	2b00      	cmp	r3, #0
   17856:	d10a      	bne.n	1786e <_strtol_r+0xf6>
   17858:	e017      	b.n	1788a <_strtol_r+0x112>
   1785a:	9900      	ldr	r1, [sp, #0]
   1785c:	2900      	cmp	r1, #0
   1785e:	d000      	beq.n	17862 <_strtol_r+0xea>
   17860:	4258      	negs	r0, r3
   17862:	9b01      	ldr	r3, [sp, #4]
   17864:	2b00      	cmp	r3, #0
   17866:	d010      	beq.n	1788a <_strtol_r+0x112>
   17868:	9b03      	ldr	r3, [sp, #12]
   1786a:	2a00      	cmp	r2, #0
   1786c:	d000      	beq.n	17870 <_strtol_r+0xf8>
   1786e:	1e6b      	subs	r3, r5, #1
   17870:	9a01      	ldr	r2, [sp, #4]
   17872:	6013      	str	r3, [r2, #0]
   17874:	e009      	b.n	1788a <_strtol_r+0x112>
   17876:	2430      	movs	r4, #48	; 0x30
   17878:	2e00      	cmp	r6, #0
   1787a:	d1ac      	bne.n	177d6 <_strtol_r+0x5e>
   1787c:	2608      	movs	r6, #8
   1787e:	e7aa      	b.n	177d6 <_strtol_r+0x5e>
   17880:	260a      	movs	r6, #10
   17882:	e7a8      	b.n	177d6 <_strtol_r+0x5e>
   17884:	2c30      	cmp	r4, #48	; 0x30
   17886:	d1a6      	bne.n	177d6 <_strtol_r+0x5e>
   17888:	e79d      	b.n	177c6 <_strtol_r+0x4e>
   1788a:	b007      	add	sp, #28
   1788c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1788e:	46c0      	nop			; (mov r8, r8)
   17890:	200002f8 	.word	0x200002f8
   17894:	7fffffff 	.word	0x7fffffff

00017898 <strtol>:
   17898:	b538      	push	{r3, r4, r5, lr}
   1789a:	1c05      	adds	r5, r0, #0
   1789c:	1c0c      	adds	r4, r1, #0
   1789e:	1c13      	adds	r3, r2, #0
   178a0:	4a03      	ldr	r2, [pc, #12]	; (178b0 <strtol+0x18>)
   178a2:	1c29      	adds	r1, r5, #0
   178a4:	6810      	ldr	r0, [r2, #0]
   178a6:	1c22      	adds	r2, r4, #0
   178a8:	f7ff ff66 	bl	17778 <_strtol_r>
   178ac:	bd38      	pop	{r3, r4, r5, pc}
   178ae:	46c0      	nop			; (mov r8, r8)
   178b0:	200002f4 	.word	0x200002f4

000178b4 <__get_current_time_locale>:
   178b4:	4b03      	ldr	r3, [pc, #12]	; (178c4 <__get_current_time_locale+0x10>)
   178b6:	4804      	ldr	r0, [pc, #16]	; (178c8 <__get_current_time_locale+0x14>)
   178b8:	681b      	ldr	r3, [r3, #0]
   178ba:	2b00      	cmp	r3, #0
   178bc:	d100      	bne.n	178c0 <__get_current_time_locale+0xc>
   178be:	4803      	ldr	r0, [pc, #12]	; (178cc <__get_current_time_locale+0x18>)
   178c0:	4770      	bx	lr
   178c2:	46c0      	nop			; (mov r8, r8)
   178c4:	200029cc 	.word	0x200029cc
   178c8:	200029d0 	.word	0x200029d0
   178cc:	00021e6c 	.word	0x00021e6c

000178d0 <__swbuf_r>:
   178d0:	b570      	push	{r4, r5, r6, lr}
   178d2:	1c05      	adds	r5, r0, #0
   178d4:	1c0e      	adds	r6, r1, #0
   178d6:	1c14      	adds	r4, r2, #0
   178d8:	2800      	cmp	r0, #0
   178da:	d004      	beq.n	178e6 <__swbuf_r+0x16>
   178dc:	6983      	ldr	r3, [r0, #24]
   178de:	2b00      	cmp	r3, #0
   178e0:	d101      	bne.n	178e6 <__swbuf_r+0x16>
   178e2:	f000 f9bf 	bl	17c64 <__sinit>
   178e6:	4b23      	ldr	r3, [pc, #140]	; (17974 <__swbuf_r+0xa4>)
   178e8:	429c      	cmp	r4, r3
   178ea:	d101      	bne.n	178f0 <__swbuf_r+0x20>
   178ec:	686c      	ldr	r4, [r5, #4]
   178ee:	e008      	b.n	17902 <__swbuf_r+0x32>
   178f0:	4b21      	ldr	r3, [pc, #132]	; (17978 <__swbuf_r+0xa8>)
   178f2:	429c      	cmp	r4, r3
   178f4:	d101      	bne.n	178fa <__swbuf_r+0x2a>
   178f6:	68ac      	ldr	r4, [r5, #8]
   178f8:	e003      	b.n	17902 <__swbuf_r+0x32>
   178fa:	4b20      	ldr	r3, [pc, #128]	; (1797c <__swbuf_r+0xac>)
   178fc:	429c      	cmp	r4, r3
   178fe:	d100      	bne.n	17902 <__swbuf_r+0x32>
   17900:	68ec      	ldr	r4, [r5, #12]
   17902:	69a3      	ldr	r3, [r4, #24]
   17904:	60a3      	str	r3, [r4, #8]
   17906:	89a3      	ldrh	r3, [r4, #12]
   17908:	071b      	lsls	r3, r3, #28
   1790a:	d50a      	bpl.n	17922 <__swbuf_r+0x52>
   1790c:	6923      	ldr	r3, [r4, #16]
   1790e:	2b00      	cmp	r3, #0
   17910:	d007      	beq.n	17922 <__swbuf_r+0x52>
   17912:	6823      	ldr	r3, [r4, #0]
   17914:	6922      	ldr	r2, [r4, #16]
   17916:	b2f6      	uxtb	r6, r6
   17918:	1a98      	subs	r0, r3, r2
   1791a:	6963      	ldr	r3, [r4, #20]
   1791c:	4298      	cmp	r0, r3
   1791e:	db0f      	blt.n	17940 <__swbuf_r+0x70>
   17920:	e008      	b.n	17934 <__swbuf_r+0x64>
   17922:	1c28      	adds	r0, r5, #0
   17924:	1c21      	adds	r1, r4, #0
   17926:	f000 f82b 	bl	17980 <__swsetup_r>
   1792a:	2800      	cmp	r0, #0
   1792c:	d0f1      	beq.n	17912 <__swbuf_r+0x42>
   1792e:	2001      	movs	r0, #1
   17930:	4240      	negs	r0, r0
   17932:	e01d      	b.n	17970 <__swbuf_r+0xa0>
   17934:	1c28      	adds	r0, r5, #0
   17936:	1c21      	adds	r1, r4, #0
   17938:	f000 f926 	bl	17b88 <_fflush_r>
   1793c:	2800      	cmp	r0, #0
   1793e:	d1f6      	bne.n	1792e <__swbuf_r+0x5e>
   17940:	68a3      	ldr	r3, [r4, #8]
   17942:	3001      	adds	r0, #1
   17944:	3b01      	subs	r3, #1
   17946:	60a3      	str	r3, [r4, #8]
   17948:	6823      	ldr	r3, [r4, #0]
   1794a:	1c5a      	adds	r2, r3, #1
   1794c:	6022      	str	r2, [r4, #0]
   1794e:	701e      	strb	r6, [r3, #0]
   17950:	6963      	ldr	r3, [r4, #20]
   17952:	4298      	cmp	r0, r3
   17954:	d005      	beq.n	17962 <__swbuf_r+0x92>
   17956:	89a3      	ldrh	r3, [r4, #12]
   17958:	1c30      	adds	r0, r6, #0
   1795a:	07db      	lsls	r3, r3, #31
   1795c:	d508      	bpl.n	17970 <__swbuf_r+0xa0>
   1795e:	2e0a      	cmp	r6, #10
   17960:	d106      	bne.n	17970 <__swbuf_r+0xa0>
   17962:	1c28      	adds	r0, r5, #0
   17964:	1c21      	adds	r1, r4, #0
   17966:	f000 f90f 	bl	17b88 <_fflush_r>
   1796a:	2800      	cmp	r0, #0
   1796c:	d1df      	bne.n	1792e <__swbuf_r+0x5e>
   1796e:	1c30      	adds	r0, r6, #0
   17970:	bd70      	pop	{r4, r5, r6, pc}
   17972:	46c0      	nop			; (mov r8, r8)
   17974:	0002206c 	.word	0x0002206c
   17978:	0002208c 	.word	0x0002208c
   1797c:	000220ac 	.word	0x000220ac

00017980 <__swsetup_r>:
   17980:	4b35      	ldr	r3, [pc, #212]	; (17a58 <__swsetup_r+0xd8>)
   17982:	b570      	push	{r4, r5, r6, lr}
   17984:	681d      	ldr	r5, [r3, #0]
   17986:	1c06      	adds	r6, r0, #0
   17988:	1c0c      	adds	r4, r1, #0
   1798a:	2d00      	cmp	r5, #0
   1798c:	d005      	beq.n	1799a <__swsetup_r+0x1a>
   1798e:	69ab      	ldr	r3, [r5, #24]
   17990:	2b00      	cmp	r3, #0
   17992:	d102      	bne.n	1799a <__swsetup_r+0x1a>
   17994:	1c28      	adds	r0, r5, #0
   17996:	f000 f965 	bl	17c64 <__sinit>
   1799a:	4b30      	ldr	r3, [pc, #192]	; (17a5c <__swsetup_r+0xdc>)
   1799c:	429c      	cmp	r4, r3
   1799e:	d101      	bne.n	179a4 <__swsetup_r+0x24>
   179a0:	686c      	ldr	r4, [r5, #4]
   179a2:	e008      	b.n	179b6 <__swsetup_r+0x36>
   179a4:	4b2e      	ldr	r3, [pc, #184]	; (17a60 <__swsetup_r+0xe0>)
   179a6:	429c      	cmp	r4, r3
   179a8:	d101      	bne.n	179ae <__swsetup_r+0x2e>
   179aa:	68ac      	ldr	r4, [r5, #8]
   179ac:	e003      	b.n	179b6 <__swsetup_r+0x36>
   179ae:	4b2d      	ldr	r3, [pc, #180]	; (17a64 <__swsetup_r+0xe4>)
   179b0:	429c      	cmp	r4, r3
   179b2:	d100      	bne.n	179b6 <__swsetup_r+0x36>
   179b4:	68ec      	ldr	r4, [r5, #12]
   179b6:	89a3      	ldrh	r3, [r4, #12]
   179b8:	b29a      	uxth	r2, r3
   179ba:	0711      	lsls	r1, r2, #28
   179bc:	d423      	bmi.n	17a06 <__swsetup_r+0x86>
   179be:	06d1      	lsls	r1, r2, #27
   179c0:	d407      	bmi.n	179d2 <__swsetup_r+0x52>
   179c2:	2209      	movs	r2, #9
   179c4:	2001      	movs	r0, #1
   179c6:	6032      	str	r2, [r6, #0]
   179c8:	3237      	adds	r2, #55	; 0x37
   179ca:	4313      	orrs	r3, r2
   179cc:	81a3      	strh	r3, [r4, #12]
   179ce:	4240      	negs	r0, r0
   179d0:	e040      	b.n	17a54 <__swsetup_r+0xd4>
   179d2:	0753      	lsls	r3, r2, #29
   179d4:	d513      	bpl.n	179fe <__swsetup_r+0x7e>
   179d6:	6b61      	ldr	r1, [r4, #52]	; 0x34
   179d8:	2900      	cmp	r1, #0
   179da:	d008      	beq.n	179ee <__swsetup_r+0x6e>
   179dc:	1c23      	adds	r3, r4, #0
   179de:	3344      	adds	r3, #68	; 0x44
   179e0:	4299      	cmp	r1, r3
   179e2:	d002      	beq.n	179ea <__swsetup_r+0x6a>
   179e4:	1c30      	adds	r0, r6, #0
   179e6:	f7fe fecd 	bl	16784 <_free_r>
   179ea:	2300      	movs	r3, #0
   179ec:	6363      	str	r3, [r4, #52]	; 0x34
   179ee:	2224      	movs	r2, #36	; 0x24
   179f0:	89a3      	ldrh	r3, [r4, #12]
   179f2:	4393      	bics	r3, r2
   179f4:	81a3      	strh	r3, [r4, #12]
   179f6:	2300      	movs	r3, #0
   179f8:	6063      	str	r3, [r4, #4]
   179fa:	6923      	ldr	r3, [r4, #16]
   179fc:	6023      	str	r3, [r4, #0]
   179fe:	2208      	movs	r2, #8
   17a00:	89a3      	ldrh	r3, [r4, #12]
   17a02:	4313      	orrs	r3, r2
   17a04:	81a3      	strh	r3, [r4, #12]
   17a06:	6923      	ldr	r3, [r4, #16]
   17a08:	2b00      	cmp	r3, #0
   17a0a:	d10b      	bne.n	17a24 <__swsetup_r+0xa4>
   17a0c:	23a0      	movs	r3, #160	; 0xa0
   17a0e:	89a2      	ldrh	r2, [r4, #12]
   17a10:	009b      	lsls	r3, r3, #2
   17a12:	4013      	ands	r3, r2
   17a14:	2280      	movs	r2, #128	; 0x80
   17a16:	0092      	lsls	r2, r2, #2
   17a18:	4293      	cmp	r3, r2
   17a1a:	d003      	beq.n	17a24 <__swsetup_r+0xa4>
   17a1c:	1c30      	adds	r0, r6, #0
   17a1e:	1c21      	adds	r1, r4, #0
   17a20:	f000 f9b2 	bl	17d88 <__smakebuf_r>
   17a24:	2301      	movs	r3, #1
   17a26:	89a2      	ldrh	r2, [r4, #12]
   17a28:	4013      	ands	r3, r2
   17a2a:	d005      	beq.n	17a38 <__swsetup_r+0xb8>
   17a2c:	2300      	movs	r3, #0
   17a2e:	60a3      	str	r3, [r4, #8]
   17a30:	6963      	ldr	r3, [r4, #20]
   17a32:	425b      	negs	r3, r3
   17a34:	61a3      	str	r3, [r4, #24]
   17a36:	e003      	b.n	17a40 <__swsetup_r+0xc0>
   17a38:	0791      	lsls	r1, r2, #30
   17a3a:	d400      	bmi.n	17a3e <__swsetup_r+0xbe>
   17a3c:	6963      	ldr	r3, [r4, #20]
   17a3e:	60a3      	str	r3, [r4, #8]
   17a40:	2000      	movs	r0, #0
   17a42:	6923      	ldr	r3, [r4, #16]
   17a44:	4283      	cmp	r3, r0
   17a46:	d105      	bne.n	17a54 <__swsetup_r+0xd4>
   17a48:	0613      	lsls	r3, r2, #24
   17a4a:	d503      	bpl.n	17a54 <__swsetup_r+0xd4>
   17a4c:	2340      	movs	r3, #64	; 0x40
   17a4e:	431a      	orrs	r2, r3
   17a50:	81a2      	strh	r2, [r4, #12]
   17a52:	3801      	subs	r0, #1
   17a54:	bd70      	pop	{r4, r5, r6, pc}
   17a56:	46c0      	nop			; (mov r8, r8)
   17a58:	200002f4 	.word	0x200002f4
   17a5c:	0002206c 	.word	0x0002206c
   17a60:	0002208c 	.word	0x0002208c
   17a64:	000220ac 	.word	0x000220ac

00017a68 <abort>:
   17a68:	b508      	push	{r3, lr}
   17a6a:	2006      	movs	r0, #6
   17a6c:	f000 fbc6 	bl	181fc <raise>
   17a70:	2001      	movs	r0, #1
   17a72:	f7fc f8a5 	bl	13bc0 <_exit>

00017a76 <__sflush_r>:
   17a76:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   17a78:	898a      	ldrh	r2, [r1, #12]
   17a7a:	1c05      	adds	r5, r0, #0
   17a7c:	1c0c      	adds	r4, r1, #0
   17a7e:	0713      	lsls	r3, r2, #28
   17a80:	d45e      	bmi.n	17b40 <__sflush_r+0xca>
   17a82:	684b      	ldr	r3, [r1, #4]
   17a84:	2b00      	cmp	r3, #0
   17a86:	dc02      	bgt.n	17a8e <__sflush_r+0x18>
   17a88:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   17a8a:	2b00      	cmp	r3, #0
   17a8c:	dd1a      	ble.n	17ac4 <__sflush_r+0x4e>
   17a8e:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   17a90:	2f00      	cmp	r7, #0
   17a92:	d017      	beq.n	17ac4 <__sflush_r+0x4e>
   17a94:	2300      	movs	r3, #0
   17a96:	682e      	ldr	r6, [r5, #0]
   17a98:	602b      	str	r3, [r5, #0]
   17a9a:	2380      	movs	r3, #128	; 0x80
   17a9c:	015b      	lsls	r3, r3, #5
   17a9e:	401a      	ands	r2, r3
   17aa0:	d001      	beq.n	17aa6 <__sflush_r+0x30>
   17aa2:	6d62      	ldr	r2, [r4, #84]	; 0x54
   17aa4:	e015      	b.n	17ad2 <__sflush_r+0x5c>
   17aa6:	1c28      	adds	r0, r5, #0
   17aa8:	6a21      	ldr	r1, [r4, #32]
   17aaa:	2301      	movs	r3, #1
   17aac:	47b8      	blx	r7
   17aae:	1c02      	adds	r2, r0, #0
   17ab0:	1c43      	adds	r3, r0, #1
   17ab2:	d10e      	bne.n	17ad2 <__sflush_r+0x5c>
   17ab4:	682b      	ldr	r3, [r5, #0]
   17ab6:	2b00      	cmp	r3, #0
   17ab8:	d00b      	beq.n	17ad2 <__sflush_r+0x5c>
   17aba:	2b1d      	cmp	r3, #29
   17abc:	d001      	beq.n	17ac2 <__sflush_r+0x4c>
   17abe:	2b16      	cmp	r3, #22
   17ac0:	d102      	bne.n	17ac8 <__sflush_r+0x52>
   17ac2:	602e      	str	r6, [r5, #0]
   17ac4:	2000      	movs	r0, #0
   17ac6:	e05e      	b.n	17b86 <__sflush_r+0x110>
   17ac8:	2140      	movs	r1, #64	; 0x40
   17aca:	89a3      	ldrh	r3, [r4, #12]
   17acc:	430b      	orrs	r3, r1
   17ace:	81a3      	strh	r3, [r4, #12]
   17ad0:	e059      	b.n	17b86 <__sflush_r+0x110>
   17ad2:	89a3      	ldrh	r3, [r4, #12]
   17ad4:	075b      	lsls	r3, r3, #29
   17ad6:	d506      	bpl.n	17ae6 <__sflush_r+0x70>
   17ad8:	6863      	ldr	r3, [r4, #4]
   17ada:	1ad2      	subs	r2, r2, r3
   17adc:	6b63      	ldr	r3, [r4, #52]	; 0x34
   17ade:	2b00      	cmp	r3, #0
   17ae0:	d001      	beq.n	17ae6 <__sflush_r+0x70>
   17ae2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   17ae4:	1ad2      	subs	r2, r2, r3
   17ae6:	2300      	movs	r3, #0
   17ae8:	1c28      	adds	r0, r5, #0
   17aea:	6a21      	ldr	r1, [r4, #32]
   17aec:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   17aee:	47b8      	blx	r7
   17af0:	89a3      	ldrh	r3, [r4, #12]
   17af2:	1c42      	adds	r2, r0, #1
   17af4:	d106      	bne.n	17b04 <__sflush_r+0x8e>
   17af6:	682a      	ldr	r2, [r5, #0]
   17af8:	2a00      	cmp	r2, #0
   17afa:	d003      	beq.n	17b04 <__sflush_r+0x8e>
   17afc:	2a1d      	cmp	r2, #29
   17afe:	d001      	beq.n	17b04 <__sflush_r+0x8e>
   17b00:	2a16      	cmp	r2, #22
   17b02:	d119      	bne.n	17b38 <__sflush_r+0xc2>
   17b04:	2200      	movs	r2, #0
   17b06:	6062      	str	r2, [r4, #4]
   17b08:	6922      	ldr	r2, [r4, #16]
   17b0a:	6022      	str	r2, [r4, #0]
   17b0c:	04db      	lsls	r3, r3, #19
   17b0e:	d505      	bpl.n	17b1c <__sflush_r+0xa6>
   17b10:	1c43      	adds	r3, r0, #1
   17b12:	d102      	bne.n	17b1a <__sflush_r+0xa4>
   17b14:	682b      	ldr	r3, [r5, #0]
   17b16:	2b00      	cmp	r3, #0
   17b18:	d100      	bne.n	17b1c <__sflush_r+0xa6>
   17b1a:	6560      	str	r0, [r4, #84]	; 0x54
   17b1c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   17b1e:	602e      	str	r6, [r5, #0]
   17b20:	2900      	cmp	r1, #0
   17b22:	d0cf      	beq.n	17ac4 <__sflush_r+0x4e>
   17b24:	1c23      	adds	r3, r4, #0
   17b26:	3344      	adds	r3, #68	; 0x44
   17b28:	4299      	cmp	r1, r3
   17b2a:	d002      	beq.n	17b32 <__sflush_r+0xbc>
   17b2c:	1c28      	adds	r0, r5, #0
   17b2e:	f7fe fe29 	bl	16784 <_free_r>
   17b32:	2000      	movs	r0, #0
   17b34:	6360      	str	r0, [r4, #52]	; 0x34
   17b36:	e026      	b.n	17b86 <__sflush_r+0x110>
   17b38:	2240      	movs	r2, #64	; 0x40
   17b3a:	4313      	orrs	r3, r2
   17b3c:	81a3      	strh	r3, [r4, #12]
   17b3e:	e022      	b.n	17b86 <__sflush_r+0x110>
   17b40:	690f      	ldr	r7, [r1, #16]
   17b42:	2f00      	cmp	r7, #0
   17b44:	d0be      	beq.n	17ac4 <__sflush_r+0x4e>
   17b46:	680b      	ldr	r3, [r1, #0]
   17b48:	600f      	str	r7, [r1, #0]
   17b4a:	1bdb      	subs	r3, r3, r7
   17b4c:	9301      	str	r3, [sp, #4]
   17b4e:	2300      	movs	r3, #0
   17b50:	0792      	lsls	r2, r2, #30
   17b52:	d100      	bne.n	17b56 <__sflush_r+0xe0>
   17b54:	694b      	ldr	r3, [r1, #20]
   17b56:	60a3      	str	r3, [r4, #8]
   17b58:	9b01      	ldr	r3, [sp, #4]
   17b5a:	2b00      	cmp	r3, #0
   17b5c:	ddb2      	ble.n	17ac4 <__sflush_r+0x4e>
   17b5e:	1c28      	adds	r0, r5, #0
   17b60:	6a21      	ldr	r1, [r4, #32]
   17b62:	1c3a      	adds	r2, r7, #0
   17b64:	9b01      	ldr	r3, [sp, #4]
   17b66:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   17b68:	47b0      	blx	r6
   17b6a:	2800      	cmp	r0, #0
   17b6c:	dc06      	bgt.n	17b7c <__sflush_r+0x106>
   17b6e:	2240      	movs	r2, #64	; 0x40
   17b70:	2001      	movs	r0, #1
   17b72:	89a3      	ldrh	r3, [r4, #12]
   17b74:	4240      	negs	r0, r0
   17b76:	4313      	orrs	r3, r2
   17b78:	81a3      	strh	r3, [r4, #12]
   17b7a:	e004      	b.n	17b86 <__sflush_r+0x110>
   17b7c:	9b01      	ldr	r3, [sp, #4]
   17b7e:	183f      	adds	r7, r7, r0
   17b80:	1a1b      	subs	r3, r3, r0
   17b82:	9301      	str	r3, [sp, #4]
   17b84:	e7e8      	b.n	17b58 <__sflush_r+0xe2>
   17b86:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00017b88 <_fflush_r>:
   17b88:	b538      	push	{r3, r4, r5, lr}
   17b8a:	690b      	ldr	r3, [r1, #16]
   17b8c:	1c05      	adds	r5, r0, #0
   17b8e:	1c0c      	adds	r4, r1, #0
   17b90:	2b00      	cmp	r3, #0
   17b92:	d101      	bne.n	17b98 <_fflush_r+0x10>
   17b94:	2000      	movs	r0, #0
   17b96:	e01c      	b.n	17bd2 <_fflush_r+0x4a>
   17b98:	2800      	cmp	r0, #0
   17b9a:	d004      	beq.n	17ba6 <_fflush_r+0x1e>
   17b9c:	6983      	ldr	r3, [r0, #24]
   17b9e:	2b00      	cmp	r3, #0
   17ba0:	d101      	bne.n	17ba6 <_fflush_r+0x1e>
   17ba2:	f000 f85f 	bl	17c64 <__sinit>
   17ba6:	4b0b      	ldr	r3, [pc, #44]	; (17bd4 <_fflush_r+0x4c>)
   17ba8:	429c      	cmp	r4, r3
   17baa:	d101      	bne.n	17bb0 <_fflush_r+0x28>
   17bac:	686c      	ldr	r4, [r5, #4]
   17bae:	e008      	b.n	17bc2 <_fflush_r+0x3a>
   17bb0:	4b09      	ldr	r3, [pc, #36]	; (17bd8 <_fflush_r+0x50>)
   17bb2:	429c      	cmp	r4, r3
   17bb4:	d101      	bne.n	17bba <_fflush_r+0x32>
   17bb6:	68ac      	ldr	r4, [r5, #8]
   17bb8:	e003      	b.n	17bc2 <_fflush_r+0x3a>
   17bba:	4b08      	ldr	r3, [pc, #32]	; (17bdc <_fflush_r+0x54>)
   17bbc:	429c      	cmp	r4, r3
   17bbe:	d100      	bne.n	17bc2 <_fflush_r+0x3a>
   17bc0:	68ec      	ldr	r4, [r5, #12]
   17bc2:	220c      	movs	r2, #12
   17bc4:	5ea3      	ldrsh	r3, [r4, r2]
   17bc6:	2b00      	cmp	r3, #0
   17bc8:	d0e4      	beq.n	17b94 <_fflush_r+0xc>
   17bca:	1c28      	adds	r0, r5, #0
   17bcc:	1c21      	adds	r1, r4, #0
   17bce:	f7ff ff52 	bl	17a76 <__sflush_r>
   17bd2:	bd38      	pop	{r3, r4, r5, pc}
   17bd4:	0002206c 	.word	0x0002206c
   17bd8:	0002208c 	.word	0x0002208c
   17bdc:	000220ac 	.word	0x000220ac

00017be0 <_cleanup_r>:
   17be0:	b508      	push	{r3, lr}
   17be2:	4902      	ldr	r1, [pc, #8]	; (17bec <_cleanup_r+0xc>)
   17be4:	f000 f8ae 	bl	17d44 <_fwalk_reent>
   17be8:	bd08      	pop	{r3, pc}
   17bea:	46c0      	nop			; (mov r8, r8)
   17bec:	00017b89 	.word	0x00017b89

00017bf0 <std.isra.0>:
   17bf0:	2300      	movs	r3, #0
   17bf2:	b510      	push	{r4, lr}
   17bf4:	1c04      	adds	r4, r0, #0
   17bf6:	6003      	str	r3, [r0, #0]
   17bf8:	6043      	str	r3, [r0, #4]
   17bfa:	6083      	str	r3, [r0, #8]
   17bfc:	8181      	strh	r1, [r0, #12]
   17bfe:	6643      	str	r3, [r0, #100]	; 0x64
   17c00:	81c2      	strh	r2, [r0, #14]
   17c02:	6103      	str	r3, [r0, #16]
   17c04:	6143      	str	r3, [r0, #20]
   17c06:	6183      	str	r3, [r0, #24]
   17c08:	1c19      	adds	r1, r3, #0
   17c0a:	2208      	movs	r2, #8
   17c0c:	305c      	adds	r0, #92	; 0x5c
   17c0e:	f7fe fdb0 	bl	16772 <memset>
   17c12:	4b05      	ldr	r3, [pc, #20]	; (17c28 <std.isra.0+0x38>)
   17c14:	6224      	str	r4, [r4, #32]
   17c16:	6263      	str	r3, [r4, #36]	; 0x24
   17c18:	4b04      	ldr	r3, [pc, #16]	; (17c2c <std.isra.0+0x3c>)
   17c1a:	62a3      	str	r3, [r4, #40]	; 0x28
   17c1c:	4b04      	ldr	r3, [pc, #16]	; (17c30 <std.isra.0+0x40>)
   17c1e:	62e3      	str	r3, [r4, #44]	; 0x2c
   17c20:	4b04      	ldr	r3, [pc, #16]	; (17c34 <std.isra.0+0x44>)
   17c22:	6323      	str	r3, [r4, #48]	; 0x30
   17c24:	bd10      	pop	{r4, pc}
   17c26:	46c0      	nop			; (mov r8, r8)
   17c28:	0001823d 	.word	0x0001823d
   17c2c:	00018265 	.word	0x00018265
   17c30:	0001829d 	.word	0x0001829d
   17c34:	000182c9 	.word	0x000182c9

00017c38 <__sfmoreglue>:
   17c38:	b570      	push	{r4, r5, r6, lr}
   17c3a:	2568      	movs	r5, #104	; 0x68
   17c3c:	1e4b      	subs	r3, r1, #1
   17c3e:	435d      	muls	r5, r3
   17c40:	1c0e      	adds	r6, r1, #0
   17c42:	1c29      	adds	r1, r5, #0
   17c44:	3174      	adds	r1, #116	; 0x74
   17c46:	f7fe fde3 	bl	16810 <_malloc_r>
   17c4a:	1e04      	subs	r4, r0, #0
   17c4c:	d008      	beq.n	17c60 <__sfmoreglue+0x28>
   17c4e:	2100      	movs	r1, #0
   17c50:	1c2a      	adds	r2, r5, #0
   17c52:	6001      	str	r1, [r0, #0]
   17c54:	6046      	str	r6, [r0, #4]
   17c56:	300c      	adds	r0, #12
   17c58:	60a0      	str	r0, [r4, #8]
   17c5a:	3268      	adds	r2, #104	; 0x68
   17c5c:	f7fe fd89 	bl	16772 <memset>
   17c60:	1c20      	adds	r0, r4, #0
   17c62:	bd70      	pop	{r4, r5, r6, pc}

00017c64 <__sinit>:
   17c64:	6983      	ldr	r3, [r0, #24]
   17c66:	b513      	push	{r0, r1, r4, lr}
   17c68:	2b00      	cmp	r3, #0
   17c6a:	d128      	bne.n	17cbe <__sinit+0x5a>
   17c6c:	6483      	str	r3, [r0, #72]	; 0x48
   17c6e:	64c3      	str	r3, [r0, #76]	; 0x4c
   17c70:	6503      	str	r3, [r0, #80]	; 0x50
   17c72:	4b13      	ldr	r3, [pc, #76]	; (17cc0 <__sinit+0x5c>)
   17c74:	4a13      	ldr	r2, [pc, #76]	; (17cc4 <__sinit+0x60>)
   17c76:	681b      	ldr	r3, [r3, #0]
   17c78:	6282      	str	r2, [r0, #40]	; 0x28
   17c7a:	9301      	str	r3, [sp, #4]
   17c7c:	4298      	cmp	r0, r3
   17c7e:	d101      	bne.n	17c84 <__sinit+0x20>
   17c80:	2301      	movs	r3, #1
   17c82:	6183      	str	r3, [r0, #24]
   17c84:	1c04      	adds	r4, r0, #0
   17c86:	f000 f81f 	bl	17cc8 <__sfp>
   17c8a:	6060      	str	r0, [r4, #4]
   17c8c:	1c20      	adds	r0, r4, #0
   17c8e:	f000 f81b 	bl	17cc8 <__sfp>
   17c92:	60a0      	str	r0, [r4, #8]
   17c94:	1c20      	adds	r0, r4, #0
   17c96:	f000 f817 	bl	17cc8 <__sfp>
   17c9a:	2104      	movs	r1, #4
   17c9c:	60e0      	str	r0, [r4, #12]
   17c9e:	2200      	movs	r2, #0
   17ca0:	6860      	ldr	r0, [r4, #4]
   17ca2:	f7ff ffa5 	bl	17bf0 <std.isra.0>
   17ca6:	68a0      	ldr	r0, [r4, #8]
   17ca8:	2109      	movs	r1, #9
   17caa:	2201      	movs	r2, #1
   17cac:	f7ff ffa0 	bl	17bf0 <std.isra.0>
   17cb0:	68e0      	ldr	r0, [r4, #12]
   17cb2:	2112      	movs	r1, #18
   17cb4:	2202      	movs	r2, #2
   17cb6:	f7ff ff9b 	bl	17bf0 <std.isra.0>
   17cba:	2301      	movs	r3, #1
   17cbc:	61a3      	str	r3, [r4, #24]
   17cbe:	bd13      	pop	{r0, r1, r4, pc}
   17cc0:	00021cc8 	.word	0x00021cc8
   17cc4:	00017be1 	.word	0x00017be1

00017cc8 <__sfp>:
   17cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17cca:	4b1d      	ldr	r3, [pc, #116]	; (17d40 <__sfp+0x78>)
   17ccc:	1c06      	adds	r6, r0, #0
   17cce:	681d      	ldr	r5, [r3, #0]
   17cd0:	69ab      	ldr	r3, [r5, #24]
   17cd2:	2b00      	cmp	r3, #0
   17cd4:	d102      	bne.n	17cdc <__sfp+0x14>
   17cd6:	1c28      	adds	r0, r5, #0
   17cd8:	f7ff ffc4 	bl	17c64 <__sinit>
   17cdc:	3548      	adds	r5, #72	; 0x48
   17cde:	68ac      	ldr	r4, [r5, #8]
   17ce0:	686b      	ldr	r3, [r5, #4]
   17ce2:	3b01      	subs	r3, #1
   17ce4:	d405      	bmi.n	17cf2 <__sfp+0x2a>
   17ce6:	220c      	movs	r2, #12
   17ce8:	5ea7      	ldrsh	r7, [r4, r2]
   17cea:	2f00      	cmp	r7, #0
   17cec:	d010      	beq.n	17d10 <__sfp+0x48>
   17cee:	3468      	adds	r4, #104	; 0x68
   17cf0:	e7f7      	b.n	17ce2 <__sfp+0x1a>
   17cf2:	682b      	ldr	r3, [r5, #0]
   17cf4:	2b00      	cmp	r3, #0
   17cf6:	d106      	bne.n	17d06 <__sfp+0x3e>
   17cf8:	1c30      	adds	r0, r6, #0
   17cfa:	2104      	movs	r1, #4
   17cfc:	f7ff ff9c 	bl	17c38 <__sfmoreglue>
   17d00:	6028      	str	r0, [r5, #0]
   17d02:	2800      	cmp	r0, #0
   17d04:	d001      	beq.n	17d0a <__sfp+0x42>
   17d06:	682d      	ldr	r5, [r5, #0]
   17d08:	e7e9      	b.n	17cde <__sfp+0x16>
   17d0a:	230c      	movs	r3, #12
   17d0c:	6033      	str	r3, [r6, #0]
   17d0e:	e016      	b.n	17d3e <__sfp+0x76>
   17d10:	2301      	movs	r3, #1
   17d12:	1c20      	adds	r0, r4, #0
   17d14:	425b      	negs	r3, r3
   17d16:	81e3      	strh	r3, [r4, #14]
   17d18:	3302      	adds	r3, #2
   17d1a:	81a3      	strh	r3, [r4, #12]
   17d1c:	6667      	str	r7, [r4, #100]	; 0x64
   17d1e:	6027      	str	r7, [r4, #0]
   17d20:	60a7      	str	r7, [r4, #8]
   17d22:	6067      	str	r7, [r4, #4]
   17d24:	6127      	str	r7, [r4, #16]
   17d26:	6167      	str	r7, [r4, #20]
   17d28:	61a7      	str	r7, [r4, #24]
   17d2a:	305c      	adds	r0, #92	; 0x5c
   17d2c:	1c39      	adds	r1, r7, #0
   17d2e:	2208      	movs	r2, #8
   17d30:	f7fe fd1f 	bl	16772 <memset>
   17d34:	1c20      	adds	r0, r4, #0
   17d36:	6367      	str	r7, [r4, #52]	; 0x34
   17d38:	63a7      	str	r7, [r4, #56]	; 0x38
   17d3a:	64a7      	str	r7, [r4, #72]	; 0x48
   17d3c:	64e7      	str	r7, [r4, #76]	; 0x4c
   17d3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17d40:	00021cc8 	.word	0x00021cc8

00017d44 <_fwalk_reent>:
   17d44:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   17d46:	1c04      	adds	r4, r0, #0
   17d48:	1c07      	adds	r7, r0, #0
   17d4a:	2600      	movs	r6, #0
   17d4c:	9101      	str	r1, [sp, #4]
   17d4e:	3448      	adds	r4, #72	; 0x48
   17d50:	2c00      	cmp	r4, #0
   17d52:	d016      	beq.n	17d82 <_fwalk_reent+0x3e>
   17d54:	6863      	ldr	r3, [r4, #4]
   17d56:	68a5      	ldr	r5, [r4, #8]
   17d58:	9300      	str	r3, [sp, #0]
   17d5a:	9b00      	ldr	r3, [sp, #0]
   17d5c:	3b01      	subs	r3, #1
   17d5e:	9300      	str	r3, [sp, #0]
   17d60:	d40d      	bmi.n	17d7e <_fwalk_reent+0x3a>
   17d62:	89ab      	ldrh	r3, [r5, #12]
   17d64:	2b01      	cmp	r3, #1
   17d66:	d908      	bls.n	17d7a <_fwalk_reent+0x36>
   17d68:	220e      	movs	r2, #14
   17d6a:	5eab      	ldrsh	r3, [r5, r2]
   17d6c:	3301      	adds	r3, #1
   17d6e:	d004      	beq.n	17d7a <_fwalk_reent+0x36>
   17d70:	1c38      	adds	r0, r7, #0
   17d72:	1c29      	adds	r1, r5, #0
   17d74:	9b01      	ldr	r3, [sp, #4]
   17d76:	4798      	blx	r3
   17d78:	4306      	orrs	r6, r0
   17d7a:	3568      	adds	r5, #104	; 0x68
   17d7c:	e7ed      	b.n	17d5a <_fwalk_reent+0x16>
   17d7e:	6824      	ldr	r4, [r4, #0]
   17d80:	e7e6      	b.n	17d50 <_fwalk_reent+0xc>
   17d82:	1c30      	adds	r0, r6, #0
   17d84:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00017d88 <__smakebuf_r>:
   17d88:	b5f0      	push	{r4, r5, r6, r7, lr}
   17d8a:	898b      	ldrh	r3, [r1, #12]
   17d8c:	b091      	sub	sp, #68	; 0x44
   17d8e:	079b      	lsls	r3, r3, #30
   17d90:	d506      	bpl.n	17da0 <__smakebuf_r+0x18>
   17d92:	1c0b      	adds	r3, r1, #0
   17d94:	3347      	adds	r3, #71	; 0x47
   17d96:	600b      	str	r3, [r1, #0]
   17d98:	610b      	str	r3, [r1, #16]
   17d9a:	2301      	movs	r3, #1
   17d9c:	614b      	str	r3, [r1, #20]
   17d9e:	e045      	b.n	17e2c <__smakebuf_r+0xa4>
   17da0:	1c0c      	adds	r4, r1, #0
   17da2:	230e      	movs	r3, #14
   17da4:	5ec9      	ldrsh	r1, [r1, r3]
   17da6:	1c06      	adds	r6, r0, #0
   17da8:	2900      	cmp	r1, #0
   17daa:	da04      	bge.n	17db6 <__smakebuf_r+0x2e>
   17dac:	2380      	movs	r3, #128	; 0x80
   17dae:	89a5      	ldrh	r5, [r4, #12]
   17db0:	401d      	ands	r5, r3
   17db2:	d110      	bne.n	17dd6 <__smakebuf_r+0x4e>
   17db4:	e00c      	b.n	17dd0 <__smakebuf_r+0x48>
   17db6:	aa01      	add	r2, sp, #4
   17db8:	f000 fad8 	bl	1836c <_fstat_r>
   17dbc:	2800      	cmp	r0, #0
   17dbe:	dbf5      	blt.n	17dac <__smakebuf_r+0x24>
   17dc0:	23f0      	movs	r3, #240	; 0xf0
   17dc2:	9d02      	ldr	r5, [sp, #8]
   17dc4:	021b      	lsls	r3, r3, #8
   17dc6:	401d      	ands	r5, r3
   17dc8:	4b19      	ldr	r3, [pc, #100]	; (17e30 <__smakebuf_r+0xa8>)
   17dca:	18ed      	adds	r5, r5, r3
   17dcc:	426b      	negs	r3, r5
   17dce:	415d      	adcs	r5, r3
   17dd0:	2780      	movs	r7, #128	; 0x80
   17dd2:	00ff      	lsls	r7, r7, #3
   17dd4:	e001      	b.n	17dda <__smakebuf_r+0x52>
   17dd6:	2500      	movs	r5, #0
   17dd8:	2740      	movs	r7, #64	; 0x40
   17dda:	1c30      	adds	r0, r6, #0
   17ddc:	1c39      	adds	r1, r7, #0
   17dde:	f7fe fd17 	bl	16810 <_malloc_r>
   17de2:	2800      	cmp	r0, #0
   17de4:	d10c      	bne.n	17e00 <__smakebuf_r+0x78>
   17de6:	89a3      	ldrh	r3, [r4, #12]
   17de8:	059a      	lsls	r2, r3, #22
   17dea:	d41f      	bmi.n	17e2c <__smakebuf_r+0xa4>
   17dec:	2202      	movs	r2, #2
   17dee:	4313      	orrs	r3, r2
   17df0:	81a3      	strh	r3, [r4, #12]
   17df2:	1c23      	adds	r3, r4, #0
   17df4:	3347      	adds	r3, #71	; 0x47
   17df6:	6023      	str	r3, [r4, #0]
   17df8:	6123      	str	r3, [r4, #16]
   17dfa:	2301      	movs	r3, #1
   17dfc:	6163      	str	r3, [r4, #20]
   17dfe:	e015      	b.n	17e2c <__smakebuf_r+0xa4>
   17e00:	2280      	movs	r2, #128	; 0x80
   17e02:	4b0c      	ldr	r3, [pc, #48]	; (17e34 <__smakebuf_r+0xac>)
   17e04:	62b3      	str	r3, [r6, #40]	; 0x28
   17e06:	89a3      	ldrh	r3, [r4, #12]
   17e08:	6020      	str	r0, [r4, #0]
   17e0a:	4313      	orrs	r3, r2
   17e0c:	81a3      	strh	r3, [r4, #12]
   17e0e:	6120      	str	r0, [r4, #16]
   17e10:	6167      	str	r7, [r4, #20]
   17e12:	2d00      	cmp	r5, #0
   17e14:	d00a      	beq.n	17e2c <__smakebuf_r+0xa4>
   17e16:	230e      	movs	r3, #14
   17e18:	5ee1      	ldrsh	r1, [r4, r3]
   17e1a:	1c30      	adds	r0, r6, #0
   17e1c:	f000 fab8 	bl	18390 <_isatty_r>
   17e20:	2800      	cmp	r0, #0
   17e22:	d003      	beq.n	17e2c <__smakebuf_r+0xa4>
   17e24:	2201      	movs	r2, #1
   17e26:	89a3      	ldrh	r3, [r4, #12]
   17e28:	4313      	orrs	r3, r2
   17e2a:	81a3      	strh	r3, [r4, #12]
   17e2c:	b011      	add	sp, #68	; 0x44
   17e2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17e30:	ffffe000 	.word	0xffffe000
   17e34:	00017be1 	.word	0x00017be1

00017e38 <_realloc_r>:
   17e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17e3a:	1c06      	adds	r6, r0, #0
   17e3c:	1c0c      	adds	r4, r1, #0
   17e3e:	1c15      	adds	r5, r2, #0
   17e40:	2900      	cmp	r1, #0
   17e42:	d104      	bne.n	17e4e <_realloc_r+0x16>
   17e44:	1c11      	adds	r1, r2, #0
   17e46:	f7fe fce3 	bl	16810 <_malloc_r>
   17e4a:	1c04      	adds	r4, r0, #0
   17e4c:	e018      	b.n	17e80 <_realloc_r+0x48>
   17e4e:	2a00      	cmp	r2, #0
   17e50:	d103      	bne.n	17e5a <_realloc_r+0x22>
   17e52:	f7fe fc97 	bl	16784 <_free_r>
   17e56:	1c2c      	adds	r4, r5, #0
   17e58:	e012      	b.n	17e80 <_realloc_r+0x48>
   17e5a:	f000 fabf 	bl	183dc <_malloc_usable_size_r>
   17e5e:	42a8      	cmp	r0, r5
   17e60:	d20e      	bcs.n	17e80 <_realloc_r+0x48>
   17e62:	1c30      	adds	r0, r6, #0
   17e64:	1c29      	adds	r1, r5, #0
   17e66:	f7fe fcd3 	bl	16810 <_malloc_r>
   17e6a:	1e07      	subs	r7, r0, #0
   17e6c:	d007      	beq.n	17e7e <_realloc_r+0x46>
   17e6e:	1c21      	adds	r1, r4, #0
   17e70:	1c2a      	adds	r2, r5, #0
   17e72:	f7fe fc61 	bl	16738 <memcpy>
   17e76:	1c30      	adds	r0, r6, #0
   17e78:	1c21      	adds	r1, r4, #0
   17e7a:	f7fe fc83 	bl	16784 <_free_r>
   17e7e:	1c3c      	adds	r4, r7, #0
   17e80:	1c20      	adds	r0, r4, #0
   17e82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00017e84 <__ssputs_r>:
   17e84:	b5f0      	push	{r4, r5, r6, r7, lr}
   17e86:	688e      	ldr	r6, [r1, #8]
   17e88:	b085      	sub	sp, #20
   17e8a:	1c07      	adds	r7, r0, #0
   17e8c:	1c0c      	adds	r4, r1, #0
   17e8e:	9203      	str	r2, [sp, #12]
   17e90:	9301      	str	r3, [sp, #4]
   17e92:	42b3      	cmp	r3, r6
   17e94:	d345      	bcc.n	17f22 <__ssputs_r+0x9e>
   17e96:	2390      	movs	r3, #144	; 0x90
   17e98:	898a      	ldrh	r2, [r1, #12]
   17e9a:	00db      	lsls	r3, r3, #3
   17e9c:	421a      	tst	r2, r3
   17e9e:	d03d      	beq.n	17f1c <__ssputs_r+0x98>
   17ea0:	2503      	movs	r5, #3
   17ea2:	6909      	ldr	r1, [r1, #16]
   17ea4:	6823      	ldr	r3, [r4, #0]
   17ea6:	9801      	ldr	r0, [sp, #4]
   17ea8:	1a5b      	subs	r3, r3, r1
   17eaa:	9302      	str	r3, [sp, #8]
   17eac:	6963      	ldr	r3, [r4, #20]
   17eae:	435d      	muls	r5, r3
   17eb0:	0feb      	lsrs	r3, r5, #31
   17eb2:	195d      	adds	r5, r3, r5
   17eb4:	9b02      	ldr	r3, [sp, #8]
   17eb6:	106d      	asrs	r5, r5, #1
   17eb8:	3301      	adds	r3, #1
   17eba:	181b      	adds	r3, r3, r0
   17ebc:	429d      	cmp	r5, r3
   17ebe:	d200      	bcs.n	17ec2 <__ssputs_r+0x3e>
   17ec0:	1c1d      	adds	r5, r3, #0
   17ec2:	1c38      	adds	r0, r7, #0
   17ec4:	0553      	lsls	r3, r2, #21
   17ec6:	d50f      	bpl.n	17ee8 <__ssputs_r+0x64>
   17ec8:	1c29      	adds	r1, r5, #0
   17eca:	f7fe fca1 	bl	16810 <_malloc_r>
   17ece:	1e06      	subs	r6, r0, #0
   17ed0:	d013      	beq.n	17efa <__ssputs_r+0x76>
   17ed2:	9a02      	ldr	r2, [sp, #8]
   17ed4:	6921      	ldr	r1, [r4, #16]
   17ed6:	f7fe fc2f 	bl	16738 <memcpy>
   17eda:	89a2      	ldrh	r2, [r4, #12]
   17edc:	4b18      	ldr	r3, [pc, #96]	; (17f40 <__ssputs_r+0xbc>)
   17ede:	4013      	ands	r3, r2
   17ee0:	2280      	movs	r2, #128	; 0x80
   17ee2:	4313      	orrs	r3, r2
   17ee4:	81a3      	strh	r3, [r4, #12]
   17ee6:	e011      	b.n	17f0c <__ssputs_r+0x88>
   17ee8:	1c2a      	adds	r2, r5, #0
   17eea:	f7ff ffa5 	bl	17e38 <_realloc_r>
   17eee:	1e06      	subs	r6, r0, #0
   17ef0:	d10c      	bne.n	17f0c <__ssputs_r+0x88>
   17ef2:	1c38      	adds	r0, r7, #0
   17ef4:	6921      	ldr	r1, [r4, #16]
   17ef6:	f7fe fc45 	bl	16784 <_free_r>
   17efa:	230c      	movs	r3, #12
   17efc:	2240      	movs	r2, #64	; 0x40
   17efe:	2001      	movs	r0, #1
   17f00:	603b      	str	r3, [r7, #0]
   17f02:	89a3      	ldrh	r3, [r4, #12]
   17f04:	4240      	negs	r0, r0
   17f06:	4313      	orrs	r3, r2
   17f08:	81a3      	strh	r3, [r4, #12]
   17f0a:	e017      	b.n	17f3c <__ssputs_r+0xb8>
   17f0c:	9b02      	ldr	r3, [sp, #8]
   17f0e:	6126      	str	r6, [r4, #16]
   17f10:	18f6      	adds	r6, r6, r3
   17f12:	6026      	str	r6, [r4, #0]
   17f14:	6165      	str	r5, [r4, #20]
   17f16:	9e01      	ldr	r6, [sp, #4]
   17f18:	1aed      	subs	r5, r5, r3
   17f1a:	60a5      	str	r5, [r4, #8]
   17f1c:	9b01      	ldr	r3, [sp, #4]
   17f1e:	42b3      	cmp	r3, r6
   17f20:	d200      	bcs.n	17f24 <__ssputs_r+0xa0>
   17f22:	9e01      	ldr	r6, [sp, #4]
   17f24:	1c32      	adds	r2, r6, #0
   17f26:	6820      	ldr	r0, [r4, #0]
   17f28:	9903      	ldr	r1, [sp, #12]
   17f2a:	f7fe fc0e 	bl	1674a <memmove>
   17f2e:	2000      	movs	r0, #0
   17f30:	68a3      	ldr	r3, [r4, #8]
   17f32:	1b9b      	subs	r3, r3, r6
   17f34:	60a3      	str	r3, [r4, #8]
   17f36:	6823      	ldr	r3, [r4, #0]
   17f38:	199e      	adds	r6, r3, r6
   17f3a:	6026      	str	r6, [r4, #0]
   17f3c:	b005      	add	sp, #20
   17f3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17f40:	fffffb7f 	.word	0xfffffb7f

00017f44 <_svfiprintf_r>:
   17f44:	b5f0      	push	{r4, r5, r6, r7, lr}
   17f46:	b09f      	sub	sp, #124	; 0x7c
   17f48:	9002      	str	r0, [sp, #8]
   17f4a:	9305      	str	r3, [sp, #20]
   17f4c:	898b      	ldrh	r3, [r1, #12]
   17f4e:	1c0e      	adds	r6, r1, #0
   17f50:	1c17      	adds	r7, r2, #0
   17f52:	061b      	lsls	r3, r3, #24
   17f54:	d510      	bpl.n	17f78 <_svfiprintf_r+0x34>
   17f56:	690b      	ldr	r3, [r1, #16]
   17f58:	2b00      	cmp	r3, #0
   17f5a:	d10d      	bne.n	17f78 <_svfiprintf_r+0x34>
   17f5c:	2140      	movs	r1, #64	; 0x40
   17f5e:	f7fe fc57 	bl	16810 <_malloc_r>
   17f62:	6030      	str	r0, [r6, #0]
   17f64:	6130      	str	r0, [r6, #16]
   17f66:	2800      	cmp	r0, #0
   17f68:	d104      	bne.n	17f74 <_svfiprintf_r+0x30>
   17f6a:	230c      	movs	r3, #12
   17f6c:	9a02      	ldr	r2, [sp, #8]
   17f6e:	3801      	subs	r0, #1
   17f70:	6013      	str	r3, [r2, #0]
   17f72:	e0d0      	b.n	18116 <_svfiprintf_r+0x1d2>
   17f74:	2340      	movs	r3, #64	; 0x40
   17f76:	6173      	str	r3, [r6, #20]
   17f78:	2300      	movs	r3, #0
   17f7a:	ad06      	add	r5, sp, #24
   17f7c:	616b      	str	r3, [r5, #20]
   17f7e:	3320      	adds	r3, #32
   17f80:	766b      	strb	r3, [r5, #25]
   17f82:	3310      	adds	r3, #16
   17f84:	76ab      	strb	r3, [r5, #26]
   17f86:	1c3c      	adds	r4, r7, #0
   17f88:	7823      	ldrb	r3, [r4, #0]
   17f8a:	2b00      	cmp	r3, #0
   17f8c:	d103      	bne.n	17f96 <_svfiprintf_r+0x52>
   17f8e:	1be3      	subs	r3, r4, r7
   17f90:	9304      	str	r3, [sp, #16]
   17f92:	d012      	beq.n	17fba <_svfiprintf_r+0x76>
   17f94:	e003      	b.n	17f9e <_svfiprintf_r+0x5a>
   17f96:	2b25      	cmp	r3, #37	; 0x25
   17f98:	d0f9      	beq.n	17f8e <_svfiprintf_r+0x4a>
   17f9a:	3401      	adds	r4, #1
   17f9c:	e7f4      	b.n	17f88 <_svfiprintf_r+0x44>
   17f9e:	9b04      	ldr	r3, [sp, #16]
   17fa0:	9802      	ldr	r0, [sp, #8]
   17fa2:	1c31      	adds	r1, r6, #0
   17fa4:	1c3a      	adds	r2, r7, #0
   17fa6:	f7ff ff6d 	bl	17e84 <__ssputs_r>
   17faa:	1c43      	adds	r3, r0, #1
   17fac:	d100      	bne.n	17fb0 <_svfiprintf_r+0x6c>
   17fae:	e0ac      	b.n	1810a <_svfiprintf_r+0x1c6>
   17fb0:	696a      	ldr	r2, [r5, #20]
   17fb2:	9b04      	ldr	r3, [sp, #16]
   17fb4:	4694      	mov	ip, r2
   17fb6:	4463      	add	r3, ip
   17fb8:	616b      	str	r3, [r5, #20]
   17fba:	7823      	ldrb	r3, [r4, #0]
   17fbc:	2b00      	cmp	r3, #0
   17fbe:	d100      	bne.n	17fc2 <_svfiprintf_r+0x7e>
   17fc0:	e0a3      	b.n	1810a <_svfiprintf_r+0x1c6>
   17fc2:	2201      	movs	r2, #1
   17fc4:	2300      	movs	r3, #0
   17fc6:	4252      	negs	r2, r2
   17fc8:	606a      	str	r2, [r5, #4]
   17fca:	a902      	add	r1, sp, #8
   17fcc:	3254      	adds	r2, #84	; 0x54
   17fce:	1852      	adds	r2, r2, r1
   17fd0:	3401      	adds	r4, #1
   17fd2:	602b      	str	r3, [r5, #0]
   17fd4:	60eb      	str	r3, [r5, #12]
   17fd6:	60ab      	str	r3, [r5, #8]
   17fd8:	7013      	strb	r3, [r2, #0]
   17fda:	65ab      	str	r3, [r5, #88]	; 0x58
   17fdc:	4f4f      	ldr	r7, [pc, #316]	; (1811c <_svfiprintf_r+0x1d8>)
   17fde:	7821      	ldrb	r1, [r4, #0]
   17fe0:	1c38      	adds	r0, r7, #0
   17fe2:	2205      	movs	r2, #5
   17fe4:	f7fe fb8e 	bl	16704 <memchr>
   17fe8:	2800      	cmp	r0, #0
   17fea:	d008      	beq.n	17ffe <_svfiprintf_r+0xba>
   17fec:	1bc0      	subs	r0, r0, r7
   17fee:	2701      	movs	r7, #1
   17ff0:	4087      	lsls	r7, r0
   17ff2:	1c38      	adds	r0, r7, #0
   17ff4:	682b      	ldr	r3, [r5, #0]
   17ff6:	3401      	adds	r4, #1
   17ff8:	4318      	orrs	r0, r3
   17ffa:	6028      	str	r0, [r5, #0]
   17ffc:	e7ee      	b.n	17fdc <_svfiprintf_r+0x98>
   17ffe:	682b      	ldr	r3, [r5, #0]
   18000:	06da      	lsls	r2, r3, #27
   18002:	d504      	bpl.n	1800e <_svfiprintf_r+0xca>
   18004:	2253      	movs	r2, #83	; 0x53
   18006:	2120      	movs	r1, #32
   18008:	a802      	add	r0, sp, #8
   1800a:	1812      	adds	r2, r2, r0
   1800c:	7011      	strb	r1, [r2, #0]
   1800e:	071a      	lsls	r2, r3, #28
   18010:	d504      	bpl.n	1801c <_svfiprintf_r+0xd8>
   18012:	2253      	movs	r2, #83	; 0x53
   18014:	212b      	movs	r1, #43	; 0x2b
   18016:	a802      	add	r0, sp, #8
   18018:	1812      	adds	r2, r2, r0
   1801a:	7011      	strb	r1, [r2, #0]
   1801c:	7822      	ldrb	r2, [r4, #0]
   1801e:	2a2a      	cmp	r2, #42	; 0x2a
   18020:	d001      	beq.n	18026 <_svfiprintf_r+0xe2>
   18022:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18024:	e00e      	b.n	18044 <_svfiprintf_r+0x100>
   18026:	9a05      	ldr	r2, [sp, #20]
   18028:	1d11      	adds	r1, r2, #4
   1802a:	6812      	ldr	r2, [r2, #0]
   1802c:	9105      	str	r1, [sp, #20]
   1802e:	2a00      	cmp	r2, #0
   18030:	db01      	blt.n	18036 <_svfiprintf_r+0xf2>
   18032:	9209      	str	r2, [sp, #36]	; 0x24
   18034:	e004      	b.n	18040 <_svfiprintf_r+0xfc>
   18036:	4252      	negs	r2, r2
   18038:	60ea      	str	r2, [r5, #12]
   1803a:	2202      	movs	r2, #2
   1803c:	4313      	orrs	r3, r2
   1803e:	602b      	str	r3, [r5, #0]
   18040:	3401      	adds	r4, #1
   18042:	e009      	b.n	18058 <_svfiprintf_r+0x114>
   18044:	7822      	ldrb	r2, [r4, #0]
   18046:	3a30      	subs	r2, #48	; 0x30
   18048:	2a09      	cmp	r2, #9
   1804a:	d804      	bhi.n	18056 <_svfiprintf_r+0x112>
   1804c:	210a      	movs	r1, #10
   1804e:	434b      	muls	r3, r1
   18050:	3401      	adds	r4, #1
   18052:	189b      	adds	r3, r3, r2
   18054:	e7f6      	b.n	18044 <_svfiprintf_r+0x100>
   18056:	9309      	str	r3, [sp, #36]	; 0x24
   18058:	7823      	ldrb	r3, [r4, #0]
   1805a:	2b2e      	cmp	r3, #46	; 0x2e
   1805c:	d118      	bne.n	18090 <_svfiprintf_r+0x14c>
   1805e:	7863      	ldrb	r3, [r4, #1]
   18060:	2b2a      	cmp	r3, #42	; 0x2a
   18062:	d109      	bne.n	18078 <_svfiprintf_r+0x134>
   18064:	9b05      	ldr	r3, [sp, #20]
   18066:	3402      	adds	r4, #2
   18068:	1d1a      	adds	r2, r3, #4
   1806a:	681b      	ldr	r3, [r3, #0]
   1806c:	9205      	str	r2, [sp, #20]
   1806e:	2b00      	cmp	r3, #0
   18070:	da0d      	bge.n	1808e <_svfiprintf_r+0x14a>
   18072:	2301      	movs	r3, #1
   18074:	425b      	negs	r3, r3
   18076:	e00a      	b.n	1808e <_svfiprintf_r+0x14a>
   18078:	2300      	movs	r3, #0
   1807a:	3401      	adds	r4, #1
   1807c:	7822      	ldrb	r2, [r4, #0]
   1807e:	3a30      	subs	r2, #48	; 0x30
   18080:	2a09      	cmp	r2, #9
   18082:	d804      	bhi.n	1808e <_svfiprintf_r+0x14a>
   18084:	210a      	movs	r1, #10
   18086:	434b      	muls	r3, r1
   18088:	3401      	adds	r4, #1
   1808a:	189b      	adds	r3, r3, r2
   1808c:	e7f6      	b.n	1807c <_svfiprintf_r+0x138>
   1808e:	9307      	str	r3, [sp, #28]
   18090:	4f23      	ldr	r7, [pc, #140]	; (18120 <_svfiprintf_r+0x1dc>)
   18092:	7821      	ldrb	r1, [r4, #0]
   18094:	1c38      	adds	r0, r7, #0
   18096:	2203      	movs	r2, #3
   18098:	f7fe fb34 	bl	16704 <memchr>
   1809c:	2800      	cmp	r0, #0
   1809e:	d007      	beq.n	180b0 <_svfiprintf_r+0x16c>
   180a0:	1bc0      	subs	r0, r0, r7
   180a2:	2740      	movs	r7, #64	; 0x40
   180a4:	4087      	lsls	r7, r0
   180a6:	1c38      	adds	r0, r7, #0
   180a8:	682b      	ldr	r3, [r5, #0]
   180aa:	3401      	adds	r4, #1
   180ac:	4318      	orrs	r0, r3
   180ae:	6028      	str	r0, [r5, #0]
   180b0:	7821      	ldrb	r1, [r4, #0]
   180b2:	481c      	ldr	r0, [pc, #112]	; (18124 <_svfiprintf_r+0x1e0>)
   180b4:	2206      	movs	r2, #6
   180b6:	1c67      	adds	r7, r4, #1
   180b8:	7629      	strb	r1, [r5, #24]
   180ba:	f7fe fb23 	bl	16704 <memchr>
   180be:	2800      	cmp	r0, #0
   180c0:	d012      	beq.n	180e8 <_svfiprintf_r+0x1a4>
   180c2:	4b19      	ldr	r3, [pc, #100]	; (18128 <_svfiprintf_r+0x1e4>)
   180c4:	2b00      	cmp	r3, #0
   180c6:	d106      	bne.n	180d6 <_svfiprintf_r+0x192>
   180c8:	2207      	movs	r2, #7
   180ca:	9b05      	ldr	r3, [sp, #20]
   180cc:	3307      	adds	r3, #7
   180ce:	4393      	bics	r3, r2
   180d0:	3308      	adds	r3, #8
   180d2:	9305      	str	r3, [sp, #20]
   180d4:	e014      	b.n	18100 <_svfiprintf_r+0x1bc>
   180d6:	ab05      	add	r3, sp, #20
   180d8:	9300      	str	r3, [sp, #0]
   180da:	9802      	ldr	r0, [sp, #8]
   180dc:	1c29      	adds	r1, r5, #0
   180de:	1c32      	adds	r2, r6, #0
   180e0:	4b12      	ldr	r3, [pc, #72]	; (1812c <_svfiprintf_r+0x1e8>)
   180e2:	e000      	b.n	180e6 <_svfiprintf_r+0x1a2>
   180e4:	bf00      	nop
   180e6:	e007      	b.n	180f8 <_svfiprintf_r+0x1b4>
   180e8:	ab05      	add	r3, sp, #20
   180ea:	9300      	str	r3, [sp, #0]
   180ec:	9802      	ldr	r0, [sp, #8]
   180ee:	1c29      	adds	r1, r5, #0
   180f0:	1c32      	adds	r2, r6, #0
   180f2:	4b0e      	ldr	r3, [pc, #56]	; (1812c <_svfiprintf_r+0x1e8>)
   180f4:	f7fe fd8a 	bl	16c0c <_printf_i>
   180f8:	9003      	str	r0, [sp, #12]
   180fa:	9b03      	ldr	r3, [sp, #12]
   180fc:	3301      	adds	r3, #1
   180fe:	d004      	beq.n	1810a <_svfiprintf_r+0x1c6>
   18100:	696b      	ldr	r3, [r5, #20]
   18102:	9a03      	ldr	r2, [sp, #12]
   18104:	189b      	adds	r3, r3, r2
   18106:	616b      	str	r3, [r5, #20]
   18108:	e73d      	b.n	17f86 <_svfiprintf_r+0x42>
   1810a:	89b3      	ldrh	r3, [r6, #12]
   1810c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1810e:	065b      	lsls	r3, r3, #25
   18110:	d501      	bpl.n	18116 <_svfiprintf_r+0x1d2>
   18112:	2001      	movs	r0, #1
   18114:	4240      	negs	r0, r0
   18116:	b01f      	add	sp, #124	; 0x7c
   18118:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1811a:	46c0      	nop			; (mov r8, r8)
   1811c:	00021ccc 	.word	0x00021ccc
   18120:	00021cd2 	.word	0x00021cd2
   18124:	00021cd6 	.word	0x00021cd6
   18128:	00000000 	.word	0x00000000
   1812c:	00017e85 	.word	0x00017e85

00018130 <_putc_r>:
   18130:	b570      	push	{r4, r5, r6, lr}
   18132:	1c05      	adds	r5, r0, #0
   18134:	1c0e      	adds	r6, r1, #0
   18136:	1c14      	adds	r4, r2, #0
   18138:	2800      	cmp	r0, #0
   1813a:	d004      	beq.n	18146 <_putc_r+0x16>
   1813c:	6983      	ldr	r3, [r0, #24]
   1813e:	2b00      	cmp	r3, #0
   18140:	d101      	bne.n	18146 <_putc_r+0x16>
   18142:	f7ff fd8f 	bl	17c64 <__sinit>
   18146:	4b15      	ldr	r3, [pc, #84]	; (1819c <_putc_r+0x6c>)
   18148:	429c      	cmp	r4, r3
   1814a:	d101      	bne.n	18150 <_putc_r+0x20>
   1814c:	686c      	ldr	r4, [r5, #4]
   1814e:	e008      	b.n	18162 <_putc_r+0x32>
   18150:	4b13      	ldr	r3, [pc, #76]	; (181a0 <_putc_r+0x70>)
   18152:	429c      	cmp	r4, r3
   18154:	d101      	bne.n	1815a <_putc_r+0x2a>
   18156:	68ac      	ldr	r4, [r5, #8]
   18158:	e003      	b.n	18162 <_putc_r+0x32>
   1815a:	4b12      	ldr	r3, [pc, #72]	; (181a4 <_putc_r+0x74>)
   1815c:	429c      	cmp	r4, r3
   1815e:	d100      	bne.n	18162 <_putc_r+0x32>
   18160:	68ec      	ldr	r4, [r5, #12]
   18162:	68a3      	ldr	r3, [r4, #8]
   18164:	3b01      	subs	r3, #1
   18166:	60a3      	str	r3, [r4, #8]
   18168:	2b00      	cmp	r3, #0
   1816a:	da10      	bge.n	1818e <_putc_r+0x5e>
   1816c:	69a2      	ldr	r2, [r4, #24]
   1816e:	4293      	cmp	r3, r2
   18170:	db07      	blt.n	18182 <_putc_r+0x52>
   18172:	6823      	ldr	r3, [r4, #0]
   18174:	701e      	strb	r6, [r3, #0]
   18176:	6823      	ldr	r3, [r4, #0]
   18178:	7819      	ldrb	r1, [r3, #0]
   1817a:	290a      	cmp	r1, #10
   1817c:	d10a      	bne.n	18194 <_putc_r+0x64>
   1817e:	1c28      	adds	r0, r5, #0
   18180:	e001      	b.n	18186 <_putc_r+0x56>
   18182:	1c28      	adds	r0, r5, #0
   18184:	1c31      	adds	r1, r6, #0
   18186:	1c22      	adds	r2, r4, #0
   18188:	f7ff fba2 	bl	178d0 <__swbuf_r>
   1818c:	e005      	b.n	1819a <_putc_r+0x6a>
   1818e:	6823      	ldr	r3, [r4, #0]
   18190:	701e      	strb	r6, [r3, #0]
   18192:	6823      	ldr	r3, [r4, #0]
   18194:	1c5a      	adds	r2, r3, #1
   18196:	6022      	str	r2, [r4, #0]
   18198:	7818      	ldrb	r0, [r3, #0]
   1819a:	bd70      	pop	{r4, r5, r6, pc}
   1819c:	0002206c 	.word	0x0002206c
   181a0:	0002208c 	.word	0x0002208c
   181a4:	000220ac 	.word	0x000220ac

000181a8 <_raise_r>:
   181a8:	b538      	push	{r3, r4, r5, lr}
   181aa:	291f      	cmp	r1, #31
   181ac:	d904      	bls.n	181b8 <_raise_r+0x10>
   181ae:	2316      	movs	r3, #22
   181b0:	6003      	str	r3, [r0, #0]
   181b2:	2001      	movs	r0, #1
   181b4:	4240      	negs	r0, r0
   181b6:	e020      	b.n	181fa <_raise_r+0x52>
   181b8:	6c42      	ldr	r2, [r0, #68]	; 0x44
   181ba:	1c0d      	adds	r5, r1, #0
   181bc:	1c04      	adds	r4, r0, #0
   181be:	2a00      	cmp	r2, #0
   181c0:	d004      	beq.n	181cc <_raise_r+0x24>
   181c2:	008b      	lsls	r3, r1, #2
   181c4:	18d2      	adds	r2, r2, r3
   181c6:	6813      	ldr	r3, [r2, #0]
   181c8:	2b00      	cmp	r3, #0
   181ca:	d108      	bne.n	181de <_raise_r+0x36>
   181cc:	1c20      	adds	r0, r4, #0
   181ce:	f000 f831 	bl	18234 <_getpid_r>
   181d2:	1c2a      	adds	r2, r5, #0
   181d4:	1c01      	adds	r1, r0, #0
   181d6:	1c20      	adds	r0, r4, #0
   181d8:	f000 f81a 	bl	18210 <_kill_r>
   181dc:	e00d      	b.n	181fa <_raise_r+0x52>
   181de:	2000      	movs	r0, #0
   181e0:	2b01      	cmp	r3, #1
   181e2:	d00a      	beq.n	181fa <_raise_r+0x52>
   181e4:	1c59      	adds	r1, r3, #1
   181e6:	d103      	bne.n	181f0 <_raise_r+0x48>
   181e8:	3317      	adds	r3, #23
   181ea:	6023      	str	r3, [r4, #0]
   181ec:	3001      	adds	r0, #1
   181ee:	e004      	b.n	181fa <_raise_r+0x52>
   181f0:	2400      	movs	r4, #0
   181f2:	1c28      	adds	r0, r5, #0
   181f4:	6014      	str	r4, [r2, #0]
   181f6:	4798      	blx	r3
   181f8:	1c20      	adds	r0, r4, #0
   181fa:	bd38      	pop	{r3, r4, r5, pc}

000181fc <raise>:
   181fc:	b508      	push	{r3, lr}
   181fe:	4b03      	ldr	r3, [pc, #12]	; (1820c <raise+0x10>)
   18200:	1c01      	adds	r1, r0, #0
   18202:	6818      	ldr	r0, [r3, #0]
   18204:	f7ff ffd0 	bl	181a8 <_raise_r>
   18208:	bd08      	pop	{r3, pc}
   1820a:	46c0      	nop			; (mov r8, r8)
   1820c:	200002f4 	.word	0x200002f4

00018210 <_kill_r>:
   18210:	b538      	push	{r3, r4, r5, lr}
   18212:	2300      	movs	r3, #0
   18214:	4c06      	ldr	r4, [pc, #24]	; (18230 <_kill_r+0x20>)
   18216:	1c05      	adds	r5, r0, #0
   18218:	1c08      	adds	r0, r1, #0
   1821a:	1c11      	adds	r1, r2, #0
   1821c:	6023      	str	r3, [r4, #0]
   1821e:	f7fb fcd9 	bl	13bd4 <_kill>
   18222:	1c43      	adds	r3, r0, #1
   18224:	d103      	bne.n	1822e <_kill_r+0x1e>
   18226:	6823      	ldr	r3, [r4, #0]
   18228:	2b00      	cmp	r3, #0
   1822a:	d000      	beq.n	1822e <_kill_r+0x1e>
   1822c:	602b      	str	r3, [r5, #0]
   1822e:	bd38      	pop	{r3, r4, r5, pc}
   18230:	20002cbc 	.word	0x20002cbc

00018234 <_getpid_r>:
   18234:	b508      	push	{r3, lr}
   18236:	f7fb fccf 	bl	13bd8 <_getpid>
   1823a:	bd08      	pop	{r3, pc}

0001823c <__sread>:
   1823c:	b538      	push	{r3, r4, r5, lr}
   1823e:	1c0c      	adds	r4, r1, #0
   18240:	250e      	movs	r5, #14
   18242:	5f49      	ldrsh	r1, [r1, r5]
   18244:	f000 f8d6 	bl	183f4 <_read_r>
   18248:	2800      	cmp	r0, #0
   1824a:	db03      	blt.n	18254 <__sread+0x18>
   1824c:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1824e:	181b      	adds	r3, r3, r0
   18250:	6563      	str	r3, [r4, #84]	; 0x54
   18252:	e003      	b.n	1825c <__sread+0x20>
   18254:	89a2      	ldrh	r2, [r4, #12]
   18256:	4b02      	ldr	r3, [pc, #8]	; (18260 <__sread+0x24>)
   18258:	4013      	ands	r3, r2
   1825a:	81a3      	strh	r3, [r4, #12]
   1825c:	bd38      	pop	{r3, r4, r5, pc}
   1825e:	46c0      	nop			; (mov r8, r8)
   18260:	ffffefff 	.word	0xffffefff

00018264 <__swrite>:
   18264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18266:	1c1e      	adds	r6, r3, #0
   18268:	898b      	ldrh	r3, [r1, #12]
   1826a:	1c05      	adds	r5, r0, #0
   1826c:	1c0c      	adds	r4, r1, #0
   1826e:	1c17      	adds	r7, r2, #0
   18270:	05db      	lsls	r3, r3, #23
   18272:	d505      	bpl.n	18280 <__swrite+0x1c>
   18274:	230e      	movs	r3, #14
   18276:	5ec9      	ldrsh	r1, [r1, r3]
   18278:	2200      	movs	r2, #0
   1827a:	2302      	movs	r3, #2
   1827c:	f000 f89a 	bl	183b4 <_lseek_r>
   18280:	89a2      	ldrh	r2, [r4, #12]
   18282:	4b05      	ldr	r3, [pc, #20]	; (18298 <__swrite+0x34>)
   18284:	1c28      	adds	r0, r5, #0
   18286:	4013      	ands	r3, r2
   18288:	81a3      	strh	r3, [r4, #12]
   1828a:	1c3a      	adds	r2, r7, #0
   1828c:	230e      	movs	r3, #14
   1828e:	5ee1      	ldrsh	r1, [r4, r3]
   18290:	1c33      	adds	r3, r6, #0
   18292:	f000 f845 	bl	18320 <_write_r>
   18296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18298:	ffffefff 	.word	0xffffefff

0001829c <__sseek>:
   1829c:	b538      	push	{r3, r4, r5, lr}
   1829e:	1c0c      	adds	r4, r1, #0
   182a0:	250e      	movs	r5, #14
   182a2:	5f49      	ldrsh	r1, [r1, r5]
   182a4:	f000 f886 	bl	183b4 <_lseek_r>
   182a8:	89a3      	ldrh	r3, [r4, #12]
   182aa:	1c42      	adds	r2, r0, #1
   182ac:	d103      	bne.n	182b6 <__sseek+0x1a>
   182ae:	4a05      	ldr	r2, [pc, #20]	; (182c4 <__sseek+0x28>)
   182b0:	4013      	ands	r3, r2
   182b2:	81a3      	strh	r3, [r4, #12]
   182b4:	e004      	b.n	182c0 <__sseek+0x24>
   182b6:	2280      	movs	r2, #128	; 0x80
   182b8:	0152      	lsls	r2, r2, #5
   182ba:	4313      	orrs	r3, r2
   182bc:	81a3      	strh	r3, [r4, #12]
   182be:	6560      	str	r0, [r4, #84]	; 0x54
   182c0:	bd38      	pop	{r3, r4, r5, pc}
   182c2:	46c0      	nop			; (mov r8, r8)
   182c4:	ffffefff 	.word	0xffffefff

000182c8 <__sclose>:
   182c8:	b508      	push	{r3, lr}
   182ca:	230e      	movs	r3, #14
   182cc:	5ec9      	ldrsh	r1, [r1, r3]
   182ce:	f000 f83b 	bl	18348 <_close_r>
   182d2:	bd08      	pop	{r3, pc}

000182d4 <strncasecmp>:
   182d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   182d6:	2500      	movs	r5, #0
   182d8:	4b10      	ldr	r3, [pc, #64]	; (1831c <strncasecmp+0x48>)
   182da:	9201      	str	r2, [sp, #4]
   182dc:	681e      	ldr	r6, [r3, #0]
   182de:	9b01      	ldr	r3, [sp, #4]
   182e0:	429d      	cmp	r5, r3
   182e2:	d017      	beq.n	18314 <strncasecmp+0x40>
   182e4:	5d43      	ldrb	r3, [r0, r5]
   182e6:	18f4      	adds	r4, r6, r3
   182e8:	7867      	ldrb	r7, [r4, #1]
   182ea:	2403      	movs	r4, #3
   182ec:	403c      	ands	r4, r7
   182ee:	2c01      	cmp	r4, #1
   182f0:	d100      	bne.n	182f4 <strncasecmp+0x20>
   182f2:	3320      	adds	r3, #32
   182f4:	5d4c      	ldrb	r4, [r1, r5]
   182f6:	1937      	adds	r7, r6, r4
   182f8:	787f      	ldrb	r7, [r7, #1]
   182fa:	46bc      	mov	ip, r7
   182fc:	2703      	movs	r7, #3
   182fe:	4662      	mov	r2, ip
   18300:	4017      	ands	r7, r2
   18302:	2f01      	cmp	r7, #1
   18304:	d100      	bne.n	18308 <strncasecmp+0x34>
   18306:	3420      	adds	r4, #32
   18308:	1b1b      	subs	r3, r3, r4
   1830a:	d104      	bne.n	18316 <strncasecmp+0x42>
   1830c:	3501      	adds	r5, #1
   1830e:	2c00      	cmp	r4, #0
   18310:	d1e5      	bne.n	182de <strncasecmp+0xa>
   18312:	e000      	b.n	18316 <strncasecmp+0x42>
   18314:	2300      	movs	r3, #0
   18316:	1c18      	adds	r0, r3, #0
   18318:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1831a:	46c0      	nop			; (mov r8, r8)
   1831c:	200002f8 	.word	0x200002f8

00018320 <_write_r>:
   18320:	b538      	push	{r3, r4, r5, lr}
   18322:	1c05      	adds	r5, r0, #0
   18324:	2000      	movs	r0, #0
   18326:	4c07      	ldr	r4, [pc, #28]	; (18344 <_write_r+0x24>)
   18328:	6020      	str	r0, [r4, #0]
   1832a:	1c08      	adds	r0, r1, #0
   1832c:	1c11      	adds	r1, r2, #0
   1832e:	1c1a      	adds	r2, r3, #0
   18330:	f7f7 fa38 	bl	f7a4 <_write>
   18334:	1c43      	adds	r3, r0, #1
   18336:	d103      	bne.n	18340 <_write_r+0x20>
   18338:	6823      	ldr	r3, [r4, #0]
   1833a:	2b00      	cmp	r3, #0
   1833c:	d000      	beq.n	18340 <_write_r+0x20>
   1833e:	602b      	str	r3, [r5, #0]
   18340:	bd38      	pop	{r3, r4, r5, pc}
   18342:	46c0      	nop			; (mov r8, r8)
   18344:	20002cbc 	.word	0x20002cbc

00018348 <_close_r>:
   18348:	b538      	push	{r3, r4, r5, lr}
   1834a:	2300      	movs	r3, #0
   1834c:	4c06      	ldr	r4, [pc, #24]	; (18368 <_close_r+0x20>)
   1834e:	1c05      	adds	r5, r0, #0
   18350:	1c08      	adds	r0, r1, #0
   18352:	6023      	str	r3, [r4, #0]
   18354:	f7fb fc26 	bl	13ba4 <_close>
   18358:	1c43      	adds	r3, r0, #1
   1835a:	d103      	bne.n	18364 <_close_r+0x1c>
   1835c:	6823      	ldr	r3, [r4, #0]
   1835e:	2b00      	cmp	r3, #0
   18360:	d000      	beq.n	18364 <_close_r+0x1c>
   18362:	602b      	str	r3, [r5, #0]
   18364:	bd38      	pop	{r3, r4, r5, pc}
   18366:	46c0      	nop			; (mov r8, r8)
   18368:	20002cbc 	.word	0x20002cbc

0001836c <_fstat_r>:
   1836c:	b538      	push	{r3, r4, r5, lr}
   1836e:	2300      	movs	r3, #0
   18370:	4c06      	ldr	r4, [pc, #24]	; (1838c <_fstat_r+0x20>)
   18372:	1c05      	adds	r5, r0, #0
   18374:	1c08      	adds	r0, r1, #0
   18376:	1c11      	adds	r1, r2, #0
   18378:	6023      	str	r3, [r4, #0]
   1837a:	f7fb fc17 	bl	13bac <_fstat>
   1837e:	1c43      	adds	r3, r0, #1
   18380:	d103      	bne.n	1838a <_fstat_r+0x1e>
   18382:	6823      	ldr	r3, [r4, #0]
   18384:	2b00      	cmp	r3, #0
   18386:	d000      	beq.n	1838a <_fstat_r+0x1e>
   18388:	602b      	str	r3, [r5, #0]
   1838a:	bd38      	pop	{r3, r4, r5, pc}
   1838c:	20002cbc 	.word	0x20002cbc

00018390 <_isatty_r>:
   18390:	b538      	push	{r3, r4, r5, lr}
   18392:	2300      	movs	r3, #0
   18394:	4c06      	ldr	r4, [pc, #24]	; (183b0 <_isatty_r+0x20>)
   18396:	1c05      	adds	r5, r0, #0
   18398:	1c08      	adds	r0, r1, #0
   1839a:	6023      	str	r3, [r4, #0]
   1839c:	f7fb fc0c 	bl	13bb8 <_isatty>
   183a0:	1c43      	adds	r3, r0, #1
   183a2:	d103      	bne.n	183ac <_isatty_r+0x1c>
   183a4:	6823      	ldr	r3, [r4, #0]
   183a6:	2b00      	cmp	r3, #0
   183a8:	d000      	beq.n	183ac <_isatty_r+0x1c>
   183aa:	602b      	str	r3, [r5, #0]
   183ac:	bd38      	pop	{r3, r4, r5, pc}
   183ae:	46c0      	nop			; (mov r8, r8)
   183b0:	20002cbc 	.word	0x20002cbc

000183b4 <_lseek_r>:
   183b4:	b538      	push	{r3, r4, r5, lr}
   183b6:	1c05      	adds	r5, r0, #0
   183b8:	2000      	movs	r0, #0
   183ba:	4c07      	ldr	r4, [pc, #28]	; (183d8 <_lseek_r+0x24>)
   183bc:	6020      	str	r0, [r4, #0]
   183be:	1c08      	adds	r0, r1, #0
   183c0:	1c11      	adds	r1, r2, #0
   183c2:	1c1a      	adds	r2, r3, #0
   183c4:	f7fb fbfa 	bl	13bbc <_lseek>
   183c8:	1c43      	adds	r3, r0, #1
   183ca:	d103      	bne.n	183d4 <_lseek_r+0x20>
   183cc:	6823      	ldr	r3, [r4, #0]
   183ce:	2b00      	cmp	r3, #0
   183d0:	d000      	beq.n	183d4 <_lseek_r+0x20>
   183d2:	602b      	str	r3, [r5, #0]
   183d4:	bd38      	pop	{r3, r4, r5, pc}
   183d6:	46c0      	nop			; (mov r8, r8)
   183d8:	20002cbc 	.word	0x20002cbc

000183dc <_malloc_usable_size_r>:
   183dc:	1f0b      	subs	r3, r1, #4
   183de:	681a      	ldr	r2, [r3, #0]
   183e0:	1f10      	subs	r0, r2, #4
   183e2:	2a00      	cmp	r2, #0
   183e4:	da04      	bge.n	183f0 <_malloc_usable_size_r+0x14>
   183e6:	1889      	adds	r1, r1, r2
   183e8:	3904      	subs	r1, #4
   183ea:	680b      	ldr	r3, [r1, #0]
   183ec:	18d0      	adds	r0, r2, r3
   183ee:	3804      	subs	r0, #4
   183f0:	4770      	bx	lr
	...

000183f4 <_read_r>:
   183f4:	b538      	push	{r3, r4, r5, lr}
   183f6:	1c05      	adds	r5, r0, #0
   183f8:	2000      	movs	r0, #0
   183fa:	4c07      	ldr	r4, [pc, #28]	; (18418 <_read_r+0x24>)
   183fc:	6020      	str	r0, [r4, #0]
   183fe:	1c08      	adds	r0, r1, #0
   18400:	1c11      	adds	r1, r2, #0
   18402:	1c1a      	adds	r2, r3, #0
   18404:	f7f7 f9ac 	bl	f760 <_read>
   18408:	1c43      	adds	r3, r0, #1
   1840a:	d103      	bne.n	18414 <_read_r+0x20>
   1840c:	6823      	ldr	r3, [r4, #0]
   1840e:	2b00      	cmp	r3, #0
   18410:	d000      	beq.n	18414 <_read_r+0x20>
   18412:	602b      	str	r3, [r5, #0]
   18414:	bd38      	pop	{r3, r4, r5, pc}
   18416:	46c0      	nop			; (mov r8, r8)
   18418:	20002cbc 	.word	0x20002cbc

0001841c <__func__.6660>:
   1841c:	74736552 00747261                       Restart.

00018424 <__func__.6656>:
   18424:	74636146 5279726f 74657365 00000000     FactoryReset....
   18434:	732f2e2e 612f6372 6f6a6c6c 6c2f6e79     ../src/alljoyn/l
   18444:	20706d61 76726573 2f656369 2f637273     amp service/src/
   18454:	706d614c 756f6241 74614474 00632e61     LampAboutData.c.
   18464:	73736150 64726f77 20736920 4c4c554e     Password is NULL
   18474:	00000021 00657548 75746153 69746172     !...Hue.Saturati
   18484:	00006e6f 67697242 656e7468 00007373     on..Brightness..
   18494:	664f6e4f 00000066 555f4a41 72616d6e     OnOff...AJ_Unmar
   184a4:	6c616873 73677241 7325203a 0000000a     shalArgs: %s....
   184b4:	732f2e2e 612f6372 6f6a6c6c 6c2f6e79     ../src/alljoyn/l
   184c4:	20706d61 76726573 2f656369 2f637273     amp service/src/
   184d4:	706d614c 74617453 00632e65 555f4a41     LampState.c.AJ_U
   184e4:	72616d6e 6c616873 69726156 3a746e61     nmarshalVariant:
   184f4:	0a732520 00000000 6e6b6e55 206e776f      %s.....Unknown 
   18504:	6c656966 25203a64 00000a73 00000001     field: %s.......
   18514:	00000004                                ....

00018518 <__func__.14444>:
   18518:	5f4d454f 445f534c 6361466f 79726f74     OEM_LS_DoFactory
   18528:	65736552 00000074                       Reset...

00018530 <__func__.14467>:
   18530:	5f4d454f 435f534c 7261656c 6c756146     OEM_LS_ClearFaul
   18540:	00000074                                t...

00018544 <aboutIconSize>:
   18544:	00000ef6                                ....

00018548 <__func__.14454>:
   18548:	5f4d454f 475f534c 72427465 74686769     OEM_LS_GetBright
   18558:	7373656e 656d754c 0000736e              nessLumens..

00018564 <__func__.14458>:
   18564:	5f4d454f 505f534c 6c75706f 46657461     OEM_LS_PopulateF
   18574:	746c7561 00000073                       aults...

0001857c <aboutIconContent>:
   1857c:	474e5089 0a1a0a0d 0d000000 52444849     .PNG........IHDR
   1858c:	63000000 9c000000 00000608 15ff6b00     ...c.........k..
   1859c:	00000059 58457419 666f5374 72617774     Y....tEXtSoftwar
   185ac:	64410065 2065626f 67616d49 61655265     e.Adobe ImageRea
   185bc:	c9717964 00003c65 54696603 4d587458     dyq.e<...fiTXtXM
   185cc:	6f633a4c 64612e6d 2e65626f 00706d78     L:com.adobe.xmp.
   185dc:	00000000 70783f3c 656b6361 65622074     ....<?xpacket be
   185ec:	3d6e6967 bfbbef22 64692022 3557223d     gin="..." id="W5
   185fc:	704d304d 69686543 65727a48 544e7a53     M0MpCehiHzreSzNT
   1860c:	636b7a63 3f226439 783c203e 706d783a     czkc9d"?> <x:xmp
   1861c:	6174656d 6c6d7820 783a736e 6461223d     meta xmlns:x="ad
   1862c:	3a65626f 6d3a736e 2f617465 3a782022     obe:ns:meta/" x:
   1863c:	74706d78 41223d6b 65626f64 504d5820     xmptk="Adobe XMP
   1864c:	726f4320 2e352065 30632d30 36203036      Core 5.0-c060 6
   1865c:	33312e31 37373734 3032202c 302f3031     1.134777, 2010/0
   1866c:	32312f32 3a37312d 303a3233 20202030     2/12-17:32:00   
   1867c:	20202020 203e2220 6664723c 4644523a          "> <rdf:RDF
   1868c:	6c6d7820 723a736e 223d6664 70747468      xmlns:rdf="http
   1869c:	772f2f3a 772e7777 726f2e33 39312f67     ://www.w3.org/19
   186ac:	302f3939 32322f32 6664722d 6e79732d     99/02/22-rdf-syn
   186bc:	2d786174 2223736e 723c203e 443a6664     tax-ns#"> <rdf:D
   186cc:	72637365 69747069 72206e6f 613a6664     escription rdf:a
   186dc:	74756f62 2022223d 6e6c6d78 6d783a73     bout="" xmlns:xm
   186ec:	3d4d4d70 74746822 2f2f3a70 612e736e     pMM="http://ns.a
   186fc:	65626f64 6d6f632e 7061782f 302e312f     dobe.com/xap/1.0
   1870c:	2f6d6d2f 6d782022 3a736e6c 65527473     /mm/" xmlns:stRe
   1871c:	68223d66 3a707474 736e2f2f 6f64612e     f="http://ns.ado
   1872c:	632e6562 782f6d6f 312f7061 732f302e     be.com/xap/1.0/s
   1873c:	65707954 7365522f 6372756f 66655265     Type/ResourceRef
   1874c:	78202223 736e6c6d 706d783a 7468223d     #" xmlns:xmp="ht
   1875c:	2f3a7074 2e736e2f 626f6461 6f632e65     tp://ns.adobe.co
   1876c:	61782f6d 2e312f70 20222f30 4d706d78     m/xap/1.0/" xmpM
   1877c:	724f3a4d 6e696769 6f446c61 656d7563     M:OriginalDocume
   1878c:	4449746e 6d78223d 69642e70 37463a64     ntID="xmp.did:F7
   1879c:	31314637 37303437 38363032 46383131     7F1174072068118F
   187ac:	36423944 38363537 34353436 20224136     D9B6756864546A" 
   187bc:	4d706d78 6f443a4d 656d7563 4449746e     xmpMM:DocumentID
   187cc:	6d78223d 69642e70 32313a64 36374345     ="xmp.did:12EC76
   187dc:	38333536 31313841 31423345 44384637     6538A811E3B17F8D
   187ec:	31323936 33453342 20223945 4d706d78     6921B3E3E9" xmpM
   187fc:	6e493a4d 6e617473 44496563 6d78223d     M:InstanceID="xm
   1880c:	69692e70 32313a64 36374345 38333436     p.iid:12EC766438
   1881c:	31313841 31423345 44384637 31323936     A811E3B17F8D6921
   1882c:	33453342 20223945 3a706d78 61657243     B3E3E9" xmp:Crea
   1883c:	54726f74 3d6c6f6f 6f644122 50206562     torTool="Adobe P
   1884c:	6f746f68 706f6873 35534320 63614d20     hotoshop CS5 Mac
   1885c:	6f746e69 3e226873 6d783c20 3a4d4d70     intosh"> <xmpMM:
   1886c:	69726544 46646576 206d6f72 65527473     DerivedFrom stRe
   1887c:	6e693a66 6e617473 44496563 6d78223d     f:instanceID="xm
   1888c:	69692e70 42393a64 42423533 39353841     p.iid:9B35BBA859
   1889c:	38363032 32393131 46383042 41413542     20681192B08FB5AA
   188ac:	43303435 20223434 65527473 6f643a66     540C44" stRef:do
   188bc:	656d7563 4449746e 6d78223d 69642e70     cumentID="xmp.di
   188cc:	37463a64 31314637 37303437 38363032     d:F77F1174072068
   188dc:	46383131 36423944 38363537 34353436     118FD9B675686454
   188ec:	2f224136 2f3c203e 3a666472 63736544     6A"/> </rdf:Desc
   188fc:	74706972 3e6e6f69 722f3c20 523a6664     ription> </rdf:R
   1890c:	203e4644 3a782f3c 6d706d78 3e617465     DF> </x:xmpmeta>
   1891c:	783f3c20 6b636170 65207465 223d646e      <?xpacket end="
   1892c:	3e3f2272 eda7147d 260b0000 54414449     r"?>}......&IDAT
   1893c:	5decda78 d55e6801 246d3e15 1d287420     x..].h^..>m$ t(.
   1894c:	12258a19 0a38a969 e1d1c44a 264c08e8     ..%.i.8.J.....L&
   1895c:	47498e8e e023a447 896968c8 5658b474     ..IGG.#..hi.t.XV
   1896c:	07431428 28b43145 05868d93 9962a4c3     (.C.E1.(......b.
   1897c:	0b282c2c c5068e1d 18b048c2 161a161a     ,,(......H......
   1898c:	0b0b2c16 7ec21586 bfedfbba bcbedecf     .,.....~........
   1899c:	fbfffffb b9cf7bff 83f7fdef e7efaa43     .....{......C...
   189ac:	f7eefbbd 9cf73dce 9bb9ee7b 4dbedf6e     .....=..{...n..M
   189bc:	4a7dc405 adae5bb6 e22d992b 940a6d4b     ..}J.[..+.-.Km..
   189cc:	ec957b8c c94bb256 571e4a63 ee9280f2     .{..V.K.cJ.W....
   189dc:	8849f79c 4164a6b9 6992bcc9 619237fd     ..I...dA...i.7.a
   189ec:	3d928741 7fd69e4a e7ffe8f7 fe4acb0b     A..=J.........J.
   189fc:	c95264a2 48c59294 92af5106 4afd2501     .dR....H.Q...%.J
   18a0c:	03b60ab6 65ae32da d8c89da5 c95064a2     .....2.e.....dP.
   18a1c:	0a087a8b ded61809 6b5e7257 80c9694e     .z......Wr^kNi..
   18a2c:	e4ac3dd1 e416b0a8 7ad396d1 190d2b28     .=.........z(+..
   18a3c:	4a6384d0 45213486 272555c3 74587c94     ..cJ.4!E.U%'.|Xt
   18a4c:	392af632 282cc4d7 e4a3bc44 0bfc6d25     2.*9..,(D...%m..
   18a5c:	26b74645 0b952f61 6a4e4aab 3208529b     EF.&a/...JNj.R.2
   18a6c:	a0b929f6 02b2a787 5c17e1d3 324b896b     .).........\k.K2
   18a7c:	aabc953a 603b748d 15321359 9618191a     :....t;`Y.2.....
   18a8c:	8a792a2e 25150bda 870c94a7 254ec642     .*y....%....B.N%
   18a9c:	48c4941f 94b78b37 88e4d21c f84d0191     ...H7.........M.
   18aac:	8a2e92a3 a7eb6cc0 276471da 1fc94fa3     .....l...qd'.O..
   18abc:	f3a86e4a 0fc8be02 24e2dc95 99711a03     Jn.........$..q.
   18acc:	88d5d1aa ca7081bb 590ccdf3 758190cd     ......p....Y...u
   18adc:	68712b84 b53789aa 464af10d 7b622697     .+qh..7...JF.&b{
   18aec:	18baefec 17a20ed6 d0f43a32 e7ec74f4     ........2:...t..
   18afc:	6d13f186 f1939dd8 c65f928a 8405cdfe     ...m......_.....
   18b0c:	eaa09e4f 3233a32a d12fb4fa 3737fb11     O...*.32../...77
   18b1c:	9df2513e 8dbca646 313b0190 e835d543     >Q..F.....;1C.5.
   18b2c:	5670e688 641771c9 65d54dbc 81e688d1     ..pV.q.d.M.e....
   18b3c:	4a93ee69 190ad6fe c51fd630 5c3674be     i..J....0....t6\
   18b4c:	ff96bb7d d80c8b51 9aa94f87 06e11326     }...Q....O..&...
   18b5c:	920fb487 4a838c9b e7fd88de d93cc814     .......J......<.
   18b6c:	140c9641 9b58191b b68d11b8 e1c92017     A.....X...... ..
   18b7c:	90321e54 d8ebf34a a6b05e6f ed2ce1e4     T.2.J...o^....,.
   18b8c:	b60322c8 218a73e2 98409f0f 3211b864     ."...s.!..@.d..2
   18b9c:	3674f5fa b5961fc2 23d7ac76 735532e3     ..t6....v..#.2Us
   18bac:	e2fc235d adde4ac7 36b74645 71fe11dc     ]#...J..EF.6...q
   18bbc:	1eebaa89 565e3256 13f62672 b81ab00b     ....V2^Vr&......
   18bcc:	69e434cd f0a33e32 8ccb9192 9935539f     .4.i2>.......S5.
   18bdc:	d8190361 fb133298 33581587 0c8b267f     a....2....X3.&..
   18bec:	8b9d9f24 543ec3fd a5ff5d7d be85c6cd     $.....>T}]......
   18bfc:	40ec37d8 f26f4742 470d9b1f 65674e2f     .7.@BGo....G/Nge
   18c0c:	a61e97d0 0390bda2 d77d4876 9280e324     ........vH}.$...
   18c1c:	117ec5df 5f556201 38a98733 3203959d     ..~..bU_3..8...2
   18c2c:	19227b32 9331e0e1 95a1188c 23244f45     2{"...1.....EO$#
   18c3c:	6427741c 67701b60 74510fec c8446499     .t'd`.pg..Qt.dD.
   18c4c:	46426b62 08115fdc 9108f719 a5f94581     bkBF._.......E..
   18c5c:	95083bc0 3d32761c 432123ab 7ae44802     .;...v2=.#!C.H.z
   18c6c:	9022602b a699c315 4d9cc5b4 c2906371     +`"........Mqc..
   18c7c:	cc3ea24e 84b5bedc 9781558c f7c9487d     N.>......U..}H..
   18c8c:	53a22503 23dc2c7f a987ffc5 a34bd08a     .%.S.,.#......K.
   18c9c:	ea44d1c4 d025dc6b 336a540e 27ec4fcb     ..D.k.%..Tj3.O.'
   18cac:	6b722dfe 85371909 35abd8c8 7c352964     .-rk..7....5d)5|
   18cbc:	f7bd2371 0da0486e 0a619337 681758ff     q#..nH..7.a..X.h
   18ccc:	8ed68740 ed02e304 6dccf3c0 d88ba85e     @..........m^...
   18cdc:	b006492b 031da42c 495ca186 981c5b0d     +I..,.....\I.[..
   18cec:	2cd3bba0 61fa8487 4e6324c9 293d11a8     ...,...a.$cN..=)
   18cfc:	fcce3e43 74d4f1fc fd4247f6 19021f30     C>.....t.GB.0...
   18d0c:	d2aa1a94 ac4faa5f a4204c64 4cd77462     ...._.O.dL .bt.L
   18d1c:	9209ae32 6cee97b1 c496403d bdcf4cbb     2......l=@...L..
   18d2c:	4aca7744 0a3ea674 0b0da04e 089f1926     Dw.Jt.>.N...&...
   18d3c:	e4369192 1dcf4ca3 a5674d4b 4d5ca2f6     ..6..L..KMg...\M
   18d4c:	0d648bdc 25f21d1c c102d5c9 f0c3b197     ..d....%........
   18d5c:	edaefe79 a8a02f89 f3c623f0 5ab9263e     y..../...#..>&.Z
   18d6c:	f929af59 1519a985 d01490cd af967df1     Y.)..........}..
   18d7c:	545697d6 64ace98c 2aafb2d1 194e6db9     ..VT...d...*.mN.
   18d8c:	320c494f 329e3192 98a852dc 6b948464     OI.2.1.2.R..d..k
   18d9c:	336d868b fa2b9e7c 4631f5ab 674c693f     ..m3|.+...1F?iLg
   18dac:	a2ce086f ead54afe 63341b09 71ac1a96     o....J....4c...q
   18dbc:	0f90d1e1 e61cf830 ec920f7d 455df392     ....0...}.....]E
   18dcc:	025bd25e ccb58ba4 600e436b 8e9febf5     ^.[.....kC.`....
   18ddc:	3ed4cb3b e9bd1de9 7ac36091 02c918c6     ;..>.....`.z....
   18dec:	3c7b2a59 343e4786 c91f7e5e a29ead6e     Y*{<.G>4^~..n...
   18dfc:	4d2a1854 49f13c06 3c064261 16a31c7e     T.*M.<.IaB.<~...
   18e0c:	1b025fcf 6d64252a e8ac44b0 448d824f     ._..*%dm.D..O..D
   18e1c:	fd41ff6c 3fcf7e17 cb064dc8 2defbeaa     l.A..~.?.M.....-
   18e2c:	05d781ad c18111df 96b52987 3aecb594     .........).....:
   18e3c:	d91e1c29 d71087a2 8c7791e1 56b487f0     ).........w....V
   18e4c:	458ca79c 04855b3d 8237f634 4d2afd8d     ...E=[..4.7...*M
   18e5c:	af6f4f5e 2a27b838 60074cda 56b457b8     ^Oo.8.'*.L.`.W.V
   18e6c:	464a35ac 3c490ea7 0ec84824 d55073ba     .5JF..I<$H...sP.
   18e7c:	052d6a75 41a59cd5 be0a2eeb 8876b597     uj-....A......v.
   18e8c:	2b043b2d 5585c760 9f4380f9 e9e2d463     -;.+`..U..C.c...
   18e9c:	6bc5684b 8af58bb6 97f0a17f 334eb554     Kh.k........T.N3
   18eac:	c18ad798 e0fbe8ad e35add7e f084d2a5     ........~.Z.....
   18ebc:	5db59f81 753797ac 47b2e484 c67d71d0     ...]..7u...G.q}.
   18ecc:	c2dd3330 d0d17e7c 96222936 afe146a9     03..|~..6)"..F..
   18edc:	4d40c846 3fccc93d 98c73e17 c6e3e865     F.@M=..?.>..e...
   18eec:	ced19670 61254c33 9324eb89 fb4b7ead     p...3L%a..$..~K.
   18efc:	864dab06 02df4c47 058ff261 541ddc87     ..M.GL..a......T
   18f0c:	91a5fb27 9d184ef4 025e8497 16fedf4e     '....N....^.N...
   18f1c:	86a323c2 15a9216f 5d51c9a7 6e63695b     .#..o!....Q][icn
   18f2c:	dec81cfa e989af78 2ad6a771 f3c6ed09     ....x...q..*....
   18f3c:	f6c46d1f e90321e6 1fc433f1 2768ae72     .m...!...3..r.h'
   18f4c:	a7672969 6cf09222 44ba2493 f3d0f5c3     i)g."..l.$.D....
   18f5c:	d5cfa164 447b239a 591e1187 311e11cf     d....#{D...Y...1
   18f6c:	84fb2e67 13cd9888 647bc9ce cfccbe03     g.........{d....
   18f7c:	e6437f88 34670eb4 7d311e1a 85f99014     ..C...g4..1}....
   18f8c:	538510d0 f86fde66 a72320d7 065b773c     ...Sf.o.. #.<w[.
   18f9c:	ae1b465d 51edf9d7 847bb7e3 de69fbda     ]F.....Q..{...i.
   18fac:	b3666dbe 24c904cc 6685982f 674cea46     .mf....$/..fF.Lg
   18fbc:	bf68df4d 0f915fa0 6406684d 32ff92bb     M.h.._..Mh.d...2
   18fcc:	a7af697f f2d870da efd4febb c568086e     .i...p......n.h.
   18fdc:	dafd334c 3790192c bdf05f98 53ec368c     L3..,..7._...6.S
   18fec:	febeb9f2 a943251f 8684bbeb fa66fea8     .....%C.......f.
   18ffc:	e1a395b4 84733db8 5cb09e66 cddc1243     .....=s.f..\C...
   1900c:	4483708c 3acc773d 4c4cd9bf 960d95af     .p.D=w.:..LL....
   1901c:	324f88f0 1acee4be 4b05be41 80b767dc     ..O2....A..K.g..
   1902c:	b355f8ad 4f56d5c1 d63ee4b0 b7ca51e1     ..U...VO..>..Q..
   1903c:	6a3b817d ca0c50d0 de246687 e476a731     }.;j.P...f$.1.v.
   1904c:	8fbd89cd 92ce2b59 26a271d0 090d30ae     ....Y+...q.&.0..
   1905c:	25a0a923 c673d5ec d0388fd7 e8382379     #..%..s...8.y#8.
   1906c:	3d3d9b3b 7546dea5 e0b5e4c2 d60242aa     ;.==..Fu.....B..
   1907c:	78603f74 bf29dde1 6efc8703 9386d0c9     t?`x..)....n....
   1908c:	0b80c446 e110ada3 c6b83352 f7010c67     F.......R3..g...
   1909c:	b61f2feb 94e2d7aa fbff40fe 8da9e24b     ./.......@..K...
   190ac:	6cf6d152 b89b95be cc31572c d2f8d2f0     R..l....,W1.....
   190bc:	b6fb8d93 c6f33d8d 3522ae75 e112ad13     .....=..u."5....
   190cc:	e2498c9a dbb9a8d9 242c80e8 34ce3981     ..I.......,$.9.4
   190dc:	dc5d37a3 972175c4 8c648cf3 70d18c64     .7]..u!...d.d..p
   190ec:	c998a70c f28e46b8 31935d93 c30bfe4a     .....F...].1J...
   190fc:	89697624 1d832636 1c893949 b601f770     $vi.6&..I9..p...
   1910c:	c9b29b10 a7ec4320 dbde78c7 39e24096     .... C...x...@.9
   1911c:	a77930a6 41f3beab cf23e406 78c0709d     .0y....A..#..p.x
   1912c:	4ce33a16 78cca746 d6a2036e 37ecbb8f     .:.LF..xn......7
   1913c:	135b5397 e9ea7abd f255bf0b e1d71ab3     .S[..z....U.....
   1914c:	7e417e0c b460d613 a1bcb90f 2400322f     .~A~..`...../2.$
   1915c:	c5aaf800 f5e7a731 b9280c36 9a8891e0     ....1...6.(.....
   1916c:	48865127 f8ed6f86 656bd906 7f64def9     'Q.H.o....ke..d.
   1917c:	9674d5c8 32e00c8b 63973bf9 1a6ad1c3     ..t....2.;.c..j.
   1918c:	bdfd6658 d05a77c7 36bce95a 9182ef96     Xf...wZ.Z..6....
   1919c:	3def1e23 b6171b40 4f0f3cfa 54f259c0     #..=@....<.O.Y.T
   191ac:	66b7cca4 59934ef8 a8b1dad3 79efc19d     ...f.N.Y.......y
   191bc:	e4990226 a89dd08f 00c8a170 9079ecb0     &.......p.....y.
   191cc:	e2ac01ca 7375f09d 7430320e 6424b9fc     ......us.20t..$d
   191dc:	0c695de4 4f440c8e e57245ff 35015c93     .]i...DO.Er..\.5
   191ec:	f3e5beb9 9f151c01 2d5ebe31 4f785681     ........1.^-.VxO
   191fc:	bf2ae3dc 32025d3d 803f7ca6 8a029863     ..*.=].2.|?.c...
   1920c:	b419da7e 5cf27efb 334b9777 15ae0be6     ~....~.\w.K3....
   1921c:	0050c473 9b8c8b99 ca832025 c16ac642     s.P.....% ..B.j.
   1922c:	132958c9 2705eb19 644cad63 bcf603d4     .X)....'c.Ld....
   1923c:	49bb0a21 7b259e50 bb4af84d ef698190     !..IP.%{M.J...i.
   1924c:	95d8010b 310edd49 c6336084 4624ae48     ....I..1.`3.H.$F
   1925c:	68b12f96 85b6da99 34748466 f7cca21d     ./.h....f.t4....
   1926c:	4e3cd94a 342f6c32 70211018 1ea4bb4e     J.<N2l/4..!pN...
   1927c:	1c3479ce 112b3d54 9198db19 e4827ec5     .y4.T=+......~..
   1928c:	b001550e 724c7f5e 0e15c836 fc4dfe01     .U..^.Lr6.....M.
   1929c:	c15c25fb e4b79acb 88a15530 8b58c860     .%\.....0U..`.X.
   192ac:	a70c5ddd 8adc742f 16038464 604f7e03     .]../t..d....~O`
   192bc:	324b3d2f 1f6c2c71 e5fa4078 e5a8c939     /=K2q,l.x@..9...
   192cc:	fead2385 6070d738 91103201 d523d6fc     .#..8.p`.2....#.
   192dc:	29861080 088e84c4 e1200113 61c979e0     ...)...... ..y.a
   192ec:	2632042a e7601c28 a6c75b53 3b047242     *.2&(.`.S[..Br.;
   192fc:	8213db24 1010319f e16da221 0f36e034     $....1..!.m.4.6.
   1930c:	214d893c a8ea5275 512a0408 e4a8e169     <.M!uR....*Qi...
   1931c:	9b19c097 deabac92 eaa19e2a e9d14111     ........*....A..
   1932c:	9f381e8b 201088cd e36d4623 841c5530     ..8.... #Fm.0U..
   1933c:	a2429b14 9a09d498 31188166 765ee6ad     ..B.....f..1..^v
   1934c:	16b4e1b5 e50ca1c9 485a2e2d 9b125d29     ........-.ZH)]..
   1935c:	7083be2d 6c00a9c8 db69f20a 16aa6f22     -..p...l..i."o..
   1936c:	214d8a42 ced8bf84 880d6c64 4d89b68c     B.M!....dl.....M
   1937c:	10c66cd9 a3b0b005 4642cc71 cdb80ce9     .l......q.BF....
   1938c:	0c692066 3620a487 c4b61085 c7c401f6     f i... 6........
   1939c:	80eda670 ca1ac3a4 bc8416d4 88be9d1a     p...............
   193ac:	2e6324b6 706d7776 7381d086 ac170e4a     .$c.vwmp...sJ...
   193bc:	96d4bc8f e00c810a 0a672565 14260442     ........e%g.B.&.
   193cc:	28585248 402466a3 0a05f7c6 d31a1137     HRX(.f$@....7...
   193dc:	e16a61f0 912285f8 ec712001 b63b9275     .aj...".. q.u.;.
   193ec:	c4fe2c8d 64e35528 24b89eec 3e500919     .,..(U.d...$..P>
   193fc:	cf3d15ef 08fc0297 911b676c 4084689c     ..=.....lg...h.@
   1940c:	f4640246 8535a8bd ad32442b 00a31849     F.d...5.+D2.I...
   1941c:	22432256 43e20123 a7e8d4c8 6eb5756a     V"C"#..C....ju.n
   1942c:	8ec6f787 7b159c5a 0609aa89 086e5541     ....Z..{....AUn.
   1943c:	ef2c8c91 0e6b57bc a57760f2 e1b4b886     ..,..Wk..`w.....
   1944c:	667dd335 f21cb253 8c81168b 04ffc1b6     5.}fS...........
   1945c:	bf610018 3952ebd8 0000dc31 45490000     ..a...R91.....IE
   1946c:	42ae444e 00008260                       ND.B`...

00019474 <__func__.14471>:
   19474:	5f4d454f 505f534c 6c75706f 50657461     OEM_LS_PopulateP
   19484:	6d617261 72657465 00000073              arameters...

00019490 <HardwareVersion>:
   19490:	00302e31 203a7325 000a7525 203a7325     1.0.%s: %u..%s: 
   194a0:	25207525 00000a66 203a7325 6d6f7266     %u %f...%s: from
   194b0:	74617453 75482865 75253d65 7461532c     State(Hue=%u,Sat
   194c0:	74617275 3d6e6f69 632c7525 726f6c6f     uration=%u,color
   194d0:	706d6554 2c75253d 67697242 656e7468     Temp=%u,Brightne
   194e0:	253d7373 6e4f2c75 3d66664f 2c297525     ss=%u,OnOff=%u),
   194f0:	536f7420 65746174 65754828 2c75253d      toState(Hue=%u,
   19500:	75746153 69746172 253d6e6f 6f632c75     Saturation=%u,co
   19510:	54726f6c 3d706d65 422c7525 68676972     lorTemp=%u,Brigh
   19520:	73656e74 75253d73 4f6e4f2c 253d6666     tness=%u,OnOff=%
   19530:	202c2975 69726570 253d646f 64202c75     u), period=%u, d
   19540:	74617275 3d6e6f69 202c7525 506d756e     uration=%u, numP
   19550:	65736c75 75253d73 7473202c 3d747261     ulses=%u, start=
   19560:	252f7525 00000a75 203a7325 6d6f7266     %u/%u...%s: from
   19570:	74617453 6e6f4365 6e696174 3e2d7265     StateContainer->
   19580:	74617473 65694665 6e49646c 61636964     stateFieldIndica
   19590:	73726f74 30203d20 2c782578 536f7420     tors = 0x%x, toS
   195a0:	65746174 746e6f43 656e6961 733e2d72     tateContainer->s
   195b0:	65746174 6c656946 646e4964 74616369     tateFieldIndicat
   195c0:	2073726f 7830203d 202c7825 69726570     ors = 0x%x, peri
   195d0:	253d646f 64202c75 74617275 3d6e6f69     od=%u, duration=
   195e0:	202c7525 506d756e 65736c75 75253d73     %u, numPulses=%u
   195f0:	7473202c 3d747261 252f7525 00000a75     , start=%u/%u...
   19600:	203a7325 6d6f7246 74617453 55203a65     %s: FromState: U
   19610:	74616470 20676e69 664f6e4f 6f742066     pdating OnOff to
   19620:	0a752520 00000000 203a7325 6d6f7246      %u.....%s: From
   19630:	74617453 55203a65 74616470 20676e69     State: Updating 
   19640:	20657548 25206f74 00000a75 203a7325     Hue to %u...%s: 
   19650:	6d6f7246 74617453 55203a65 74616470     FromState: Updat
   19660:	20676e69 75746153 69746172 74206e6f     ing Saturation t
   19670:	7525206f 0000000a 203a7325 6d6f7246     o %u....%s: From
   19680:	74617453 55203a65 74616470 20676e69     State: Updating 
   19690:	6f6c6f43 65542072 7420706d 7525206f     Color Temp to %u
   196a0:	0000000a 203a7325 6d6f7246 74617453     ....%s: FromStat
   196b0:	55203a65 74616470 20676e69 67697242     e: Updating Brig
   196c0:	656e7468 74207373 7525206f 0000000a     htness to %u....
   196d0:	203a7325 74536f54 3a657461 64705520     %s: ToState: Upd
   196e0:	6e697461 6e4f2067 2066664f 25206f74     ating OnOff to %
   196f0:	00000a75 203a7325 74536f54 3a657461     u...%s: ToState:
   19700:	64705520 6e697461 75482067 6f742065      Updating Hue to
   19710:	0a752520 00000000 203a7325 74536f54      %u.....%s: ToSt
   19720:	3a657461 64705520 6e697461 61532067     ate: Updating Sa
   19730:	61727574 6e6f6974 206f7420 000a7525     turation to %u..
   19740:	203a7325 74536f54 3a657461 64705520     %s: ToState: Upd
   19750:	6e697461 6f432067 20726f6c 706d6554     ating Color Temp
   19760:	206f7420 000a7525 203a7325 74536f54      to %u..%s: ToSt
   19770:	3a657461 64705520 6e697461 72422067     ate: Updating Br
   19780:	74686769 7373656e 206f7420 000a7525     ightness to %u..
   19790:	203a7325 65754828 2c75253d 75746153     %s: (Hue=%u,Satu
   197a0:	69746172 253d6e6f 6f632c75 54726f6c     ration=%u,colorT
   197b0:	3d706d65 422c7525 68676972 73656e74     emp=%u,Brightnes
   197c0:	75253d73 4f6e4f2c 253d6666 202c2975     s=%u,OnOff=%u), 
   197d0:	6e617274 69746973 65506e6f 646f6972     transitionPeriod
   197e0:	2c75253d 61747320 253d7472 75252f75     =%u, start=%u/%u
   197f0:	0000000a 203a7325 74617473 65694665     ....%s: stateFie
   19800:	6e49646c 61636964 73726f74 2578303d     ldIndicators=0x%
   19810:	74202c78 736e6172 6f697469 7265506e     x, transitionPer
   19820:	3d646f69 202c7525 72617473 75253d74     iod=%u, start=%u
   19830:	0a75252f 00000000 203a7325 61647055     /%u.....%s: Upda
   19840:	676e6974 4f6e4f20 74206666 7525206f     ting OnOff to %u
   19850:	0000000a 2d2d2d2d 2d2d2d2d 2d2d2d2d     ....------------
   19860:	2d2d2d2d 74617473 6e6f2e65 3d66664f     ----state.onOff=
   19870:	2d2d6425 2d2d2d2d 2d2d2d2d 2d2d2d2d     %d--------------
   19880:	2d2d2d2d 2d2d2d2d 00000a2d 203a7325     ---------...%s: 
   19890:	61647055 676e6974 65754820 206f7420     Updating Hue to 
   198a0:	000a7525 203a7325 61647055 676e6974     %u..%s: Updating
   198b0:	74615320 74617275 206e6f69 25206f74      Saturation to %
   198c0:	00000a75 203a7325 61647055 676e6974     u...%s: Updating
   198d0:	6c6f4320 5420726f 20706d65 25206f74      Color Temp to %
   198e0:	00000a75 203a7325 61647055 676e6974     u...%s: Updating
   198f0:	69724220 6e746867 20737365 25206f74      Brightness to %
   19900:	00000a75 656d6f53 746f6e20 63696669     u...Some notific
   19910:	6f697461 0000006e 253d3d3d 62203a73     ation...===%s: b
   19920:	68676972 73656e74 75252073 6d756c20     rightness %u lum
   19930:	3d736e65 000a3d3d 203a7325 65646f63     ens===..%s: code
   19940:	0a64253d 00000000 72656e45 555f7967     =%d.....Energy_U
   19950:	65676173 6c694d5f 6177696c 00737474     sage_Milliwatts.
   19960:	67697242 656e7468 4c5f7373 6e656d75     Brightness_Lumen
   19970:	00000073 706d614c 73726556 006e6f69     s...LampVersion.
   19980:	656b614d 00000000 65646f4d 0000006c     Make....Model...
   19990:	706d614c 65707954 00000000 706d614c     LampType....Lamp
   199a0:	65736142 65707954 00000000 706d614c     BaseType....Lamp
   199b0:	6d616542 6c676e41 00000065 6d6d6944     BeamAngle...Dimm
   199c0:	656c6261 00000000 6f6c6f43 00000072     able....Color...
   199d0:	69726156 656c6261 6f6c6f43 6d655472     VariableColorTem
   199e0:	00000070 45736148 63656666 00007374     p...HasEffects..
   199f0:	566e694d 61746c6f 00006567 5678614d     MinVoltage..MaxV
   19a00:	61746c6f 00006567 74746157 00656761     oltage..Wattage.
   19a10:	61636e49 7365646e 746e6563 69757145     IncandescentEqui
   19a20:	656c6176 0000746e 4c78614d 6e656d75     valent..MaxLumen
   19a30:	00000073 546e694d 65706d65 75746172     s...MinTemperatu
   19a40:	00006572 5478614d 65706d65 75746172     re..MaxTemperatu
   19a50:	00006572 6f6c6f43 6e655272 69726564     re..ColorRenderi
   19a60:	6e49676e 00786564 706d614c 00004449     ngIndex.LampID..
   19a70:	2e67726f 6a6c6c61 2e6e796f 4e737542     org.alljoyn.BusN
   19a80:	0065646f 70747468 692f2f3a 6567616d     ode.http://image
   19a90:	6c632e73 72617069 6e617074 632e6164     s.clipartpanda.c
   19aa0:	6c2f6d6f 74686769 6c75622d 6e702d62     om/light-bulb-pn
   19ab0:	33312d67 33393830 32373130 32333935     g-13089301725932
   19ac0:	39313233 30303532 632d7870 74737972     32192500px-cryst
   19ad0:	635f6c61 7261656c 7070615f 69746b5f     al_clear_app_kti
   19ae0:	76732e70 69682d67 676e702e 00000000     p.svg-hi.png....
   19af0:	67616d69 6e702f65 00000067              image/png...

00019afc <LampDetails>:
   19afc:	47010102 00000006 00000064 01010101     ...G....d.......
   19b0c:	000000b4 0000010e 000000f0 0000004b     ............K...
   19b1c:	00000384 00000a8c 00001388 00000000     ................

00019b2c <__func__.14403>:
   19b2c:	5f4d454f 415f534c 796c7070 736c7550     OEM_LS_ApplyPuls
   19b3c:	66664565 00746365                       eEffect.

00019b44 <__func__.14412>:
   19b44:	5f4d454f 415f534c 796c7070 736c7550     OEM_LS_ApplyPuls
   19b54:	66664565 4f746365 6174536e 69466574     eEffectOnStateFi
   19b64:	73646c65 00000000                       elds....

00019b6c <FirmwareVersion>:
   19b6c:	00302e31                                1.0.

00019b70 <__func__.14374>:
   19b70:	5f4d454f 535f534c 6e4f7465 0066664f     OEM_LS_SetOnOff.

00019b80 <__func__.14420>:
   19b80:	5f4d454f 545f534c 736e6172 6f697469     OEM_LS_Transitio
   19b90:	6174536e 00006574                       nState..

00019b98 <__func__.14379>:
   19b98:	5f4d454f 535f534c 75487465 00000065     OEM_LS_SetHue...

00019ba8 <__func__.14384>:
   19ba8:	5f4d454f 535f534c 72427465 74686769     OEM_LS_SetBright
   19bb8:	7373656e 00000000                       ness....

00019bc0 <__func__.14426>:
   19bc0:	5f4d454f 545f534c 736e6172 6f697469     OEM_LS_Transitio
   19bd0:	6174536e 69466574 73646c65 00000000     nStateFields....

00019be0 <__func__.14389>:
   19be0:	5f4d454f 535f534c 61537465 61727574     OEM_LS_SetSatura
   19bf0:	6e6f6974 00000000                       tion....

00019bf8 <__func__.14394>:
   19bf8:	5f4d454f 535f534c 6f437465 54726f6c     OEM_LS_SetColorT
   19c08:	00706d65                                emp.

00019c0c <__func__.14440>:
   19c0c:	5f4d454f 525f534c 61747365 00007472     OEM_LS_Restart..

00019c1c <DEFAULT_MANUFACTURER_LANG1>:
   19c1c:	706d6f43 20796e61 4e452841 00000029     Company A(EN)...

00019c2c <DEFAULT_MANUFACTURER_LANG2>:
   19c2c:	6d726946 28412061 412d4544 00002954     Firma A(DE-AT)..

00019c3c <SUPPORTED_LANG2>:
   19c3c:	412d6564 00000054                       de-AT...

00019c44 <DEFAULT_LANGUAGE>:
   19c44:	00006e65                                en..

00019c48 <DEFAULT_DESCRIPTION_LANG2>:
   19c48:	6e69654d 73726520 20736574 20454f49     Mein erstes IOE 
   19c58:	61726547 00007465                       Geraet..

00019c60 <DEFAULT_DEVICE_NAME_LANG2>:
   19c60:	69766544 4e206563 20656d61 29454428     Device Name (DE)
   19c70:	00000000 00412f4e 732f2e2e 612f6372     ....N/A.../src/a
   19c80:	6f6a6c6c 6c2f6e79 20706d61 76726573     lljoyn/lamp serv
   19c90:	2f656369 2f637273 5f4d454f 505f534c     ice/src/OEM_LS_P
   19ca0:	69766f72 6e6f6973 2e676e69 00000063     rovisioning.c...
   19cb0:	61647055 69466574 49646c65 4d41526e     UpdateFieldInRAM
   19cc0:	52524520 2d20524f 65696620 2520646c      ERROR - field %
   19cd0:	61682073 65722073 6f206461 20796c6e     s has read only 
   19ce0:	72747461 74756269 726f2065 20736920     attribute or is 
   19cf0:	76697270 0a657461 00000000 70707553     private.....Supp
   19d00:	6574726f 6e614c64 67617567 00007365     ortedLanguages..
   19d10:	00007361 69766544 64496563 00000000     as..DeviceId....
   19d20:	49707041 00000064 69766544 614e6563     AppId...DeviceNa
   19d30:	0000656d 61666544 4c746c75 75676e61     me..DefaultLangu
   19d40:	00656761 73736150 65646f63 00000000     age.Passcode....
   19d50:	6c616552 6d614e6d 00000065 4e707041     RealmName...AppN
   19d60:	00656d61 63736544 74706972 006e6f69     ame.Description.
   19d70:	756e614d 74636166 72657275 00000000     Manufacturer....
   19d80:	65646f4d 6d754e6c 00726562 65746144     ModelNumber.Date
   19d90:	614d664f 6166756e 72757463 00000065     OfManufacture...
   19da0:	74666f53 65726177 73726556 006e6f69     SoftwareVersion.
   19db0:	6f534a41 61777466 65566572 6f697372     AJSoftwareVersio
   19dc0:	0000006e 4c78614d 74676e65 00000068     n...MaxLength...
   19dd0:	64726148 65726177 73726556 006e6f69     HardwareVersion.
   19de0:	70707553 5574726f 00006c72 35313032     SupportUrl..2015
   19df0:	2d31312d 00003630 2e302e30 00000031     -11-06..0.0.1...
   19e00:	69746f4e 72656966 00000000 30333033     Notifier....3030
   19e10:	30333033 30333033 00000000              30303030....

00019e1c <DEFAULT_DEVICE_NAME_LANG1>:
   19e1c:	446f6345 00006d69                       EcoDim..

00019e24 <propertyStoreProperties>:
   19e24:	00019d14 0000008a 00019d20 0000008a     ........ .......
   19e34:	00019d28 0000008f 00019d34 00000083     (.......4.......
   19e44:	00019d44 00000001 00019d50 00000001     D.......P.......
   19e54:	00019d5c 00000082 00019d64 00000084     \.......d.......
   19e64:	00019d70 00000096 00019d80 00000082     p...............
   19e74:	00019d8c 00000080 00019da0 00000080     ................
   19e84:	00019db0 00000080 00019dc4 00000082     ................
   19e94:	00019dd0 00000080 00019de0 00000084     ................

00019ea4 <DEFAULT_DESCRIPTION_LANG1>:
   19ea4:	706d614c 6d696420 0072656d              Lamp dimmer.

00019eb0 <DEFAULT_SUPPORT_URL_LANG1>:
   19eb0:	70747468 772f2f3a 652e7777 706d6178     http://www.examp
   19ec0:	632e656c 00006d6f                       le.com..

00019ec8 <DEFAULT_SUPPORT_URL_LANG2>:
   19ec8:	70747468 772f2f3a 652e7777 706d6178     http://www.examp
   19ed8:	632e656c 00006d6f 04030201 04030201     le.com..........
   19ee8:	04030201 04030201 0000006f 415f4a41     ........o...AJ_A
   19ef8:	74756f62 6f6e6e41 65636e75 6e202d20     boutAnnounce - n
   19f08:	6968746f 7420676e 6e61206f 6e756f6e     othing to announ
   19f18:	00006563 415f4a41 74756f62 6f6e6e41     ce..AJ_AboutAnno
   19f28:	65636e75 61202d20 756f6e6e 6e69636e     unce - announcin
   19f38:	6f702067 253d7472 00000a64 415f4a41     g port=%d...AJ_A
   19f48:	74756f62 6f6e6e41 65636e75 72726520     boutAnnounce err
   19f58:	3120726f 61747320 3d737574 0a732520     or 1 status= %s.
   19f68:	00000000 415f4a41 74756f62 6f6e6e41     ....AJ_AboutAnno
   19f78:	65636e75 72726520 3220726f 61747320     unce error 2 sta
   19f88:	3d737574 0a732520 00000000 415f4a41     tus= %s.....AJ_A
   19f98:	74756f62 6f6e6e41 65636e75 72726520     boutAnnounce err
   19fa8:	3320726f 61747320 3d737574 0a732520     or 3 status= %s.
   19fb8:	00000000 6f6e6e41 65636e75 6a626f20     ....Announce obj
   19fc8:	20746365 202e2e2e 00000000 415f4a41     ect ... ....AJ_A
   19fd8:	74756f62 6f6e6e41 65636e75 72726520     boutAnnounce err
   19fe8:	3420726f 61747320 3d737574 0a732520     or 4 status= %s.
   19ff8:	00000000 415f4a41 74756f62 6f6e6e41     ....AJ_AboutAnno
   1a008:	65636e75 73203520 75746174 25203d73     unce 5 status= %
   1a018:	00000a73 415f4a41 74756f62 6f6e6e41     s...AJ_AboutAnno
   1a028:	65636e75 73203620 75746174 25203d73     unce 6 status= %
   1a038:	00000a73 415f4a41 74756f62 6f6e6e41     s...AJ_AboutAnno
   1a048:	65636e75 72726520 3720726f 61747320     unce error 7 sta
   1a058:	3d737574 0a732520 00000000 415f4a41     tus= %s.....AJ_A
   1a068:	74756f62 6e616e55 6e756f6e 29286563     boutUnannounce()
   1a078:	6f4e203a 6f626120 61207475 756f6e6e     : No about annou
   1a088:	6d65636e 20746e65 63206f74 65636e61     ncement to cance
   1a098:	0000006c 79617928 00000029 732f2e2e     l...(yay)...../s
   1a0a8:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1a0b8:	65726f63 6372732f 5f6a612f 68747561     core/src/aj_auth
   1a0c8:	69746e65 69746163 632e6e6f 00000000     entication.c....
   1a0d8:	3c203233 6973203d 0000657a 7473616d     32 <= size..mast
   1a0e8:	73207265 65726365 00000074 48444345     er secret...ECDH
   1a0f8:	72614d45 6c616873 78746328 2c70253d     EMarshal(ctx=%p,
   1a108:	67736d20 2970253d 0000000a 48444345      msg=%p)....ECDH
   1a118:	72614d45 6c616873 20666920 54554128     EMarshal if (AUT
   1a128:	4c435f48 544e4549 203d3d20 2d787463     H_CLIENT == ctx-
   1a138:	6c6f723e 20202965 0000000a 48444345     >role)  ....ECDH
   1a148:	72614d45 6c616873 5f4a4120 656e6547     EMarshal AJ_Gene
   1a158:	65746172 654b4844 69615079 74732072     rateDHKeyPair st
   1a168:	73757461 0a73253d 00000000 48444345     atus=%s.....ECDH
   1a178:	72614d45 6c616873 20666920 74632828     EMarshal if ((ct
   1a188:	763e2d78 69737265 3e206e6f 3631203e     x->version >> 16
   1a198:	203c2029 00202933 48444345 72614d45     ) < 3) .ECDHEMar
   1a1a8:	6c616873 44434520 614d4548 61687372     shal ECDHEMarsha
   1a1b8:	2031566c 74617473 253d7375 00000a73     lV1 status=%s...
   1a1c8:	48444345 72614d45 6c616873 20666920     ECDHEMarshal if 
   1a1d8:	74632828 763e2d78 69737265 3e206e6f     ((ctx->version >
   1a1e8:	3631203e 203c2029 65202933 2065736c     > 16) < 3) else 
   1a1f8:	00000000 48444345 72614d45 6c616873     ....ECDHEMarshal
   1a208:	44434520 614d4548 61687372 2032566c      ECDHEMarshalV2 
   1a218:	74617473 253d7375 00000a73 48444345     status=%s...ECDH
   1a228:	6d6e5545 68737261 63286c61 253d7874     EUnmarshal(ctx=%
   1a238:	6d202c70 253d6773 000a2970 48444345     p, msg=%p)..ECDH
   1a248:	6d6e5545 68737261 69206c61 41282066     EUnmarshal if (A
   1a258:	5f485455 56524553 3d205245 7463203d     UTH_SERVER == ct
   1a268:	723e2d78 29656c6f 00000020 48444345     x->role) ...ECDH
   1a278:	6d6e5545 68737261 73206c61 75746174     EUnmarshal statu
   1a288:	73253d73 00000a20 48444345 6d6e5545     s=%s ...ECDHEUnm
   1a298:	68737261 69206c61 28282066 2d787463     arshal if ((ctx-
   1a2a8:	7265763e 6e6f6973 203e3e20 20293631     >version >> 16) 
   1a2b8:	2933203c 00000020 48444345 6d6e5545     < 3) ...ECDHEUnm
   1a2c8:	68737261 45206c61 45484443 616d6e55     arshal ECDHEUnma
   1a2d8:	61687372 2031566c 74617473 253d7375     rshalV1 status=%
   1a2e8:	000a2073 48444345 6d6e5545 68737261     s ..ECDHEUnmarsh
   1a2f8:	65206c61 2065736c 00000000 48444345     al else ....ECDH
   1a308:	6d6e5545 68737261 45206c61 45484443     EUnmarshal ECDHE
   1a318:	616d6e55 61687372 2032566c 74617473     UnmarshalV2 stat
   1a328:	253d7375 00000a73 65696c63 6620746e     us=%s...client f
   1a338:	73696e69 00646568 76726573 66207265     inished.server f
   1a348:	73696e69 00646568 6f6e613c 6f6d796e     inished.<anonymo
   1a358:	003e7375 61796128 00002979 455f4a41     us>.(ayay)..AJ_E
   1a368:	41534443 72614d5f 6c616873 67736d28     CDSA_Marshal(msg
   1a378:	2970253d 7250203a 74617669 656b2065     =%p): Private ke
   1a388:	65722079 72697571 000a6465 455f4a41     y required..AJ_E
   1a398:	41534443 72614d5f 6c616873 67736d28     CDSA_Marshal(msg
   1a3a8:	2970253d 6953203a 76206e67 66697265     =%p): Sign verif
   1a3b8:	20726569 6f727265 00000a72 76797628     ier error...(vyv
   1a3c8:	00000029 29767928 00000000 79612861     )...(yv)....a(ay
   1a3d8:	00000029 455f4a41 41534443 72614d5f     )...AJ_ECDSA_Mar
   1a3e8:	6c616873 67736d28 2970253d 6543203a     shal(msg=%p): Ce
   1a3f8:	66697472 74616369 68632065 206e6961     rtificate chain 
   1a408:	75716572 64657269 0000000a 29796128     required....(ay)
   1a418:	00000000 455f4a41 41534443 72614d5f     ....AJ_ECDSA_Mar
   1a428:	6c616873 67736d28 2970253d 614d203a     shal(msg=%p): Ma
   1a438:	61687372 6563206c 66697472 74616369     rshal certificat
   1a448:	72652065 0a726f72 00000000 455f4a41     e error.....AJ_E
   1a458:	41534443 6d6e555f 68737261 6d286c61     CDSA_Unmarshal(m
   1a468:	253d6773 203a2970 6f736552 65637275     sg=%p): Resource
   1a478:	72726520 000a726f 455f4a41 41534443      error..AJ_ECDSA
   1a488:	6d6e555f 68737261 6d286c61 253d6773     _Unmarshal(msg=%
   1a498:	203a2970 74726543 63696669 20657461     p): Certificate 
   1a4a8:	6f636564 66206564 656c6961 00000a64     decode failed...

0001a4b8 <__func__.6313>:
   1a4b8:	48444345 6d6e5545 68737261 32566c61     ECDHEUnmarshalV2
   1a4c8:	00000000                                ....

0001a4cc <defaultSessionOpts>:
   1a4cc:	0105ff01 00000000 66617274 00000000     ........traf....
   1a4dc:	746c756d 00000069 786f7270 00000000     multi...prox....
   1a4ec:	6e617274 00000073 706f7250 65636341     trans...PropAcce
   1a4fc:	29287373 4a41203a 5252455f 4749535f     ss(): AJ_ERR_SIG
   1a50c:	5554414e 00004552 706f7250 65636341     NATURE..PropAcce
   1a51c:	6d287373 303d6773 2c702578 3d626320     ss(msg=0x%p, cb=
   1a52c:	70257830 706f202c 2973253d 0000000a     0x%p, op=%s)....
   1a53c:	00746573 00746567 425f4a41 65527375     set.get.AJ_BusRe
   1a54c:	73657571 6d614e74 75622865 78303d73     questName(bus=0x
   1a55c:	202c7025 656d616e 7325223d 66202c22     %p, name="%s", f
   1a56c:	7367616c 2578303d 000a2978 00007573     lags=0x%x)..su..
   1a57c:	425f4a41 65527375 7361656c 6d614e65     AJ_BusReleaseNam
   1a58c:	75622865 78303d73 202c7025 656d616e     e(bus=0x%p, name
   1a59c:	7325223d 000a2922 425f4a41 64417375     ="%s")..AJ_BusAd
   1a5ac:	74726576 4e657369 28656d61 3d737562     vertiseName(bus=
   1a5bc:	70257830 616e202c 223d656d 2c227325     0x%p, name="%s",
   1a5cc:	61727420 6f70736e 614d7472 303d6b73      transportMask=0
   1a5dc:	2c782578 3d706f20 292e6425 0000000a     x%x, op=%d.)....
   1a5ec:	00007173 425f4a41 69467375 6441646e     sq..AJ_BusFindAd
   1a5fc:	74726576 4e657369 28656d61 3d737562     vertiseName(bus=
   1a60c:	70257830 616e202c 7250656d 78696665     0x%p, namePrefix
   1a61c:	7325223d 6f202c22 64253d70 000a292e     ="%s", op=%d.)..
   1a62c:	425f4a41 69467375 6441646e 74726576     AJ_BusFindAdvert
   1a63c:	4e657369 42656d61 61725479 6f70736e     iseNameByTranspo
   1a64c:	62287472 303d7375 2c702578 6d616e20     rt(bus=0x%p, nam
   1a65c:	65725065 3d786966 22732522 7274202c     ePrefix="%s", tr
   1a66c:	70736e61 3d74726f 2c2e6425 3d706f20     ansport=%d., op=
   1a67c:	292e6425 0000000a 425f4a41 69427375     %d.)....AJ_BusBi
   1a68c:	6553646e 6f697373 726f506e 75622874     ndSessionPort(bu
   1a69c:	78303d73 202c7025 74726f70 2e64253d     s=0x%p, port=%d.
   1a6ac:	706f202c 303d7374 29702578 0000000a     , opts=0x%p)....
   1a6bc:	425f4a41 6e557375 646e6962 73736553     AJ_BusUnbindSess
   1a6cc:	286e6f69 3d737562 70257830 6f70202c     ion(bus=0x%p, po
   1a6dc:	253d7472 0a292e64 00000000 425f4a41     rt=%d.).....AJ_B
   1a6ec:	61437375 6c65636e 73736553 6c6e6f69     usCancelSessionl
   1a6fc:	28737365 3d737562 70257830 6573202c     ess(bus=0x%p, se
   1a70c:	6c616972 3d6d754e 292e6425 0000000a     rialNum=%d.)....
   1a71c:	425f4a41 6f4a7375 65536e69 6f697373     AJ_BusJoinSessio
   1a72c:	7562286e 78303d73 202c7025 73736573     n(bus=0x%p, sess
   1a73c:	486e6f69 3d74736f 22732522 6f70202c     ionHost="%s", po
   1a74c:	253d7472 202c2e64 7374706f 2578303d     rt=%d., opts=0x%
   1a75c:	000a2970 425f4a41 654c7375 53657661     p)..AJ_BusLeaveS
   1a76c:	69737365 62286e6f 303d7375 2c702578     ession(bus=0x%p,
   1a77c:	73657320 6e6f6973 253d6449 0a292e64      sessionId=%d.).
   1a78c:	00000000 425f4a41 65537375 6e694c74     ....AJ_BusSetLin
   1a79c:	6d69546b 74756f65 73756228 2578303d     kTimeout(bus=0x%
   1a7ac:	73202c70 69737365 64496e6f 2e64253d     p, sessionId=%d.
   1a7bc:	696c202c 69546b6e 756f656d 64253d74     , linkTimeout=%d
   1a7cc:	000a292e 425f4a41 65537375 67695374     .)..AJ_BusSetSig
   1a7dc:	526c616e 53656c75 61697265 7562286c     nalRuleSerial(bu
   1a7ec:	78303d73 202c7025 656c7572 69727453     s=0x%p, ruleStri
   1a7fc:	223d676e 2c227325 6c757220 64253d65     ng="%s", rule=%d
   1a80c:	000a292e 425f4a41 64417375 67695364     .)..AJ_BusAddSig
   1a81c:	526c616e 28656c75 3d737562 70257830     nalRule(bus=0x%p
   1a82c:	6973202c 6c616e67 656d614e 7325223d     , signalName="%s
   1a83c:	69202c22 7265746e 65636166 656d614e     ", interfaceName
   1a84c:	7325223d 72202c22 3d656c75 292e6425     ="%s", rule=%d.)
   1a85c:	0000000a 65707974 6973273d 6c616e67     ....type='signal
   1a86c:	656d2c27 7265626d 0000273d 746e6927     ',member='..'int
   1a87c:	61667265 273d6563 00000000 425f4a41     erface='....AJ_B
   1a88c:	65527375 41796c70 70656363 73655374     usReplyAcceptSes
   1a89c:	6e6f6973 67736d28 2578303d 61202c70     sion(msg=0x%p, a
   1a8ac:	70656363 64253d74 000a292e 425f4a41     ccept=%d.)..AJ_B
   1a8bc:	65527375 65766f6d 73736553 4d6e6f69     usRemoveSessionM
   1a8cc:	65626d65 75622872 78303d73 202c7025     ember(bus=0x%p, 
   1a8dc:	73736573 496e6f69 64253d64 656d202c     sessionId=%d, me
   1a8ec:	7265626d 2e73253d 00000a29 425f4a41     mber=%s.)...AJ_B
   1a8fc:	69507375 6228676e 303d7375 2c702578     usPing(bus=0x%p,
   1a90c:	6d616e20 73253d65 6974202c 756f656d      name=%s, timeou
   1a91c:	64253d74 00000a29 425f4a41 61487375     t=%d)...AJ_BusHa
   1a92c:	656c646e 4d737542 61737365 6d286567     ndleBusMessage(m
   1a93c:	303d6773 29702578 0000000a 425f4a41     sg=0x%p)....AJ_B
   1a94c:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1a95c:	29286567 4a41203a 54454d5f 5f444f48     ge(): AJ_METHOD_
   1a96c:	474e4950 00000000 4d5f4a41 4f485445     PING....AJ_METHO
   1a97c:	4f4a5f44 535f4e49 49535345 00004e4f     D_JOIN_SESSION..
   1a98c:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1a99c:	61737365 29286567 4a41203a 54454d5f     essage(): AJ_MET
   1a9ac:	5f444f48 5f544547 4843414d 5f454e49     HOD_GET_MACHINE_
   1a9bc:	00004449 646e6148 6547656c 63614d74     ID..HandleGetMac
   1a9cc:	656e6968 6d286449 303d6773 2c702578     hineId(msg=0x%p,
   1a9dc:	70657220 303d796c 29702578 0000000a      reply=0x%p)....
   1a9ec:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1a9fc:	61737365 29286567 4a41203a 54454d5f     essage(): AJ_MET
   1aa0c:	5f444f48 52544e49 4550534f 00005443     HOD_INTROSPECT..
   1aa1c:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1aa2c:	61737365 29286567 4a41203a 54454d5f     essage(): AJ_MET
   1aa3c:	5f444f48 5f544547 43534544 54504952     HOD_GET_DESCRIPT
   1aa4c:	5f4e4f49 474e414c 00000000 425f4a41     ION_LANG....AJ_B
   1aa5c:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1aa6c:	29286567 4a41203a 54454d5f 5f444f48     ge(): AJ_METHOD_
   1aa7c:	52544e49 4550534f 575f5443 5f485449     INTROSPECT_WITH_
   1aa8c:	43534544 00000000 425f4a41 61487375     DESC....AJ_BusHa
   1aa9c:	656c646e 4d737542 61737365 29286567     ndleBusMessage()
   1aaac:	4a41203a 54454d5f 5f444f48 48435845     : AJ_METHOD_EXCH
   1aabc:	45474e41 4955475f 00005344 425f4a41     ANGE_GUIDS..AJ_B
   1aacc:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1aadc:	29286567 4a41203a 54454d5f 5f444f48     ge(): AJ_METHOD_
   1aaec:	5f4e4547 53534553 5f4e4f49 0059454b     GEN_SESSION_KEY.
   1aafc:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1ab0c:	61737365 29286567 4a41203a 54454d5f     essage(): AJ_MET
   1ab1c:	5f444f48 48435845 45474e41 4f52475f     HOD_EXCHANGE_GRO
   1ab2c:	4b5f5055 00535945 425f4a41 61487375     UP_KEYS.AJ_BusHa
   1ab3c:	656c646e 4d737542 61737365 29286567     ndleBusMessage()
   1ab4c:	4a41203a 54454d5f 5f444f48 48435845     : AJ_METHOD_EXCH
   1ab5c:	45474e41 4955535f 00534554 425f4a41     ANGE_SUITES.AJ_B
   1ab6c:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1ab7c:	29286567 4a41203a 54454d5f 5f444f48     ge(): AJ_METHOD_
   1ab8c:	5f59454b 48435845 45474e41 00000000     KEY_EXCHANGE....
   1ab9c:	4d5f4a41 4f485445 454b5f44 58455f59     AJ_METHOD_KEY_EX
   1abac:	4e414843 73204547 75746174 73253d73     CHANGE status=%s
   1abbc:	0000000a 425f4a41 61487375 656c646e     ....AJ_BusHandle
   1abcc:	4d737542 61737365 29286567 4a41203a     BusMessage(): AJ
   1abdc:	54454d5f 5f444f48 5f59454b 48545541     _METHOD_KEY_AUTH
   1abec:	49544e45 49544143 00004e4f 425f4a41     ENTICATION..AJ_B
   1abfc:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1ac0c:	29286567 4a41203a 5045525f 495f594c     ge(): AJ_REPLY_I
   1ac1c:	4a412844 54454d5f 5f444f48 48435845     D(AJ_METHOD_EXCH
   1ac2c:	45474e41 4955475f 00295344 425f4a41     ANGE_GUIDS).AJ_B
   1ac3c:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1ac4c:	29286567 4a41203a 5045525f 495f594c     ge(): AJ_REPLY_I
   1ac5c:	4a412844 54454d5f 5f444f48 48435845     D(AJ_METHOD_EXCH
   1ac6c:	45474e41 4955535f 29534554 00000000     ANGE_SUITES)....
   1ac7c:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1ac8c:	61737365 29286567 4a41203a 5045525f     essage(): AJ_REP
   1ac9c:	495f594c 4a412844 54454d5f 5f444f48     LY_ID(AJ_METHOD_
   1acac:	5f59454b 48435845 45474e41 00000029     KEY_EXCHANGE)...
   1acbc:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1accc:	61737365 29286567 4a41203a 5045525f     essage(): AJ_REP
   1acdc:	495f594c 4a412844 54454d5f 5f444f48     LY_ID(AJ_METHOD_
   1acec:	5f59454b 48545541 49544e45 49544143     KEY_AUTHENTICATI
   1acfc:	00294e4f 425f4a41 61487375 656c646e     ON).AJ_BusHandle
   1ad0c:	4d737542 61737365 29286567 4a41203a     BusMessage(): AJ
   1ad1c:	5045525f 495f594c 4a412844 54454d5f     _REPLY_ID(AJ_MET
   1ad2c:	5f444f48 5f4e4547 53534553 5f4e4f49     HOD_GEN_SESSION_
   1ad3c:	2959454b 00000000 425f4a41 61487375     KEY)....AJ_BusHa
   1ad4c:	656c646e 4d737542 61737365 29286567     ndleBusMessage()
   1ad5c:	4a41203a 5045525f 495f594c 4a412844     : AJ_REPLY_ID(AJ
   1ad6c:	54454d5f 5f444f48 48435845 45474e41     _METHOD_EXCHANGE
   1ad7c:	4f52475f 4b5f5055 29535945 00000000     _GROUP_KEYS)....
   1ad8c:	425f4a41 61487375 656c646e 4d737542     AJ_BusHandleBusM
   1ad9c:	61737365 29286567 4a41203a 5045525f     essage(): AJ_REP
   1adac:	495f594c 4a412844 54454d5f 5f444f48     LY_ID(AJ_METHOD_
   1adbc:	434e4143 535f4c45 49535345 454c4e4f     CANCEL_SESSIONLE
   1adcc:	00295353 425f4a41 61487375 656c646e     SS).AJ_BusHandle
   1addc:	4d737542 61737365 29286567 4a41203a     BusMessage(): AJ
   1adec:	4749535f 5f4c414e 5345537b 4e4f4953     _SIGNAL_{SESSION
   1adfc:	494f4a5f 7c44454e 454d414e 5143415f     _JOINED|NAME_ACQ
   1ae0c:	45524955 00007d44 425f4a41 61487375     UIRED}..AJ_BusHa
   1ae1c:	656c646e 4d737542 61737365 29286567     ndleBusMessage()
   1ae2c:	4a41203a 5045525f 495f594c 4a412844     : AJ_REPLY_ID(AJ
   1ae3c:	54454d5f 5f444f48 4e41437b 5f4c4543     _METHOD_{CANCEL_
   1ae4c:	45564441 53495452 44417c45 54524556     ADVERTISE|ADVERT
   1ae5c:	5f455349 454d414e 0000297d 415f4a41     ISE_NAME})..AJ_A
   1ae6c:	74756f62 646e6148 6547656c 6f725074     boutHandleGetPro
   1ae7c:	00000070 415f4a41 74756f62 646e6148     p...AJ_AboutHand
   1ae8c:	6547656c 6f624174 61447475 00006174     leGetAboutData..
   1ae9c:	415f4a41 74756f62 646e6148 6547656c     AJ_AboutHandleGe
   1aeac:	6a624f74 44746365 72637365 69747069     tObjectDescripti
   1aebc:	00006e6f 415f4a41 74756f62 6e6f6349     on..AJ_AboutIcon
   1aecc:	646e6148 6547656c 6f725074 00000070     HandleGetProp...
   1aedc:	415f4a41 74756f62 6e6f6349 646e6148     AJ_AboutIconHand
   1aeec:	6547656c 4c525574 00000000 415f4a41     leGetURL....AJ_A
   1aefc:	74756f62 6e6f6349 646e6148 6547656c     boutIconHandleGe
   1af0c:	6e6f4374 746e6574 00000000 425f4a41     tContent....AJ_B
   1af1c:	61487375 656c646e 4d737542 61737365     usHandleBusMessa
   1af2c:	29286567 69777320 3a686374 66656420     ge() switch: def
   1af3c:	746c7561 00000000 4d5f4a41 4d5f4753     ault....AJ_MSG_M
   1af4c:	4f485445 41435f44 00004c4c 74697773     ETHOD_CALL..swit
   1af5c:	65206863 7320646e 75746174 25203d73     ch end status= %
   1af6c:	00000a73 2d67736d 7264683e 736d3e2d     s...msg->hdr->ms
   1af7c:	70795467 3d3d2065 5f4a4120 5f47534d     gType == AJ_MSG_
   1af8c:	4854454d 435f444f 004c4c41 415f4a41     METHOD_CALL.AJ_A
   1af9c:	74756f62 6f6e6e41 65636e75 00000000     boutAnnounce....
   1afac:	425f4a41 65537375 73615074 726f7773     AJ_BusSetPasswor
   1afbc:	6c614364 6361626c 7562286b 78303d73     dCallback(bus=0x
   1afcc:	202c7025 43647770 626c6c61 3d6b6361     %p, pwdCallback=
   1afdc:	70257830 00000a29 425f4a41 65537375     0x%p)...AJ_BusSe
   1afec:	74754174 73694c68 656e6574 6c614372     tAuthListenerCal
   1affc:	6361626c 7562286b 78303d73 202c7025     lback(bus=0x%p, 
   1b00c:	68747561 7473694c 72656e65 6c6c6143     authListenerCall
   1b01c:	6b636162 2578303d 000a2970 425f4a41     back=0x%p)..AJ_B
   1b02c:	75417375 6e656874 61636974 65506574     usAuthenticatePe
   1b03c:	62287265 303d7375 2c702578 65657020     er(bus=0x%p, pee
   1b04c:	6d614e72 25223d65 202c2273 6c6c6163     rName="%s", call
   1b05c:	6b636162 2578303d 63202c70 6e6f4362     back=0x%p, cbCon
   1b06c:	74786574 2578303d 000a2970 425f4a41     text=0x%p)..AJ_B
   1b07c:	72507375 6547706f 736d2874 78303d67     usPropGet(msg=0x
   1b08c:	202c7025 6c6c6163 6b636162 2578303d     %p, callback=0x%
   1b09c:	63202c70 65746e6f 303d7478 29702578     p, context=0x%p)
   1b0ac:	0000000a 425f4a41 72507375 6553706f     ....AJ_BusPropSe
   1b0bc:	736d2874 78303d67 202c7025 6c6c6163     t(msg=0x%p, call
   1b0cc:	6b636162 2578303d 63202c70 65746e6f     back=0x%p, conte
   1b0dc:	303d7478 29702578 0000000a 425f4a41     xt=0x%p)....AJ_B
   1b0ec:	72507375 6547706f 6c6c4174 67736d28     usPropGetAll(msg
   1b0fc:	2578303d 63202c70 626c6c61 3d6b6361     =0x%p, callback=
   1b10c:	70257830 6f63202c 7865746e 78303d74     0x%p, context=0x
   1b11c:	0a297025 00000000 706f7250 65636341     %p).....PropAcce
   1b12c:	6c417373 736d286c 78303d67 202c7025     ssAll(msg=0x%p, 
   1b13c:	303d6263 29702578 0000000a 425f4a41     cb=0x%p)....AJ_B
   1b14c:	6e457375 656c6261 75636553 79746972     usEnableSecurity
   1b15c:	73756228 2578303d 73202c70 65746975     (bus=0x%p, suite
   1b16c:	78303d73 0a297025 00000000 00a00402     s=0x%p).........
   1b17c:	00031010 101002a0 a0101010 00000310     ................
   1b18c:	00000606 00000406 00040106 00000201     ................
   1b19c:	00000202                                ....

0001b1a0 <OID_SIG_ECDSA_SHA256>:
   1b1a0:	ce48862a 0203043d                       *.H.=...

0001b1a8 <OID_DN_CN>:
   1b1a8:	00030455                                U...

0001b1ac <OID_KEY_ECC>:
   1b1ac:	ce48862a 0001023d                       *.H.=...

0001b1b4 <OID_DN_OU>:
   1b1b4:	000b0455 2d2d2d2d 4745422d 45204e49     U...-----BEGIN E
   1b1c4:	52502043 54415649 454b2045 2d2d2d59     C PRIVATE KEY---
   1b1d4:	00002d2d 2d2d2d2d 444e452d 20434520     --..-----END EC 
   1b1e4:	56495250 20455441 2d59454b 2d2d2d2d     PRIVATE KEY-----
   1b1f4:	00000000 6d257925 48256425 53254d25     ....%y%m%d%H%M%S
   1b204:	0000005a 6d255925 48256425 53254d25     Z...%Y%m%d%H%M%S
   1b214:	0000005a 2d2d2d2d 4745422d 43204e49     Z...-----BEGIN C
   1b224:	49545245 41434946 2d2d4554 002d2d2d     ERTIFICATE-----.
   1b234:	2d2d2d2d 444e452d 52454320 49464954     -----END CERTIFI
   1b244:	45544143 2d2d2d2d 0000002d              CATE-----...

0001b250 <OID_BASIC_CONSTRAINTS>:
   1b250:	00131d55                                U...

0001b254 <OID_CRV_PRIME256V1>:
   1b254:	ce48862a 0701033d                       *.H.=...

0001b25c <daemonService>:
   1b25c:	2e67726f 6a6c6c61 2e6e796f 4e737542     org.alljoyn.BusN
   1b26c:	0065646f 74697257 6e694c65 69203a65     ode.WriteLine: i
   1b27c:	6675426f 65733e2d 6928646e 6675426f     oBuf->send(ioBuf
   1b28c:	00002029 65707974 6973273d 6c616e67     ) ..type='signal
   1b29c:	656d2c27 7265626d 614e273d 774f656d     ',member='NameOw
   1b2ac:	4372656e 676e6168 2c276465 65746e69     nerChanged',inte
   1b2bc:	63616672 6f273d65 662e6772 64656572     rface='org.freed
   1b2cc:	746b7365 442e706f 27737542 00000000     esktop.DBus'....
   1b2dc:	48545541 4f4e4120 4f4d594e 000a5355     AUTH ANONYMOUS..
   1b2ec:	00004b4f 4f464e49 505f4d52 4f544f52     OK..INFORM_PROTO
   1b2fc:	5245565f 4e4f4953 00000000 732f2e2e     _VERSION....../s
   1b30c:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1b31c:	65726f63 6372732f 5f6a612f 6e6e6f63     core/src/aj_conn
   1b32c:	2e746365 00000063 415f4a41 65687475     ect.c...AJ_Authe
   1b33c:	6369746e 28657461 41203a29 52455f4a     nticate(): AJ_ER
   1b34c:	49545f52 554f454d 00000054 415f4a41     R_TIMEOUT...AJ_A
   1b35c:	65687475 6369746e 28657461 41203a29     uthenticate(): A
   1b36c:	52455f4a 45525f52 52554f53 00534543     J_ERR_RESOURCES.
   1b37c:	4f464e49 505f4d52 4f544f52 5245565f     INFORM_PROTO_VER
   1b38c:	4e4f4953 0a303120 00000000 49474542     SION 10.....BEGI
   1b39c:	0000204e 465f4a41 42646e69 6e417375     N ..AJ_FindBusAn
   1b3ac:	6e6f4364 7463656e 203a2928 6e6e6f43     dConnect(): Conn
   1b3bc:	69746365 74206e6f 72656d69 61747320     ection timer sta
   1b3cc:	64657472 00000000 465f4a41 42646e69     rted....AJ_FindB
   1b3dc:	6e417375 6e6f4364 7463656e 203a2928     usAndConnect(): 
   1b3ec:	445f4a41 6f637369 20726576 74617473     AJ_Discover stat
   1b3fc:	253d7375 00000a73 20504354 6e6e6f63     us=%s...TCP conn
   1b40c:	69746365 73206e6f 74726174 00206465     ection started .
   1b41c:	465f4a41 42646e69 6e417375 6e6f4364     AJ_FindBusAndCon
   1b42c:	7463656e 203a2928 4e5f4a41 435f7465     nect(): AJ_Net_C
   1b43c:	656e6e6f 73207463 75746174 73253d73     onnect status=%s
   1b44c:	0000000a 465f4a41 42646e69 6e417375     ....AJ_FindBusAn
   1b45c:	6e6f4364 7463656e 203a2928 415f4a41     dConnect(): AJ_A
   1b46c:	65687475 6369746e 20657461 74617473     uthenticate stat
   1b47c:	253d7375 00000a73 465f4a41 42646e69     us=%s...AJ_FindB
   1b48c:	6e417375 6e6f4364 7463656e 203a2928     usAndConnect(): 
   1b49c:	63616c42 73696c6b 676e6974 756f7220     Blacklisting rou
   1b4ac:	676e6974 646f6e20 00000065 72746552     ting node...Retr
   1b4bc:	676e6979 74697720 20612068 2077656e     ying with a new 
   1b4cc:	656c6573 6f697463 7266206e 74206d6f     selection from t
   1b4dc:	72206568 6974756f 6e20676e 2065646f     he routing node 
   1b4ec:	70736572 65736e6f 73696c20 00000074     response list...
   1b4fc:	465f4a41 42646e69 6e417375 6e6f4364     AJ_FindBusAndCon
   1b50c:	7463656e 203a2928 53746553 616e6769     nect(): SetSigna
   1b51c:	6c75526c 73207365 75746174 73253d73     lRules status=%s
   1b52c:	0000000a 465f4a41 42646e69 6e417375     ....AJ_FindBusAn
   1b53c:	6e6f4364 7463656e 203a2928 74617473     dConnect(): stat
   1b54c:	253d7375 00000a73 646e6946 64657243     us=%s...FindCred
   1b55c:	69746e65 74286c61 3d657079 30257830     ential(type=0x%0
   1b56c:	202c5834 303d6469 2c702578 6e656c20     4X, id=0x%p, len
   1b57c:	2964253d 0000000a 475f4a41 72437465     =%d)....AJ_GetCr
   1b58c:	6e656465 6c616974 70797428 78303d65     edential(type=0x
   1b59c:	58343025 6469202c 2578303d 6c202c70     %04X, id=0x%p, l
   1b5ac:	253d6e65 000a2964 535f4a41 65726f74     en=%d)..AJ_Store
   1b5bc:	64657243 69746e65 61286c61 64657243     Credential(aCred
   1b5cc:	2578303d 000a2970 61647055 72436574     =0x%p)..UpdateCr
   1b5dc:	61286465 64657243 2578303d 73202c70     ed(aCred=0x%p, s
   1b5ec:	3d746f6c 0a296425 00000000 732f2e2e     lot=%d)......./s
   1b5fc:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1b60c:	65726f63 6372732f 5f6a612f 64657263     core/src/aj_cred
   1b61c:	00632e73 61647055 72436574 29286465     s.c.UpdateCred()
   1b62c:	4a41203a 5252455f 4941465f 4552554c     : AJ_ERR_FAILURE
   1b63c:	206e6f20 6c6c756e 65726320 746e6564      on null credent
   1b64c:	006c6169 61647055 72436574 29286465     ial.UpdateCred()
   1b65c:	4a41203a 5252455f 4941465f 4552554c     : AJ_ERR_FAILURE
   1b66c:	206e6f20 74697277 61662065 72756c69      on write failur
   1b67c:	6e6f2065 70797420 69662065 00646c65     e on type field.
   1b68c:	535f4a41 65726f74 64657243 69746e65     AJ_StoreCredenti
   1b69c:	61286c61 64657243 2578303d 203a2970     al(aCred=0x%p): 
   1b6ac:	455f4a41 465f5252 554c4941 000a4552     AJ_ERR_FAILURE..
   1b6bc:	535f4a41 65726f74 72656550 72636553     AJ_StorePeerSecr
   1b6cc:	70287465 47726565 3d646975 70257830     et(peerGuid=0x%p
   1b6dc:	6573202c 74657263 2578303d 6c202c70     , secret=0x%p, l
   1b6ec:	253d6e65 65202c64 72697078 6f697461     en=%d, expiratio
   1b6fc:	78303d6e 58383025 00000a29 445f4a41     n=0x%08X)...AJ_D
   1b70c:	74656c65 65724365 746e6564 286c6169     eleteCredential(
   1b71c:	65707974 2578303d 2c583430 3d646920     type=0x%04X, id=
   1b72c:	70257830 656c202c 64253d6e 0000000a     0x%p, len=%d....
   1b73c:	535f4a41 65726f74 61636f4c 6572436c     AJ_StoreLocalCre
   1b74c:	746e6564 286c6169 65707974 2578303d     dential(type=0x%
   1b75c:	2c583430 3d646920 70257830 6164202c     04X, id=0x%p, da
   1b76c:	303d6174 2c702578 6e656c20 2c64253d     ta=0x%p, len=%d,
   1b77c:	70786520 74617269 3d6e6f69 30257830      expiration=0x%0
   1b78c:	0a295838 00000000                       8X).....

0001b794 <__func__.12497>:
   1b794:	74696e49 434d4343 65746e6f 00007478     InitCCMContext..

0001b7a4 <__func__.12611>:
   1b7a4:	5f534541 5f525443 47425244 7365525f     AES_CTR_DRBG_Res
   1b7b4:	00646565 732f2e2e 612f6372 6f6a6c6c     eed.../src/alljo
   1b7c4:	742f6e79 206e6968 65726f63 6372732f     yn/thin core/src
   1b7d4:	5f6a612f 70797263 632e6f74 00000000     /aj_crypto.c....
   1b7e4:	6e654c6e 203d3c20 00003531 3d3d2030     nLen <= 15..0 ==
   1b7f4:	69732820 2520657a 29363120 00000000      (size % 16)....
   1b804:	455f4a41 7972636e 435f7470 29284d43     AJ_Encrypt_CCM()
   1b814:	4a41203a 5252455f 5345525f 4352554f     : AJ_ERR_RESOURC
   1b824:	00005345 445f4a41 79726365 435f7470     ES..AJ_Decrypt_C
   1b834:	29284d43 4a41203a 5252455f 5345525f     CM(): AJ_ERR_RES
   1b844:	4352554f 00005345 746e6f63 2d747865     OURCES..context-
   1b854:	642e543e 5b617461 303d5d30 20782578     >T.data[0]=0x%x 
   1b864:	78257830 25783020 78302078 00207825     0x%x 0x%x 0x%x .
   1b874:	2067736d 736d202b 6e654c67 3d5d305b     msg + msgLen[0]=
   1b884:	78257830 78303d20 3d207825 78257830     0x%x =0x%x =0x%x
   1b894:	78303d20 0a207825 00000000 445f4a41      =0x%x .....AJ_D
   1b8a4:	79726365 435f7470 29284d43 4a41203a     ecrypt_CCM(): AJ
   1b8b4:	5252455f 4345535f 54495255 00000059     _ERR_SECURITY...
   1b8c4:	435f4a41 74707972 52505f6f 3a292846     AJ_Crypto_PRF():
   1b8d4:	5f4a4120 5f525245 41564e49 0044494c      AJ_ERR_INVALID.
   1b8e4:	435f4a41 74707972 52505f6f 3a292846     AJ_Crypto_PRF():
   1b8f4:	5f4a4120 5f525245 4f534552 45435255      AJ_ERR_RESOURCE
   1b904:	00000053 2b203631 20363120 73203d3d     S...16 + 16 == s
   1b914:	00657a69                                ize.

0001b918 <__func__.12580>:
   1b918:	5f534541 5f525443 47425244 4343425f     AES_CTR_DRBG_BCC
   1b928:	00000000 00004efe 00004f0e 00004f1e     .....N...O...O..
   1b938:	00004f2e 00004f3e 00004f4e 00004f5e     .O..>O..NO..^O..
   1b948:	00004f6e 00004f7e 0000503e 0000504e     nO..~O..>P..NP..
   1b958:	0000505e 0000506e 0000507e 0000508e     ^P..nP..~P...P..
   1b968:	0000509e 000050ae 000050be              .P...P...P..

0001b974 <b_P256>:
   1b974:	27d2604b 3bce3c3e cc53b0f6 651d06b0     K`.'><.;..S....e
   1b984:	769886bc b3ebbd55 aa3a93e7 5ac635d8     ...vU.....:..5.Z
   1b994:	00000000                                ....

0001b998 <baseP256>:
   1b998:	d898c296 f4a13945 2deb33a0 77037d81     ....E9...3.-.}.w
   1b9a8:	63a440f2 f8bce6e5 e12c4247 6b17d1f2     .@.c....GB,....k
   1b9b8:	00000000 37bf51f5 cbb64068 6b315ece     .....Q.7h@...^1k
   1b9c8:	2bce3357 7c0f9e16 8ee7eb4a fe1a7f9b     W3.+...|J.......
   1b9d8:	4fe342e2 00000000 00000000 00000000     .B.O............

0001b9e8 <orderDBL256>:
   1b9e8:	fc632551 ffffffff f3b9cac3 ffffffff     Q%c.............
   1b9f8:	a7179e85 ffffffff bce6faae ffffffff     ................
	...
   1ba18:	00000001 00000000 ffffffff ffffffff     ................
   1ba28:	00000001 00000000 00000000 00000000     ................
	...

0001ba78 <modulusP256>:
   1ba78:	ffffffff ffffffff ffffffff 00000000     ................
	...
   1ba90:	00000001 ffffffff 00000000              ............

0001ba9c <big_one>:
   1ba9c:	00000001 00000000 00000000 00000000     ................
	...

0001bac0 <orderP256>:
   1bac0:	fc632551 f3b9cac2 a7179e84 bce6faad     Q%c.............
   1bad0:	ffffffff ffffffff 00000000 ffffffff     ................
   1bae0:	00000000 0000649c 000063d0 000063d4     .....d...c...c..
   1baf0:	000063d8 000063dc 000063e0 000063e4     .c...c...c...c..
   1bb00:	000063e8 000063ec 000063f0 000063f4     .c...c...c...c..
   1bb10:	000063f8 000063fc 00006400 00006404     .c...c...d...d..
   1bb20:	00006408 0000640c 00006410 00006414     .d...d...d...d..
   1bb30:	00006418 0000641c 00006420 00006424     .d...d.. d..$d..
   1bb40:	00006428 0000642c 00006430 00006434     (d..,d..0d..4d..
   1bb50:	00006438 0000643c 00006440 00006444     8d..<d..@d..Dd..
   1bb60:	00006448 0000644c 00006450 00006454     Hd..Ld..Pd..Td..
   1bb70:	00006458 0000645c 00006460 00006464     Xd..\d..`d..dd..
   1bb80:	00006468 0000646c 00006470 00006474     hd..ld..pd..td..
   1bb90:	00006478 0000647c 00006480 00006484     xd..|d...d...d..
   1bba0:	00006488 0000648c 00006490 00006494     .d...d...d...d..
   1bbb0:	203a7325 29752528 0000000a 20782530     %s: (%u)....0%x 
   1bbc0:	00000000 00202020 20202020 000a7325     ....   .    %s..
   1bbd0:	455f4a41 4e5f5252 004c4c55 455f4a41     AJ_ERR_NULL.AJ_E
   1bbe0:	495f5252 4c41564e 00004449 455f4a41     RR_INVALID..AJ_E
   1bbf0:	495f5252 55425f4f 52454646 00000000     RR_IO_BUFFER....
   1bc00:	455f4a41 575f5252 45544952 00000000     AJ_ERR_WRITE....
   1bc10:	455f4a41 545f5252 4f454d49 00005455     AJ_ERR_TIMEOUT..
   1bc20:	455f4a41 4d5f5252 48535241 00004c41     AJ_ERR_MARSHAL..
   1bc30:	455f4a41 455f5252 4f5f444e 41445f46     AJ_ERR_END_OF_DA
   1bc40:	00004154 455f4a41 4e5f5252 4f4d5f4f     TA..AJ_ERR_NO_MO
   1bc50:	00004552 455f4a41 435f5252 454e4e4f     RE..AJ_ERR_CONNE
   1bc60:	00005443 455f4a41 555f5252 4f4e4b4e     CT..AJ_ERR_UNKNO
   1bc70:	00004e57 455f4a41 4e5f5252 414d5f4f     WN..AJ_ERR_NO_MA
   1bc80:	00484354 455f4a41 445f5252 4c415349     TCH.AJ_ERR_DISAL
   1bc90:	45574f4c 00000044 455f4a41 465f5252     LOWED...AJ_ERR_F
   1bca0:	554c4941 00004552 455f4a41 525f5252     AILURE..AJ_ERR_R
   1bcb0:	41545345 00005452 455f4a41 4c5f5252     ESTART..AJ_ERR_L
   1bcc0:	5f4b4e49 454d4954 0054554f 455f4a41     INK_TIMEOUT.AJ_E
   1bcd0:	445f5252 45564952 00000052 455f4a41     RR_DRIVER...AJ_E
   1bce0:	4f5f5252 43454a42 41505f54 00004854     RR_OBJECT_PATH..
   1bcf0:	455f4a41 425f5252 00595355 455f4a41     AJ_ERR_BUSY.AJ_E
   1bd00:	445f5252 00504348 455f4a41 415f5252     RR_DHCP.AJ_ERR_A
   1bd10:	53454343 00000053 455f4a41 535f5252     CCESS...AJ_ERR_S
   1bd20:	49535345 4c5f4e4f 0054534f 455f4a41     ESSION_LOST.AJ_E
   1bd30:	4c5f5252 5f4b4e49 44414544 00000000     RR_LINK_DEAD....
   1bd40:	455f4a41 485f5252 435f5244 5552524f     AJ_ERR_HDR_CORRU
   1bd50:	00005450 455f4a41 525f5252 41545345     PT..AJ_ERR_RESTA
   1bd60:	415f5452 00005050 455f4a41 495f5252     RT_APP..AJ_ERR_I
   1bd70:	5245544e 54505552 00004445 455f4a41     NTERRUPTED..AJ_E
   1bd80:	525f5252 43454a45 00444554 455f4a41     RR_REJECTED.AJ_E
   1bd90:	525f5252 45474e41 00000000 455f4a41     RR_RANGE....AJ_E
   1bda0:	415f5252 53454343 4f525f53 4e495455     RR_ACCESS_ROUTIN
   1bdb0:	4f4e5f47 00004544 455f4a41 4b5f5252     G_NODE..AJ_ERR_K
   1bdc0:	455f5945 52495058 00004445 455f4a41     EY_EXPIRED..AJ_E
   1bdd0:	535f5252 4e5f4950 50535f4f 00454341     RR_SPI_NO_SPACE.
   1bde0:	455f4a41 535f5252 525f4950 00444145     AJ_ERR_SPI_READ.
   1bdf0:	455f4a41 535f5252 575f4950 45544952     AJ_ERR_SPI_WRITE
   1be00:	00000000 455f4a41 4f5f5252 565f444c     ....AJ_ERR_OLD_V
   1be10:	49535245 00004e4f 455f4a41 4e5f5252     ERSION..AJ_ERR_N
   1be20:	4d415256 4145525f 00000044 455f4a41     VRAM_READ...AJ_E
   1be30:	4e5f5252 4d415256 4952575f 00004554     RR_NVRAM_WRITE..
   1be40:	455f4a41 575f5252 444c554f 4f4c425f     AJ_ERR_WOULD_BLO
   1be50:	00004b43 455f4a41 415f5252 5f504452     CK..AJ_ERR_ARDP_
   1be60:	43534944 454e4e4f 44455443 00000000     DISCONNECTED....
   1be70:	455f4a41 415f5252 5f504452 43534944     AJ_ERR_ARDP_DISC
   1be80:	454e4e4f 4e495443 00000047 455f4a41     ONNECTING...AJ_E
   1be90:	415f5252 5f504452 4f4d4552 435f4554     RR_ARDP_REMOTE_C
   1bea0:	454e4e4f 4f495443 45525f4e 00544553     ONNECTION_RESET.
   1beb0:	455f4a41 415f5252 5f504452 424f5250     AJ_ERR_ARDP_PROB
   1bec0:	49545f45 554f454d 00000054 455f4a41     E_TIMEOUT...AJ_E
   1bed0:	415f5252 5f504452 4b434142 53455250     RR_ARDP_BACKPRES
   1bee0:	45525553 00000000 455f4a41 415f5252     SURE....AJ_ERR_A
   1bef0:	5f504452 444e4553 5058455f 44455249     RDP_SEND_EXPIRED
   1bf00:	00000000 455f4a41 415f5252 5f504452     ....AJ_ERR_ARDP_
   1bf10:	56434552 5058455f 44455249 00000000     RECV_EXPIRED....
   1bf20:	455f4a41 415f5252 5f504452 53524556     AJ_ERR_ARDP_VERS
   1bf30:	5f4e4f49 5f544f4e 50505553 4554524f     ION_NOT_SUPPORTE
   1bf40:	00000044 6b6e753c 6e776f6e 0000003e     D...<unknown>...
   1bf50:	73656e64 3d646973 34767069 0000003d     dnessid=ipv4=...
   1bf60:	76637075 00003d34                       upcv4=..

0001bf68 <__func__.12644>:
   1bf68:	72776552 53657469 65646e65 666e4972     RewriteSenderInf
   1bf78:	0000006f                                o...

0001bf7c <queries.12654>:
   1bf7c:	6c615f08 796f6a6c 745f046e 6c057063     ._alljoyn._tcp.l
   1bf8c:	6c61636f 800c0000 615f0801 6f6a6c6c     ocal......_alljo
   1bf9c:	5f046e79 c0706475 800c001a 00000001     yn._udp.........

0001bfac <txtvers.12657>:
   1bfac:	74787409 73726576 0000303d              .txtvers=0..

0001bfb8 <search.12655>:
   1bfb8:	61657306 00686372                       .search.

0001bfc0 <local.12656>:
   1bfc0:	10001ac0 00000100 00007800 732f2e2e     .........x..../s
   1bfd0:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1bfe0:	65726f63 6372732f 5f6a612f 63736964     core/src/aj_disc
   1bff0:	00632e6f 73726150 4e444d65 6d6f4453     o.c.ParseMDNSDom
   1c000:	4e6e6961 28656d61 49203a29 6675736e     ainName(): Insuf
   1c010:	69636966 20746e65 73667562 00657a69     ficient bufsize.
   1c020:	73726150 4e444d65 6d6f4453 4e6e6961     ParseMDNSDomainN
   1c030:	28656d61 49203a29 6c61766e 63206469     ame(): Invalid c
   1c040:	72706d6f 69737365 00006e6f 73726150     ompression..Pars
   1c050:	4e444d65 73655253 6372756f 63655265     eMDNSResourceRec
   1c060:	2864726f 45203a29 726f7272 63636f20     ord(): Error occ
   1c070:	64657275 69687720 6420656c 72657365     ured while deser
   1c080:	696c6169 676e697a 6d6f6420 206e6961     ializing domain 
   1c090:	656d616e 00000000 73726150 4e444d65     name....ParseMDN
   1c0a0:	73655253 6372756f 63655265 2864726f     SResourceRecord(
   1c0b0:	49203a29 6675736e 69636966 20746e65     ): Insufficient 
   1c0c0:	66667562 73207265 00657a69 73726150     buffer size.Pars
   1c0d0:	4e444d65 76725353 74614452 3a292861     eMDNSSrvRData():
   1c0e0:	736e4920 69666675 6e656963 75622074      Insufficient bu
   1c0f0:	7a697366 64252065 00000000 73726150     fsize %d....Pars
   1c100:	4e444d65 76725353 74614452 3a292861     eMDNSSrvRData():
   1c110:	736e4920 69666675 6e656963 75622074      Insufficient bu
   1c120:	7a697366 64252065 20726f20 61766e69     fsize %d or inva
   1c130:	2064696c 676e656c 25206874 00000064     lid length %d...
   1c140:	73726150 4e444d65 78655453 61445274     ParseMDNSTextRDa
   1c150:	29286174 6e49203a 66667573 65696369     ta(): Insufficie
   1c160:	6220746e 69736675 2520657a 00000064     nt bufsize %d...
   1c170:	76706a61 00000000 00005f74 00005f6e     ajpv....t_..n_..
   1c180:	73726150 4e444d65 78655453 61445274     ParseMDNSTextRDa
   1c190:	29286174 694d203a 74616d73 64656863     ta(): Mismatched
   1c1a0:	4c445220 74676e65 00000068 73726150      RDLength...Pars
   1c1b0:	4e444d65 73655253 6372756f 63655265     eMDNSResourceRec
   1c1c0:	2864726f 45203a29 726f7272 63636f20     ord(): Error occ
   1c1d0:	64657275 69687720 6420656c 72657365     ured while deser
   1c1e0:	696c6169 676e697a 73657220 6372756f     ializing resourc
   1c1f0:	61642065 00006174 2d2d2d2d 2d2d2d2d     e data..--------
   1c200:	2d2d2d2d 74532d2d 20747261 534e446d     ------Start mDNS
   1c210:	72617020 2d206573 2d2d2d2d 2d2d2d2d      parse ---------
   1c220:	2d2d2d2d 00002d2d 73726150 4e444d65     ------..ParseMDN
   1c230:	61654853 28726564 49203a29 6675736e     SHeader(): Insuf
   1c240:	69636966 20746e65 73667562 20657a69     ficient bufsize 
   1c250:	000a6425 6f727245 636f2072 65727563     %d..Error occure
   1c260:	68772064 20656c69 65736564 6c616972     d while deserial
   1c270:	6e697a69 65682067 72656461 00000000     izing header....
   1c280:	6f727245 68772072 20656c69 65736564     Error while dese
   1c290:	6c616972 6e697a69 75712067 69747365     rializing questi
   1c2a0:	72206e6f 726f6365 00002e64 70696b53     on record...Skip
   1c2b0:	676e6970 656e7520 63657078 20646574     ping unexpected 
   1c2c0:	73657571 6e6f6974 206e6920 70736572     question in resp
   1c2d0:	65736e6f 6977202c 62206c6c 69732065     onse, will be si
   1c2e0:	746e656c 6920796c 726f6e67 002e6465     lently ignored..
   1c2f0:	6f727245 68772072 20656c69 65736564     Error while dese
   1c300:	6c616972 6e697a69 6e612067 72657773     rializing answer
   1c310:	63657220 2e64726f 00000000 636f7250      record.....Proc
   1c320:	65737365 6e612064 72657773 0a642520     essed answer %d.
   1c330:	00000000 6c6c615f 6e796f6a 63745f2e     ...._alljoyn._tc
   1c340:	6f6c2e70 006c6163 6e756f46 615f2064     p.local.Found _a
   1c350:	6f6a6c6c 2e5f6e79 2e706374 61636f6c     lljoyn_.tcp.loca
   1c360:	5450206c 65722052 64726f63 0000002e     l PTR record....
   1c370:	6e756f46 615f2064 6f6a6c6c 2e5f6e79     Found _alljoyn_.
   1c380:	7064755f 636f6c2e 50206c61 72205254     _udp.local PTR r
   1c390:	726f6365 00002e64 6e756f46 20612064     ecord...Found a 
   1c3a0:	20565253 77736e61 77207265 20687469     SRV answer with 
   1c3b0:	616d6f64 6e206e69 20656d61 2e732520     domain name  %s.
   1c3c0:	0000000a 6c6c615f 6e796f6a 64755f2e     ...._alljoyn._ud
   1c3d0:	6f6c2e70 006c6163 6f727245 68772072     p.local.Error wh
   1c3e0:	20656c69 65736564 6c616972 6e697a69     ile deserializin
   1c3f0:	75612067 726f6874 20797469 6f636572     g authority reco
   1c400:	002e6472 70696b53 676e6970 6e6f6e20     rd..Skipping non
   1c410:	6c65722d 6e617665 75612074 726f6874     -relevant author
   1c420:	20797469 6f636572 202c6472 6c6c6977     ity record, will
   1c430:	20656220 656c6973 796c746e 6e676920      be silently ign
   1c440:	6465726f 0000002e 6f727245 68772072     ored....Error wh
   1c450:	20656c69 65736564 6c616972 6e697a69     ile deserializin
   1c460:	64612067 69746964 6c616e6f 63657220     g additional rec
   1c470:	2e64726f 00000000 636f7250 69737365     ord.....Processi
   1c480:	6120676e 74696464 616e6f69 6572206c     ng additional re
   1c490:	64726f63 0a642520 00000000 65766461     cord %d.....adve
   1c4a0:	73697472 00002e65 6e756f46 64612064     rtise...Found ad
   1c4b0:	74726576 2e657369 5854202a 65722054     vertise.* TXT re
   1c4c0:	64726f63 74697720 75662068 6c206c6c     cord with full l
   1c4d0:	6c656261 2e732520 0000000a 646e6573     abel %s.....send
   1c4e0:	692d7265 2e6f666e 00000000 6e756f46     er-info.....Foun
   1c4f0:	65732064 7265646e 666e692d 202a2e6f     d sender-info.* 
   1c500:	20545854 6f636572 77206472 20687469     TXT record with 
   1c510:	6c6c7566 6d616e20 25203a65 000a2e73     full name: %s...
   1c520:	6e756f46 6e612064 61204120 74696464     Found an A addit
   1c530:	616e6f69 6572206c 64726f63 0000002e     ional record....
   1c540:	445f4a41 6f637369 28726576 66657270     AJ_Discover(pref
   1c550:	223d7869 2c227325 72657320 65636976     ix="%s", service
   1c560:	2578303d 74202c70 6f656d69 253d7475     =0x%p, timeout=%
   1c570:	73202c64 63656c65 6e6f6974 6d697420     d, selection tim
   1c580:	74756f65 2e64253d 00000a29 445f4a41     eout=%d.)...AJ_D
   1c590:	6f637369 28726576 73203a29 75746174     iscover(): statu
   1c5a0:	73253d73 0000000a 656c6553 6f697463     s=%s....Selectio
   1c5b0:	6974206e 2072656d 72617473 00646574     n timer started.
   1c5c0:	706d6f43 5765736f 61486f68 3a292873     ComposeWhoHas():
   1c5d0:	5f4a4120 5f525245 4f534552 45435255      AJ_ERR_RESOURCE
   1c5e0:	00000053 445f4a41 6f637369 28726576     S...AJ_Discover(
   1c5f0:	57203a29 482d4f48 73205341 20646e65     ): WHO-HAS send 
   1c600:	74617473 253d7375 00000a73 445f4a41     status=%s...AJ_D
   1c610:	6f637369 28726576 4e203a29 5547206f     iscover(): No GU
   1c620:	00214449 706d6f43 4d65736f 52736e44     ID!.ComposeMDnsR
   1c630:	29287165 7270203a 78696665 6f6f7420     eq(): prefix too
   1c640:	6e6f6c20 25203a67 00000a64 6b70282a      long: %d...*(pk
   1c650:	202b2074 3d202931 7327203d 00000027     t + 1) == 's'...
   1c660:	4e5f4a41 535f7465 54646e65 3a29286f     AJ_Net_SendTo():
   1c670:	77655220 65746972 646e6553 6e497265      RewriteSenderIn
   1c680:	66206f66 656c6961 00002e64 445f4a41     fo failed...AJ_D
   1c690:	6f637369 28726576 6d203a29 20534e44     iscover(): mDNS 
   1c6a0:	63736964 7265766f 22206465 0a227325     discovered "%s".
   1c6b0:	00000000 445f4a41 6f637369 28726576     ....AJ_Discover(
   1c6c0:	53203a29 7070696b 20676e69 63616c62     ): Skipping blac
   1c6d0:	73696c6b 20646574 74756f52 20676e69     klisted Routing 
   1c6e0:	65646f4e 00000000 73726150 41734965     Node....ParseIsA
   1c6f0:	00000074 445f4a41 6f637369 28726576     t...AJ_Discover(
   1c700:	49203a29 54412d53 73696420 65766f63     ): IS-AT discove
   1c710:	20646572 22732522 0000000a 445f4a41     red "%s"....AJ_D
   1c720:	6f637369 28726576 53203a29 20706f74     iscover(): Stop 
   1c730:	63736964 7265766f 666f2079 73252220     discovery of "%s
   1c740:	00000a22                                "...

0001c744 <senderinfo.12660>:
   1c744:	6e65730b 2d726564 6f666e69 100040c0     .sender-info.@..
   1c754:	00000100 3c007800 74787409 73726576     .....x.<.txtvers
   1c764:	6107303d 3d76706a 70043031 05323d76     =0.ajpv=10.pv=2.
   1c774:	3d646973 70691337 313d3476 312e3239     sid=7.ipv4=192.1
   1c784:	322e3836 30312e30 70750a30 3d347663     68.20.100.upcv4=
   1c794:	33353335                                5353

0001c798 <nameone.12658>:
   1c798:	3d315f6e                                n_1=

0001c79c <sendmatchonly.12659>:
   1c79c:	313d6d03 65707974 6973273d 6c616e67     .m=1type='signal
   1c7ac:	656d2c27 7265626d 614e273d 774f656d     ',member='NameOw
   1c7bc:	4372656e 676e6168 2c276465 65746e69     nerChanged',inte
   1c7cc:	63616672 6f273d65 662e6772 64656572     rface='org.freed
   1c7dc:	746b7365 442e706f 27737542 6772612c     esktop.DBus',arg
   1c7ec:	00273d31 72612c27 273d3267 00000027     1='.',arg2=''...
   1c7fc:	732f2e2e 612f6372 6f6a6c6c 742f6e79     ../src/alljoyn/t
   1c80c:	206e6968 65726f63 6372732f 5f6a612f     hin core/src/aj_
   1c81c:	64697567 0000632e 475f4a41 5f444955     guid.c..AJ_GUID_
   1c82c:	4e646441 4d656d61 69707061 6728676e     AddNameMapping(g
   1c83c:	3d646975 70257830 6e75202c 65757169     uid=0x%p, unique
   1c84c:	656d614e 7325223d 73202c22 69767265     Name="%s", servi
   1c85c:	614e6563 223d656d 29227325 6441203a     ceName="%s"): Ad
   1c86c:	616d2064 20686374 656c7572 72726520     d match rule err
   1c87c:	000a726f 475f4a41 5f444955 4e646441     or..AJ_GUID_AddN
   1c88c:	4d656d61 69707061 2928676e 4a41203a     ameMapping(): AJ
   1c89c:	5252455f 5345525f 4352554f 00005345     _ERR_RESOURCES..
   1c8ac:	475f4a41 5f444955 646e6148 6441656c     AJ_GUID_HandleAd
   1c8bc:	74614d64 65526863 28796c70 3d67736d     dMatchReply(msg=
   1c8cc:	70257830 65203a29 726f7272 2e73253d     0x%p): error=%s.
   1c8dc:	0000000a 656d614e 4f736148 72656e77     ....NameHasOwner
   1c8ec:	67736d28 2578303d 203a2970 7372614d     (msg=0x%p): Mars
   1c8fc:	206c6168 6f727265 00000a72 475f4a41     hal error...AJ_G
   1c90c:	5f444955 646e6148 614e656c 6148656d     UID_HandleNameHa
   1c91c:	6e774f73 65527265 28796c70 3d67736d     sOwnerReply(msg=
   1c92c:	70257830 65203a29 726f7272 2e73253d     0x%p): error=%s.
   1c93c:	0000000a 475f4a41 5f444955 646e6148     ....AJ_GUID_Hand
   1c94c:	614e656c 6148656d 6e774f73 65527265     leNameHasOwnerRe
   1c95c:	28796c70 3d67736d 70257830 55203a29     ply(msg=0x%p): U
   1c96c:	72616d6e 6c616873 72726520 000a726f     nmarshal error..
   1c97c:	00737373                                sss.

0001c980 <annotateSecure>:
   1c980:	613c2020 746f6e6e 6f697461 616e206e       <annotation na
   1c990:	223d656d 2e67726f 6a6c6c61 2e6e796f     me="org.alljoyn.
   1c9a0:	2e737542 75636553 20226572 756c6176     Bus.Secure" valu
   1c9b0:	00223d65                                e=".

0001c9b4 <__func__.6659>:
   1c9b4:	415f4a41 636f6c6c 6c706552 6e6f4379     AJ_AllocReplyCon
   1c9c4:	74786574 00000000                       text....

0001c9cc <argOpen>:
   1c9cc:	20202020 6772613c 00000000                  <arg....

0001c9d8 <typeAttr>:
   1c9d8:	70797420 00223d65                        type=".

0001c9e0 <nameAttr>:
   1c9e0:	6d616e20 00223d65                        name=".

0001c9e8 <Direction>:
   1c9e8:	0001d034 0001d058 0001d048 0001d060     4...X...H...`...
   1c9f8:	0001d084 0001d074                       ....t...

0001ca00 <secureOff>:
   1ca00:	2266666f 000a3e2f                       off"/>..

0001ca08 <secureTrue>:
   1ca08:	65757274 0a3e2f22 00000000 00000022     true"/>....."...
   1ca18:	20202020 00000000 7365643c 70697263         ....<descrip
   1ca28:	6e6f6974 00000000 6e616c20 67617567     tion.... languag
   1ca38:	00223d65 65642f3c 69726373 6f697470     e=".</descriptio
   1ca48:	000a3e6e 732f2e2e 612f6372 6f6a6c6c     n>..../src/alljo
   1ca58:	742f6e79 206e6968 65726f63 6372732f     yn/thin core/src
   1ca68:	5f6a612f 72746e69 6570736f 632e7463     /aj_introspect.c
   1ca78:	00000000 63656843 6769536b 7574616e     ....CheckSignatu
   1ca88:	29286572 4a41203a 5252455f 4749535f     re(): AJ_ERR_SIG
   1ca98:	5554414e 00004552 2121210a 61766e49     NATURE...!!!Inva
   1caa8:	2064696c 2067736d 6e656469 69666974     lid msg identifi
   1cab8:	69207265 6369646e 73657461 6f727020     er indicates pro
   1cac8:	6d617267 676e696d 72726520 2121726f     gramming error!!
   1cad8:	00000021 706d6f43 5365736f 616e6769     !...ComposeSigna
   1cae8:	65727574 203a2928 455f4a41 525f5252     ture(): AJ_ERR_R
   1caf8:	554f5345 53454352 00000000 61707845     ESOURCES....Expa
   1cb08:	6e49646e 66726574 73656361 203a2928     ndInterfaces(): 
   1cb18:	00007325 535f4a41 72507465 4f79786f     %s..AJ_SetProxyO
   1cb28:	63656a62 74615074 3a292868 5f4a4120     bjectPath(): AJ_
   1cb38:	5f525245 4e4b4e55 004e574f 2d67736d     ERR_UNKNOWN.msg-
   1cb48:	7264683e 736d3e2d 70795467 3d3d2065     >hdr->msgType ==
   1cb58:	00003120 415f4a41 636f6c6c 6c706552      1..AJ_AllocRepl
   1cb68:	6e6f4379 74786574 203a2928 6c696146     yContext(): Fail
   1cb78:	74206465 6c61206f 61636f6c 72206574     ed to allocate r
   1cb88:	796c7065 6e6f6320 74786574 7320202e     eply context.  s
   1cb98:	75746174 4a413d73 5252455f 5345525f     tatus=AJ_ERR_RES
   1cba8:	4352554f 00005345 6b6f6f4c 654d7075     OURCES..LookupMe
   1cbb8:	67617373 28644965 41203a29 52455f4a     ssageId(): AJ_ER
   1cbc8:	4f4e5f52 54414d5f 00004843 61706e55     R_NO_MATCH..Unpa
   1cbd8:	734d6b63 28644967 41203a29 52455f4a     ckMsgId(): AJ_ER
   1cbe8:	4e495f52 494c4156 00000044 4d5f4a41     R_INVALID...AJ_M
   1cbf8:	73687261 72506c61 7265706f 72417974     arhsalPropertyAr
   1cc08:	29287367 7473203a 73757461 0a73253d     gs(): status=%s.
   1cc18:	00000000 003e3d3c 0000002f 495f4a41     ....<=>./...AJ_I
   1cc28:	746e6564 4d796669 61737365 29286567     dentifyMessage()
   1cc38:	4a41203a 5252455f 4345535f 54495255     : AJ_ERR_SECURIT
   1cc48:	00000059 63656843 7465526b 536e7275     Y...CheckReturnS
   1cc58:	616e6769 65727574 203a2928 74617473     ignature(): stat
   1cc68:	253d7375 00000a73 495f4a41 746e6564     us=%s...AJ_Ident
   1cc78:	50796669 65706f72 28797472 25203a29     ifyProperty(): %
   1cc88:	00000a73 75636553 79746972 6f697620     s...Security vio
   1cc98:	6974616c 61206e6f 73656363 676e6973     lation accessing
   1cca8:	6f727020 74726570 00000079 206e6547      property...Gen 
   1ccb8:	204c4d58 72617473 00646574 206e6547     XML started.Gen 
   1ccc8:	3a4c4d58 45202020 6e617078 746e4964     XML:   ExpandInt
   1ccd8:	61667265 00736563 206e6547 3a4c4d58     erfaces.Gen XML:
   1cce8:	45202020 6e617078 746e4964 61667265        ExpandInterfa
   1ccf8:	20736563 00646e65 206e6547 3a4c4d58     ces end.Gen XML:
   1cd08:	69202020 6f282066 74496a62 3d207265        if (objIter =
   1cd18:	554e203d 20294c4c 00000000 206e6547     = NULL) ....Gen 
   1cd28:	3a4c4d58 69202020 73282066 75746174     XML:   if (statu
   1cd38:	3d3d2073 5f4a4120 20294b4f 00000000     s == AJ_OK) ....
   1cd48:	206e6547 3a4c4d58 66692020 68632820     Gen XML:  if (ch
   1cd58:	20646c69 28202626 73726946 736e4974     ild && (FirstIns
   1cd68:	636e6174 626f2865 703e2d6a 2c687461     tance(obj->path,
   1cd78:	69686320 202c646c 296e656c 203d3d20      child, len) == 
   1cd88:	6c696863 6a624f64 20202929 00000000     childObj))  ....
   1cd98:	206e6547 3a4c4d58 69202020 6c282066     Gen XML:   if (l
   1cda8:	75676e61 54656761 21206761 554e203d     anguageTag != NU
   1cdb8:	26204c4c 68632026 4f646c69 63656a62     LL && childObjec
   1cdc8:	65744974 206c2e72 4a41203c 58414d5f     tIter.l < AJ_MAX
   1cdd8:	4a424f5f 5f544345 5453494c 20202953     _OBJECT_LISTS)  
   1cde8:	00000020 206e6547 3a4c4d58 64202020      ...Gen XML:   d
   1cdf8:	4c637365 756b6f6f 203d2070 4c4c554e     escLookup = NULL
   1ce08:	00000020 206e6547 3a4c4d58 20202020      ...Gen XML:    
   1ce18:	28206669 63736564 74706972 206e6f69     if (description 
   1ce28:	4e203d21 294c4c55 00002020 206e6547     != NULL)  ..Gen 
   1ce38:	3a4c4d58 20202020 574c4d58 65746972     XML:    XMLWrite
   1ce48:	20676154 00000020 206e6547 3a4c4d58     Tag  ...Gen XML:
   1ce58:	20202020 574c4d58 65746972 00202072         XMLWriter  .
   1ce68:	6961460a 2064656c 67206f74 72656e65     .Failed to gener
   1ce78:	20657461 204c4d58 6863202d 206b6365     ate XML - check 
   1ce88:	65746e69 63616672 65642065 69726373     interface descri
   1ce98:	6f697470 6f20736e 73252066 726f6620     ptions of %s for
   1cea8:	72726520 0a73726f 00000000 696d6552      errors.....Remi
   1ceb8:	7265646e 624f203a 7463656a 746f6e20     nder: Object not
   1cec8:	74657920 64646120 74206465 6874206f      yet added to th
   1ced8:	624f2065 7463656a 7473694c 6f64202c     e ObjectList, do
   1cee8:	746f6e20 726f6620 20746567 63206f74      not forget to c
   1cef8:	206c6c61 69676552 72657473 656a624f     all RegisterObje
   1cf08:	00737463 485f4a41 6c646e61 746e4965     cts.AJ_HandleInt
   1cf18:	70736f72 52746365 65757165 29287473     rospectRequest()
   1cf28:	2031203a 74617473 253d7375 00000a73     : 1 status=%s...
   1cf38:	485f4a41 6c646e61 746e4965 70736f72     AJ_HandleIntrosp
   1cf48:	52746365 65757165 29287473 6146203a     ectRequest(): Fa
   1cf58:	64656c69 206f7420 656e6567 65746172     iled to generate
   1cf68:	4c4d5820 7473202e 73757461 0a73253d      XML. status=%s.
   1cf78:	00000000 485f4a41 6c646e61 746e4965     ....AJ_HandleInt
   1cf88:	70736f72 52746365 65757165 29287473     rospectRequest()
   1cf98:	20642520 65747962 666f2073 4c4d5820      %d bytes of XML
   1cfa8:	0000000a 485f4a41 6c646e61 746e4965     ....AJ_HandleInt
   1cfb8:	70736f72 52746365 65757165 29287473     rospectRequest()
   1cfc8:	6863203a 72646c69 3e206e65 00003020     : children > 0..
   1cfd8:	485f4a41 6c646e61 746e4965 70736f72     AJ_HandleIntrosp
   1cfe8:	52746365 65757165 29287473 2032203a     ectRequest(): 2 
   1cff8:	74617473 253d7375 00000a73 485f4a41     status=%s...AJ_H
   1d008:	6c646e61 746e4965 70736f72 52746365     andleIntrospectR
   1d018:	65757165 29287473 204f4e20 4354414d     equest() NO MATC
   1d028:	6f662048 73252072 0000000a 69642022     H for %s...." di
   1d038:	74636572 3d6e6f69 226e6922 000a3e2f     rection="in"/>..
   1d048:	69642022 74636572 3d6e6f69 74756f22     " direction="out
   1d058:	0a3e2f22 00000000 69642022 74636572     "/>....." direct
   1d068:	3d6e6f69 226e6922 00000a3e 69642022     ion="in">..." di
   1d078:	74636572 3d6e6f69 74756f22 000a3e22     rection="out">..
   1d088:	63612022 73736563 7277223d 22657469     " access="write"
   1d098:	00000000 63612022 73736563 6572223d     ...." access="re
   1d0a8:	72776461 22657469 00000000 63612022     adwrite"...." ac
   1d0b8:	73736563 6572223d 00226461 2f3c2020     cess="read".  </
   1d0c8:	6e676973 0a3e6c61 00000000 2f3c2020     signal>.....  </
   1d0d8:	6874656d 0a3e646f 00000000 2f3c2020     method>.....  </
   1d0e8:	706f7270 79747265 00000a3e 733c2020     property>...  <s
   1d0f8:	616e6769 0000006c 6d3c2020 6f687465     ignal...  <metho
   1d108:	00000064 703c2020 65706f72 00797472     d...  <property.

0001d118 <argClose>:
   1d118:	20202020 72612f3c 000a3e67                  </arg>..

0001d124 <trueVal>:
   1d124:	65757274 00000022                       true"...

0001d12c <MemberOpen>:
   1d12c:	0001d0f4 0001d100 0001d10c              ............

0001d138 <nodeClose>:
   1d138:	6f6e2f3c 0a3e6564 00000000              </node>.....

0001d144 <sessionlessAttr>:
   1d144:	73657320 6e6f6973 7373656c 0000223d      sessionless="..

0001d154 <interfaceOpen>:
   1d154:	746e693c 61667265 00006563              <interface..

0001d160 <nodeOpen>:
   1d160:	646f6e3c 00000065                       <node...

0001d168 <interfaceClose>:
   1d168:	6e692f3c 66726574 3e656361 0000000a     </interface>....

0001d178 <Access>:
   1d178:	0001d088 0001d09c 0001d0b4              ............

0001d184 <MemberClose>:
   1d184:	0001d0c4 0001d0d4 0001d044 0001d0e4     ........D.......

0001d194 <falseVal>:
   1d194:	736c6166 00002265 0000a3e6 0000a312     false"..........
   1d1a4:	0000a322 0000a328 0000a346 0000a352     "...(...F...R...
   1d1b4:	0000a362 0000a368 0000a372 0000a3e6     b...h...r.......
   1d1c4:	0000a3e6 0000a3e6 0000a3e6 0000a3e6     ................
   1d1d4:	0000a3e6 0000a3e6 0000a378 0000a396     ........x.......
   1d1e4:	0000a3e6 0000a3a4 0000aed4 0000ae8c     ................
   1d1f4:	0000ae92 0000ae98 0000ae9e 0000aea4     ................
   1d204:	0000aeac 0000aeb2 0000aeb8 0000aed4     ................
   1d214:	0000aed4 0000aed4 0000aed4 0000aed4     ................
   1d224:	0000aed4 0000aed4 0000aebe 0000aec6     ................
   1d234:	0000ae88 0000aece                       ........

0001d23c <TypeForHdr>:
   1d23c:	73736f00 73737573 00007567 00000000     .osssussgu......
   1d24c:	75757175                                uquu

0001d250 <__func__.12869>:
   1d250:	435f4a41 6b636568 6f636e49 676e696d     AJ_CheckIncoming
   1d260:	69726553 00006c61                       Serial..

0001d268 <__func__.13155>:
   1d268:	555f4a41 72616d6e 6c616873 736f6c43     AJ_UnmarshalClos
   1d278:	6e6f4365 6e696174 00007265              eContainer..

0001d284 <internalErrorHdr>:
   1d284:	0000036c 00000000 00000001 00000000     l...............

0001d294 <__func__.13327>:
   1d294:	4d5f4a41 68737261 65526c61 4d796c70     AJ_MarshalReplyM
   1d2a4:	00006773                                sg..

0001d2a8 <__func__.13278>:
   1d2a8:	445f4a41 76696c65 734d7265 72615067     AJ_DeliverMsgPar
   1d2b8:	6c616974 00000000 2d2d2d2d 6e65532d     tial....-----Sen
   1d2c8:	61642064 2d2d6174 2d2d2d2d 00000000     d data------....
   1d2d8:	732f2e2e 612f6372 6f6a6c6c 742f6e79     ../src/alljoyn/t
   1d2e8:	206e6968 65726f63 6372732f 5f6a612f     hin core/src/aj_
   1d2f8:	2e67736d 00000063 64616f4c 65747942     msg.c...LoadByte
   1d308:	3a292873 5f4a4120 5f525245 4f534552     s(): AJ_ERR_RESO
   1d318:	45435255 00000053 64616f4c 65747942     URCES...LoadByte
   1d328:	3a292873 6d756e20 65747942 64253d73     s(): numBytes=%d
   1d338:	426f692c 3e2d6675 53667562 20657a69     ,ioBuf->bufSize 
   1d348:	4a41202d 5f4f495f 5f465542 534e4f43     - AJ_IO_BUF_CONS
   1d358:	44454d55 426f6928 3d296675 0a206425     UMED(ioBuf)=%d .
   1d368:	00000000 64616f4c 65747942 3a292873     ....LoadBytes():
   1d378:	5f4a4120 5f525245 44414552 00000000      AJ_ERR_READ....
   1d388:	7372614d 286c6168 41203a29 52455f4a     Marshal(): AJ_ER
   1d398:	554e5f52 00004c4c 7372614d 286c6168     R_NULL..Marshal(
   1d3a8:	41203a29 52455f4a 414d5f52 41485352     ): AJ_ERR_MARSHA
   1d3b8:	0000004c 7372614d 4d6c6168 29286773     L...MarshalMsg()
   1d3c8:	7473203a 73757461 0a73253d 00000000     : status=%s.....
   1d3d8:	69726553 6e206c61 65626d75 203d2072     Serial number = 
   1d3e8:	000a6425 76657270 00000000 445f4a41     %d..prev....AJ_D
   1d3f8:	76696c65 734d7265 41203a67 52455f4a     eliverMsg: AJ_ER
   1d408:	414d5f52 41485352 0000204c 72636e45     R_MARSHAL ..Encr
   1d418:	4d747079 61737365 29286567 4a41203a     yptMessage(): AJ
   1d428:	5252455f 5345525f 4352554f 00005345     _ERR_RESOURCES..
   1d438:	72636e45 4d747079 73737365 28656761     EncryptMesssage(
   1d448:	70203a29 20726565 6e207325 6120746f     ): peer %s not a
   1d458:	65687475 6369746e 64657461 00000000     uthenticated....
   1d468:	72636e45 4d747079 61737365 29286567     EncryptMessage()
   1d478:	4a41203a 5252455f 4345535f 54495255     : AJ_ERR_SECURIT
   1d488:	00000059 445f4a41 76696c65 734d7265     Y...AJ_DeliverMs
   1d498:	3a292867 5f4a4120 5f525245 5352414d     g(): AJ_ERR_MARS
   1d4a8:	004c4148 555f4a41 72616d6e 6c616873     HAL.AJ_Unmarshal
   1d4b8:	2867734d 41203a29 52455f4a 4f4e5f52     Msg(): AJ_ERR_NO
   1d4c8:	524f4d5f 00000045 555f4a41 72616d6e     _MORE...AJ_Unmar
   1d4d8:	6c616873 28677241 4d203a29 61737365     shalArg(): Messa
   1d4e8:	62206567 2079646f 676e656c 69206874     ge body length i
   1d4f8:	6e692073 72726f63 2c746365 61747320     s incorrect, sta
   1d508:	20737574 4a41203d 5252455f 4d4e555f     tus = AJ_ERR_UNM
   1d518:	48535241 00004c41 555f4a41 72616d6e     ARSHAL..AJ_Unmar
   1d528:	6c616873 28776152 41203a29 52455f4a     shalRaw(): AJ_ER
   1d538:	49535f52 54414e47 00455255 555f4a41     R_SIGNATURE.AJ_U
   1d548:	72616d6e 6c616873 28776152 41203a29     nmarshalRaw(): A
   1d558:	52455f4a 4e555f52 5352414d 004c4148     J_ERR_UNMARSHAL.
   1d568:	555f4a41 72616d6e 6c616873 746e6f43     AJ_UnmarshalCont
   1d578:	656e6961 3a292872 5f4a4120 5f525245     ainer(): AJ_ERR_
   1d588:	414d4e55 41485352 0000004c 65707954     UNMARSHAL...Type
   1d598:	67616c46 28285b73 2d677261 7079743e     Flags[((arg->typ
   1d5a8:	29644965 203d3d20 20272827 28207c7c     eId) == '(' || (
   1d5b8:	2d677261 7079743e 29644965 203d3d20     arg->typeId) == 
   1d5c8:	29272927 28203f20 2d677261 7079743e     ')') ? (arg->typ
   1d5d8:	29644965 27202d20 3a202728 28282820     eId) - '(' : (((
   1d5e8:	2d677261 7079743e 29644965 27203c20     arg->typeId) < '
   1d5f8:	7c202761 6128207c 3e2d6772 65707974     a' || (arg->type
   1d608:	20296449 7d27203e 3f202927 277d2720     Id) > '}') ? '}'
   1d618:	32202b20 27202d20 3a202761 72612820      + 2 - 'a' : (ar
   1d628:	743e2d67 49657079 2b202964 2d203220     g->typeId) + 2 -
   1d638:	27612720 205d2029 78302026 00003032      'a') ] & 0x20..
   1d648:	2d67736d 74756f3e 3d207265 7261203d     msg->outer == ar
   1d658:	00000067 555f4a41 72616d6e 6c616873     g...AJ_Unmarshal
   1d668:	736f6c43 6e6f4365 6e696174 29287265     CloseContainer()
   1d678:	4a41203a 5252455f 4d4e555f 48535241     : AJ_ERR_UNMARSH
   1d688:	00004c41 555f4a41 72616d6e 6c616873     AL..AJ_Unmarshal
   1d698:	736f6c43 6e6f4365 6e696174 29287265     CloseContainer()
   1d6a8:	4a41203a 5252455f 4749535f 5554414e     : AJ_ERR_SIGNATU
   1d6b8:	00004552 2d67736d 6769733e 7366664f     RE..msg->sigOffs
   1d6c8:	3d207465 7473203d 6e656c72 67736d28     et == strlen(msg
   1d6d8:	69733e2d 74616e67 29657275 00000000     ->signature)....
   1d6e8:	75426f69 723e2d66 50646165 3c207274     ioBuf->readPtr <
   1d6f8:	426f6920 3e2d6675 74697277 72745065      ioBuf->writePtr
   1d708:	00000000 75426f69 723e2d66 50646165     ....ioBuf->readP
   1d718:	303d7274 20782578 75426f69 773e2d66     tr=0x%x ioBuf->w
   1d728:	65746972 20727450 7830203d 41207825     ritePtr = 0x%x A
   1d738:	4f495f4a 4655425f 4156415f 69284c49     J_IO_BUF_AVAIL(i
   1d748:	6675426f 253d2029 00000a64 72756321     oBuf) =%d...!cur
   1d758:	746e6572 0067734d 20656854 6e6e6f63     rentMsg.The conn
   1d768:	69746365 77206e6f 72207361 63656a65     ection was rejec
   1d778:	20646574 74207962 72206568 6974756f     ted by the routi
   1d788:	6e20676e 0065646f 64616548 64207265     ng node.Header d
   1d798:	2073656f 20746f6e 746e6f63 206e6961     oes not contain 
   1d7a8:	20656874 75716572 64657269 65696620     the required fie
   1d7b8:	2073646c 20726f66 20656874 7373656d     lds for the mess
   1d7c8:	20656761 65707974 00000000 72636544     age type....Decr
   1d7d8:	4d747079 61737365 29286567 4a41203a     yptMessage(): AJ
   1d7e8:	5252455f 4345535f 54495255 00000059     _ERR_SECURITY...
   1d7f8:	2d67736d 7264683e 65733e2d 6c616972     msg->hdr->serial
   1d808:	206d754e 6425203d 0000000a 6d6e5556     Num = %d....VUnm
   1d818:	68737261 72416c61 29287367 4a41203a     arshalArgs(): AJ
   1d828:	6d6e555f 68737261 6f436c61 6961746e     _UnmarshalContai
   1d838:	2072656e 74617473 3d207375 0a732520     ner status = %s.
   1d848:	00000000 6d6e5556 68737261 72416c61     ....VUnmarshalAr
   1d858:	29287367 5556203a 72616d6e 6c616873     gs(): VUnmarshal
   1d868:	73677241 61747320 20737574 7325203d     Args status = %s
   1d878:	0000000a 6d6e5556 68737261 72416c61     ....VUnmarshalAr
   1d888:	29287367 4a41203a 6d6e555f 68737261     gs(): AJ_Unmarsh
   1d898:	6c436c61 4365736f 61746e6f 72656e69     alCloseContainer
   1d8a8:	61747320 20737574 7325203d 0000000a      status = %s....
   1d8b8:	6d6e5556 68737261 72416c61 29287367     VUnmarshalArgs()
   1d8c8:	4a41203a 6d6e555f 68737261 61566c61     : AJ_UnmarshalVa
   1d8d8:	6e616972 74732074 73757461 25203d20     riant status = %
   1d8e8:	00000a73 555f4a41 72616d6e 6c616873     s...AJ_Unmarshal
   1d8f8:	73677241 203a2928 455f4a41 555f5252     Args(): AJ_ERR_U
   1d908:	5058454e 45544345 00000044 555f4a41     NEXPECTED...AJ_U
   1d918:	72616d6e 6c616873 73677241 203a2928     nmarshalArgs(): 
   1d928:	455f4a41 555f5252 52414d4e 4c414853     AJ_ERR_UNMARSHAL
   1d938:	00000000 67736d21 756f3e2d 00726574     ....!msg->outer.
   1d948:	445f4a41 76696c65 734d7265 72615067     AJ_DeliverMsgPar
   1d958:	6c616974 203a2928 455f4a41 555f5252     tial(): AJ_ERR_U
   1d968:	5058454e 45544345 00000044 445f4a41     NEXPECTED...AJ_D
   1d978:	76696c65 734d7265 72615067 6c616974     eliverMsgPartial
   1d988:	203a2928 455f4a41 535f5252 52554345     (): AJ_ERR_SECUR
   1d998:	00595449 445f4a41 76696c65 734d7265     ITY.AJ_DeliverMs
   1d9a8:	72615067 6c616974 203a2928 455f4a41     gPartial(): AJ_E
   1d9b8:	535f5252 414e4749 45525554 00000000     RR_SIGNATURE....
   1d9c8:	445f4a41 76696c65 734d7265 72615067     AJ_DeliverMsgPar
   1d9d8:	6c616974 203a2928 74617473 253d7375     tial(): status=%
   1d9e8:	00000a73 4d5f4a41 68737261 61526c61     s...AJ_MarshalRa
   1d9f8:	3a292877 5f4a4120 5f525245 55434553     w(): AJ_ERR_SECU
   1da08:	59544952 00000000 4d5f4a41 68737261     RITY....AJ_Marsh
   1da18:	61526c61 3a292877 5f4a4120 5f525245     alRaw(): AJ_ERR_
   1da28:	54495257 00000045 4d5f4a41 68737261     WRITE...AJ_Marsh
   1da38:	6c436c61 4365736f 61746e6f 72656e69     alCloseContainer
   1da48:	203a2928 455f4a41 535f5252 414e4749     (): AJ_ERR_SIGNA
   1da58:	45525554 00000000 4d5f4a41 68737261     TURE....AJ_Marsh
   1da68:	72416c61 29287367 4a41203a 5252455f     alArgs(): AJ_ERR
   1da78:	454e555f 43455058 00444554 6874656d     _UNEXPECTED.meth
   1da88:	6143646f 3e2d6c6c 2d726468 67736d3e     odCall->hdr->msg
   1da98:	65707954 203d3d20 00000031              Type == 1...

0001daa4 <__func__.13335>:
   1daa4:	4d5f4a41 68737261 72456c61 4d726f72     AJ_MarshalErrorM
   1dab4:	69576773 6e496874 00006f66              sgWithInfo..

0001dac0 <TypeFlags>:
   1dac0:	14240028 00001800 00141441 12000000     (.$.....A.......
   1dad0:	00120044 81141844 00111800 00000028     D...D.......(...

0001dae0 <__func__.13297>:
   1dae0:	4d5f4a41 68737261 6c436c61 4365736f     AJ_MarshalCloseC
   1daf0:	61746e6f 72656e69 00000000              ontainer....

0001dafc <__func__.13054>:
   1dafc:	555f4a41 72616d6e 6c616873 0067734d     AJ_UnmarshalMsg.

0001db0c <__func__.13024>:
   1db0c:	525f4a41 74657365 73677241 00000000     AJ_ResetArgs....
   1db1c:	4e5f4a41 535f7465 28646e65 3d667562     AJ_Net_Send(buf=
   1db2c:	70257830 00000a29 4e5f4a41 525f7465     0x%p)...AJ_Net_R
   1db3c:	28766345 4d203a29 73617720 6425203a     Ecv(): M was: %d
   1db4c:	7872202c 7466654c 7265766f 73617720     , rxLeftover was
   1db5c:	6425203a 0000000a 4e5f4a41 525f7465     : %d....AJ_Net_R
   1db6c:	28766365 74203a29 6f656d69 202e7475     ecv(): timeout. 
   1db7c:	74617473 413d7375 52455f4a 49545f52     status=AJ_ERR_TI
   1db8c:	554f454d 00000054 4e5f4a41 525f7465     MEOUT...AJ_Net_R
   1db9c:	28766365 42203a29 45464655 564f2052     ecv(): BUFFER OV
   1dbac:	55525245 61203a4e 6f466b73 75253d72     ERRUN: askFor=%u
   1dbbc:	6572202c 75253d74 0000000a 4e5f4a41     , ret=%u....AJ_N
   1dbcc:	525f7465 28766365 72203a29 28646165     et_Recv(): read(
   1dbdc:	61662029 64656c69 7473202e 73757461     ) failed. status
   1dbec:	5f4a413d 5f525245 44414552 00000000     =AJ_ERR_READ....
   1dbfc:	4e5f4a41 525f7465 28766365 6e203a29     AJ_Net_Recv(): n
   1dc0c:	6c207765 6f746665 20726576 000a6425     ew leftover %d..
   1dc1c:	4e5f4a41 525f7465 46766365 286d6f72     AJ_Net_RecvFrom(
   1dc2c:	72203a29 28646165 61662029 2e736c69     ): read() fails.
   1dc3c:	61747320 3d737574 455f4a41 525f5252      status=AJ_ERR_R
   1dc4c:	00444145 4e5f4a41 525f7465 46766365     EAD.AJ_Net_RecvF
   1dc5c:	286d6f72 73203a29 75746174 73253d73     rom(): status=%s
   1dc6c:	0000000a 4e5f4a41 435f7465 656e6e6f     ....AJ_Net_Conne
   1dc7c:	29287463 00000000 4e5f4a41 435f7465     ct()....AJ_Net_C
   1dc8c:	656e6e6f 29287463 7069203a 203d3476     onnect(): ipv4= 
   1dc9c:	202c7825 74726f70 25203d20 00000a64     %x, port = %d...
   1dcac:	4e5f4a41 435f7465 656e6e6f 29287463     AJ_Net_Connect()
   1dcbc:	6f63203a 63656e6e 00000074 4e5f4a41     : connect...AJ_N
   1dccc:	435f7465 656e6e6f 29287463 6f63203a     et_Connect(): co
   1dcdc:	63656e6e 4b4f2074 00000000 4e5f4a41     nnect OK....AJ_N
   1dcec:	435f7465 656e6e6f 29287463 6f63203a     et_Connect(): co
   1dcfc:	63656e6e 20292874 63637573 3a737365     nnect() success:
   1dd0c:	61747320 3d737574 4f5f4a41 0000004b      status=AJ_OK...
   1dd1c:	65766153 7473614d 65537265 74657263     SaveMasterSecret
   1dd2c:	65657028 69754772 70253d64 7865202c     (peerGuid=%p, ex
   1dd3c:	61726970 6e6f6974 2964253d 0000000a     piration=%d)....
   1dd4c:	65766153 7473614d 65537265 74657263     SaveMasterSecret
   1dd5c:	65657028 69754772 70253d64 7865202c     (peerGuid=%p, ex
   1dd6c:	61726970 6e6f6974 2964253d 6e49203a     piration=%d): In
   1dd7c:	696c6176 74732064 0a657461 00000000     valid state.....
   1dd8c:	4779654b 70286e65 4e726565 3d656d61     KeyGen(peerName=
   1dd9c:	22732522 6f72202c 253d656c 202c2e64     "%s", role=%d., 
   1ddac:	636e6f6e 223d3165 2c227325 6e6f6e20     nonce1="%s", non
   1ddbc:	3d326563 22732522 756f202c 66756274     ce2="%s", outbuf
   1ddcc:	2c70253d 6e656c20 2e64253d 00000a29     =%p, len=%d.)...
   1dddc:	732f2e2e 612f6372 6f6a6c6c 742f6e79     ../src/alljoyn/t
   1ddec:	206e6968 65726f63 6372732f 5f6a612f     hin core/src/aj_
   1ddfc:	72656570 0000632e 4779654b 29286e65     peer.c..KeyGen()
   1de0c:	4a41203a 5252455f 454e555f 43455058     : AJ_ERR_UNEXPEC
   1de1c:	00444554 73736573 206e6f69 0079656b     TED.session key.
   1de2c:	4779654b 29286e65 4a41203a 5252455f     KeyGen(): AJ_ERR
   1de3c:	5345525f 4352554f 00005345 4779654b     _RESOURCES..KeyG
   1de4c:	56206e65 66697265 20726569 7325203d     en Verifier = %s
   1de5c:	0000000a 72656570 746e6f43 2e747865     ....peerContext.
   1de6c:	72656570 64697547 7825203d 0000000a     peerGuid= %x....
   1de7c:	485f4a41 73646e61 656b6168 656d6954     AJ_HandshakeTime
   1de8c:	2874756f 50203a29 20726565 61736964     out(): Peer disa
   1de9c:	61657070 00646572 475f4a41 6c457465     ppeared.AJ_GetEl
   1deac:	65737061 6d695464 70262865 43726565     apsedTime(&peerC
   1debc:	65746e6f 742e7478 72656d69 5254202c     ontext.timer, TR
   1decc:	20294555 6425203d 0000000a 4d5f4a41     UE) = %d....AJ_M
   1dedc:	415f5841 5f485455 454d4954 25203d20     AX_AUTH_TIME = %
   1deec:	00000a64 485f4a41 73646e61 656b6168     d...AJ_Handshake
   1defc:	656d6954 2874756f 41203a29 52455f4a     Timeout(): AJ_ER
   1df0c:	49545f52 554f454d 00000054 485f4a41     R_TIMEOUT...AJ_H
   1df1c:	73646e61 656b6168 656d6954 2874756f     andshakeTimeout(
   1df2c:	41203a29 4b4f5f4a 00000000 505f4a41     ): AJ_OK....AJ_P
   1df3c:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1df4c:	69754765 6d287364 253d6773 72202c70     eGuids(msg=%p, r
   1df5c:	796c7065 2970253d 0000000a 505f4a41     eply=%p)....AJ_P
   1df6c:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1df7c:	69754765 69207364 70282066 43726565     eGuids if (peerC
   1df8c:	65746e6f 702e7478 47726565 29646975     ontext.peerGuid)
   1df9c:	00000020 505f4a41 48726565 6c646e61      ...AJ_PeerHandl
   1dfac:	63784565 676e6168 69754765 6d287364     eExchangeGuids(m
   1dfbc:	253d6773 72202c70 796c7065 2970253d     sg=%p, reply=%p)
   1dfcc:	6148203a 6873646e 20656b61 70206e69     : Handshake in p
   1dfdc:	72676f72 0a737365 00000000 505f4a41     rogress.....AJ_P
   1dfec:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1dffc:	69754765 6d287364 253d6773 72202c70     eGuids(msg=%p, r
   1e00c:	796c7065 2970253d 6e55203a 7372616d     eply=%p): Unmars
   1e01c:	206c6168 6f727265 00000a72 475f4a41     hal error...AJ_G
   1e02c:	5f444955 6d6f7246 69727453 203a676e     UID_FromString: 
   1e03c:	3d727473 000a7325 505f4a41 48726565     str=%s..AJ_PeerH
   1e04c:	6c646e61 63784565 676e6168 69754765     andleExchangeGui
   1e05c:	6d287364 253d6773 72202c70 796c7065     ds(msg=%p, reply
   1e06c:	2970253d 6e49203a 696c6176 55472064     =%p): Invalid GU
   1e07c:	000a4449 505f4a41 48726565 6c646e61     ID..AJ_PeerHandl
   1e08c:	63784565 676e6168 69754765 6d287364     eExchangeGuids(m
   1e09c:	253d6773 72202c70 796c7065 2970253d     sg=%p, reply=%p)
   1e0ac:	6441203a 616e2064 6d20656d 69707061     : Add name mappi
   1e0bc:	6520676e 726f7272 0000000a 475f4a41     ng error....AJ_G
   1e0cc:	5f444955 646e6946 65657020 6e6f4372     UID_Find peerCon
   1e0dc:	74786574 6565702e 69754772 25203d64     text.peerGuid= %
   1e0ec:	00000a64 475f4a41 5f444955 646e6946     d...AJ_GUID_Find
   1e0fc:	4a412020 7465475f 72656550 64657243       AJ_GetPeerCred
   1e10c:	69746e65 73206c61 75746174 25203d73     ential status= %
   1e11c:	00000a73 475f4a41 5f444955 646e6946     s...AJ_GUID_Find
   1e12c:	4a412020 6572435f 746e6564 456c6169       AJ_CredentialE
   1e13c:	72697078 73206465 75746174 25203d73     xpired status= %
   1e14c:	00000a73 505f4a41 48726565 6c646e61     s...AJ_PeerHandl
   1e15c:	63784565 676e6168 69754765 6d287364     eExchangeGuids(m
   1e16c:	253d6773 72202c70 796c7065 2970253d     sg=%p, reply=%p)
   1e17c:	6556203a 6f697372 7825206e 0000000a     : Version %x....
   1e18c:	505f4a41 48726565 6c646e61 63784565     AJ_PeerHandleExc
   1e19c:	676e6168 49554765 65527344 28796c70     hangeGUIDsReply(
   1e1ac:	3d67736d 3a297025 766e4920 64696c61     msg=%p): Invalid
   1e1bc:	72657620 6e6f6973 0000000a 505f4a41      version....AJ_P
   1e1cc:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1e1dc:	69755365 28736574 3d67736d 202c7025     eSuites(msg=%p, 
   1e1ec:	6c706572 70253d79 00000a29 505f4a41     reply=%p)...AJ_P
   1e1fc:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1e20c:	69755365 28736574 3d67736d 202c7025     eSuites(msg=%p, 
   1e21c:	6c706572 70253d79 55203a29 72616d6e     reply=%p): Unmar
   1e22c:	6c616873 72726520 000a726f 505f4a41     shal error..AJ_P
   1e23c:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1e24c:	69755365 28736574 3d67736d 202c7025     eSuites(msg=%p, 
   1e25c:	6c706572 70253d79 4d203a29 68737261     reply=%p): Marsh
   1e26c:	65206c61 726f7272 0000000a 68637845     al error....Exch
   1e27c:	65676e61 69755320 20736574 706d6f43     ange Suites Comp
   1e28c:	6574656c 00000000 505f4a41 48726565     lete....AJ_PeerH
   1e29c:	6c646e61 79654b65 68637845 65676e61     andleKeyExchange
   1e2ac:	67736d28 2c70253d 70657220 253d796c     (msg=%p, reply=%
   1e2bc:	000a2970 505f4a41 48726565 6c646e61     p)..AJ_PeerHandl
   1e2cc:	79654b65 68637845 65676e61 6e614820     eKeyExchange Han
   1e2dc:	61687364 6156656b 2064696c 74617473     dshakeValid stat
   1e2ec:	253d7375 00000a73 505f4a41 48726565     us=%s...AJ_PeerH
   1e2fc:	6c646e61 79654b65 68637845 65676e61     andleKeyExchange
   1e30c:	5f4a4120 75537349 45657469 6c62616e      AJ_IsSuiteEnabl
   1e31c:	65206465 726f7272 00000020 505f4a41     ed error ...AJ_P
   1e32c:	48726565 6c646e61 79654b65 68637845     eerHandleKeyExch
   1e33c:	65676e61 61747320 3d737574 000a7325     ange status=%s..
   1e34c:	505f4a41 48726565 6c646e61 79654b65     AJ_PeerHandleKey
   1e35c:	68637845 65676e61 5f4a4120 7372614d     Exchange AJ_Mars
   1e36c:	416c6168 20736772 74617473 253d7375     halArgs status=%
   1e37c:	00000a73 505f4a41 48726565 6c646e61     s...AJ_PeerHandl
   1e38c:	79654b65 68637845 65676e61 5f4a4120     eKeyExchange AJ_
   1e39c:	4579654b 61686378 4d65676e 68737261     KeyExchangeMarsh
   1e3ac:	73206c61 75746174 73253d73 0000000a     al status=%s....
   1e3bc:	2079654b 68637845 65676e61 6d6f4320     Key Exchange Com
   1e3cc:	74656c70 00000065 505f4a41 48726565     plete...AJ_PeerH
   1e3dc:	6c646e61 79654b65 68637845 65676e61     andleKeyExchange
   1e3ec:	6c706552 736d2879 70253d67 53203a29     Reply(msg=%p): S
   1e3fc:	65746975 73696d20 6374616d 00000a68     uite mismatch...
   1e40c:	505f4a41 48726565 6c646e61 79654b65     AJ_PeerHandleKey
   1e41c:	68747541 69746e65 69746163 6d286e6f     Authentication(m
   1e42c:	253d6773 72202c70 796c7065 2970253d     sg=%p, reply=%p)
   1e43c:	0000000a 505f4a41 48726565 6c646e61     ....AJ_PeerHandl
   1e44c:	79654b65 68747541 69746e65 69746163     eKeyAuthenticati
   1e45c:	6d286e6f 253d6773 72202c70 796c7065     on(msg=%p, reply
   1e46c:	2970253d 6153203a 6d206576 65747361     =%p): Save maste
   1e47c:	65732072 74657263 72726520 000a726f     r secret error..
   1e48c:	505f4a41 48726565 6c646e61 79654b65     AJ_PeerHandleKey
   1e49c:	68747541 69746e65 69746163 65526e6f     AuthenticationRe
   1e4ac:	28796c70 3d67736d 0a297025 00000000     ply(msg=%p).....
   1e4bc:	505f4a41 48726565 6c646e61 79654b65     AJ_PeerHandleKey
   1e4cc:	68747541 69746e65 69746163 65526e6f     AuthenticationRe
   1e4dc:	28796c70 3d67736d 3a297025 72726520     ply(msg=%p): err
   1e4ec:	253d726f 000a2e73 505f4a41 48726565     or=%s...AJ_PeerH
   1e4fc:	6c646e61 79654b65 68747541 69746e65     andleKeyAuthenti
   1e50c:	69746163 65526e6f 28796c70 3d67736d     cationReply(msg=
   1e51c:	3a297025 766e4920 64696c61 61747320     %p): Invalid sta
   1e52c:	000a6574 505f4a41 48726565 6c646e61     te..AJ_PeerHandl
   1e53c:	79654b65 68747541 69746e65 69746163     eKeyAuthenticati
   1e54c:	65526e6f 28796c70 3d67736d 3a297025     onReply(msg=%p):
   1e55c:	79654b20 74756120 746e6568 74616369      Key authenticat
   1e56c:	206e6f69 616d6e75 61687372 7265206c     ion unmarshal er
   1e57c:	0a726f72 00000000 2079654b 68747541     ror.....Key Auth
   1e58c:	69746e65 69746163 43206e6f 6c706d6f     entication Compl
   1e59c:	00657465 505f4a41 48726565 6c646e61     ete.AJ_PeerHandl
   1e5ac:	79654b65 68747541 69746e65 69746163     eKeyAuthenticati
   1e5bc:	65526e6f 28796c70 3d67736d 3a297025     onReply(msg=%p):
   1e5cc:	76615320 616d2065 72657473 63657320      Save master sec
   1e5dc:	20746572 6f727265 00000a72 505f4a41     ret error...AJ_P
   1e5ec:	48726565 6c646e61 6e654765 73736553     eerHandleGenSess
   1e5fc:	4b6e6f69 6d287965 253d6773 72202c70     ionKey(msg=%p, r
   1e60c:	796c7065 2970253d 0000000a 505f4a41     eply=%p)....AJ_P
   1e61c:	48726565 6c646e61 6e654765 73736553     eerHandleGenSess
   1e62c:	4b6e6f69 203a7965 646e6148 6b616873     ionKey: Handshak
   1e63c:	6c615665 00006469 505f4a41 48726565     eValid..AJ_PeerH
   1e64c:	6c646e61 6e654765 73736553 4b6e6f69     andleGenSessionK
   1e65c:	6d287965 253d6773 72202c70 796c7065     ey(msg=%p, reply
   1e66c:	2970253d 654b203a 6f6e2079 76612074     =%p): Key not av
   1e67c:	616c6961 0a656c62 00000000 505f4a41     ailable.....AJ_P
   1e68c:	48726565 6c646e61 63784565 676e6168     eerHandleExchang
   1e69c:	6f724765 654b7075 6d287379 253d6773     eGroupKeys(msg=%
   1e6ac:	72202c70 796c7065 2970253d 0000000a     p, reply=%p)....
   1e6bc:	505f4a41 48726565 6c646e61 63784565     AJ_PeerHandleExc
   1e6cc:	676e6168 6f724765 654b7075 29287379     hangeGroupKeys()
   1e6dc:	4a41203a 5252455f 564e495f 44494c41     : AJ_ERR_INVALID
   1e6ec:	00000000                                ....

0001e6f0 <DBusPeerInterface>:
   1e6f0:	67726f23 6572662e 73656465 706f746b     #org.freedesktop
   1e700:	7542442e 65502e73 00007265              .DBus.Peer..

0001e70c <DaemonIfaces>:
   1e70c:	0001e7a8 00000000                       ........

0001e714 <AJ_ErrResources>:
   1e714:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1e724:	6f736552 65637275 00000073              Resources...

0001e730 <AJ_ErrMaxSizeExceeded>:
   1e730:	2e67726f 6a6c6c61 2e6e796f 6f727245     org.alljoyn.Erro
   1e740:	614d2e72 7a695378 63784565 65646565     r.MaxSizeExceede
   1e750:	00000064                                d...

0001e754 <PeerSessionInterface>:
   1e754:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1e764:	72656550 7365532e 6e6f6973 00000000     Peer.Session....

0001e774 <AboutIconIface>:
   1e774:	0001e97c 0001ebf4 0001ec00 0001ec0c     |...............
   1e784:	0001ec14 0001ec20 00000000              .... .......

0001e790 <DBusInterface>:
   1e790:	2e67726f 65657266 6b736564 2e706f74     org.freedesktop.
   1e7a0:	73754244 00000000                       DBus....

0001e7a8 <DaemonIface>:
   1e7a8:	0001e8e8 0001eda0 0001edac 00000000     ................

0001e7b8 <AJ_DBusDestination>:
   1e7b8:	2e67726f 65657266 6b736564 2e706f74     org.freedesktop.
   1e7c8:	73754244 00000000                       DBus....

0001e7d0 <BusObjectPath>:
   1e7d0:	67726f2f 6c6c612f 6e796f6a 7375422f     /org/alljoyn/Bus
   1e7e0:	00000000                                ....

0001e7e4 <AboutIconIfaces>:
   1e7e4:	0001e8d4 0001e774 00000000              ....t.......

0001e7f0 <AJ_StandardObjects>:
   1e7f0:	0001e870 0001eaa8 00000010 00000000     p...............
   1e800:	0001e7d0 0001eb34 00000010 00000000     ....4...........
   1e810:	0001ea90 0001e968 00000000 00000000     ....h...........
   1e820:	0001ebf0 0001e8fc 00000000 00000000     ................
   1e830:	0001eba0 0001e70c 00000010 00000000     ................
   1e840:	0001e974 0001eba4 00000008 00000000     t...............
   1e850:	0001ea18 0001e7e4 00000008 00000000     ................
	...

0001e870 <DBusObjectPath>:
   1e870:	67726f2f 6572662f 73656465 706f746b     /org/freedesktop
   1e880:	7542442f 00000073                       /DBus...

0001e888 <DBusIntrospectableInterface>:
   1e888:	67726f23 6572662e 73656465 706f746b     #org.freedesktop
   1e898:	7542442e 6e492e73 736f7274 74636570     .DBus.Introspect
   1e8a8:	656c6261 00000000                       able....

0001e8b0 <PeerAuthInterface>:
   1e8b0:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1e8c0:	72656550 7475412e 746e6568 74616369     Peer.Authenticat
   1e8d0:	006e6f69                                ion.

0001e8d4 <AJ_PropertiesIface>:
   1e8d4:	0001ea58 0001f170 0001f180 0001f190     X...p...........
   1e8e4:	00000000                                ....

0001e8e8 <DaemonInterface>:
   1e8e8:	2e67726f 6a6c6c61 2e6e796f 6d656144     org.alljoyn.Daem
   1e8f8:	00006e6f                                on..

0001e8fc <CommonIfaces>:
   1e8fc:	0001eb94 0001ebb0 0001ea08 00000000     ................

0001e90c <AJ_ErrTimeout>:
   1e90c:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1e91c:	656d6954 0074756f                       Timeout.

0001e924 <AJ_ErrRejected>:
   1e924:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1e934:	656a6552 64657463 00000000              Rejected....

0001e940 <PeerSessionIface>:
   1e940:	0001e754 0001ed64 0001ed88 00000000     T...d...........

0001e950 <AboutIface>:
   1e950:	0001ea7c 0001ebf4 0001ec30 0001ec48     |.......0...H...
   1e960:	0001ec68 00000000                       h.......

0001e968 <PeerIfaces>:
   1e968:	0001e940 0001ea2c 00000000              @...,.......

0001e974 <AboutObjectPath>:
   1e974:	6f62412f 00007475                       /About..

0001e97c <AboutIconInterface>:
   1e97c:	2e67726f 6a6c6c61 2e6e796f 6e6f6349     org.alljoyn.Icon
   1e98c:	00000000                                ....

0001e990 <AllSeenIntrospectableInterface>:
   1e990:	67726f23 6c6c612e 6e656573 746e492e     #org.allseen.Int
   1e9a0:	70736f72 61746365 00656c62              rospectable.

0001e9ac <BusIface>:
   1e9ac:	0001eb3c 0001edb8 0001edc8 0001ede8     <...............
   1e9bc:	0001ee08 0001ee24 0001ee3c 0001ee5c     ....$...<...\...
   1e9cc:	0001ee78 0001ee98 0001eebc 0001eed8     x...............
   1e9dc:	0001ef00 0001ef14 0001ef34 0001ef5c     ........4...\...
   1e9ec:	0001ef8c 0001efa8 0001efc4 0001efe4     ................
   1e9fc:	0001eff4 0001f014 00000000              ............

0001ea08 <AJ_AllSeenIntrospectionIface>:
   1ea08:	0001e990 0001f11c 0001f13c 00000000     ........<.......

0001ea18 <AboutIconObjectPath>:
   1ea18:	6f62412f 442f7475 63697665 6f634965     /About/DeviceIco
   1ea28:	0000006e                                n...

0001ea2c <PeerAuthIface>:
   1ea2c:	0001e8b0 0001ec88 0001eca4 0001ecc4     ................
   1ea3c:	0001ece0 0001ecf8 0001ed10 0001ed2c     ............,...
   1ea4c:	0001ed48 0001ed58 00000000              H...X.......

0001ea58 <DBusPropsInterface>:
   1ea58:	67726f23 6572662e 73656465 706f746b     #org.freedesktop
   1ea68:	7542442e 72502e73 7265706f 73656974     .DBus.Properties
   1ea78:	00000000                                ....

0001ea7c <AboutInterface>:
   1ea7c:	2e67726f 6a6c6c61 2e6e796f 756f6241     org.alljoyn.Abou
   1ea8c:	00000074                                t...

0001ea90 <PeerObjectPath>:
   1ea90:	67726f2f 6c6c612f 6e796f6a 7375422f     /org/alljoyn/Bus
   1eaa0:	6565502f 00000072                       /Peer...

0001eaa8 <DBusIfaces>:
   1eaa8:	0001eb04 00000000                       ........

0001eab0 <AJ_ErrServiceUnknown>:
   1eab0:	2e67726f 65657266 6b736564 2e706f74     org.freedesktop.
   1eac0:	73754244 7272452e 532e726f 69767265     DBus.Error.Servi
   1ead0:	6e556563 776f6e6b 0000006e              ceUnknown...

0001eadc <AJ_ErrLanguageNotSuppored>:
   1eadc:	2e67726f 6a6c6c61 2e6e796f 6f727245     org.alljoyn.Erro
   1eaec:	614c2e72 6175676e 6f4e6567 70755374     r.LanguageNotSup
   1eafc:	74726f70 00006465                       ported..

0001eb04 <DBusIface>:
   1eb04:	0001e790 0001f04c 0001f058 0001f074     ....L...X...t...
   1eb14:	0001f088 0001f098 0001f0bc 0001f0d4     ................
   1eb24:	0001f0e4 0001f0f4 0001f108 00000000     ................

0001eb34 <BusIfaces>:
   1eb34:	0001e9ac 00000000                       ........

0001eb3c <BusInterface>:
   1eb3c:	2e67726f 6a6c6c61 2e6e796f 00737542     org.alljoyn.Bus.

0001eb4c <AJ_ErrUpdateNotAllowed>:
   1eb4c:	2e67726f 6a6c6c61 2e6e796f 6f727245     org.alljoyn.Erro
   1eb5c:	70552e72 65746164 41746f4e 776f6c6c     r.UpdateNotAllow
   1eb6c:	00006465                                ed..

0001eb70 <AJ_ErrSecurityViolation>:
   1eb70:	2e67726f 6a6c6c61 2e6e796f 2e737542     org.alljoyn.Bus.
   1eb80:	75636553 79746972 6c6f6956 6f697461     SecurityViolatio
   1eb90:	0000006e                                n...

0001eb94 <AJ_IntrospectionIface>:
   1eb94:	0001e888 0001f160 00000000              ....`.......

0001eba0 <DaemonObjectPath>:
   1eba0:	0000002f                                /...

0001eba4 <AboutIfaces>:
   1eba4:	0001e8d4 0001e950 00000000              ....P.......

0001ebb0 <DBusPeerIface>:
   1ebb0:	0001e6f0 0001f030 0001f038 00000000     ....0...8.......

0001ebc0 <AJ_BusDestination>:
   1ebc0:	2e67726f 6a6c6c61 2e6e796f 00737542     org.alljoyn.Bus.

0001ebd0 <AJ_ErrInvalidValue>:
   1ebd0:	2e67726f 6a6c6c61 2e6e796f 6f727245     org.alljoyn.Erro
   1ebe0:	6e492e72 696c6176 6c615664 00006575     r.InvalidValue..
   1ebf0:	0000003f 72655640 6e6f6973 0000713e     ?...@Version>q..
   1ec00:	6d694d40 70795465 00733e65 7a695340     @MimeType>s.@Siz
   1ec10:	00753e65 7465473f 206c7255 0000733e     e>u.?GetUrl >s..
   1ec20:	7465473f 746e6f43 20746e65 0079613e     ?GetContent >ay.
   1ec30:	7465473f 756f6241 74614474 733c2061     ?GetAboutData <s
   1ec40:	7b613e20 007d7673 7465473f 656a624f      >a{sv}.?GetObje
   1ec50:	65447463 69726373 6f697470 613e206e     ctDescription >a
   1ec60:	73616f28 00000029 6e412621 6e756f6e     (oas)...!&Announ
   1ec70:	3e206563 713e2071 28613e20 2973616f     ce >q >q >a(oas)
   1ec80:	7b613e20 007d7673 6378453f 676e6168      >a{sv}.?Exchang
   1ec90:	69754765 3c207364 753c2073 20733e20     eGuids <s <u >s 
   1eca0:	0000753e 6e65473f 73736553 4b6e6f69     >u..?GenSessionK
   1ecb0:	3c207965 733c2073 20733c20 3e20733e     ey <s <s <s >s >
   1ecc0:	00000073 6378453f 676e6168 6f724765     s...?ExchangeGro
   1ecd0:	654b7075 3c207379 3e207961 00007961     upKeys <ay >ay..
   1ece0:	7475413f 61684368 6e656c6c 3c206567     ?AuthChallenge <
   1ecf0:	733e2073 00000000 6378453f 676e6168     s >s....?Exchang
   1ed00:	69755365 20736574 2075613c 0075613e     eSuites <au >au.
   1ed10:	79654b3f 68637845 65676e61 20753c20     ?KeyExchange <u 
   1ed20:	3e20763c 763e2075 00000000 79654b3f     <v >u >v....?Key
   1ed30:	68747541 69746e65 69746163 3c206e6f     Authentication <
   1ed40:	763e2076 00000000 63654d40 696e6168     v >v....@Mechani
   1ed50:	20736d73 0000733e 72655640 6e6f6973     sms >s..@Version
   1ed60:	00753e20 6363413f 53747065 69737365      >u.?AcceptSessi
   1ed70:	3c206e6f 753c2071 20733c20 737b613c     on <q <u <s <a{s
   1ed80:	3e207d76 00000062 73655321 6e6f6973     v} >b...!Session
   1ed90:	6e696f4a 3e206465 753e2071 00733e20     Joined >q >u >s.
   1eda0:	6f725021 65526562 00000071 6f725021     !ProbeReq...!Pro
   1edb0:	63416562 0000006b 73655321 6e6f6973     beAck...!Session
   1edc0:	74736f4c 00753e20 756f4621 6441646e     Lost >u.!FoundAd
   1edd0:	74726576 64657369 656d614e 20733e20     vertisedName >s 
   1ede0:	3e20713e 00000073 736f4c21 76644174     >q >s...!LostAdv
   1edf0:	69747265 4e646573 20656d61 3e20733e     ertisedName >s >
   1ee00:	733e2071 00000000 53504d21 69737365     q >s....!MPSessi
   1ee10:	68436e6f 65676e61 753e2064 20733e20     onChanged >u >s 
   1ee20:	0000623e 7664413f 69747265 614e6573     >b..?AdvertiseNa
   1ee30:	3c20656d 713c2073 00753e20 6e61433f     me <s <q >u.?Can
   1ee40:	416c6563 72657664 65736974 656d614e     celAdvertiseName
   1ee50:	20733c20 3e20713c 00000075 6e69463f      <s <q >u...?Fin
   1ee60:	76644164 69747265 4e646573 20656d61     dAdvertisedName 
   1ee70:	3e20733c 00000075 6e61433f 466c6563     <s >u...?CancelF
   1ee80:	41646e69 72657664 65736974 6d614e64     indAdvertisedNam
   1ee90:	733c2065 00000000 6e69423f 73655364     e <s....?BindSes
   1eea0:	6e6f6973 74726f50 20713c20 737b613c     sionPort <q <a{s
   1eeb0:	3e207d76 713e2075 00000000 626e553f     v} >u >q....?Unb
   1eec0:	53646e69 69737365 6f506e6f 3c207472     indSessionPort <
   1eed0:	753e2071 00000000 696f4a3f 7365536e     q >u....?JoinSes
   1eee0:	6e6f6973 20733c20 3c20713c 76737b61     sion <s <q <a{sv
   1eef0:	753e207d 20753e20 737b613e 00007d76     } >u >u >a{sv}..
   1ef00:	61654c3f 65536576 6f697373 753c206e     ?LeaveSession <u
   1ef10:	00753e20 6e61433f 536c6563 69737365      >u.?CancelSessi
   1ef20:	656c6e6f 654d7373 67617373 753c2065     onlessMessage <u
   1ef30:	00753e20 6e69463f 76644164 69747265      >u.?FindAdverti
   1ef40:	4e646573 42656d61 61725479 6f70736e     sedNameByTranspo
   1ef50:	3c207472 713c2073 00753e20 6e61433f     rt <s <q >u.?Can
   1ef60:	466c6563 41646e69 72657664 65736974     celFindAdvertise
   1ef70:	6d614e64 54794265 736e6172 74726f70     dNameByTransport
   1ef80:	20733c20 3e20713c 00000075 7465533f      <s <q >u...?Set
   1ef90:	6b6e694c 656d6954 2074756f 3c20753c     LinkTimeout <u <
   1efa0:	753e2075 00753e20 6d65523f 5365766f     u >u >u.?RemoveS
   1efb0:	69737365 654d6e6f 7265626d 73753c20     essionMember <us
   1efc0:	00753e20 73655321 6e6f6973 74736f4c      >u.!SessionLost
   1efd0:	68746957 73616552 3e206e6f 753e2075     WithReason >u >u
   1efe0:	00000000 6e69503f 733c2067 20753c20     ....?Ping <s <u 
   1eff0:	0000753e 7465533f 656c6449 656d6954     >u..?SetIdleTime
   1f000:	7374756f 20753c20 3e20753c 753e2075     outs <u <u >u >u
   1f010:	00753e20 6d69533f 48656c70 6f6c6c65      >u.?SimpleHello
   1f020:	20733c20 3e20753c 733e2073 00753e20      <s <u >s >s >u.
   1f030:	6e69503f 00000067 7465473f 6863614d     ?Ping...?GetMach
   1f040:	49656e69 733e2064 00000000 6c65483f     ineId >s....?Hel
   1f050:	3e206f6c 00000073 6d614e21 6e774f65     lo >s...!NameOwn
   1f060:	68437265 65676e61 733e2064 20733e20     erChanged >s >s 
   1f070:	0000733e 6d614e21 71634165 65726975     >s..!NameAcquire
   1f080:	733e2064 00000000 6d614e21 736f4c65     d >s....!NameLos
   1f090:	733e2074 00000000 6f725021 74726570     t >s....!Propert
   1f0a0:	43736569 676e6168 3e206465 613e2073     iesChanged >s >a
   1f0b0:	7d76737b 73613e20 00000000 7165523f     {sv} >as....?Req
   1f0c0:	74736575 656d614e 20733c20 3e20753c     uestName <s <u >
   1f0d0:	00000075 6464413f 6374614d 733c2068     u...?AddMatch <s
   1f0e0:	00000000 6d65523f 4d65766f 68637461     ....?RemoveMatch
   1f0f0:	00733c20 6c65523f 65736165 656d614e      <s.?ReleaseName
   1f100:	20733c20 0000753e 6d614e3f 73614865      <s >u..?NameHas
   1f110:	656e774f 733c2072 00623e20 7465473f     Owner <s >b.?Get
   1f120:	63736544 74706972 4c6e6f69 75676e61     DescriptionLangu
   1f130:	73656761 73613e20 00000000 746e493f     ages >as....?Int
   1f140:	70736f72 57746365 44687469 72637365     rospectWithDescr
   1f150:	69747069 3c206e6f 733e2073 00000000     iption <s >s....
   1f160:	746e493f 70736f72 20746365 0000733e     ?Introspect >s..
   1f170:	7465473f 20733c20 3e20733c 00000076     ?Get <s <s >v...
   1f180:	7465533f 20733c20 3c20733c 00000076     ?Set <s <s <v...
   1f190:	7465473f 206c6c41 3e20733c 76737b61     ?GetAll <s >a{sv
   1f1a0:	0000007d                                }...

0001f1a4 <ftable>:
   1f1a4:	a56363c6 847c7cf8 997777ee 8d7b7bf6     .cc..||..ww..{{.
   1f1b4:	0df2f2ff bd6b6bd6 b16f6fde 54c5c591     .....kk..oo....T
   1f1c4:	50303060 03010102 a96767ce 7d2b2b56     `00P.....gg.V++}
   1f1d4:	19fefee7 62d7d7b5 e6abab4d 9a7676ec     .......bM....vv.
   1f1e4:	45caca8f 9d82821f 40c9c989 877d7dfa     ...E.......@.}}.
   1f1f4:	15fafaef eb5959b2 c947478e 0bf0f0fb     .....YY..GG.....
   1f204:	ecadad41 67d4d4b3 fda2a25f eaafaf45     A......g_...E...
   1f214:	bf9c9c23 f7a4a453 967272e4 5bc0c09b     #...S....rr....[
   1f224:	c2b7b775 1cfdfde1 ae93933d 6a26264c     u.......=...L&&j
   1f234:	5a36366c 413f3f7e 02f7f7f5 4fcccc83     l66Z~??A.......O
   1f244:	5c343468 f4a5a551 34e5e5d1 08f1f1f9     h44\Q......4....
   1f254:	937171e2 73d8d8ab 53313162 3f15152a     .qq....sb11S*..?
   1f264:	0c040408 52c7c795 65232346 5ec3c39d     .......RF##e...^
   1f274:	28181830 a1969637 0f05050a b59a9a2f     0..(7......./...
   1f284:	0907070e 36121224 9b80801b 3de2e2df     ....$..6.......=
   1f294:	26ebebcd 6927274e cdb2b27f 9f7575ea     ...&N''i.....uu.
   1f2a4:	1b090912 9e83831d 742c2c58 2e1a1a34     ........X,,t4...
   1f2b4:	2d1b1b36 b26e6edc ee5a5ab4 fba0a05b     6..-.nn..ZZ.[...
   1f2c4:	f65252a4 4d3b3b76 61d6d6b7 ceb3b37d     .RR.v;;M...a}...
   1f2d4:	7b292952 3ee3e3dd 712f2f5e 97848413     R)){...>^//q....
   1f2e4:	f55353a6 68d1d1b9 00000000 2cededc1     .SS....h.......,
   1f2f4:	60202040 1ffcfce3 c8b1b179 ed5b5bb6     @  `....y....[[.
   1f304:	be6a6ad4 46cbcb8d d9bebe67 4b393972     .jj....Fg...r99K
   1f314:	de4a4a94 d44c4c98 e85858b0 4acfcf85     .JJ..LL..XX....J
   1f324:	6bd0d0bb 2aefefc5 e5aaaa4f 16fbfbed     ...k...*O.......
   1f334:	c5434386 d74d4d9a 55333366 94858511     .CC..MM.f33U....
   1f344:	cf45458a 10f9f9e9 06020204 817f7ffe     .EE.............
   1f354:	f05050a0 443c3c78 ba9f9f25 e3a8a84b     .PP.x<<D%...K...
   1f364:	f35151a2 fea3a35d c0404080 8a8f8f05     .QQ.]....@@.....
   1f374:	ad92923f bc9d9d21 48383870 04f5f5f1     ?...!...p88H....
   1f384:	dfbcbc63 c1b6b677 75dadaaf 63212142     c...w......uB!!c
   1f394:	30101020 1affffe5 0ef3f3fd 6dd2d2bf      ..0...........m
   1f3a4:	4ccdcd81 140c0c18 35131326 2fececc3     ...L....&..5.../
   1f3b4:	e15f5fbe a2979735 cc444488 3917172e     .__.5....DD....9
   1f3c4:	57c4c493 f2a7a755 827e7efc 473d3d7a     ...WU....~~.z==G
   1f3d4:	ac6464c8 e75d5dba 2b191932 957373e6     .dd..]].2..+.ss.
   1f3e4:	a06060c0 98818119 d14f4f9e 7fdcdca3     .``......OO.....
   1f3f4:	66222244 7e2a2a54 ab90903b 8388880b     D""fT**~;.......
   1f404:	ca46468c 29eeeec7 d3b8b86b 3c141428     .FF....)k...(..<
   1f414:	79dedea7 e25e5ebc 1d0b0b16 76dbdbad     ...y.^^........v
   1f424:	3be0e0db 56323264 4e3a3a74 1e0a0a14     ...;d22Vt::N....
   1f434:	db494992 0a06060c 6c242448 e45c5cb8     .II.....H$$l.\\.
   1f444:	5dc2c29f 6ed3d3bd efacac43 a66262c4     ...]...nC....bb.
   1f454:	a8919139 a4959531 37e4e4d3 8b7979f2     9...1......7.yy.
   1f464:	32e7e7d5 43c8c88b 5937376e b76d6dda     ...2...Cn77Y.mm.
   1f474:	8c8d8d01 64d5d5b1 d24e4e9c e0a9a949     .......d.NN.I...
   1f484:	b46c6cd8 fa5656ac 07f4f4f3 25eaeacf     .ll..VV........%
   1f494:	af6565ca 8e7a7af4 e9aeae47 18080810     .ee..zz.G.......
   1f4a4:	d5baba6f 887878f0 6f25254a 722e2e5c     o....xx.J%%o\..r
   1f4b4:	241c1c38 f1a6a657 c7b4b473 51c6c697     8..$W...s......Q
   1f4c4:	23e8e8cb 7cdddda1 9c7474e8 211f1f3e     ...#...|.tt.>..!
   1f4d4:	dd4b4b96 dcbdbd61 868b8b0d 858a8a0f     .KK.a...........
   1f4e4:	907070e0 423e3e7c c4b5b571 aa6666cc     .pp.|>>Bq....ff.
   1f4f4:	d8484890 05030306 01f6f6f7 120e0e1c     .HH.............
   1f504:	a36161c2 5f35356a f95757ae d0b9b969     .aa.j55_.WW.i...
   1f514:	91868617 58c1c199 271d1d3a b99e9e27     .......X:..''...
   1f524:	38e1e1d9 13f8f8eb b398982b 33111122     ...8....+..."..3
   1f534:	bb6969d2 70d9d9a9 898e8e07 a7949433     .ii....p....3...
   1f544:	b69b9b2d 221e1e3c 92878715 20e9e9c9     -...<.."....... 
   1f554:	49cece87 ff5555aa 78282850 7adfdfa5     ...I.UU.P((x...z
   1f564:	8f8c8c03 f8a1a159 80898909 170d0d1a     ....Y...........
   1f574:	dabfbf65 31e6e6d7 c6424284 b86868d0     e......1.BB..hh.
   1f584:	c3414182 b0999929 772d2d5a 110f0f1e     .AA.)...Z--w....
   1f594:	cbb0b07b fc5454a8 d6bbbb6d 3a16162c     {....TT.m...,..:

0001f5a4 <__func__.12099>:
   1f5a4:	415f4a41 435f5345 315f4342 455f3832     AJ_AES_CBC_128_E
   1f5b4:	5952434e 00005450                       NCRYPT..

0001f5bc <sbox>:
   1f5bc:	7b777c63 c56f6bf2 2b670130 76abd7fe     c|w{.ko.0.g+...v
   1f5cc:	7dc982ca f04759fa afa2d4ad c072a49c     ...}.YG.......r.
   1f5dc:	2693fdb7 ccf73f36 f1e5a534 1531d871     ...&6?..4...q.1.
   1f5ec:	c323c704 9a059618 e2801207 75b227eb     ..#..........'.u
   1f5fc:	1a2c8309 a05a6e1b b3d63b52 842fe329     ..,..nZ.R;..)./.
   1f60c:	ed00d153 5bb1fc20 39becb6a cf584c4a     S... ..[j..9JLX.
   1f61c:	fbaaefd0 85334d43 7f02f945 a89f3c50     ....CM3.E...P<..
   1f62c:	8f40a351 f5389d92 21dab6bc d2f3ff10     Q.@...8....!....
   1f63c:	ec130ccd 1744975f 3d7ea7c4 73195d64     ...._.D...~=d].s
   1f64c:	dc4f8160 88902a22 14b8ee46 db0b5ede     `.O."*..F....^..
   1f65c:	0a3a32e0 5c240649 62acd3c2 79e49591     .2:.I.$\...b...y
   1f66c:	6d37c8e7 a94ed58d eaf4566c 08ae7a65     ..7m..N.lV..ez..
   1f67c:	2e2578ba c6b4a61c 1f74dde8 8a8bbd4b     .x%.......t.K...
   1f68c:	66b53e70 0ef60348 b9573561 9e1dc186     p>.fH...a5W.....
   1f69c:	1198f8e1 948ed969 e9871e9b df2855ce     ....i........U(.
   1f6ac:	0d89a18c 6842e6bf 0f2d9941 16bb54b0     ......BhA.-..T..
   1f6bc:	732f2e2e 612f6372 6f6a6c6c 742f6e79     ../src/alljoyn/t
   1f6cc:	206e6968 65726f63 6372732f 5f6a612f     hin core/src/aj_
   1f6dc:	635f7773 74707972 00632e6f 6e656c28     sw_crypto.c.(len
   1f6ec:	31202520 3d202936 0030203d               % 16) == 0.

0001f6f8 <Rconst>:
   1f6f8:	00000001 00000002 00000004 00000008     ................
   1f708:	00000010 00000020 00000040 00000080     .... ...@.......
   1f718:	0000001b 00000036 0000006c 000000d8     ....6...l.......

0001f728 <nibble_lower.5493>:
   1f728:	33323130 37363534 62613938 66656463     0123456789abcdef
   1f738:	00000000                                ....

0001f73c <nibble_upper.5492>:
   1f73c:	33323130 37363534 42413938 46454443     0123456789ABCDEF
   1f74c:	00000000 00006425 252e7525 75252e75     ....%d..%u.%u.%u
   1f75c:	0075252e                                .%u.

0001f760 <VERSION.5469>:
   1f760:	302e3531 30302e34 61542062 76222067     15.04.00b Tag "v
   1f770:	302e3531 30302e34 00002262 646e6148     15.04.00b"..Hand
   1f780:	676e696c 74654720 666e6f43 72756769     ling GetConfigur
   1f790:	6f697461 7220736e 65757165 00007473     ations request..
   1f7a0:	46434a41 65475f47 6e6f4374 75676966     AJCFG_GetConfigu
   1f7b0:	69746172 48736e6f 6c646e61 29287265     rationsHandler()
   1f7c0:	4a41203a 6d6e555f 68737261 72416c61     : AJ_UnmarshalAr
   1f7d0:	73207367 75746174 203d2073 000a7325     gs status = %s..
   1f7e0:	46434a41 65475f47 6e6f4374 75676966     AJCFG_GetConfigu
   1f7f0:	69746172 48736e6f 6c646e61 29287265     rationsHandler()
   1f800:	4a41203a 72614d5f 6c616873 6c706552     : AJ_MarshalRepl
   1f810:	67734d79 61747320 20737574 7325203d     yMsg status = %s
   1f820:	0000000a 46434a41 65475f47 6e6f4374     ....AJCFG_GetCon
   1f830:	75676966 69746172 48736e6f 6c646e61     figurationsHandl
   1f840:	29287265 4a41203a 5f435653 706f7250     er(): AJSVC_Prop
   1f850:	79747265 726f7453 65525f65 6c416461     ertyStore_ReadAl
   1f860:	7473206c 73757461 25203d20 00000a73     l status = %s...
   1f870:	46434a41 65475f47 6e6f4374 75676966     AJCFG_GetConfigu
   1f880:	69746172 48736e6f 6c646e61 29287265     rationsHandler()
   1f890:	4a41203a 6c65445f 72657669 2067734d     : AJ_DeliverMsg 
   1f8a0:	74617473 3d207375 0a732520 00000000     status = %s.....
   1f8b0:	2a2a2a2a 2a2a2a2a 2a2a2a2a 464e4f43     ************CONF
   1f8c0:	475f4749 435f5445 49464e4f 4f435f47     IG_GET_CONFIG_CO
   1f8d0:	4749464e 54415255 534e4f49 2a2a2a2a     NFIGURATIONS****
   1f8e0:	2a2a2a2a 0000002a 6e6f432f 00676966     *****.../Config.
   1f8f0:	67726f24 6c6c612e 6e796f6a 6e6f432e     $org.alljoyn.Con
   1f900:	00676966 6361463f 79726f74 65736552     fig.?FactoryRese
   1f910:	00000074 7365523f 74726174 00000000     t...?Restart....
   1f920:	7465473f 666e6f43 72756769 6f697461     ?GetConfiguratio
   1f930:	3c20736e 613e2073 7d76737b 00000000     ns <s >a{sv}....
   1f940:	6470553f 43657461 69666e6f 61727567     ?UpdateConfigura
   1f950:	6e6f6974 733c2073 7b613c20 007d7673     tions <s <a{sv}.
   1f960:	7365523f 6f437465 6769666e 74617275     ?ResetConfigurat
   1f970:	736e6f69 20733c20 0073613c 7465533f     ions <s <as.?Set
   1f980:	73736150 65646f63 20733c20 0079613c     Passcode <s <ay.

0001f990 <AJSVC_ConfigInterfaces>:
   1f990:	0001e8d4 0001f99c 00000000              ............

0001f99c <AJSVC_ConfigInterface>:
   1f99c:	0001f8f0 0001ebf4 0001f904 0001f914     ................
   1f9ac:	0001f920 0001f940 0001f960 0001f97c      ...@...`...|...
   1f9bc:	00000000                                ....

0001f9c0 <AJNS_NotificationVersion>:
   1f9c0:	03f20002                                         ..

0001f9c2 <AJNS_NotificationProducerPort>:
   1f9c2:	692f03f2                                         ..

0001f9c4 <AJNS_NotificationObjectPathInfo>:
   1f9c4:	666e692f 0000006f                       /info...

0001f9cc <AJNS_NotificationSignalName>:
   1f9cc:	6f6e2621 79666974 20713e20 3e20693e     !&notify >q >i >
   1f9dc:	733e2071 20733e20 2079613e 3e20733e     q >s >s >ay >s >
   1f9ec:	76697b61 613e207d 7d73737b 28613e20     a{iv} >a{ss} >a(
   1f9fc:	00297373                                ss).

0001fa00 <AJNS_NotificationDismisserVersion>:
   1fa00:	00000001                                ....

0001fa04 <AJNS_NotificationObjectPathEmergency>:
   1fa04:	656d652f 6e656772 00007963              /emergency..

0001fa10 <AJNS_NotificationProducerObjectPath>:
   1fa10:	746f6e2f 63696669 6f697461 6f72506e     /notificationPro
   1fa20:	65637564 00000072                       ducer...

0001fa28 <AJNS_NotificationDismisserInterfaces>:
   1fa28:	0001e8d4 0001fb58 00000000 732f2e2e     ....X........./s
   1fa38:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1fa48:	65726f63 6372732f 746f4e2f 63696669     core/src/Notific
   1fa58:	6f697461 6d6f436e 2e6e6f6d 00000063     ationCommon.c...
   1fa68:	49707041 61632064 6f6e206e 65622074     AppId can not be
   1fa78:	4c554e20 0000004c 252f7325 64252f73      NULL...%s/%s/%d
   1fa88:	00000000 6c756f43 6f6e2064 614d2074     ....Could not Ma
   1fa98:	61687372 6953206c 6c616e67 00000000     rshal Signal....
   1faa8:	6c756f43 6f6e2064 65442074 6576696c     Could not Delive
   1fab8:	654d2072 67617373 00000065 2e67726f     r Message...org.
   1fac8:	6a6c6c61 2e6e796f 69746f4e 61636966     alljoyn.Notifica
   1fad8:	6e6f6974 6f72502e 65637564 00000072     tion.Producer...
   1fae8:	7369443f 7373696d 00693c20 2e67726f     ?Dismiss <i.org.
   1faf8:	6a6c6c61 2e6e796f 69746f4e 61636966     alljoyn.Notifica
   1fb08:	6e6f6974 7369442e 7373696d 00007265     tion.Dismisser..
   1fb18:	69442621 73696d73 693e2073 79613e20     !&Dismiss >i >ay
   1fb28:	00000000                                ....

0001fb2c <AJNS_NotificationInterfaces>:
   1fb2c:	0001e8d4 20000250 00000000              ....P.. ....

0001fb38 <AJNS_NOTIFICATION_TTL_MIN>:
   1fb38:	a8c0001e                                         ..

0001fb3a <AJNS_NOTIFICATION_TTL_MAX>:
   1fb3a:	772fa8c0                                         ..

0001fb3c <AJNS_NotificationObjectPathWarning>:
   1fb3c:	7261772f 676e696e 00000000              /warning....

0001fb48 <AJNS_NotificationProducerInterface>:
   1fb48:	0001fac4 0001fae8 0001ebf4 00000000     ................

0001fb58 <AJNS_NotificationDismisserInterface>:
   1fb58:	0001faf4 0001fb18 0001ebf4 00000000     ................

0001fb68 <AJNS_NotificationPropertyVersion>:
   1fb68:	72655640 6e6f6973 0000713e              @Version>q..

0001fb74 <AJNS_NotificationProducerInterfaces>:
   1fb74:	0001e8d4 0001fb48 0001fb58 00000000     ....H...X.......

0001fb84 <AJNS_NotificationInterfaceName>:
   1fb84:	2e67726f 6a6c6c61 2e6e796f 69746f4e     org.alljoyn.Noti
   1fb94:	61636966 6e6f6974 00000000 732f2e2e     fication....../s
   1fba4:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1fbb4:	65726f63 6372732f 746f4e2f 63696669     core/src/Notific
   1fbc4:	6f697461 6f72506e 65637564 00632e72     ationProducer.c.
   1fbd4:	6c756f43 6f6e2064 65532074 4e20646e     Could not Send N
   1fbe4:	6669746f 74616369 206e6f69 654d202d     otification - Me
   1fbf4:	67617373 70795465 73692065 746f6e20     ssageType is not
   1fc04:	6c617620 00006469 204c5454 27752527      valid..TTL '%u'
   1fc14:	20736920 20746f6e 61762061 2064696c      is not a valid 
   1fc24:	204c5454 756c6176 00000a65 69766544     TTL value...Devi
   1fc34:	64496563 7665442f 4e656369 2f656d61     ceId/DeviceName/
   1fc44:	49707041 70412f64 6d614e70 61632065     AppId/AppName ca
   1fc54:	6f6e206e 65622074 4c554e20 0000004c     n not be NULL...
   1fc64:	69766544 64496563 7665442f 4e656369     DeviceId/DeviceN
   1fc74:	2f656d61 49707041 70412f64 6d614e70     ame/AppId/AppNam
   1fc84:	61632065 6f6e206e 65622074 706d6520     e can not be emp
   1fc94:	00007974 6769724f 6c616e69 646e6553     ty..OriginalSend
   1fca4:	63207265 6e206e61 6220746f 554e2065     er can not be NU
   1fcb4:	00004c4c 6769724f 6c616e69 646e6553     LL..OriginalSend
   1fcc4:	63207265 6e206e61 6220746f 6d652065     er can not be em
   1fcd4:	00797470 73732861 00000029 68636952     pty.a(ss)...Rich
   1fce4:	64754120 4c206f69 75676e61 2f656761      Audio Language/
   1fcf4:	206c7255 206e6163 20746f6e 65206562     Url can not be e
   1fd04:	7974706d 00000000 676e614c 65676175     mpty....Language
   1fd14:	7865542f 61632074 6f6e206e 65622074     /Text can not be
   1fd24:	706d6520 00007974 7372614d 4e6c6168      empty..MarshalN
   1fd34:	6669746f 74616369 206e6f69 6c696166     otification fail
   1fd44:	203a6465 27732527 0000000a 6c756f43     ed: '%s'....Coul
   1fd54:	6f6e2064 65642074 6574656c 746f4e20     d not delete Not
   1fd64:	63696669 6f697461 202d206e 7373654d     ification - Mess
   1fd74:	54656761 20657079 6e207369 7620746f     ageType is not v
   1fd84:	64696c61 00000000 6c756f43 6f6e2064     alid....Could no
   1fd94:	65442074 6574656c 73654d20 65676173     t Delete Message
   1fda4:	6e202d20 656d206f 67617373 6f742065      - no message to
   1fdb4:	6c656420 00657465 6c756f43 6f6e2064      delete.Could no
   1fdc4:	65442074 6574656c 73654d20 65676173     t Delete Message
   1fdd4:	00000000 6c756f43 6f6e2064 61632074     ....Could not ca
   1fde4:	6c65636e 73654d20 65676173 6e202d20     ncel Message - n
   1fdf4:	656d206f 67617373 6f742065 6e616320     o message to can
   1fe04:	006c6563 6c756f43 6f6e2064 69662074     cel.Could not fi
   1fe14:	6d20646e 68637461 20676e69 7373654d     nd matching Mess
   1fe24:	20656761 69726573 6e206c61 65626d75     age serial numbe
   1fe34:	202d2072 6d206f6e 61737365 74206567     r - no message t
   1fe44:	6163206f 6c65636e 00000000 6c696146     o cancel....Fail
   1fe54:	74206465 6573206f 6320646e 65636e61     ed to send cance
   1fe64:	6974616c 00006e6f 6c756f43 6f6e2064     lation..Could no
   1fe74:	6e752074 7372616d 206c6168 7373656d     t unmarshal mess
   1fe84:	00656761 6c696146 74206465 6573206f     age.Failed to se
   1fe94:	6220646e 20646e69 73736573 206e6f69     nd bind session 
   1fea4:	74726f70 73656d20 65676173 00000000     port message....
   1feb4:	4a6c6c41 206e796f 63736964 656e6e6f     AllJoyn disconne
   1fec4:	62207463 73207375 75746174 64253d73     ct bus status=%d
   1fed4:	0000000a 6c696146 74206465 6573206f     ....Failed to se
   1fee4:	7520646e 6e69626e 65732064 6f697373     nd unbind sessio
   1fef4:	6f70206e 253d7472 00000a64 732f2e2e     n port=%d...../s
   1ff04:	612f6372 6f6a6c6c 742f6e79 206e6968     rc/alljoyn/thin 
   1ff14:	65726f63 6372732f 7265532f 65636976     core/src/Service
   1ff24:	6d6f4373 2e6e6f6d 00000063 616d6e55     sCommon.c...Unma
   1ff34:	61687372 7070416c 203a6449 75736e49     rshalAppId: Insu
   1ff44:	63696666 746e6569 66756220 20726566     fficient buffer 
   1ff54:	657a6973 68532021 646c756f 20656220     size! Should be 
   1ff64:	6c207461 74736165 20752520 20747562     at least %u but 
   1ff74:	20746f67 000a7525 732f2e2e 612f6372     got %u..../src/a
   1ff84:	6f6a6c6c 742f6e79 206e6968 65726f63     lljoyn/thin core
   1ff94:	6372732f 7265532f 65636976 6e614873     /src/ServicesHan
   1ffa4:	72656c64 00632e73 6c696146 61206465     dlers.c.Failed a
   1ffb4:	6d657474 74207470 6f63206f 63656e6e     ttempt to connec
   1ffc4:	6f742074 73756220 6c73202c 69706565     t to bus, sleepi
   1ffd4:	6620676e 2520726f 65732064 646e6f63     ng for %d second
   1ffe4:	00000a73 21212121 74617453 203d7375     s...!!!!Status= 
   1fff4:	21217325 0a212121 00000000 6c696146     %s!!!!!.....Fail
   20004:	74206465 6547206f 696e5574 4e657571     ed to GetUniqueN
   20014:	28656d61 72662029 6e206d6f 796c7765     ame() from newly
   20024:	6e6f6320 7463656e 62206465 202c7375      connected bus, 
   20034:	72746572 676e6979 00000000 76726553     retrying....Serv
   20044:	20656369 6e6e6f43 65746365 6e614864     ice ConnectedHan
   20054:	72656c64 74657220 656e7275 6e612064     dler returned an
   20064:	72726520 2520726f 00000a73 6e696f4a      error %s...Join
   20074:	73736553 526e6f69 796c7065 4a41203a     SessionReply: AJ
   20084:	54454d5f 5f444f48 4e494f4a 5345535f     _METHOD_JOIN_SES
   20094:	4e4f4953 4a41203a 5252455f 4941465f     SION: AJ_ERR_FAI
   200a4:	4552554c 00000000 00007575 6e696f4a     LURE....uu..Join
   200b4:	73736553 526e6f69 796c7065 6166203a     SessionReply: fa
   200c4:	64656c69 206f7420 616d6e75 61687372     iled to unmarsha
   200d4:	0000006c 6e696f4a 73736553 526e6f69     l...JoinSessionR
   200e4:	796c7065 4a41203a 5252455f 4941465f     eply: AJ_ERR_FAI
   200f4:	4552554c 00000000 6e696f4a 73736553     LURE....JoinSess
   20104:	526e6f69 796c7065 6166203a 64656c69     ionReply: failed
   20114:	206f7420 7372616d 006c6168 4a6c6c41      to marshal.AllJ
   20124:	206e796f 63736964 656e6e6f 00007463     oyn disconnect..

00020134 <__func__.5448>:
   20134:	32414853 555f3635 74616470 00000065     SHA256_Update...

00020144 <__func__.5458>:
   20144:	32414853 465f3635 6c616e69 00000000     SHA256_Final....

00020154 <sha256_initial_hash_value>:
   20154:	6a09e667 bb67ae85 3c6ef372 a54ff53a     g..j..g.r.n<:.O.
   20164:	510e527f 9b05688c 1f83d9ab 5be0cd19     .R.Q.h.........[
   20174:	732f2e2e 612f6372 6f6a6c6c 742f6e79     ../src/alljoyn/t
   20184:	206e6968 65726f63 6372732f 6168732f     hin core/src/sha
   20194:	00632e32 746e6f63 20747865 28203d21     2.c.context != (
   201a4:	32414853 435f3635 292a5854 26262030     SHA256_CTX*)0 &&
   201b4:	74616420 3d212061 68732820 625f3261      data != (sha2_b
   201c4:	2a657479 00003029 746e6f63 20747865     yte*)0..context 
   201d4:	28203d21 32414853 435f3635 292a5854     != (SHA256_CTX*)
   201e4:	00000030 33323130 37363534 62613938     0...0123456789ab
   201f4:	66656463 00000000 746e6f63 20747865     cdef....context 
   20204:	28203d21 35414853 435f3231 292a5854     != (SHA512_CTX*)
   20214:	26262030 74616420 3d212061 68732820     0 && data != (sh
   20224:	625f3261 2a657479 00003029 746e6f63     a2_byte*)0..cont
   20234:	20747865 28203d21 35414853 435f3231     ext != (SHA512_C
   20244:	292a5854 00000030 746e6f63 20747865     TX*)0...context 
   20254:	28203d21 33414853 435f3438 292a5854     != (SHA384_CTX*)
   20264:	00000030                                0...

00020268 <K256>:
   20268:	428a2f98 71374491 b5c0fbcf e9b5dba5     ./.B.D7q........
   20278:	3956c25b 59f111f1 923f82a4 ab1c5ed5     [.V9...Y..?..^..
   20288:	d807aa98 12835b01 243185be 550c7dc3     .....[....1$.}.U
   20298:	72be5d74 80deb1fe 9bdc06a7 c19bf174     t].r........t...
   202a8:	e49b69c1 efbe4786 0fc19dc6 240ca1cc     .i...G.........$
   202b8:	2de92c6f 4a7484aa 5cb0a9dc 76f988da     o,.-..tJ...\...v
   202c8:	983e5152 a831c66d b00327c8 bf597fc7     RQ>.m.1..'....Y.
   202d8:	c6e00bf3 d5a79147 06ca6351 14292967     ....G...Qc..g)).
   202e8:	27b70a85 2e1b2138 4d2c6dfc 53380d13     ...'8!...m,M..8S
   202f8:	650a7354 766a0abb 81c2c92e 92722c85     Ts.e..jv.....,r.
   20308:	a2bfe8a1 a81a664b c24b8b70 c76c51a3     ....Kf..p.K..Ql.
   20318:	d192e819 d6990624 f40e3585 106aa070     ....$....5..p.j.
   20328:	19a4c116 1e376c08 2748774c 34b0bcb5     .....l7.LwH'...4
   20338:	391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3     ...9J..NO..[.o.h
   20348:	748f82ee 78a5636f 84c87814 8cc70208     ...toc.x.x......
   20358:	90befffa a4506ceb bef9a3f7 c67178f2     .....lP......xq.
   20368:	42000800 42000c00 42001000 42001400     ...B...B...B...B
   20378:	42001800 42001c00 57202d2d 31434e49     ...B...B-- WINC1
   20388:	20303035 20504455 65696c63 6520746e     500 UDP client e
   20398:	706d6178 2d20656c 2d0a0d2d 4153202d     xample --..-- SA
   203a8:	3132444d 4c50585f 454e4941 52505f44     MD21_XPLAINED_PR
   203b8:	2d2d204f 2d2d0a0d 6d6f4320 656c6970     O --..-- Compile
   203c8:	46203a64 20206265 30322031 31203631     d: Feb  1 2016 1
   203d8:	31333a36 2037333a 000d2d2d 0c0b0a09     6:31:37 --......
   203e8:	00000e0d 50504128 52452829 255b2952     ....(APP)(ERR)[%
   203f8:	255b5d73 00005d64 61766e69 6564696c     s][%d]..invalide
   20408:	636f6920 6320746c 0000646d               ioclt cmd..

00020414 <__FUNCTION__.13024>:
   20414:	625f6d6e 695f7375 6c74636f 00000000     nm_bus_ioctl....

00020424 <__FUNCTION__.12356>:
   20424:	5f666968 00727369                       hif_isr.

0002042c <__FUNCTION__.12378>:
   2042c:	5f666968 65636572 00657669              hif_receive.

00020438 <__FUNCTION__.12391>:
   20438:	5f666968 69676572 72657473 0062635f     hif_register_cb.

00020448 <__FUNCTION__.12363>:
   20448:	5f666968 646e6168 695f656c 00007273     hif_handle_isr..
   20458:	46494828 69614629 6f74206c 6b617720     (HIF)Fail to wak
   20468:	74207075 63206568 00706968 66696828     up the chip.(hif
   20478:	49572029 485f4946 5f54534f 5f564352     ) WIFI_HOST_RCV_
   20488:	4c525443 6220305f 66207375 006c6961     CTRL_0 bus fail.
   20498:	66696828 49572029 485f4946 5f54534f     (hif) WIFI_HOST_
   204a8:	5f564352 4c525443 6220315f 66207375     RCV_CTRL_1 bus f
   204b8:	006c6961 66696828 64612029 73657264     ail.(hif) addres
   204c8:	75622073 61662073 00006c69 66696828     s bus fail..(hif
   204d8:	6f432029 70757272 20646574 6b636170     ) Corrupted pack
   204e8:	53207465 20657a69 7525203d 204c3c20     et Size = %u <L 
   204f8:	7525203d 2047202c 7525203d 504f202c     = %u, G = %u, OP
   20508:	25203d20 3e583230 0000000a 66696828      = %02X>....(hif
   20518:	6e692029 696c6176 72672064 2070756f     ) invalid group 
   20528:	00004449 66696828 6f682029 61207473     ID..(hif) host a
   20538:	64207070 276e6469 65732074 58522074     pp didn't set RX
   20548:	6e6f4420 00000065 66696828 72572029      Done...(hif) Wr
   20558:	20676e6f 657a6953 00000000 66696828     ong Size....(hif
   20568:	61462029 2065736c 65746e69 70757272     ) False interrup
   20578:	6c252074 00000078 66696828 61462029     t %lx...(hif) Fa
   20588:	74206c69 6552206f 69206461 7265746e     il to Read inter
   20598:	74707572 67657220 00000000 66696828     rupt reg....(hif
   205a8:	41462029 74204c49 6177206f 7075656b     ) FAIL to wakeup
   205b8:	65687420 69686320 00000070 46494828      the chip...(HIF
   205c8:	61462029 74206c69 6168206f 656c646e     ) Fail to handle
   205d8:	746e6920 75727265 25207470 72742064      interrupt %d tr
   205e8:	67412079 2e6e6961 00000a2e 66696820     y Again..... hif
   205f8:	6365725f 65766965 6e49203a 696c6176     _receive: Invali
   20608:	72612064 656d7567 0000746e 20505041     d argument..APP 
   20618:	75716552 65747365 69532064 6920657a     Requested Size i
   20628:	616c2073 72656772 61687420 6874206e     s larger than th
   20638:	65722065 65766963 75622064 72656666     e recived buffer
   20648:	7a697320 253c2065 253c3e64 000a3e64      size <%d><%d>..
   20658:	20505041 75716552 65747365 64412064     APP Requested Ad
   20668:	73657264 65622073 646e6f79 65687420     dress beyond the
   20678:	63657220 64657669 66756220 20726566      recived buffer 
   20688:	72646461 20737365 20646e61 676e656c     address and leng
   20698:	00006874 20705247 6425203f 0000000a     th..GRp ? %d....

000206a8 <__FUNCTION__.12347>:
   206a8:	5f666968 646e6573 00000000              hif_send....

000206b4 <__FUNCTION__.12315>:
   206b4:	5f6d326d 69666977 0062635f              m2m_wifi_cb.

000206c0 <__FUNCTION__.12364>:
   206c0:	5f6d326d 69666977 6e6f635f 7463656e     m2m_wifi_connect
   206d0:	0063735f 50504128 4e492829 00294f46     _sc.(APP)(INFO).
   206e0:	666e6f43 7463696c 49206465 20222050     Conflicted IP " 
   206f0:	252e7525 75252e75 2075252e 000a2022     %u.%u.%u.%u " ..
   20700:	20514552 20746f4e 69666564 2064656e     REQ Not defined 
   20710:	000a6425 41564e49 2044494c 4e494f50     %d..INVALID POIN
   20720:	00524554 41564e49 2044494c 44495353     TER.INVALID SSID
   20730:	00000000 41564e49 2044494c 00004843     ....INVALID CH..
   20740:	41564e49 2044494c 50434844 52455320     INVALID DHCP SER
   20750:	20524556 00005049 41564e49 2044494c     VER IP..INVALID 
   20760:	2059454b 45444e49 00000058 41564e49     KEY INDEX...INVA
   20770:	2044494c 2059454b 455a4953 00000000     LID KEY SIZE....
   20780:	41564e49 2044494c 20504557 0059454b     INVALID WEP KEY.
   20790:	41564e49 2044494c 48545541 49544e45     INVALID AUTHENTI
   207a0:	49544143 4d204e4f 0045444f 2079654b     CATION MODE.Key 
   207b0:	6e207369 7620746f 64696c61 00000000     is not valid....
   207c0:	44495353 4e454c20 564e4920 44494c41     SSID LEN INVALID
   207d0:	00000000 49204843 4c41564e 00004449     ....CH INVALID..
   207e0:	61766e49 2064696c 20706557 2079656b     Invalid Wep key 
   207f0:	65646e69 64252078 0000000a 61766e49     index %d....Inva
   20800:	2064696c 20706557 2079656b 676e656c     lid Wep key leng
   20810:	25206874 00000a64 6f636e49 63657272     th %d...Incorrec
   20820:	53502074 656b204b 656c2079 6874676e     t PSK key length
   20830:	00000000 65646e75 656e6966 65732064     ....undefined se
   20840:	79742063 00006570 41564e49 2044494c     c type..INVALID 
   20850:	6f206f4e 63732066 73206e61 73746f6c     No of scan slots
   20860:	00000021 41564e49 2044494c 6e616373     !...INVALID scan
   20870:	6f6c7320 69742074 0021656d 41564e49      slot time!.INVA
   20880:	2044494c 6f206f4e 72702066 2065626f     LID No of probe 
   20890:	75716572 73747365 72657020 61637320     requests per sca
   208a0:	6c73206e 0000746f 41564e49 2044494c     n slot..INVALID 
   208b0:	49535352 72687420 6f687365 2520646c     RSSI threshold %
   208c0:	000a2064 5f53505f 56524553 205f5245     d .._PS_SERVER_ 
   208d0:	6e207369 6420746f 6e696665 00006465     is not defined..
   208e0:	7473694c 63206e65 6e6e6168 73206c65     Listen channel s
   208f0:	6c756f68 6e6f2064 6220796c 2c312065     hould only be 1,
   20900:	6f203620 31312072 00000000 45574f50      6 or 11....POWE
   20910:	41532052 25204556 00000a64 41564e49     R SAVE %d...INVA
   20920:	2044494c 414d4f44 4e204e49 00454d41     LID DOMAIN NAME.

00020930 <__FUNCTION__.11724>:
   20930:	635f6d6e 656c6b6c 775f7373 00656b61     nm_clkless_wake.
   20940:	20737542 6f727265 31282072 57202e29     Bus error (1). W
   20950:	20656b61 66207075 656c6961 00000064     ake up failed...
   20960:	20737542 6f727265 32282072 57202e29     Bus error (2). W
   20970:	20656b61 66207075 656c6961 00000064     ake up failed...
   20980:	636f6c63 7320736b 6c6c6974 46464f20     clocks still OFF
   20990:	6157202e 7520656b 61662070 64656c69     . Wake up failed
   209a0:	00000000 696d6e5b 61747320 3a5d7472     ....[nmi start]:
   209b0:	69616620 6572206c 72206461 30206765      fail read reg 0
   209c0:	31313178 2e2e2038 0000002e 6c696166     x1118 ......fail
   209d0:	74206465 6564206f 696e692d 6c616974     ed to de-initial
   209e0:	00657a69 6f727245 68772072 20656c69     ize.Error while 
   209f0:	74697277 20676e69 00676572 6f727245     writing reg.Erro
   20a00:	68772072 20656c69 64616572 20676e69     r while reading 
   20a10:	00676572 6c75705b 5f70756c 6c727463     reg.[pullup_ctrl
   20a20:	66203a5d 656c6961 6f742064 61657220     ]: failed to rea
   20a30:	00000064 6c75705b 5f70756c 6c727463     d...[pullup_ctrl
   20a40:	66203a5d 656c6961 6f742064 69727720     ]: failed to wri
   20a50:	00006574                                te..

00020a54 <__FUNCTION__.11813>:
   20a54:	70696863 6965645f 0074696e              chip_deinit.

00020a60 <__FUNCTION__.12205>:
   20a60:	645f6d6e 695f7672 0074696e              nm_drv_init.

00020a6c <__FUNCTION__.12212>:
   20a6c:	645f6d6e 645f7672 696e6965 00000074     nm_drv_deinit...
   20a7c:	696d6e5b 61747320 3a5d7472 69616620     [nmi start]: fai
   20a8c:	6e69206c 62207469 00007375 70696843     l init bus..Chip
   20a9c:	20444920 0a786c25 00000000 6c696166      ID %lx.....fail
   20aac:	74206465 6e65206f 656c6261 746e6920     ed to enable int
   20abc:	75727265 2e737470 0000002e 6d726946     errupts.....Firm
   20acc:	65726177 72657620 3a202020 2e752520     ware ver   : %u.
   20adc:	252e7525 00000a75 206e694d 76697264     %u.%u...Min driv
   20aec:	76207265 3a207265 2e752520 252e7525     er ver : %u.%u.%
   20afc:	00000a75 72727543 69726420 20726576     u...Curr driver 
   20b0c:	3a726576 2e752520 252e7525 00000a75     ver: %u.%u.%u...
   20b1c:	6d726946 65726177 72657620 6e6f6973     Firmware version
   20b2c:	73696d20 6374616d 00002168 696d6e5b      mismatch!..[nmi
   20b3c:	6f747320 203a5d70 70696863 6965645f      stop]: chip_dei
   20b4c:	2074696e 6c696166 00000000 696d6e5b     nit fail....[nmi
   20b5c:	6f747320 203a5d70 6c696166 696e6920      stop]: fail ini
   20b6c:	75622074 00000073 0001219c 0001219c     t bus....!...!..
   20b7c:	000121cc 0001214e 00012172 00012180     .!..N!..r!...!..
   20b8c:	000121b2 000121b2 000121fa 0001213e     .!...!...!..>!..
   20b9c:	0001225c 0001225c 0001225c 0001225c     \"..\"..\"..\"..
   20bac:	0001218e                                .!..

00020bb0 <__FUNCTION__.11751>:
   20bb0:	5f697073 74697277 65725f65 00000067     spi_write_reg...

00020bc0 <__FUNCTION__.11702>:
   20bc0:	5f697073 00646d63                       spi_cmd.

00020bc8 <__FUNCTION__.11759>:
   20bc8:	735f6d6e 775f6970 65746972 00000000     nm_spi_write....

00020bd8 <__FUNCTION__.11710>:
   20bd8:	5f697073 5f646d63 00707372              spi_cmd_rsp.

00020be4 <__FUNCTION__.11768>:
   20be4:	5f697073 64616572 6765725f 00000000     spi_read_reg....

00020bf4 <__FUNCTION__.11776>:
   20bf4:	735f6d6e 725f6970 00646165 696d6e5b     nm_spi_read.[nmi
   20c04:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
   20c14:	65722064 6e6f7073 72206573 2c646165     d response read,
   20c24:	73756220 72726520 2e2e726f 0000002e      bus error......
   20c34:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   20c44:	61642064 72206174 6f707365 2065736e     d data response 
   20c54:	64616572 7562202c 72652073 2e726f72     read, bus error.
   20c64:	00002e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20c74:	656c6961 61642064 72206174 6f707365     ailed data respo
   20c84:	2065736e 64616572 282e2e2e 78323025     nse read...(%02x
   20c94:	00000a29 696d6e5b 69707320 46203a5d     )...[nmi spi]: F
   20ca4:	656c6961 61642064 62206174 6b636f6c     ailed data block
   20cb4:	61657220 62202c64 65207375 726f7272      read, bus error
   20cc4:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20cd4:	656c6961 61642064 62206174 6b636f6c     ailed data block
   20ce4:	63726320 61657220 62202c64 65207375      crc read, bus e
   20cf4:	726f7272 002e2e2e 696d6e5b 69707320     rror....[nmi spi
   20d04:	46203a5d 656c6961 6d632064 72772064     ]: Failed cmd wr
   20d14:	2c657469 73756220 72726520 2e2e726f     ite, bus error..
   20d24:	0000002e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20d34:	656c6961 6d632064 77202c64 65746972     ailed cmd, write
   20d44:	67657220 30252820 2e297838 000a2e2e      reg (%08x).....
   20d54:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   20d64:	6d632064 65722064 6e6f7073 202c6573     d cmd response, 
   20d74:	74697277 65722065 25282067 29783830     write reg (%08x)
   20d84:	0a2e2e2e 00000000 696d6e5b 69707320     ........[nmi spi
   20d94:	46203a5d 656c6961 6d632064 72202c64     ]: Failed cmd, r
   20da4:	20646165 20676572 38302528 2e2e2978     ead reg (%08x)..
   20db4:	00000a2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20dc4:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
   20dd4:	202c6573 64616572 67657220 30252820     se, read reg (%0
   20de4:	2e297838 000a2e2e 696d6e5b 69707320     8x).....[nmi spi
   20df4:	46203a5d 656c6961 61642064 72206174     ]: Failed data r
   20e04:	2e646165 00002e2e 696d6e5b 69707320     ead.....[nmi spi
   20e14:	46203a5d 656c6961 6e692064 6e726574     ]: Failed intern
   20e24:	72206c61 20646165 746f7270 6c6f636f     al read protocol
   20e34:	74697720 52432068 6e6f2043 6572202c      with CRC on, re
   20e44:	69727974 7720676e 20687469 20435243     tyring with CRC 
   20e54:	2e66666f 00002e2e 696d6e5b 69707320     off.....[nmi spi
   20e64:	46203a5d 656c6961 6e692064 6e726574     ]: Failed intern
   20e74:	72206c61 20646165 746f7270 6c6f636f     al read protocol
   20e84:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20e94:	656c6961 6e692064 6e726574 77206c61     ailed internal w
   20ea4:	65746972 6f727020 6f636f74 6572206c     rite protocol re
   20eb4:	2e2e2e67 00000000 696d6e5b 69707320     g.......[nmi spi
   20ec4:	46203a5d 206c6961 20646d63 64616572     ]: Fail cmd read
   20ed4:	69686320 64692070 002e2e2e 696d6e5b      chip id....[nmi
   20ee4:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
   20ef4:	72202c64 20646165 636f6c62 2528206b     d, read block (%
   20f04:	29783830 0a2e2e2e 00000000 696d6e5b     08x)........[nmi
   20f14:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
   20f24:	65722064 6e6f7073 202c6573 64616572     d response, read
   20f34:	6f6c6220 28206b63 78383025 2e2e2e29      block (%08x)...
   20f44:	0000000a 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20f54:	656c6961 6c622064 206b636f 61746164     ailed block data
   20f64:	61657220 2e2e2e64 00000000 696d6e5b      read.......[nmi
   20f74:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
   20f84:	77202c64 65746972 6f6c6220 28206b63     d, write block (
   20f94:	78383025 2e2e2e29 0000000a 696d6e5b     %08x).......[nmi
   20fa4:	69707320 203a5d20 6c696146 63206465      spi ]: Failed c
   20fb4:	7220646d 6f707365 2c65736e 69727720     md response, wri
   20fc4:	62206574 6b636f6c 30252820 2e297838     te block (%08x).
   20fd4:	000a2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   20fe4:	656c6961 61642064 62206174 6b636f6c     ailed data block
   20ff4:	646d6320 69727720 202c6574 20737562      cmd write, bus 
   21004:	6f727265 2e2e2e72 00000000 696d6e5b     error.......[nmi
   21014:	69707320 46203a5d 656c6961 61642064      spi]: Failed da
   21024:	62206174 6b636f6c 69727720 202c6574     ta block write, 
   21034:	20737562 6f727265 2e2e2e72 00000000     bus error.......
   21044:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   21054:	61642064 62206174 6b636f6c 63726320     d data block crc
   21064:	69727720 202c6574 20737562 6f727265      write, bus erro
   21074:	2e2e2e72 00000000 696d6e5b 69707320     r.......[nmi spi
   21084:	46203a5d 656c6961 6c622064 206b636f     ]: Failed block 
   21094:	61746164 69727720 2e2e6574 0000002e     data write......

000210a4 <__FUNCTION__.11793>:
   210a4:	735f6d6e 695f6970 0074696e              nm_spi_init.

000210b0 <__FUNCTION__.11741>:
   210b0:	5f697073 61746164 6972775f 00006574     spi_data_write..

000210c0 <crc7_syndrome_table>:
   210c0:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   210d0:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   210e0:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   210f0:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   21100:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   21110:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   21120:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   21130:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   21140:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   21150:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   21160:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   21170:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   21180:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   21190:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   211a0:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   211b0:	151c070e 3138232a 5d544f46 79706b62     ....*#81FOT]bkpy

000211c0 <__FUNCTION__.11726>:
   211c0:	5f697073 61746164 6165725f 00000064     spi_data_read...
   211d0:	52524528 75432952 6e657272 253c2074     (ERRR)Current <%
   211e0:	000a3e64 20494e53 65637845 20736465     d>..SNI Exceeds 
   211f0:	2078614d 676e654c 00006874 6e6b6e55     Max Length..Unkn
   21200:	206e776f 204c5353 6b636f53 4f207465     own SSL Socket O
   21210:	6f697470 6425206e 0000000a 20746f4e     ption %d....Not 
   21220:	204c5353 6b636f53 00007465 000131de     SSL Socket...1..
   21230:	000131da 000131da 0001323a 0001323a     .1...1..:2..:2..
   21240:	000131f4 000131e4 000131fa 00013228     .1...1...1..(2..
   21250:	000134a8 00013488 00013488 00013514     .4...4...4...5..
   21260:	0001349a 000134b6 0001348c 000134c4     .4...4...4...4..
   21270:	00013504 74697845 20676e69 68746977     .5..Exiting with
   21280:	61747320 20737574 0a2e6425 00000000      status %d......
   21290:	00013e3a 00013e54 00013e6c 00013e84     :>..T>..l>...>..
   212a0:	00013e9c 0001413a 0001414c 00014158     .>..:A..LA..XA..
   212b0:	00014164 00014170 0105ff01 00000001     dA..pA..........

000212c0 <LSF_State_Interface>:
   212c0:	00021b8c 0002181c 00021828 00021880     ........(.......
   212d0:	000218f0 0002190c 00021918 00021920     ............ ...
   212e0:	00021930 00021940 00000000              0...@.......

000212ec <LSF_Interfaces>:
   212ec:	0001e8d4 00021ba8 00021b20 00021b34     ........ ...4...
   212fc:	000212c0 00000000                       ........

00021304 <__func__.15375>:
   21304:	504d414c 6e61485f 4d656c64 61737365     LAMP_HandleMessa
   21314:	00006567                                ge..

00021318 <__func__.15432>:
   21318:	6e69616d 00000000                       main....

00021320 <LSF_Details_Interface_Name>:
   21320:	2e67726f 736c6c61 2e6e6565 2e46534c     org.allseen.LSF.
   21330:	706d614c 61746544 00736c69 30303030     LampDetails.0000
   21340:	00003030 6b636f73 635f7465 62203a62     00..socket_cb: b
   21350:	20646e69 6f727265 000d2172 6b636f73     ind error!..sock
   21360:	635f7465 64752062 65722070 0d217663     et_cb udp recv!.
   21370:	00000000 70207872 656b6361 656c2074     ....rx packet le
   21380:	6874676e 6425203d 0000000a 6b636f73     ngth= %d....sock
   21390:	635f7465 63742062 6f632070 63656e6e     et_cb tcp connec
   213a0:	000d2174 6b636f73 635f7465 63742062     t!..socket_cb tc
   213b0:	65732070 0d21646e 00000000 2d2d2d2d     p send!.....----
   213c0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 7473702d     -------------pst
   213d0:	63655272 733e2d76 75423631 72656666     rRecv->s16Buffer
   213e0:	657a6953 6425203d 2d2d2d2d 2d2d2d2d     Size= %d--------
   213f0:	2d2d2d2d 2d2d2d2d 00000a2d 69666977     ---------...wifi
   21400:	3a62635f 4d324d20 4649575f 45525f49     _cb: M2M_WIFI_RE
   21410:	435f5053 535f4e4f 45544154 4148435f     SP_CON_STATE_CHA
   21420:	4445474e 4f43203a 43454e4e 0d444554     NGED: CONNECTED.
   21430:	00000000 69666977 3a62635f 4d324d20     ....wifi_cb: M2M
   21440:	4649575f 45525f49 435f5053 535f4e4f     _WIFI_RESP_CON_S
   21450:	45544154 4148435f 4445474e 4944203a     TATE_CHANGED: DI
   21460:	4e4f4353 5443454e 000d4445 644f4345     SCONNECTED..ECOd
   21470:	00006d69 35353434 33333636 00000000     im..44556633....
   21480:	69666977 3a62635f 4d324d20 4649575f     wifi_cb: M2M_WIF
   21490:	45525f49 48445f51 435f5043 20464e4f     I_REQ_DHCP_CONF 
   214a0:	5049203a 20736920 252e7525 75252e75     : IP is %u.%u.%u
   214b0:	0d75252e 0000000a 6e69616d 326d203a     .%u.....main: m2
   214c0:	69775f6d 695f6966 2074696e 6c6c6163     m_wifi_init call
   214d0:	72726520 2821726f 0d296425 0000000a      error!(%d).....
   214e0:	5f6d326d 69666977 6e6f635f 7463656e     m2m_wifi_connect
   214f0:	00000d21 6e69616d 6166203a 64656c69     !...main: failed
   21500:	206f7420 61657263 52206574 44552058      to create RX UD
   21510:	6c432050 746e6569 636f7320 2074656b     P Client socket 
   21520:	6f727265 000d2172 2d2d2d2d 21212121     error!..----!!!!
   21530:	4e4e4f43 49544345 5320474e 54524154     CONNECTING START
   21540:	21214445 2d2d2121 00002d2d 732f2e2e     ED!!!!----..../s
   21550:	6d2f6372 2e6e6961 00000063 203a7325     rc/main.c...%s: 
   21560:	4d5f4a41 4f485445 49425f44 535f444e     AJ_METHOD_BIND_S
   21570:	49535345 505f4e4f 3a54524f 5f4a4120     ESSION_PORT: AJ_
   21580:	5f525245 4c494146 0a455255 00000000     ERR_FAILURE.....
   21590:	203a7325 425f4a41 65527375 73657571     %s: AJ_BusReques
   215a0:	6d614e74 0a292865 00000000 203a7325     tName().....%s: 
   215b0:	74696e49 696c6169 676e697a 6f624120     Initializing Abo
   215c0:	0a217475 00000000 203a7325 20746f47     ut!.....%s: Got 
   215d0:	65636341 53207470 69737365 000a6e6f     Accept Session..
   215e0:	00737571 203a7325 65636341 64657470     qus.%s: Accepted
   215f0:	6c756d20 6f706974 20746e69 73736573      multipoint sess
   21600:	206e6f69 253d6469 72662075 6a206d6f     ion id=%u from j
   21610:	656e696f 73253d72 0000000a 203a7325     oiner=%s....%s: 
   21620:	65636341 64657470 73657320 6e6f6973     Accepted session
   21630:	3d646920 66207525 206d6f72 6e696f6a      id=%u from join
   21640:	253d7265 00000a73 203a7325 65636341     er=%s...%s: Acce
   21650:	64657470 6a657220 65746365 65732064     pted rejected se
   21660:	6f697373 64695f6e 2075253d 6e696f6a     ssion_id=%u join
   21670:	253d7265 00000a73 40404040 40404040     er=%s...@@@@@@@@
   21680:	40404040 25404040 47203a73 5320746f     @@@@@@@%s: Got S
   21690:	69737365 4a206e6f 656e696f 40404064     ession Joined@@@
   216a0:	40404040 40404040 0a404040 00000000     @@@@@@@@@@@.....
   216b0:	6b6e694c 6d697420 74756f65 74657320     Link timeout set
   216c0:	206f7420 000a6425 4c746553 546b6e69      to %d..SetLinkT
   216d0:	6f656d69 66207475 656c6961 64252064     imeout failed %d
   216e0:	0000000a 46434a41 654d5f47 67617373     ....AJCFG_Messag
   216f0:	6f725065 73736563 7320726f 75746174     eProcessor statu
   21700:	25203d73 00000a73 203a7325 65746e49     s= %s...%s: Inte
   21710:	63616672 73253d65 0000000a 706d614c     rface=%s....Lamp
   21720:	76726553 56656369 69737265 00006e6f     ServiceVersion..
   21730:	706d614c 6c756146 00007374 74757575     LampFaults..uuut
   21740:	00000000 5f46534c 4c554146 00005354     ....LSF_FAULTS..
   21750:	203a7325 646e6550 46676e69 6f746361     %s: PendingFacto
   21760:	65527972 52746573 65757165 3d207473     ryResetRequest =
   21770:	5254203d 000a4555 6e69616d 6166203a     = TRUE..main: fa
   21780:	64656c69 206f7420 61657263 54206574     iled to create T
   21790:	63205043 6e65696c 6f732074 74656b63     CP client socket
   217a0:	72726520 0d21726f 00000000 6b636f73      error!.....sock
   217b0:	6e5f7465 65626d75 656e2072 6f632077     et_number new co
   217c0:	63656e6e 6e6f6974 6425203a 00000a0d     nnection: %d....
   217d0:	20746572 756c6176 25203a65 000a0d64     ret value: %d...
   217e0:	6e69616d 7953203a 63695473 6f63206b     main: SysTick co
   217f0:	6769666e 74617275 206e6f69 6f727265     nfiguration erro
   21800:	00002172 67726f2f 6c6c612f 6e656573     r!../org/allseen
   21810:	46534c2f 6d614c2f 00000070 72655640     /LSF/Lamp...@Ver
   21820:	6e6f6973 0000753e 6172543f 7469736e     sion>u..?Transit
   21830:	4c6e6f69 53706d61 65746174 6d695420     ionLampState Tim
   21840:	61747365 743c706d 77654e20 74617453     estamp<t NewStat
   21850:	7b613c65 207d7673 6e617254 69746973     e<a{sv} Transiti
   21860:	65506e6f 646f6972 4c20753c 52706d61     onPeriod<u LampR
   21870:	6f707365 4365736e 3e65646f 00000075     esponseCode>u...
   21880:	7070413f 7550796c 4565736c 63656666     ?ApplyPulseEffec
   21890:	72462074 74536d6f 3c657461 76737b61     t FromState<a{sv
   218a0:	6f54207d 74617453 7b613c65 207d7673     } ToState<a{sv} 
   218b0:	69726570 753c646f 72756420 6f697461     period<u duratio
   218c0:	20753c6e 506d756e 65736c75 20753c73     n<u numPulses<u 
   218d0:	656d6974 6d617473 20743c70 706d614c     timestamp<t Lamp
   218e0:	70736552 65736e6f 65646f43 0000753e     ResponseCode>u..
   218f0:	6d614c21 61745370 68436574 65676e61     !LampStateChange
   21900:	614c2064 4449706d 0000733e 4f6e4f40     d LampID>s..@OnO
   21910:	623d6666 00000000 65754840 0000753d     ff=b....@Hue=u..
   21920:	74615340 74617275 3d6e6f69 00000075     @Saturation=u...
   21930:	6c6f4340 6554726f 753d706d 00000000     @ColorTemp=u....
   21940:	69724240 6e746867 3d737365 00000075     @Brightness=u...
   21950:	6b614d40 00753e65 646f4d40 753e6c65     @Make>u.@Model>u
   21960:	00000000 70795440 00753e65 6d614c40     ....@Type>u.@Lam
   21970:	70795470 00753e65 6d614c40 73614270     pType>u.@LampBas
   21980:	70795465 00753e65 6d614c40 61654270     eType>u.@LampBea
   21990:	676e416d 753e656c 00000000 6d694440     mAngle>u....@Dim
   219a0:	6c62616d 00623e65 6c6f4340 623e726f     mable>b.@Color>b
   219b0:	00000000 72615640 6c626169 6c6f4365     ....@VariableCol
   219c0:	6554726f 623e706d 00000000 73614840     orTemp>b....@Has
   219d0:	65666645 3e737463 00000062 6e694d40     Effects>b...@Min
   219e0:	746c6f56 3e656761 00000075 78614d40     Voltage>u...@Max
   219f0:	746c6f56 3e656761 00000075 74615740     Voltage>u...@Wat
   21a00:	65676174 0000753e 636e4940 65646e61     tage>u..@Incande
   21a10:	6e656373 75714574 6c617669 3e746e65     scentEquivalent>
   21a20:	00000075 78614d40 656d754c 753e736e     u...@MaxLumens>u
   21a30:	00000000 6e694d40 706d6554 74617265     ....@MinTemperat
   21a40:	3e657275 00000075 78614d40 706d6554     ure>u...@MaxTemp
   21a50:	74617265 3e657275 00000075 6c6f4340     erature>u...@Col
   21a60:	6552726f 7265646e 49676e69 7865646e     orRenderingIndex
   21a70:	0000753e 6d614c40 3e444970 00000073     >u..@LampID>s...
   21a80:	656e4540 5f796772 67617355 694d5f65     @Energy_Usage_Mi
   21a90:	77696c6c 73747461 0000753e 69724240     lliwatts>u..@Bri
   21aa0:	6e746867 5f737365 656d754c 753e736e     ghtness_Lumens>u
   21ab0:	00000000 6d614c40 72655370 65636976     ....@LampService
   21ac0:	73726556 3e6e6f69 00000075 656c433f     Version>u...?Cle
   21ad0:	614c7261 6146706d 20746c75 706d614c     arLampFault Lamp
   21ae0:	6c756146 646f4374 20753c65 706d614c     FaultCode<u Lamp
   21af0:	70736552 65736e6f 65646f43 4c20753e     ResponseCode>u L
   21b00:	46706d61 746c7561 65646f43 0000753e     ampFaultCode>u..
   21b10:	6d614c40 75614670 3e73746c 00007561     @LampFaults>au..

00021b20 <LSF_Parameters_Interface>:
   21b20:	00021bdc 0002181c 00021a80 00021a9c     ................
   21b30:	00000000                                ....

00021b34 <LSF_Details_Interface>:
   21b34:	00021320 0002181c 00021950 00021958      .......P...X...
   21b44:	00021964 0002196c 00021978 00021988     d...l...x.......
   21b54:	0002199c 000219a8 000219b4 000219cc     ................
   21b64:	000219dc 000219ec 000219fc 00021a08     ................
   21b74:	00021a24 00021a34 00021a48 00021a5c     $...4...H...\...
   21b84:	00021a74 00000000                       t.......

00021b8c <LSF_State_Interface_Name>:
   21b8c:	2e67726f 736c6c61 2e6e6565 2e46534c     org.allseen.LSF.
   21b9c:	706d614c 74617453 00000065              LampState...

00021ba8 <LSF_Interface>:
   21ba8:	00021bc0 0002181c 00021ab4 00021acc     ................
   21bb8:	00021b10 00000000                       ........

00021bc0 <LSF_Interface_Name>:
   21bc0:	2e67726f 736c6c61 2e6e6565 2e46534c     org.allseen.LSF.
   21bd0:	706d614c 76726553 00656369              LampService.

00021bdc <LSF_Parameters_Interface_Name>:
   21bdc:	2e67726f 736c6c61 2e6e6565 2e46534c     org.allseen.LSF.
   21bec:	706d614c 61726150 6574656d 00007372     LampParameters..

00021bfc <__func__.15339>:
   21bfc:	41746547 72506c6c 0073706f 00015a18     GetAllProps..Z..
   21c0c:	00015906 000159ec 000158f2 000159ec     .Y...Y...X...Y..
   21c1c:	000159f6 000159ec 000158f2 00015906     .Y...Y...X...Y..
   21c2c:	00015906 000159f6 000158f2 000158fc     .Y...Y...X...X..
   21c3c:	000158fc 000158fc 00015c5e 00016078     .X...X..^\..x`..
   21c4c:	00016056 00016056 0001604a 00015f3e     V`..V`..J`..>_..
   21c5c:	00015f3e 0001603e 0001604a 00015f3e     >_..>`..J`..>_..
   21c6c:	0001603e 00015f3e 0001604a 00015f42     >`..>_..J`..B_..
   21c7c:	00015f42 00015f42 00016258 7566202c     B_..B_..Xb.., fu
   21c8c:	6974636e 203a6e6f 73736100 69747265     nction: .asserti
   21c9c:	22206e6f 20227325 6c696166 203a6465     on "%s" failed: 
   21cac:	656c6966 73252220 6c202c22 20656e69     file "%s", line 
   21cbc:	73256425 000a7325 00000043              %d%s%s..C...

00021cc8 <_global_impure_ptr>:
   21cc8:	20000294 2b302d23 6c680020 6665004c     ... #-0+ .hlL.ef
   21cd8:	47464567 32313000 36353433 41393837     gEFG.0123456789A
   21ce8:	45444342 31300046 35343332 39383736     BCDEF.0123456789
   21cf8:	64636261 00006665                       abcdef..

00021d00 <_DAYS_BEFORE_MONTH>:
   21d00:	00000000 0000001f 0000003b 0000005a     ........;...Z...
   21d10:	00000078 00000097 000000b5 000000d4     x...............
   21d20:	000000f3 00000111 00000130 0000014e     ........0...N...
   21d30:	252f6d25 79252f64 3a482500 25004d25     %m/%d/%y.%H:%M.%
   21d40:	4d253a48 0053253a 545f434c 00454d49     H:%M:%S.LC_TIME.
   21d50:	006e614a 00626546 0072614d 00727041     Jan.Feb.Mar.Apr.
   21d60:	0079614d 006e754a 006c754a 00677541     May.Jun.Jul.Aug.
   21d70:	00706553 0074634f 00766f4e 00636544     Sep.Oct.Nov.Dec.
   21d80:	756e614a 00797261 72626546 79726175     January.February
   21d90:	72614d00 41006863 6c697270 6e754a00     .March.April.Jun
   21da0:	754a0065 4100796c 73756775 65530074     e.July.August.Se
   21db0:	6d657470 00726562 6f74634f 00726562     ptember.October.
   21dc0:	65766f4e 7265626d 63654400 65626d65     November.Decembe
   21dd0:	75530072 6f4d006e 7554006e 65570065     r.Sun.Mon.Tue.We
   21de0:	68540064 72460075 61530069 75530074     d.Thu.Fri.Sat.Su
   21df0:	7961646e 6e6f4d00 00796164 73657554     nday.Monday.Tues
   21e00:	00796164 6e646557 61647365 68540079     day.Wednesday.Th
   21e10:	64737275 46007961 61646972 61530079     ursday.Friday.Sa
   21e20:	64727574 25007961 62252061 20652520     turday.%a %b %e 
   21e30:	253a4825 53253a4d 00592520 50004d41     %H:%M:%S %Y.AM.P
   21e40:	6125004d 20622520 25206525 4d253a48     M.%a %b %e %H:%M
   21e50:	2053253a 25205a25 646d0059 3a492500     :%S %Z %Y.md.%I:
   21e60:	253a4d25 70252053 00000000              %M:%S %p....

00021e6c <_C_time_locale>:
   21e6c:	00021d50 00021d54 00021d58 00021d5c     P...T...X...\...
   21e7c:	00021d60 00021d64 00021d68 00021d6c     `...d...h...l...
   21e8c:	00021d70 00021d74 00021d78 00021d7c     p...t...x...|...
   21e9c:	00021d80 00021d88 00021d91 00021d97     ................
   21eac:	00021d60 00021d9d 00021da2 00021da7     `...............
   21ebc:	00021dae 00021db8 00021dc0 00021dc9     ................
   21ecc:	00021dd2 00021dd6 00021dda 00021dde     ................
   21edc:	00021de2 00021de6 00021dea 00021dee     ................
   21eec:	00021df5 00021dfc 00021e04 00021e0e     ................
   21efc:	00021e17 00021e1e 00021d3f 00021d30     ........?...0...
   21f0c:	00021e27 00021e3c 00021e3f 00021e42     '...<...?...B...
   21f1c:	00021d80 00021d88 00021d91 00021d97     ................
   21f2c:	00021d60 00021d9d 00021da2 00021da7     `...............
   21f3c:	00021dae 00021db8 00021dc0 00021dc9     ................
   21f4c:	00021e5a 00021e5d 00021cc3 00021cc3     Z...]...........
   21f5c:	00021cc3 00021cc3 00021cc3              ............

00021f68 <_ctype_>:
   21f68:	20202000 20202020 28282020 20282828     .         ((((( 
   21f78:	20202020 20202020 20202020 20202020                     
   21f88:	10108820 10101010 10101010 10101010      ...............
   21f98:	04040410 04040404 10040404 10101010     ................
   21fa8:	41411010 41414141 01010101 01010101     ..AAAAAA........
   21fb8:	01010101 01010101 01010101 10101010     ................
   21fc8:	42421010 42424242 02020202 02020202     ..BBBBBB........
   21fd8:	02020202 02020202 02020202 10101010     ................
   21fe8:	00000020 00000000 00000000 00000000      ...............
	...

0002206c <__sf_fake_stdin>:
	...

0002208c <__sf_fake_stdout>:
	...

000220ac <__sf_fake_stderr>:
	...

000220cc <_init>:
   220cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   220ce:	46c0      	nop			; (mov r8, r8)
   220d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   220d2:	bc08      	pop	{r3}
   220d4:	469e      	mov	lr, r3
   220d6:	4770      	bx	lr

000220d8 <__init_array_start>:
   220d8:	000000d9 	.word	0x000000d9

000220dc <_fini>:
   220dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   220de:	46c0      	nop			; (mov r8, r8)
   220e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   220e2:	bc08      	pop	{r3}
   220e4:	469e      	mov	lr, r3
   220e6:	4770      	bx	lr

000220e8 <__fini_array_start>:
   220e8:	000000b1 	.word	0x000000b1
